.TH "galahad_bgo.h" 3 "Sun Apr 2 2023" "C interfaces to GALAHAD BGO" \" -*- nroff -*-
.ad l
.nh
.SH NAME
galahad_bgo.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdbool\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include 'galahad_precision\&.h'\fP
.br
\fC#include 'galahad_cfunctions\&.h'\fP
.br
\fC#include 'galahad_trb\&.h'\fP
.br
\fC#include 'galahad_ugo\&.h'\fP
.br
\fC#include 'galahad_lhs\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBbgo_control_type\fP"
.br
.ti -1c
.RI "struct \fBbgo_time_type\fP"
.br
.ti -1c
.RI "struct \fBbgo_inform_type\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBbgo_initialize\fP (void **data, struct \fBbgo_control_type\fP *control, int *status)"
.br
.ti -1c
.RI "void \fBbgo_read_specfile\fP (struct \fBbgo_control_type\fP *control, const char specfile[])"
.br
.ti -1c
.RI "void \fBbgo_import\fP (struct \fBbgo_control_type\fP *control, void **data, int *status, int n, const real_wp_ x_l[], const real_wp_ x_u[], const char H_type[], int ne, const int H_row[], const int H_col[], const int H_ptr[])"
.br
.ti -1c
.RI "void \fBbgo_reset_control\fP (struct \fBbgo_control_type\fP *control, void **data, int *status)"
.br
.ti -1c
.RI "void \fBbgo_solve_with_mat\fP (void **data, void *userdata, int *status, int n, real_wp_ x[], real_wp_ g[], int ne, int(*eval_f)(int, const real_wp_[], real_wp_ *, const void *), int(*eval_g)(int, const real_wp_[], real_wp_[], const void *), int(*eval_h)(int, int, const real_wp_[], real_wp_[], const void *), int(*eval_hprod)(int, const real_wp_[], real_wp_[], const real_wp_[], bool, const void *), int(*eval_prec)(int, const real_wp_[], real_wp_[], const real_wp_[], const void *))"
.br
.ti -1c
.RI "void \fBbgo_solve_without_mat\fP (void **data, void *userdata, int *status, int n, real_wp_ x[], real_wp_ g[], int(*eval_f)(int, const real_wp_[], real_wp_ *, const void *), int(*eval_g)(int, const real_wp_[], real_wp_[], const void *), int(*eval_hprod)(int, const real_wp_[], real_wp_[], const real_wp_[], bool, const void *), int(*eval_shprod)(int, const real_wp_[], int, const int[], const real_wp_[], int *, int[], real_wp_[], bool, const void *), int(*eval_prec)(int, const real_wp_[], real_wp_[], const real_wp_[], const void *))"
.br
.ti -1c
.RI "void \fBbgo_solve_reverse_with_mat\fP (void **data, int *status, int *eval_status, int n, real_wp_ x[], real_wp_ f, real_wp_ g[], int ne, real_wp_ H_val[], const real_wp_ u[], real_wp_ v[])"
.br
.ti -1c
.RI "void \fBbgo_solve_reverse_without_mat\fP (void **data, int *status, int *eval_status, int n, real_wp_ x[], real_wp_ f, real_wp_ g[], real_wp_ u[], real_wp_ v[], int index_nz_v[], int *nnz_v, const int index_nz_u[], int nnz_u)"
.br
.ti -1c
.RI "void \fBbgo_information\fP (void **data, struct \fBbgo_inform_type\fP *inform, int *status)"
.br
.ti -1c
.RI "void \fBbgo_terminate\fP (void **data, struct \fBbgo_control_type\fP *control, struct \fBbgo_inform_type\fP *inform)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SH "Introduction"
.PP
.SS "Purpose"
The bgo package uses a \fBmulti-start trust-region method to find an approximation to the global minimizer of a differentiable objective function f(x) of n variables x, subject to simple bounds x^l <= x <= x^u on the variables\&.\fP Here, any of the components of the vectors of bounds x^l and x^u may be infinite\&. The method offers the choice of direct and iterative solution of the key trust-region subproblems, and is suitable for large problems\&. First derivatives are required, and if second derivatives can be calculated, they will be exploited---if the product of second derivatives with a vector may be found but not the derivatives themselves, that may also be exploited\&.
.PP
The package offers both random multi-start and local-minimize-and probe methods to try to locate the global minimizer\&. There are no theoretical guarantees unless the sampling is huge, and realistically the success of the methods decreases as the dimension and nonconvexity increase\&.
.SS "Authors"
N\&. I\&. M\&. Gould, STFC-Rutherford Appleton Laboratory, England\&.
.PP
C interface, additionally J\&. Fowkes, STFC-Rutherford Appleton Laboratory\&.
.PP
Julia interface, additionally A\&. Montoison and D\&. Orban, Polytechnique Montréal\&.
.SS "Originally released"
July 2016, C interface August 2021\&.
.SS "Terminology"
The \fIgradient\fP nabla_x f(x) of f(x) is the vector whose i-th component is partial f(x)/partial x_i\&. The \fIHessian\fP nabla_{xx} f(x) of f(x) is the symmetric matrix whose i,j-th entry is partial^2 f(x)/partial x_i partial x_j\&. The Hessian is \fIsparse\fP if a significant and useful proportion of the entries are universally zero\&.
.SS "Method"
A choice of two methods is available\&. In the first, local-minimization-and-probe, approach, local minimization and univariate global minimization are intermixed\&. Given a current champion x^S_k, a local minimizer x_k of f(x) within the feasible box x^l <= x <= x^u is found using the GALAHAD package trb\&. Thereafter m random directions p are generated, and univariate local minimizer of f(x_k + alpha p) as a function of the scalar alpha along each p within the interval [alpha^L,alpha^u], where alpha^L and alpha^u are the smallest and largest alpha for which x^l <= x_k + alpha p <= x^u, is performed using the GALAHAD package ugo\&. The point x_k + alpha p that gives the smallest value of f is then selected as the new champion x^S_{k+1}\&.
.PP
The random directions p are chosen in one of three ways\&. The simplest is to select the components as  
(ignore next phrase - doxygen bug!)
 \[p_i = \mbox{pseudo random} \in \left\{ \begin{array}{rl} \mbox{[-1,1]} & \mbox{if} \;\; x^l_i < x_{k,i} < x^u_i \\ \mbox{[0,1]} & \mbox{if} \;\; x_{k,i} = x^l_i \\ \mbox{[-1,0]} & \mbox{if} \;\; x_{k,i} = x^u_i \end{array} \right. \]  
  \n
                         ( [-1,1] if x^l_i < x_{k,i} < x^u_i
  p_i = pseudo random in ( [0,1] if x_{k,i} = x^l_i
                         ( [-1,0] if x_{k,i} = x^u_i
  \n
 for each 1 <= i <= n\&. An alternative is to pick p by partitioning each dimension of the feasible ``hypercube'' box into m equal segments, and then selecting sub-boxes randomly within this hypercube using GALAHAD's Latin hypercube sampling package, lhs\&. Each components of p is then selected in its sub-box, either uniformly or pseudo randomly\&.
.PP
The other, random-multi-start, method provided selects m starting points at random, either componentwise pseudo randomly in the feasible box, or by partitioning each component into m equal segments, assigning each to a sub-box using Latin hypercube sampling, and finally choosing the values either uniformly or pseudo randomly\&. Local minimizers within the feasible box are then computed by the GALAHAD package trb, and the best is assigned as the current champion\&. This process is then repeated until evaluation limits are achieved\&.
.PP
If n=1, the GALAHAD package UGO is called directly\&.
.PP
We reiterate that there are no theoretical guarantees unless the sampling is huge, and realistically the success of the methods decreases as the dimension and nonconvexity increase\&. Thus the methods used should best be viewed as heuristics\&.
.SS "References"
The generic bound-constrained trust-region method is described in detail in
.PP
A\&. R\&. Conn, N\&. I\&. M\&. Gould and Ph\&. L\&. Toint (2000), Trust-region methods\&. SIAM/MPS Series on Optimization,
.PP
the univariate global minimization method employed is an extension of that due to
.PP
D\&. Lera and Ya\&. D\&. Sergeyev (2013), ``Acceleration of univariate global optimization algorithms working with Lipschitz functions and Lipschitz first derivatives'' SIAM J\&. Optimization Vol\&. 23, No\&. 1, pp\&. 508–529,
.PP
while the Latin-hypercube sampling method employed is that of
.PP
B\&. Beachkofski and R\&. Grandhi (2002)\&. ``Improved Distributed Hypercube Sampling'', 43rd AIAA structures, structural dynamics, and materials conference, pp\&. 2002-1274\&.
.SH "Call order"
.PP
To solve a given problem, functions from the bgo package must be called in the following order:
.PP
.IP "\(bu" 2
\fBbgo_initialize\fP - provide default control parameters and set up initial data structures
.IP "\(bu" 2
\fBbgo_read_specfile\fP (optional) - override control values by reading replacement values from a file
.IP "\(bu" 2
\fBbgo_import\fP - set up problem data structures and fixed values
.IP "\(bu" 2
\fBbgo_reset_control\fP (optional) - possibly change control parameters if a sequence of problems are being solved
.IP "\(bu" 2
solve the problem by calling one of
.IP "  \(bu" 4
\fBbgo_solve_with_mat\fP - solve using function calls to evaluate function, gradient and Hessian values
.IP "  \(bu" 4
\fBbgo_solve_without_mat\fP - solve using function calls to evaluate function and gradient values and Hessian-vector products
.IP "  \(bu" 4
\fBbgo_solve_reverse_with_mat\fP - solve returning to the calling program to obtain function, gradient and Hessian values, or
.IP "  \(bu" 4
\fBbgo_solve_reverse_without_mat\fP - solve returning to the calling prorgram to obtain function and gradient values and Hessian-vector products
.PP

.IP "\(bu" 2
\fBbgo_information\fP (optional) - recover information about the solution and solution process
.IP "\(bu" 2
\fBbgo_terminate\fP - deallocate data structures
.PP
.PP
   
  See the examples section for illustrations of use.
  
.SH "Symmetric matrix storage formats"
.PP
The symmetric n by n matrix H = nabla_{xx}f may be presented and stored in a variety of formats\&. But crucially symmetry is exploited by only storing values from the lower triangular part (i\&.e, those entries that lie on or below the leading diagonal)\&.
.PP
Both C-style (0 based) and fortran-style (1-based) indexing is allowed\&. Choose \fCcontrol\&.f_indexing\fP as \fCfalse\fP for C style and \fCtrue\fP for fortran style; the discussion below presumes C style, but add 1 to indices for the corresponding fortran version\&.
.PP
Wrappers will automatically convert between 0-based (C) and 1-based (fortran) array indexing, so may be used transparently from C\&. This conversion involves both time and memory overheads that may be avoided by supplying data that is already stored using 1-based indexing\&.
.SS "Dense storage format"
The matrix H is stored as a compact dense matrix by rows, that is, the values of the entries of each row in turn are stored in order within an appropriate real one-dimensional array\&. Since H is symmetric, only the lower triangular part (that is the part H_{ij} for 0 <= j <= i <= n-1) need be held\&. In this case the lower triangle should be stored by rows, that is component i * i / 2 + j of the storage array H_val will hold the value H_{ij} (and, by symmetry, H_{ji}) for 0 <= j <= i <= n-1\&.
.SS "Sparse co-ordinate storage format"
Only the nonzero entries of the matrices are stored\&. For the l-th entry, 0 <= l <= ne-1, of H, its row index i, column index j and value H_{ij}, 0 <= j <= i <= n-1, are stored as the l-th components of the integer arrays H_row and H_col and real array H_val, respectively, while the number of nonzeros is recorded as H_ne = ne\&. Note that only the entries in the lower triangle should be stored\&.
.SS "Sparse row-wise storage format"
Again only the nonzero entries are stored, but this time they are ordered so that those in row i appear directly before those in row i+1\&. For the i-th row of H the i-th component of the integer array H_ptr holds the position of the first entry in this row, while H_ptr(n) holds the total number of entries\&. The column indices j, 0 <= j <= i, and values H_{ij} of the entries in the i-th row are stored in components l = H_ptr(i), \&.\&.\&., H_ptr(i+1)-1 of the integer array H_col, and real array H_val, respectively\&. Note that as before only the entries in the lower triangle should be stored\&. For sparse matrices, this scheme almost always requires less storage than its predecessor\&. 
.SH "Data Structure Documentation"
.PP 
.SH "struct bgo_control_type"
.PP 
\fBData Fields:\fP
.RS 4
bool \fIf_indexing\fP use C or Fortran sparse matrix indexing 
.br
.PP
int \fIerror\fP error and warning diagnostics occur on stream error 
.br
.PP
int \fIout\fP general output occurs on stream out 
.br
.PP
int \fIprint_level\fP the level of output required\&. Possible values are: 
.PD 0

.IP "\(bu" 2
<= 0 no output, 
.IP "\(bu" 2
1 a one-line summary for every improvement 
.IP "\(bu" 2
2 a summary of each iteration 
.IP "\(bu" 2
>= 3 increasingly verbose (debugging) output 
.PP

.br
.PP
int \fIattempts_max\fP the maximum number of random searches from the best point found so far 
.br
.PP
int \fImax_evals\fP the maximum number of function evaluations made 
.br
.PP
int \fIsampling_strategy\fP sampling strategy used\&. Possible values are 
.PD 0

.IP "\(bu" 2
1 uniformly spread 
.IP "\(bu" 2
2 Latin hypercube sampling 
.IP "\(bu" 2
3 niformly spread within a Latin hypercube 
.PP

.br
.PP
int \fIhypercube_discretization\fP hyper-cube discretization (for sampling stategies 2 and 3) 
.br
.PP
int \fIalive_unit\fP removal of the file alive_file from unit alive_unit terminates execution 
.br
.PP
char \fIalive_file[31]\fP see alive_unit 
.br
.PP
real_wp_ \fIinfinity\fP any bound larger than infinity in modulus will be regarded as infinite 
.br
.PP
real_wp_ \fIobj_unbounded\fP the smallest value the objective function may take before the problem is marked as unbounded 
.br
.PP
real_wp_ \fIcpu_time_limit\fP the maximum CPU time allowed (-ve means infinite) 
.br
.PP
real_wp_ \fIclock_time_limit\fP the maximum elapsed clock time allowed (-ve means infinite) 
.br
.PP
bool \fIrandom_multistart\fP perform random-multistart as opposed to local minimize and probe 
.br
.PP
bool \fIhessian_available\fP is the Hessian matrix of second derivatives available or is access only via matrix-vector products? 
.br
.PP
bool \fIspace_critical\fP if \&.space_critical true, every effort will be made to use as little space as possible\&. This may result in longer computation time 
.br
.PP
bool \fIdeallocate_error_fatal\fP if \&.deallocate_error_fatal is true, any array/pointer deallocation error will terminate execution\&. Otherwise, computation will continue 
.br
.PP
char \fIprefix[31]\fP all output lines will be prefixed by \&.prefix(2:LEN(TRIM(\&.prefix))-1) where \&.prefix contains the required string enclosed in quotes, e\&.g\&. 'string' or 'string' 
.br
.PP
struct ugo_control_type \fIugo_control\fP control parameters for UGO 
.br
.PP
struct lhs_control_type \fIlhs_control\fP control parameters for LHS 
.br
.PP
struct trb_control_type \fItrb_control\fP control parameters for TRB 
.br
.PP
.RE
.PP
.SH "struct bgo_time_type"
.PP 
\fBData Fields:\fP
.RS 4
real_sp_ \fItotal\fP the total CPU time spent in the package 
.br
.PP
real_sp_ \fIunivariate_global\fP the CPU time spent performing univariate global optimization 
.br
.PP
real_sp_ \fImultivariate_local\fP the CPU time spent performing multivariate local optimization 
.br
.PP
real_wp_ \fIclock_total\fP the total clock time spent in the package 
.br
.PP
real_wp_ \fIclock_univariate_global\fP the clock time spent performing univariate global optimization 
.br
.PP
real_wp_ \fIclock_multivariate_local\fP the clock time spent performing multivariate local optimization 
.br
.PP
.RE
.PP
.SH "struct bgo_inform_type"
.PP 
\fBData Fields:\fP
.RS 4
int \fIstatus\fP return status\&. See BGO_solve for details 
.br
.PP
int \fIalloc_status\fP the status of the last attempted allocation/deallocation 
.br
.PP
char \fIbad_alloc[81]\fP the name of the array for which an allocation/deallocation error ocurred 
.br
.PP
int \fIf_eval\fP the total number of evaluations of the objective function 
.br
.PP
int \fIg_eval\fP the total number of evaluations of the gradient of the objective function 
.br
.PP
int \fIh_eval\fP the total number of evaluations of the Hessian of the objective function 
.br
.PP
real_wp_ \fIobj\fP the value of the objective function at the best estimate of the solution determined by BGO_solve 
.br
.PP
real_wp_ \fInorm_pg\fP the norm of the projected gradient of the objective function at the best estimate of the solution determined by BGO_solve 
.br
.PP
struct \fBbgo_time_type\fP \fItime\fP timings (see above) 
.br
.PP
struct ugo_inform_type \fIugo_inform\fP inform parameters for UGO 
.br
.PP
struct lhs_inform_type \fIlhs_inform\fP inform parameters for LHS 
.br
.PP
struct trb_inform_type \fItrb_inform\fP inform parameters for TRB 
.br
.PP
.RE
.PP
.SH "Function Documentation"
.PP 
.SS "void bgo_initialize (void ** data, struct \fBbgo_control_type\fP * control, int * status)"
Set default control values and initialize private data
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIcontrol\fP is a struct containing control information (see \fBbgo_control_type\fP)
.br
\fIstatus\fP is a scalar variable of type int, that gives the exit status from the package\&. Possible values are (currently): 
.PD 0

.IP "\(bu" 2
0\&. The import was succesful\&. 
.PP
.RE
.PP

.SS "void bgo_read_specfile (struct \fBbgo_control_type\fP * control, const char specfile[])"
Read the content of a specification file, and assign values associated with given keywords to the corresponding control parameters\&. By default, the spcification file will be named RUNBGO\&.SPC and lie in the current directory\&. Refer to Table 2\&.1 in the fortran documentation provided in $GALAHAD/doc/bgo\&.pdf for a list of keywords that may be set\&.
.PP
\fBParameters\fP
.RS 4
\fIcontrol\fP is a struct containing control information (see \fBbgo_control_type\fP) 
.br
\fIspecfile\fP is a character string containing the name of the specification file 
.RE
.PP

.SS "void bgo_import (struct \fBbgo_control_type\fP * control, void ** data, int * status, int n, const real_wp_ x_l[], const real_wp_ x_u[], const char H_type[], int ne, const int H_row[], const int H_col[], const int H_ptr[])"
Import problem data into internal storage prior to solution\&.
.PP
\fBParameters\fP
.RS 4
\fIcontrol\fP is a struct whose members provide control paramters for the remaining prcedures (see \fBbgo_control_type\fP)
.br
\fIdata\fP holds private internal data
.br
\fIstatus\fP is a scalar variable of type int, that gives the exit status from the package\&. Possible values are: 
.PD 0

.IP "\(bu" 2
1\&. The import was succesful, and the package is ready for the solve phase 
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restriction n > 0 or requirement that type contains its relevant string 'dense', 'coordinate', 'sparse_by_rows', 'diagonal' or 'absent' has been violated\&.
.PP
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables\&.
.br
\fIx_l\fP is a one-dimensional array of size n and type double, that holds the values x^l of the lower bounds on the optimization variables x\&. The j-th component of x_l, j = 0, \&.\&.\&., n-1, contains x^l_j\&.
.br
\fIx_u\fP is a one-dimensional array of size n and type double, that holds the values x^u of the upper bounds on the optimization variables x\&. The j-th component of x_u, j = 0, \&.\&.\&., n-1, contains x^u_j\&.
.br
\fIH_type\fP is a one-dimensional array of type char that specifies the \fBsymmetric storage scheme \fP used for the Hessian\&. It should be one of 'coordinate', 'sparse_by_rows', 'dense', 'diagonal' or 'absent', the latter if access to the Hessian is via matrix-vector products; lower or upper case variants are allowed\&.
.br
\fIne\fP is a scalar variable of type int, that holds the number of entries in the lower triangular part of H in the sparse co-ordinate storage scheme\&. It need not be set for any of the other three schemes\&.
.br
\fIH_row\fP is a one-dimensional array of size ne and type int, that holds the row indices of the lower triangular part of H in the sparse co-ordinate storage scheme\&. It need not be set for any of the other three schemes, and in this case can be NULL
.br
\fIH_col\fP is a one-dimensional array of size ne and type int, that holds the column indices of the lower triangular part of H in either the sparse co-ordinate, or the sparse row-wise storage scheme\&. It need not be set when the dense or diagonal storage schemes are used, and in this case can be NULL
.br
\fIH_ptr\fP is a one-dimensional array of size n+1 and type int, that holds the starting position of each row of the lower triangular part of H, as well as the total number of entries, in the sparse row-wise storage scheme\&. It need not be set when the other schemes are used, and in this case can be NULL 
.RE
.PP

.SS "void bgo_reset_control (struct \fBbgo_control_type\fP * control, void ** data, int * status)"
Reset control parameters after import if required\&.
.PP
\fBParameters\fP
.RS 4
\fIcontrol\fP is a struct whose members provide control paramters for the remaining prcedures (see \fBbgo_control_type\fP)
.br
\fIdata\fP holds private internal data
.br
\fIstatus\fP is a scalar variable of type int, that gives the exit status from the package\&. Possible values are: 
.PD 0

.IP "\(bu" 2
1\&. The import was succesful, and the package is ready for the solve phase 
.PP
.RE
.PP

.SS "void bgo_solve_with_mat (void ** data, void * userdata, int * status, int n, real_wp_ x[], real_wp_ g[], int ne, int(*)(int, const real_wp_[], real_wp_ *, const void *) eval_f, int(*)(int, const real_wp_[], real_wp_[], const void *) eval_g, int(*)(int, int, const real_wp_[], real_wp_[], const void *) eval_h, int(*)(int, const real_wp_[], real_wp_[], const real_wp_[], bool, const void *) eval_hprod, int(*)(int, const real_wp_[], real_wp_[], const real_wp_[], const void *) eval_prec)"
Find an approximation to the global minimizer of a given function subject to simple bounds on the variables using a multistart trust-region method\&.
.PP
This call is for the case where H = nabla_{xx}f(x) is provided specifically, and all function/derivative information is available by function calls\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIuserdata\fP is a structure that allows data to be passed into the function and derivative evaluation programs\&.
.br
\fIstatus\fP is a scalar variable of type int, that gives the entry and exit status from the package\&. 
.br
 On initial entry, status must be set to 1\&. 
.br
 Possible exit are: 
.PD 0

.IP "\(bu" 2
0\&. The run was succesful
.PP
.PD 0
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restriction n > 0 or requirement that type contains its relevant string 'dense', 'coordinate', 'sparse_by_rows', 'diagonal' or 'absent' has been violated\&. 
.IP "\(bu" 2
-7\&. The objective function appears to be unbounded from below 
.IP "\(bu" 2
-9\&. The analysis phase of the factorization failed; the return status from the factorization package is given in the component inform\&.factor_status 
.IP "\(bu" 2
-10\&. The factorization failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-11\&. The solution of a set of linear equations using factors from the factorization package failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-16\&. The problem is so ill-conditioned that further progress is impossible\&. 
.IP "\(bu" 2
-18\&. Too many iterations have been performed\&. This may happen if control\&.maxit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-19\&. The CPU time limit has been reached\&. This may happen if control\&.cpu_time_limit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-82\&. The user has forced termination of solver by removing the file named control\&.alive_file from unit unit control\&.alive_unit\&.
.PP
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables
.br
\fIx\fP is a one-dimensional array of size n and type double, that holds the values x of the optimization variables\&. The j-th component of x, j = 0, \&.\&.\&. , n-1, contains x_j\&.
.br
\fIg\fP is a one-dimensional array of size n and type double, that holds the gradient g = nabla_xf(x) of the objective function\&. The j-th component of g, j = 0, \&.\&.\&. , n-1, contains g_j \&.
.br
\fIne\fP is a scalar variable of type int, that holds the number of entries in the lower triangular part of the Hessian matrix H\&.
.br
\fIeval_f\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_f( int n, const double x[], double *f, const void *userdata )

.fi
.PP
 The value of the objective function f(x) evaluated at x=x must be assigned to f, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_f\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_g\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_g( int n, const double x[], double g[], const void *userdata )

.fi
.PP
 The components of the gradient g = nabla_x f(x) of the objective function evaluated at x=x must be assigned to g, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_g\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_h\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_h( int n, int ne, const double x[], double h[],
            const void *userdata )

.fi
.PP
 The nonzeros of the Hessian H = nabla_{xx}f(x) of the objective function evaluated at x=x must be assigned to h in the same order as presented to bgo_import, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_h\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_prec\fP is an optional user-supplied function that may be NULL\&. If non-NULL, it must have the following signature: 
.PP
.nf
int eval_prec( int n, const double x[], double u[], const double v[],
               const void *userdata )

.fi
.PP
 The product u = P(x) v of the user's preconditioner P(x) evaluated at x with the vector v = v, the result u must be retured in u, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_prec\fP via the structure \fCuserdata\fP\&. 
.RE
.PP

.SS "void bgo_solve_without_mat (void ** data, void * userdata, int * status, int n, real_wp_ x[], real_wp_ g[], int(*)(int, const real_wp_[], real_wp_ *, const void *) eval_f, int(*)(int, const real_wp_[], real_wp_[], const void *) eval_g, int(*)(int, const real_wp_[], real_wp_[], const real_wp_[], bool, const void *) eval_hprod, int(*)(int, const real_wp_[], int, const int[], const real_wp_[], int *, int[], real_wp_[], bool, const void *) eval_shprod, int(*)(int, const real_wp_[], real_wp_[], const real_wp_[], const void *) eval_prec)"
Find an approximation to the global minimizer of a given function subject to simple bounds on the variables using a multistart trust-region method\&.
.PP
This call is for the case where access to H = nabla_{xx}f(x) is provided by Hessian-vector products, and all function/derivative information is available by function calls\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIuserdata\fP is a structure that allows data to be passed into the function and derivative evaluation programs\&.
.br
\fIstatus\fP is a scalar variable of type int, that gives the entry and exit status from the package\&. 
.br
 On initial entry, status must be set to 1\&. 
.br
 Possible exit are: 
.PD 0

.IP "\(bu" 2
0\&. The run was succesful
.PP
.PD 0
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restriction n > 0 or requirement that type contains its relevant string 'dense', 'coordinate', 'sparse_by_rows', 'diagonal' or 'absent' has been violated\&. 
.IP "\(bu" 2
-7\&. The objective function appears to be unbounded from below 
.IP "\(bu" 2
-9\&. The analysis phase of the factorization failed; the return status from the factorization package is given in the component inform\&.factor_status 
.IP "\(bu" 2
-10\&. The factorization failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-11\&. The solution of a set of linear equations using factors from the factorization package failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-16\&. The problem is so ill-conditioned that further progress is impossible\&. 
.IP "\(bu" 2
-18\&. Too many iterations have been performed\&. This may happen if control\&.maxit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-19\&. The CPU time limit has been reached\&. This may happen if control\&.cpu_time_limit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-82\&. The user has forced termination of solver by removing the file named control\&.alive_file from unit unit control\&.alive_unit\&.
.PP
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables
.br
\fIx\fP is a one-dimensional array of size n and type double, that holds the values x of the optimization variables\&. The j-th component of x, j = 0, \&.\&.\&. , n-1, contains x_j\&.
.br
\fIg\fP is a one-dimensional array of size n and type double, that holds the gradient g = nabla_xf(x) of the objective function\&. The j-th component of g, j = 0, \&.\&.\&. , n-1, contains g_j \&.
.br
\fIeval_f\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_f( int n, const double x[], double *f, const void *userdata )

.fi
.PP
 The value of the objective function f(x) evaluated at x=x must be assigned to f, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_f\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_g\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_g( int n, const double x[], double g[], const void *userdata )

.fi
.PP
 The components of the gradient g = nabla_x f(x) of the objective function evaluated at x=x must be assigned to g, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_g\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_hprod\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_hprod( int n, const double x[], double u[], const double v[],
                bool got_h, const void *userdata )

.fi
.PP
 The sum u + nabla_{xx}f(x) v of the product of the Hessian nabla_{xx}f(x) of the objective function evaluated at x=x with the vector v=v and the vector $u must be returned in u, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. The Hessian has already been evaluated or used at x if got_h is true\&. Data may be passed into \fCeval_hprod\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_shprod\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_shprod( int n, const double x[], int nnz_v,
                 const int index_nz_v[], const double v[],
                 int *nnz_u, int index_nz_u[], double u[],
                 bool got_h, const void *userdata )

.fi
.PP
 The product u = nabla_{xx}f(x) v of the Hessian nabla_{xx}f(x) of the objective function evaluated at x with the sparse vector v=v must be returned in u, and the function return value set to 0\&. Only the components index_nz_v[0:nnz_v-1] of v are nonzero, and the remaining components may not have been be set\&. On exit, the user must indicate the nnz_u indices of u that are nonzero in index_nz_u[0:nnz_u-1], and only these components of u need be set\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. The Hessian has already been evaluated or used at x if got_h is true\&. Data may be passed into \fCeval_prec\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_prec\fP is an optional user-supplied function that may be NULL\&. If non-NULL, it must have the following signature: 
.PP
.nf
int eval_prec( int n, const double x[], double u[], const double v[],
               const void *userdata )

.fi
.PP
 The product u = P(x) v of the user's preconditioner P(x) evaluated at x with the vector v = v, the result u must be retured in u, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_prec\fP via the structure \fCuserdata\fP\&. 
.RE
.PP

.SS "void bgo_solve_reverse_with_mat (void ** data, int * status, int * eval_status, int n, real_wp_ x[], real_wp_ f, real_wp_ g[], int ne, real_wp_ H_val[], const real_wp_ u[], real_wp_ v[])"
Find an approximation to the global minimizer of a given function subject to simple bounds on the variables using a multistart trust-region method\&.
.PP
This call is for the case where H = nabla_{xx}f(x) is provided specifically, but function/derivative information is only available by returning to the calling procedure
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIstatus\fP is a scalar variable of type int, that gives the entry and exit status from the package\&. 
.br
 On initial entry, status must be set to 1\&. 
.br
 Possible exit are: 
.PD 0

.IP "\(bu" 2
0\&. The run was succesful
.PP
.PD 0
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restriction n > 0 or requirement that type contains its relevant string 'dense', 'coordinate', 'sparse_by_rows', 'diagonal' or 'absent' has been violated\&. 
.IP "\(bu" 2
-7\&. The objective function appears to be unbounded from below 
.IP "\(bu" 2
-9\&. The analysis phase of the factorization failed; the return status from the factorization package is given in the component inform\&.factor_status 
.IP "\(bu" 2
-10\&. The factorization failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-11\&. The solution of a set of linear equations using factors from the factorization package failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-16\&. The problem is so ill-conditioned that further progress is impossible\&. 
.IP "\(bu" 2
-18\&. Too many iterations have been performed\&. This may happen if control\&.maxit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-19\&. The CPU time limit has been reached\&. This may happen if control\&.cpu_time_limit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-82\&. The user has forced termination of solver by removing the file named control\&.alive_file from unit unit control\&.alive_unit\&.
.PP
.br
\fIstatus\fP (continued) 
.PD 0

.IP "\(bu" 2
2\&. The user should compute the objective function value f(x) at the point x indicated in x and then re-enter the function\&. The required value should be set in f, and eval_status should be set to 0\&. If the user is unable to evaluate f(x)--- for instance, if the function is undefined at x--- the user need not set f, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
3\&. The user should compute the gradient of the objective function nabla_x f(x) at the point x indicated in x and then re-enter the function\&. The value of the i-th component of the g radient should be set in g[i], for i = 0, \&.\&.\&., n-1 and eval_status should be set to 0\&. If the user is unable to evaluate a component of nabla_x f(x) --- for instance if a component of the gradient is undefined at x -the user need not set g, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
4\&. The user should compute the Hessian of the objective function nabla_{xx}f(x) at the point x indicated in x and then re-enter the function\&. The value l-th component of the Hessian stored according to the scheme input in the remainder of H should be set in H_val[l], for l = 0, \&.\&.\&., ne-1 and eval_status should be set to 0\&. If the user is unable to evaluate a component of nabla_{xx}f(x) --- for instance, if a component of the Hessian is undefined at x --- the user need not set H_val, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
5\&. The user should compute the product nabla_{xx}f(x)v of the Hessian of the objective function nabla_{xx}f(x) at the point x indicated in x with the vector v, add the result to the vector u and then re-enter the function\&. The vectors u and v are given in u and v respectively, the resulting vector u + nabla_{xx}f(x)v should be set in u and eval_status should be set to 0\&. If the user is unable to evaluate the product--- for instance, if a component of the Hessian is undefined at x --- the user need not alter u, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
6\&. The user should compute the product u = P(x)v of their preconditioner P(x) at the point x indicated in x with the vector v and then re-enter the function\&. The vector v is given in v, the resulting vector u = P(x)v should be set in u and eval_status should be set to 0\&. If the user is unable to evaluate the product--- for instance, if a component of the preconditioner is undefined at x --- the user need not set u, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
23\&. The user should follow the instructions for 2 \fBand\fP 3 above before returning\&. 
.IP "\(bu" 2
25\&. The user should follow the instructions for 2 \fBand\fP 5 above before returning\&. 
.IP "\(bu" 2
35\&. The user should follow the instructions for 3 \fBand\fP 5 above before returning\&. 
.IP "\(bu" 2
235\&. The user should follow the instructions for 2, 3 \fBand\fP 5 above before returning\&.
.PP
.br
\fIeval_status\fP is a scalar variable of type int, that is used to indicate if objective function/gradient/Hessian values can be provided (see above)
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables
.br
\fIx\fP is a one-dimensional array of size n and type double, that holds the values x of the optimization variables\&. The j-th component of x, j = 0, \&.\&.\&. , n-1, contains x_j\&.
.br
\fIf\fP is a scalar variable pointer of type double, that holds the value of the objective function\&.
.br
\fIg\fP is a one-dimensional array of size n and type double, that holds the gradient g = nabla_xf(x) of the objective function\&. The j-th component of g, j = 0, \&.\&.\&. , n-1, contains g_j \&.
.br
\fIne\fP is a scalar variable of type int, that holds the number of entries in the lower triangular part of the Hessian matrix H\&.
.br
\fIH_val\fP is a one-dimensional array of size ne and type double, that holds the values of the entries of the lower triangular part of the Hessian matrix H in any of the available storage schemes\&.
.br
\fIu\fP is a one-dimensional array of size n and type double, that is used for reverse communication (see above for details)
.br
\fIv\fP is a one-dimensional array of size n and type double, that is used for reverse communication (see above for details) 
.RE
.PP

.SS "void bgo_solve_reverse_without_mat (void ** data, int * status, int * eval_status, int n, real_wp_ x[], real_wp_ f, real_wp_ g[], real_wp_ u[], real_wp_ v[], int index_nz_v[], int * nnz_v, const int index_nz_u[], int nnz_u)"
Find an approximation to the global minimizer of a given function subject to simple bounds on the variables using a multistart trust-region method\&.
.PP
This call is for the case where access to H = nabla_{xx}f(x) is provided by Hessian-vector products, but function/derivative information is only available by returning to the calling procedure\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIstatus\fP is a scalar variable of type int, that gives the entry and exit status from the package\&. 
.br
 On initial entry, status must be set to 1\&. 
.br
 Possible exit are: 
.PD 0

.IP "\(bu" 2
0\&. The run was succesful
.PP
.PD 0
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restriction n > 0 or requirement that type contains its relevant string 'dense', 'coordinate', 'sparse_by_rows', 'diagonal' or 'absent' has been violated\&. 
.IP "\(bu" 2
-7\&. The objective function appears to be unbounded from below 
.IP "\(bu" 2
-9\&. The analysis phase of the factorization failed; the return status from the factorization package is given in the component inform\&.factor_status 
.IP "\(bu" 2
-10\&. The factorization failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-11\&. The solution of a set of linear equations using factors from the factorization package failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-16\&. The problem is so ill-conditioned that further progress is impossible\&. 
.IP "\(bu" 2
-18\&. Too many iterations have been performed\&. This may happen if control\&.maxit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-19\&. The CPU time limit has been reached\&. This may happen if control\&.cpu_time_limit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-82\&. The user has forced termination of solver by removing the file named control\&.alive_file from unit unit control\&.alive_unit\&.
.PP
.br
\fIstatus\fP (continued) 
.PD 0

.IP "\(bu" 2
2\&. The user should compute the objective function value f(x) at the point x indicated in x and then re-enter the function\&. The required value should be set in f, and eval_status should be set to 0\&. If the user is unable to evaluate f(x) --- for instance, if the function is undefined at x --- the user need not set f, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
3\&. The user should compute the gradient of the objective function nabla_x f(x) at the point x indicated in x and then re-enter the function\&. The value of the i-th component of the g radient should be set in g[i], for i = 0, \&.\&.\&., n-1 and eval_status should be set to 0\&. If the user is unable to evaluate a component of nabla_x f(x) --- for instance if a component of the gradient is undefined at x -the user need not set g, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
5\&. The user should compute the product nabla_{xx}f(x)v of the Hessian of the objective function nabla_{xx}f(x) at the point x indicated in x with the vector v, add the result to the vector u and then re-enter the function\&. The vectors u and v are given in u and v respectively, the resulting vector u + nabla_{xx}f(x)v should be set in u and eval_status should be set to 0\&. If the user is unable to evaluate the product--- for instance, if a component of the Hessian is undefined at x --- the user need not alter u, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
6\&. The user should compute the product u = P(x)v of their preconditioner P(x) at the point x indicated in x with the vector v and then re-enter the function\&. The vector v is given in v, the resulting vector u = P(x)v should be set in u and eval_status should be set to 0\&. If the user is unable to evaluate the product--- for instance, if a component of the preconditioner is undefined at x --- the user need not set u, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
7\&. The user should compute the product u = nabla_{xx}f(x)v of the Hessian of the objective function nabla_{xx}f(x) at the point x indicated in x with the \fBsparse\fP vector v=v and then re-enter the function\&. The nonzeros of v are stored in v[index_nz_v[0:nnz_v-1]] while the nonzeros of u should be returned in u[index_nz_u[0:nnz_u-1]]; the user must set nnz_u and index_nz_u accordingly, and set eval_status to 0\&. If the user is unable to evaluate the product--- for instance, if a component of the Hessian is undefined at x--- the user need not alter u, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
23\&. The user should follow the instructions for 2 \fBand\fP 3 above before returning\&. 
.IP "\(bu" 2
25\&. The user should follow the instructions for 2 \fBand\fP 5 above before returning\&. 
.IP "\(bu" 2
35\&. The user should follow the instructions for 3 \fBand\fP 5 above before returning\&. 
.IP "\(bu" 2
235\&. The user should follow the instructions for 2, 3 \fBand\fP 5 above before returning\&.
.PP
.br
\fIeval_status\fP is a scalar variable of type int, that is used to indicate if objective function/gradient/Hessian values can be provided (see above)
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables
.br
\fIx\fP is a one-dimensional array of size n and type double, that holds the values x of the optimization variables\&. The j-th component of x, j = 0, \&.\&.\&. , n-1, contains x_j\&.
.br
\fIf\fP is a scalar variable pointer of type double, that holds the value of the objective function\&.
.br
\fIg\fP is a one-dimensional array of size n and type double, that holds the gradient g = nabla_xf(x) of the objective function\&. The j-th component of g, j = 0, \&.\&.\&. , n-1, contains g_j \&.
.br
\fIu\fP is a one-dimensional array of size n and type double, that is used for reverse communication (see status=5,6,7 above for details)
.br
\fIv\fP is a one-dimensional array of size n and type double, that is used for reverse communication (see status=5,6,7 above for details)
.br
\fIindex_nz_v\fP is a one-dimensional array of size n and type int, that is used for reverse communication (see status=7 above for details)
.br
\fInnz_v\fP is a scalar variable of type int, that is used for reverse communication (see status=7 above for details)
.br
\fIindex_nz_u\fP s a one-dimensional array of size n and type int, that is used for reverse communication (see status=7 above for details)
.br
\fInnz_u\fP is a scalar variable of type int, that is used for reverse communication (see status=7 above for details)\&. On initial (status=1) entry, nnz_u should be set to an (arbitrary) nonzero value, and nnz_u=0 is recommended 
.RE
.PP

.SS "void bgo_information (void ** data, struct \fBbgo_inform_type\fP * inform, int * status)"
Provides output information
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIinform\fP is a struct containing output information (see \fBbgo_inform_type\fP)
.br
\fIstatus\fP is a scalar variable of type int, that gives the exit status from the package\&. Possible values are (currently): 
.PD 0

.IP "\(bu" 2
0\&. The values were recorded succesfully 
.PP
.RE
.PP

.SS "void bgo_terminate (void ** data, struct \fBbgo_control_type\fP * control, struct \fBbgo_inform_type\fP * inform)"
Deallocate all internal private storage
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIcontrol\fP is a struct containing control information (see \fBbgo_control_type\fP)
.br
\fIinform\fP is a struct containing output information (see \fBbgo_inform_type\fP) 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for C interfaces to GALAHAD BGO from the source code\&.

.TH "tru_control_type" 3 "Mon Sep 6 2021" "C interfaces to GALAHAD TRU" \" -*- nroff -*-
.ad l
.nh
.SH NAME
tru_control_type
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <tru\&.h>\fP
.SS "Data Fields"

.in +1c
.ti -1c
.RI "bool \fBf_indexing\fP"
.br
.RI "use C or Fortran sparse matrix indexing "
.ti -1c
.RI "int \fBerror\fP"
.br
.RI "error and warning diagnostics occur on stream error "
.ti -1c
.RI "int \fBout\fP"
.br
.RI "general output occurs on stream out "
.ti -1c
.RI "int \fBprint_level\fP"
.br
.RI "the level of output required\&. "
.ti -1c
.RI "int \fBstart_print\fP"
.br
.RI "any printing will start on this iteration "
.ti -1c
.RI "int \fBstop_print\fP"
.br
.RI "any printing will stop on this iteration "
.ti -1c
.RI "int \fBprint_gap\fP"
.br
.RI "the number of iterations between printing "
.ti -1c
.RI "int \fBmaxit\fP"
.br
.RI "the maximum number of iterations allowed "
.ti -1c
.RI "int \fBalive_unit\fP"
.br
.RI "removal of the file alive_file from unit alive_unit terminates execution "
.ti -1c
.RI "char \fBalive_file\fP [31]"
.br
.RI "see alive_unit "
.ti -1c
.RI "int \fBnon_monotone\fP"
.br
.RI "the descent strategy used\&. "
.ti -1c
.RI "int \fBmodel\fP"
.br
.RI "the model used\&. "
.ti -1c
.RI "int \fBnorm\fP"
.br
.RI "the trust-region norm used\&. "
.ti -1c
.RI "int \fBsemi_bandwidth\fP"
.br
.RI "specify the semi-bandwidth of the band matrix P if required "
.ti -1c
.RI "int \fBlbfgs_vectors\fP"
.br
.RI "number of vectors used by the L-BFGS matrix P if required "
.ti -1c
.RI "int \fBmax_dxg\fP"
.br
.RI "number of vectors used by the sparsity-based secant Hessian if required "
.ti -1c
.RI "int \fBicfs_vectors\fP"
.br
.RI "number of vectors used by the Lin-More' incomplete factorization matrix P if required "
.ti -1c
.RI "int \fBmi28_lsize\fP"
.br
.RI "the maximum number of fill entries within each column of the incomplete factor L computed by HSL_MI28\&. In general, increasing \&.mi28_lsize improve the quality of the preconditioner but increases the time to compute and then apply the preconditioner\&. Values less than 0 are treated as 0 "
.ti -1c
.RI "int \fBmi28_rsize\fP"
.br
.RI "the maximum number of entries within each column of the strictly lower triangular matrix R used in the computation of the preconditioner by HSL_MI28\&. Rank-1 arrays of size \&.mi28_rsize * n are allocated internally to hold R\&. Thus the amount of memory used, as well as the amount of work involved in computing the preconditioner, depends on \&.mi28_rsize\&. Setting \&.mi28_rsize > 0 generally leads to a higher quality preconditioner than using \&.mi28_rsize = 0, and choosing \&.mi28_rsize >= \&.mi28_lsize is generally recommended "
.ti -1c
.RI "real_wp_ \fBstop_g_absolute\fP"
.br
.RI "overall convergence tolerances\&. The iteration will terminate when the norm of the gradient of the objective function is smaller than MAX( \&.stop_g_absolute, \&.stop_g_relative * norm of the initial gradient or if the step is less than \&.stop_s "
.ti -1c
.RI "real_wp_ \fBstop_g_relative\fP"
.br
.RI "see stop_g_absolute "
.ti -1c
.RI "real_wp_ \fBstop_s\fP"
.br
.RI "see stop_g_absolute "
.ti -1c
.RI "int \fBadvanced_start\fP"
.br
.RI "try to pick a good initial trust-region radius using \&.advanced_start iterates of a variant on the strategy of Sartenaer SISC 18(6) 1990:1788-1803 "
.ti -1c
.RI "real_wp_ \fBinitial_radius\fP"
.br
.RI "initial value for the trust-region radius "
.ti -1c
.RI "real_wp_ \fBmaximum_radius\fP"
.br
.RI "maximum permitted trust-region radius "
.ti -1c
.RI "real_wp_ \fBeta_successful\fP"
.br
.RI "a potential iterate will only be accepted if the actual decrease f - f(x_{new}) is larger than \&.eta_successful times that predicted by a quadratic model of the decrease\&. The trust-region radius will be increased if this relative decrease is greater than \&.eta_very_successful but smaller than \&.eta_too_successful "
.ti -1c
.RI "real_wp_ \fBeta_very_successful\fP"
.br
.RI "see eta_successful "
.ti -1c
.RI "real_wp_ \fBeta_too_successful\fP"
.br
.RI "see eta_successful "
.ti -1c
.RI "real_wp_ \fBradius_increase\fP"
.br
.RI "on very successful iterations, the trust-region radius will be increased by the factor \&.radius_increase, while if the iteration is unsucceful, the radius will be decreased by a factor \&.radius_reduce but no more than \&.radius_reduce_max "
.ti -1c
.RI "real_wp_ \fBradius_reduce\fP"
.br
.RI "see radius_increase; "
.ti -1c
.RI "real_wp_ \fBradius_reduce_max\fP"
.br
.RI "see radius_increase; "
.ti -1c
.RI "real_wp_ \fBobj_unbounded\fP"
.br
.RI "the smallest value the objective function may take before the problem is marked as unbounded "
.ti -1c
.RI "real_wp_ \fBcpu_time_limit\fP"
.br
.RI "the maximum CPU time allowed (-ve means infinite) "
.ti -1c
.RI "real_wp_ \fBclock_time_limit\fP"
.br
.RI "the maximum elapsed clock time allowed (-ve means infinite) "
.ti -1c
.RI "bool \fBhessian_available\fP"
.br
.RI "is the Hessian matrix of second derivatives available or is access only via matrix-vector products? "
.ti -1c
.RI "bool \fBsubproblem_direct\fP"
.br
.RI "use a direct (factorization) or (preconditioned) iterative method to find the search direction "
.ti -1c
.RI "bool \fBretrospective_trust_region\fP"
.br
.RI "is a retrospective strategy to be used to update the trust-region radius? "
.ti -1c
.RI "bool \fBrenormalize_radius\fP"
.br
.RI "should the radius be renormalized to account for a change in preconditioner? "
.ti -1c
.RI "bool \fBspace_critical\fP"
.br
.RI "if \&.space_critical true, every effort will be made to use as little space as possible\&. This may result in longer computation time "
.ti -1c
.RI "bool \fBdeallocate_error_fatal\fP"
.br
.RI "if \&.deallocate_error_fatal is true, any array/pointer deallocation error will terminate execution\&. Otherwise, computation will continue "
.ti -1c
.RI "char \fBprefix\fP [31]"
.br
.RI "all output lines will be prefixed by \&.prefix(2:LEN(TRIM(\&.prefix))-1) where \&.prefix contains the required string enclosed in quotes, e\&.g\&. 'string' or 'string' "
.in -1c
.SH "Detailed Description"
.PP 
control derived type as a C struct 
.SH "Field Documentation"
.PP 
.SS "int model"

.PP
the model used\&. Possible values are 
.PD 0

.IP "\(bu" 2
0 dynamic (\fInot yet implemented\fP) 
.IP "\(bu" 2
1 first-order (no Hessian) 
.IP "\(bu" 2
2 second-order (exact Hessian) 
.IP "\(bu" 2
3 barely second-order (identity Hessian) 
.IP "\(bu" 2
4 secant second-order (sparsity-based) 
.IP "\(bu" 2
5 secant second-order (limited-memory BFGS, with \&.lbfgs_vectors history) 
.IP "\(bu" 2
6 secant second-order (limited-memory SR1, with \&.lbfgs_vectors history) 
.PP

.SS "int non_monotone"

.PP
the descent strategy used\&. Possible values are 
.PD 0

.IP "\(bu" 2
<= 0 a monotone strategy is used\&. 
.IP "\(bu" 2
anything else, a non-monotone strategy with history length \&.non_monotine is used\&. 
.PP

.SS "int norm"

.PP
the trust-region norm used\&. The norm is defined via ||v||^2 = v^T P v, and will define the preconditioner used for iterative methods\&. Possible values for P are 
.PD 0

.IP "\(bu" 2
-3 users own preconditioner 
.IP "\(bu" 2
-2 P = limited-memory BFGS matrix (with \&.lbfgs_vectors history) 
.IP "\(bu" 2
-1 identity (= Euclidan two-norm) 
.IP "\(bu" 2
0 automatic (\fInot yet implemented\fP) 
.IP "\(bu" 2
1 diagonal, P = diag( max( Hessian, \&.min_diagonal ) ) 
.IP "\(bu" 2
2 banded, P = band( Hessian ) with semi-bandwidth \&.semi_bandwidth 
.IP "\(bu" 2
3 re-ordered band, P=band(order(A)) with semi-bandwidth \&.semi_bandwidth 
.IP "\(bu" 2
4 full factorization, P = Hessian, Schnabel-Eskow modification 
.IP "\(bu" 2
5 full factorization, P = Hessian, GMPS modification (\fInot yet implemented\fP) 
.IP "\(bu" 2
6 incomplete factorization of Hessian, Lin-More' 
.IP "\(bu" 2
7 incomplete factorization of Hessian, HSL_MI28 
.IP "\(bu" 2
8 incomplete factorization of Hessian, Munskgaard (\fInot yet implemented\fP) 
.IP "\(bu" 2
9 expanding band of Hessian (\fInot yet implemented\fP) 
.IP "\(bu" 2
10 diagonalizing norm from GALAHAD_DPS (\fIsubproblem_direct only\fP) 
.PP

.SS "int print_level"

.PP
the level of output required\&. 
.PD 0

.IP "\(bu" 2
<= 0 gives no output, 
.IP "\(bu" 2
= 1 gives a one-line summary for every iteration, 
.IP "\(bu" 2
= 2 gives a summary of the inner iteration for each iteration, 
.IP "\(bu" 2
>= 3 gives increasingly verbose (debugging) output 
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for C interfaces to GALAHAD TRU from the source code\&.

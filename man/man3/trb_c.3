.TH "galahad_trb.h" 3 "Wed May 3 2023" "C interfaces to GALAHAD TRB" \" -*- nroff -*-
.ad l
.nh
.SH NAME
galahad_trb.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdbool\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include 'galahad_precision\&.h'\fP
.br
\fC#include 'galahad_cfunctions\&.h'\fP
.br
\fC#include 'galahad_trs\&.h'\fP
.br
\fC#include 'galahad_gltr\&.h'\fP
.br
\fC#include 'galahad_psls\&.h'\fP
.br
\fC#include 'galahad_lms\&.h'\fP
.br
\fC#include 'galahad_sha\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBtrb_control_type\fP"
.br
.ti -1c
.RI "struct \fBtrb_time_type\fP"
.br
.ti -1c
.RI "struct \fBtrb_inform_type\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBtrb_initialize\fP (void **data, struct \fBtrb_control_type\fP *control, int *status)"
.br
.ti -1c
.RI "void \fBtrb_read_specfile\fP (struct \fBtrb_control_type\fP *control, const char specfile[])"
.br
.ti -1c
.RI "void \fBtrb_import\fP (struct \fBtrb_control_type\fP *control, void **data, int *status, int n, const real_wp_ x_l[], const real_wp_ x_u[], const char H_type[], int ne, const int H_row[], const int H_col[], const int H_ptr[])"
.br
.ti -1c
.RI "void \fBtrb_reset_control\fP (struct \fBtrb_control_type\fP *control, void **data, int *status)"
.br
.ti -1c
.RI "void \fBtrb_solve_with_mat\fP (void **data, void *userdata, int *status, int n, real_wp_ x[], real_wp_ g[], int ne, int(*eval_f)(int, const real_wp_[], real_wp_ *, const void *), int(*eval_g)(int, const real_wp_[], real_wp_[], const void *), int(*eval_h)(int, int, const real_wp_[], real_wp_[], const void *), int(*eval_prec)(int, const real_wp_[], real_wp_[], const real_wp_[], const void *))"
.br
.ti -1c
.RI "void \fBtrb_solve_without_mat\fP (void **data, void *userdata, int *status, int n, real_wp_ x[], real_wp_ g[], int(*eval_f)(int, const real_wp_[], real_wp_ *, const void *), int(*eval_g)(int, const real_wp_[], real_wp_[], const void *), int(*eval_hprod)(int, const real_wp_[], real_wp_[], const real_wp_[], bool, const void *), int(*eval_shprod)(int, const real_wp_[], int, const int[], const real_wp_[], int *, int[], real_wp_[], bool, const void *), int(*eval_prec)(int, const real_wp_[], real_wp_[], const real_wp_[], const void *))"
.br
.ti -1c
.RI "void \fBtrb_solve_reverse_with_mat\fP (void **data, int *status, int *eval_status, int n, real_wp_ x[], real_wp_ f, real_wp_ g[], int ne, real_wp_ H_val[], const real_wp_ u[], real_wp_ v[])"
.br
.ti -1c
.RI "void \fBtrb_solve_reverse_without_mat\fP (void **data, int *status, int *eval_status, int n, real_wp_ x[], real_wp_ f, real_wp_ g[], real_wp_ u[], real_wp_ v[], int index_nz_v[], int *nnz_v, const int index_nz_u[], int nnz_u)"
.br
.ti -1c
.RI "void \fBtrb_information\fP (void **data, struct \fBtrb_inform_type\fP *inform, int *status)"
.br
.ti -1c
.RI "void \fBtrb_terminate\fP (void **data, struct \fBtrb_control_type\fP *control, struct \fBtrb_inform_type\fP *inform)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SH "Introduction"
.PP
.SS "Purpose"
The trb package uses a \fBtrust-region method to find a (local) minimizer of a differentiable objective function f(x) of many variables x, where the variables satisfy the simple bounds {x^l <= x <= x^u}\&.\fP The method offers the choice of direct and iterative solution of the key subproblems, and is most suitable for large problems\&. First derivatives are required, and if second derivatives can be calculated, they will be exploited---if the product of second derivatives with a vector may be found but not the derivatives themselves, that may also be exploited\&.
.SS "Authors"
N\&. I\&. M\&. Gould, STFC-Rutherford Appleton Laboratory, England\&.
.PP
C interface, additionally J\&. Fowkes, STFC-Rutherford Appleton Laboratory\&.
.PP
Julia interface, additionally A\&. Montoison and D\&. Orban, Polytechnique MontrÃ©al\&.
.SS "Originally released"
July 2021, C interface August 2021\&.
.SS "Terminology"
The \fIgradient\fP nabla_x f(x) of f(x) is the vector whose i-th component is partial f(x)/partial x_i\&. The \fIHessian\fP nabla_{xx} f(x) of f(x) is the symmetric matrix whose i,j-th entry is partial^2 f(x)/partial x_i partial x_j\&. The Hessian is \fIsparse\fP if a significant and useful proportion of the entries are universally zero\&.
.SS "Method"
A trust-region method is used\&. In this, an improvement to a current estimate of the required minimizer, x_k is sought by computing a step s_k\&. The step is chosen to approximately minimize a model m_k(s) of f(x_k + s) within the intersection of the bound constraints x^l <= x <= x^u and a trust region ||s_k|| <= Delta_k for some specified positive 'radius' Delta_k\&. The quality of the resulting step s_k is assessed by computing the 'ratio' (f(x_k) - f(x_k + s_k))/ (m_k(0) - m_k(s_k))\&. The step is deemed to have succeeded if the ratio exceeds a given eta_s > 0, and in this case x_{k+1} = x_k + s_k\&. Otherwise x_{k+1} = x_k, and the radius is reduced by powers of a given reduction factor until it is smaller than ||s_k||\&. If the ratio is larger than eta_v >= eta_d, the radius will be increased so that it exceeds ||s_k|| by a given increase factor\&. The method will terminate as soon as ||nabla_x f(x_k)|| is smaller than a specified value\&.
.PP
Either linear or quadratic models m_k(s) may be used\&. The former will be taken as the first two terms f(x_k) + s^T nabla_x f(x_k) of a Taylor series about x_k, while the latter uses an approximation to the first three terms f(x_k) + s^T nabla_x f(x_k) + 1/2 s^T B_k s, for which B_k is a symmetric approximation to the Hessian nabla_{xx}f(x_k); possible approximations include the true Hessian, limited-memory secant and sparsity approximations and a scaled identity matrix\&. Normally a two-norm trust region will be used, but this may change if preconditioning is employed\&.
.PP
The model minimization is carried out in two stages\&. Firstly, the so-called generalized Cauchy point for the quadratic subproblem is found---the purpose of this point is to ensure that the algorithm converges and that the set of bounds which are satisfied as equations at the solution is rapidly identified\&. Thereafter an improvement to the quadratic model on the face of variables predicted to be active by the Cauchy point is sought using either a direct approach involving factorization or an iterative (conjugate-gradient/Lanczos) approach based on approximations to the required solution from a so-called Krlov subspace\&. The direct approach is based on the knowledge that the required solution satisfies the linear system of equations (B_k + lambda_k I) s_k = - nabla_x f(x_k), involving a scalar Lagrange multiplier lambda_k, on the space of inactive variables\&. This multiplier is found by uni-variate root finding, using a safeguarded Newton-like process, by the GALAHAD package TRS\&. The iterative approach uses GALAHAD package GLTR, and is best accelerated by preconditioning with good approximations to B_k using GALAHAD's PSLS\&. The iterative approach has the advantage that only matrix-vector products B_k v are required, and thus B_k is not required explicitly\&. However when factorizations of B_k are possible, the direct approach is often more efficient\&.
.PP
The iteration is terminated as soon as the Euclidean norm of the projected gradient, \[||\min(\max( x_k - nabla_x f(x_k), x^l), x^u) -x_k||_2,\] is sufficiently small\&. At such a point, nabla_x f(x_k) = z_k, where the i-th dual variable z_i is non-negative if x_i is on its lower bound x^l_i, non-positive if x_i is on its upper bound x^u_i, and zero if x_i lies strictly between its bounds\&.
.SS "References"
The generic bound-constrained trust-region method is described in detail in
.PP
A\&. R\&. Conn, N\&. I\&. M\&. Gould and Ph\&. L\&. Toint, 'Trust-region methods', SIAM/MPS Series on Optimization (2000)\&.
.SH "Call order"
.PP
To solve a given problem, functions from the trb package must be called in the following order:
.PP
.IP "\(bu" 2
\fBtrb_initialize\fP - provide default control parameters and set up initial data structures
.IP "\(bu" 2
\fBtrb_read_specfile\fP (optional) - override control values by reading replacement values from a file
.IP "\(bu" 2
\fBtrb_import\fP - set up problem data structures and fixed values
.IP "\(bu" 2
\fBtrb_reset_control\fP (optional) - possibly change control parameters if a sequence of problems are being solved
.IP "\(bu" 2
solve the problem by calling one of
.IP "  \(bu" 4
\fBtrb_solve_with_mat\fP - solve using function calls to evaluate function, gradient and Hessian values
.IP "  \(bu" 4
\fBtrb_solve_without_mat\fP - solve using function calls to evaluate function and gradient values and Hessian-vector products
.IP "  \(bu" 4
\fBtrb_solve_reverse_with_mat\fP - solve returning to the calling program to obtain function, gradient and Hessian values, or
.IP "  \(bu" 4
\fBtrb_solve_reverse_without_mat\fP - solve returning to the calling prorgram to obtain function and gradient values and Hessian-vector products
.PP

.IP "\(bu" 2
\fBtrb_information\fP (optional) - recover information about the solution and solution process
.IP "\(bu" 2
\fBtrb_terminate\fP - deallocate data structures
.PP
.PP
   
  See the examples section for illustrations of use.
  
.SH "Symmetric matrix storage formats"
.PP
The symmetric n by n matrix H = nabla_{xx}f may be presented and stored in a variety of formats\&. But crucially symmetry is exploited by only storing values from the lower triangular part (i\&.e, those entries that lie on or below the leading diagonal)\&.
.PP
Both C-style (0 based) and fortran-style (1-based) indexing is allowed\&. Choose \fCcontrol\&.f_indexing\fP as \fCfalse\fP for C style and \fCtrue\fP for fortran style; the discussion below presumes C style, but add 1 to indices for the corresponding fortran version\&.
.PP
Wrappers will automatically convert between 0-based (C) and 1-based (fortran) array indexing, so may be used transparently from C\&. This conversion involves both time and memory overheads that may be avoided by supplying data that is already stored using 1-based indexing\&.
.SS "Dense storage format"
The matrix H is stored as a compact dense matrix by rows, that is, the values of the entries of each row in turn are stored in order within an appropriate real one-dimensional array\&. Since H is symmetric, only the lower triangular part (that is the part H_{ij} for 0 <= j <= i <= n-1) need be held\&. In this case the lower triangle should be stored by rows, that is component i * i / 2 + j of the storage array H_val will hold the value H_{ij} (and, by symmetry, H_{ji}) for 0 <= j <= i <= n-1\&.
.SS "Sparse co-ordinate storage format"
Only the nonzero entries of the matrices are stored\&. For the l-th entry, 0 <= l <= ne-1, of H, its row index i, column index j and value H_{ij}, 0 <= j <= i <= n-1, are stored as the l-th components of the integer arrays H_row and H_col and real array H_val, respectively, while the number of nonzeros is recorded as H_ne = ne\&. Note that only the entries in the lower triangle should be stored\&.
.SS "Sparse row-wise storage format"
Again only the nonzero entries are stored, but this time they are ordered so that those in row i appear directly before those in row i+1\&. For the i-th row of H the i-th component of the integer array H_ptr holds the position of the first entry in this row, while H_ptr(n) holds the total number of entries\&. The column indices j, 0 <= j <= i, and values H_{ij} of the entries in the i-th row are stored in components l = H_ptr(i), \&.\&.\&., H_ptr(i+1)-1 of the integer array H_col, and real array H_val, respectively\&. Note that as before only the entries in the lower triangle should be stored\&. For sparse matrices, this scheme almost always requires less storage than its predecessor\&. 
.SH "Data Structure Documentation"
.PP 
.SH "struct trb_control_type"
.PP 
control derived type as a C struct 
.PP
\fBData Fields:\fP
.RS 4
bool \fIf_indexing\fP use C or Fortran sparse matrix indexing 
.br
.PP
int \fIerror\fP error and warning diagnostics occur on stream error 
.br
.PP
int \fIout\fP general output occurs on stream out 
.br
.PP
int \fIprint_level\fP the level of output required\&. 
.PD 0

.IP "\(bu" 2
<= 0 gives no output, 
.IP "\(bu" 2
= 1 gives a one-line summary for every iteration, 
.IP "\(bu" 2
= 2 gives a summary of the inner iteration for each iteration, 
.IP "\(bu" 2
>= 3 gives increasingly verbose (debugging) output 
.PP

.br
.PP
int \fIstart_print\fP any printing will start on this iteration 
.br
.PP
int \fIstop_print\fP any printing will stop on this iteration 
.br
.PP
int \fIprint_gap\fP the number of iterations between printing 
.br
.PP
int \fImaxit\fP the maximum number of iterations performed 
.br
.PP
int \fIalive_unit\fP removal of the file alive_file from unit alive_unit terminates execution 
.br
.PP
char \fIalive_file[31]\fP see alive_unit 
.br
.PP
int \fImore_toraldo\fP more_toraldo >= 1 gives the number of More'-Toraldo projected searches to be used to improve upon the Cauchy point, anything else is for the standard add-one-at-a-time CG search 
.br
.PP
int \fInon_monotone\fP non-monotone <= 0 monotone strategy used, anything else non-monotone strategy with this history length used 
.br
.PP
int \fImodel\fP the model used\&. Possible values are 
.PD 0

.IP "\(bu" 2
0 dynamic (\fInot yet implemented\fP) 
.IP "\(bu" 2
1 first-order (no Hessian) 
.IP "\(bu" 2
2 second-order (exact Hessian) 
.IP "\(bu" 2
3 barely second-order (identity Hessian) 
.IP "\(bu" 2
4 secant second-order (sparsity-based) 
.IP "\(bu" 2
5 secant second-order (limited-memory BFGS, with \&.lbfgs_vectors history) (\fInot yet implemented\fP) 
.IP "\(bu" 2
6 secant second-order (limited-memory SR1, with \&.lbfgs_vectors history) (\fInot yet implemented\fP) 
.PP

.br
.PP
int \fInorm\fP The norm is defined via ||v||^2 = v^T P v, and will define the preconditioner used for iterative methods\&. Possible values for P are\&. 
.PD 0

.IP "\(bu" 2
-3 users own preconditioner 
.IP "\(bu" 2
-2 P = limited-memory BFGS matrix (with \&.lbfgs_vectors history) 
.IP "\(bu" 2
-1 identity (= Euclidan two-norm) 
.IP "\(bu" 2
0 automatic (\fInot yet implemented\fP) 
.IP "\(bu" 2
1 diagonal, P = diag( max( Hessian, \&.min_diagonal ) ) 
.IP "\(bu" 2
2 banded, P = band( Hessian ) with semi-bandwidth \&.semi_bandwidth 
.IP "\(bu" 2
3 re-ordered band, P=band(order(A)) with semi-bandwidth \&.semi_bandwidth 
.IP "\(bu" 2
4 full factorization, P = Hessian, Schnabel-Eskow modification 
.IP "\(bu" 2
5 full factorization, P = Hessian, GMPS modification (\fInot yet implemented\fP) 
.IP "\(bu" 2
6 incomplete factorization of Hessian, Lin-More' 
.IP "\(bu" 2
7 incomplete factorization of Hessian, HSL_MI28 
.IP "\(bu" 2
8 incomplete factorization of Hessian, Munskgaard (\fInot yet implemented\fP) 
.IP "\(bu" 2
9 expanding band of Hessian (\fInot yet implemented\fP) 
.PP

.br
.PP
int \fIsemi_bandwidth\fP specify the semi-bandwidth of the band matrix P if required 
.br
.PP
int \fIlbfgs_vectors\fP number of vectors used by the L-BFGS matrix P if required 
.br
.PP
int \fImax_dxg\fP number of vectors used by the sparsity-based secant Hessian if required 
.br
.PP
int \fIicfs_vectors\fP number of vectors used by the Lin-More' incomplete factorization matrix P if required 
.br
.PP
int \fImi28_lsize\fP the maximum number of fill entries within each column of the incomplete factor L computed by HSL_MI28\&. In general, increasing \&.mi28_lsize improve the quality of the preconditioner but increases the time to compute and then apply the preconditioner\&. Values less than 0 are treated as 0 
.br
.PP
int \fImi28_rsize\fP the maximum number of entries within each column of the strictly lower triangular matrix R used in the computation of the preconditioner by HSL_MI28\&. Rank-1 arrays of size \&.mi28_rsize * n are allocated internally to hold R\&. Thus the amount of memory used, as well as the amount of work involved in computing the preconditioner, depends on \&.mi28_rsize\&. Setting \&.mi28_rsize > 0 generally leads to a higher quality preconditioner than using \&.mi28_rsize = 0, and choosing \&.mi28_rsize >= \&.mi28_lsize is generally recommended 
.br
.PP
int \fIadvanced_start\fP iterates of a variant on the strategy of Sartenaer SISC 18(6)1990:1788-1803 
.br
.PP
real_wp_ \fIinfinity\fP any bound larger than infinity in modulus will be regarded as infinite 
.br
.PP
real_wp_ \fIstop_pg_absolute\fP overall convergence tolerances\&. The iteration will terminate when the norm of the gradient of the objective function is smaller than MAX( \&.stop_pg_absolute, \&.stop_pg_relative * norm of the initial gradient ) or if the step is less than \&.stop_s 
.br
.PP
real_wp_ \fIstop_pg_relative\fP see stop_pg_absolute 
.br
.PP
real_wp_ \fIstop_s\fP see stop_pg_absolute 
.br
.PP
real_wp_ \fIinitial_radius\fP initial value for the trust-region radius 
.br
.PP
real_wp_ \fImaximum_radius\fP maximum permitted trust-region radius 
.br
.PP
real_wp_ \fIstop_rel_cg\fP required relative reduction in the resuiduals from CG 
.br
.PP
real_wp_ \fIeta_successful\fP a potential iterate will only be accepted if the actual decrease f - f(x_new) is larger than \&.eta_successful times that predicted by a quadratic model of the decrease\&. The trust-region radius will be increased if this relative decrease is greater than \&.eta_very_successful but smaller than \&.eta_too_successful 
.br
.PP
real_wp_ \fIeta_very_successful\fP see eta_successful 
.br
.PP
real_wp_ \fIeta_too_successful\fP see eta_successful 
.br
.PP
real_wp_ \fIradius_increase\fP on very successful iterations, the trust-region radius will be increased the factor \&.radius_increase, while if the iteration is unsucceful, the radius will be decreased by a factor \&.radius_reduce but no more than \&.radius_reduce_max 
.br
.PP
real_wp_ \fIradius_reduce\fP see radius_increase 
.br
.PP
real_wp_ \fIradius_reduce_max\fP see radius_increase 
.br
.PP
real_wp_ \fIobj_unbounded\fP the smallest value the objective function may take before the problem is marked as unbounded 
.br
.PP
real_wp_ \fIcpu_time_limit\fP the maximum CPU time allowed (-ve means infinite) 
.br
.PP
real_wp_ \fIclock_time_limit\fP the maximum elapsed clock time allowed (-ve means infinite) 
.br
.PP
bool \fIhessian_available\fP is the Hessian matrix of second derivatives available or is access only via matrix-vector products? 
.br
.PP
bool \fIsubproblem_direct\fP use a direct (factorization) or (preconditioned) iterative method to find the search direction 
.br
.PP
bool \fIretrospective_trust_region\fP is a retrospective strategy to be used to update the trust-region radius 
.br
.PP
bool \fIrenormalize_radius\fP should the radius be renormalized to account for a change in preconditioner? 
.br
.PP
bool \fItwo_norm_tr\fP should an ellipsoidal trust-region be used rather than an infinity norm one? 
.br
.PP
bool \fIexact_gcp\fP is the exact Cauchy point required rather than an approximation? 
.br
.PP
bool \fIaccurate_bqp\fP should the minimizer of the quadratic model within the intersection of the trust-region and feasible box be found (to a prescribed accuracy) rather than a (much) cheaper approximation? 
.br
.PP
bool \fIspace_critical\fP if \&.space_critical true, every effort will be made to use as little space as possible\&. This may result in longer computation time 
.br
.PP
bool \fIdeallocate_error_fatal\fP if \&.deallocate_error_fatal is true, any array/pointer deallocation error will terminate execution\&. Otherwise, computation will continue 
.br
.PP
char \fIprefix[31]\fP all output lines will be prefixed by \&.prefix(2:LEN(TRIM(\&.prefix))-1) where \&.prefix contains the required string enclosed in quotes, e\&.g\&. 'string' or 'string' 
.br
.PP
struct trs_control_type \fItrs_control\fP control parameters for TRS 
.br
.PP
struct gltr_control_type \fIgltr_control\fP control parameters for GLTR 
.br
.PP
struct psls_control_type \fIpsls_control\fP control parameters for PSLS 
.br
.PP
struct lms_control_type \fIlms_control\fP control parameters for LMS 
.br
.PP
struct lms_control_type \fIlms_control_prec\fP control parameters for LMS used for preconditioning 
.br
.PP
struct sha_control_type \fIsha_control\fP control parameters for SHA 
.br
.PP
.RE
.PP
.SH "struct trb_time_type"
.PP 
time derived type as a C struct 
.PP
\fBData Fields:\fP
.RS 4
real_sp_ \fItotal\fP the total CPU time spent in the package 
.br
.PP
real_sp_ \fIpreprocess\fP the CPU time spent preprocessing the problem 
.br
.PP
real_sp_ \fIanalyse\fP the CPU time spent analysing the required matrices prior to factorization 
.br
.PP
real_sp_ \fIfactorize\fP the CPU time spent factorizing the required matrices 
.br
.PP
real_sp_ \fIsolve\fP the CPU time spent computing the search direction 
.br
.PP
real_wp_ \fIclock_total\fP the total clock time spent in the package 
.br
.PP
real_wp_ \fIclock_preprocess\fP the clock time spent preprocessing the problem 
.br
.PP
real_wp_ \fIclock_analyse\fP the clock time spent analysing the required matrices prior to factorization 
.br
.PP
real_wp_ \fIclock_factorize\fP the clock time spent factorizing the required matrices 
.br
.PP
real_wp_ \fIclock_solve\fP the clock time spent computing the search direction 
.br
.PP
.RE
.PP
.SH "struct trb_inform_type"
.PP 
inform derived type as a C struct 
.PP
\fBData Fields:\fP
.RS 4
int \fIstatus\fP return status\&. See TRB_solve for details 
.br
.PP
int \fIalloc_status\fP the status of the last attempted allocation/deallocation 
.br
.PP
char \fIbad_alloc[81]\fP the name of the array for which an allocation/deallocation error occurred 
.br
.PP
int \fIiter\fP the total number of iterations performed 
.br
.PP
int \fIcg_iter\fP the total number of CG iterations performed 
.br
.PP
int \fIcg_maxit\fP the maximum number of CG iterations allowed per iteration 
.br
.PP
int \fIf_eval\fP the total number of evaluations of the objective function 
.br
.PP
int \fIg_eval\fP the total number of evaluations of the gradient of the objective function 
.br
.PP
int \fIh_eval\fP the total number of evaluations of the Hessian of the objective function 
.br
.PP
int \fIn_free\fP the number of variables that are free from their bounds 
.br
.PP
int \fIfactorization_max\fP the maximum number of factorizations in a sub-problem solve 
.br
.PP
int \fIfactorization_status\fP the return status from the factorization 
.br
.PP
int64_t \fImax_entries_factors\fP the maximum number of entries in the factors 
.br
.PP
int64_t \fIfactorization_integer\fP the total integer workspace required for the factorization 
.br
.PP
int64_t \fIfactorization_real\fP the total real workspace required for the factorization 
.br
.PP
real_wp_ \fIobj\fP the value of the objective function at the best estimate of the solution determined by TRB_solve 
.br
.PP
real_wp_ \fInorm_pg\fP the norm of the projected gradient of the objective function at the best estimate of the solution determined by TRB_solve 
.br
.PP
real_wp_ \fIradius\fP the current value of the trust-region radius 
.br
.PP
struct \fBtrb_time_type\fP \fItime\fP timings (see above) 
.br
.PP
struct trs_inform_type \fItrs_inform\fP inform parameters for TRS 
.br
.PP
struct gltr_inform_type \fIgltr_inform\fP inform parameters for GLTR 
.br
.PP
struct psls_inform_type \fIpsls_inform\fP inform parameters for PSLS 
.br
.PP
struct lms_inform_type \fIlms_inform\fP inform parameters for LMS 
.br
.PP
struct lms_inform_type \fIlms_inform_prec\fP inform parameters for LMS used for preconditioning 
.br
.PP
struct sha_inform_type \fIsha_inform\fP inform parameters for SHA 
.br
.PP
.RE
.PP
.SH "Function Documentation"
.PP 
.SS "void trb_initialize (void ** data, struct \fBtrb_control_type\fP * control, int * status)"
Set default control values and initialize private data
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIcontrol\fP is a struct containing control information (see \fBtrb_control_type\fP)
.br
\fIstatus\fP is a scalar variable of type int, that gives the exit status from the package\&. Possible values are (currently): 
.PD 0

.IP "\(bu" 2
0\&. The import was succesful\&. 
.PP
.RE
.PP

.SS "void trb_read_specfile (struct \fBtrb_control_type\fP * control, const char specfile[])"
Read the content of a specification file, and assign values associated with given keywords to the corresponding control parameters\&. By default, the spcification file will be named RUNTRB\&.SPC and lie in the current directory\&. Refer to Table 2\&.1 in the fortran documentation provided in $GALAHAD/doc/trb\&.pdf for a list of keywords that may be set\&.
.PP
\fBParameters\fP
.RS 4
\fIcontrol\fP is a struct containing control information (see \fBtrb_control_type\fP)
.br
\fIspecfile\fP is a character string containing the name of the specification file 
.RE
.PP

.SS "void trb_import (struct \fBtrb_control_type\fP * control, void ** data, int * status, int n, const real_wp_ x_l[], const real_wp_ x_u[], const char H_type[], int ne, const int H_row[], const int H_col[], const int H_ptr[])"
Import problem data into internal storage prior to solution\&.
.PP
\fBParameters\fP
.RS 4
\fIcontrol\fP is a struct whose members provide control paramters for the remaining prcedures (see \fBtrb_control_type\fP)
.br
\fIdata\fP holds private internal data
.br
\fIstatus\fP is a scalar variable of type int, that gives the exit status from the package\&. Possible values are: 
.PD 0

.IP "\(bu" 2
1\&. The import was succesful, and the package is ready for the solve phase 
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restriction n > 0 or requirement that type contains its relevant string 'dense', 'coordinate', 'sparse_by_rows', 'diagonal' or 'absent' has been violated\&.
.PP
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables\&.
.br
\fIx_l\fP is a one-dimensional array of size n and type double, that holds the values x^l of the lower bounds on the optimization variables x\&. The j-th component of x_l, j = 0, \&.\&.\&., n-1, contains x^l_j\&.
.br
\fIx_u\fP is a one-dimensional array of size n and type double, that holds the values x^u of the upper bounds on the optimization variables x\&. The j-th component of x_u, j = 0, \&.\&.\&., n-1, contains x^u_j\&.
.br
\fIH_type\fP is a one-dimensional array of type char that specifies the \fBsymmetric storage scheme \fP used for the Hessian\&. It should be one of 'coordinate', 'sparse_by_rows', 'dense', 'diagonal' or 'absent', the latter if access to the Hessian is via matrix-vector products; lower or upper case variants are allowed\&.
.br
\fIne\fP is a scalar variable of type int, that holds the number of entries in the lower triangular part of H in the sparse co-ordinate storage scheme\&. It need not be set for any of the other three schemes\&.
.br
\fIH_row\fP is a one-dimensional array of size ne and type int, that holds the row indices of the lower triangular part of H in the sparse co-ordinate storage scheme\&. It need not be set for any of the other three schemes, and in this case can be NULL
.br
\fIH_col\fP is a one-dimensional array of size ne and type int, that holds the column indices of the lower triangular part of H in either the sparse co-ordinate, or the sparse row-wise storage scheme\&. It need not be set when the dense or diagonal storage schemes are used, and in this case can be NULL
.br
\fIH_ptr\fP is a one-dimensional array of size n+1 and type int, that holds the starting position of each row of the lower triangular part of H, as well as the total number of entries, in the sparse row-wise storage scheme\&. It need not be set when the other schemes are used, and in this case can be NULL 
.RE
.PP

.SS "void trb_reset_control (struct \fBtrb_control_type\fP * control, void ** data, int * status)"
Reset control parameters after import if required\&.
.PP
\fBParameters\fP
.RS 4
\fIcontrol\fP is a struct whose members provide control paramters for the remaining prcedures (see \fBtrb_control_type\fP)
.br
\fIdata\fP holds private internal data
.br
\fIstatus\fP is a scalar variable of type int, that gives the exit status from the package\&. Possible values are: 
.PD 0

.IP "\(bu" 2
1\&. The import was succesful, and the package is ready for the solve phase 
.PP
.RE
.PP

.SS "void trb_solve_with_mat (void ** data, void * userdata, int * status, int n, real_wp_ x[], real_wp_ g[], int ne, int(*)(int, const real_wp_[], real_wp_ *, const void *) eval_f, int(*)(int, const real_wp_[], real_wp_[], const void *) eval_g, int(*)(int, int, const real_wp_[], real_wp_[], const void *) eval_h, int(*)(int, const real_wp_[], real_wp_[], const real_wp_[], const void *) eval_prec)"
Find a local minimizer of a given function subject to simple bounds on the variables using a trust-region method\&.
.PP
This call is for the case where H = nabla_{xx}f(x) is provided specifically, and all function/derivative information is available by function calls\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIuserdata\fP is a structure that allows data to be passed into the function and derivative evaluation programs\&.
.br
\fIstatus\fP is a scalar variable of type int, that gives the entry and exit status from the package\&. 
.br
 On initial entry, status must be set to 1\&. 
.br
 Possible exit are: 
.PD 0

.IP "\(bu" 2
0\&. The run was succesful
.PP
.PD 0
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restriction n > 0 or requirement that type contains its relevant string 'dense', 'coordinate', 'sparse_by_rows', 'diagonal' or 'absent' has been violated\&. 
.IP "\(bu" 2
-7\&. The objective function appears to be unbounded from below 
.IP "\(bu" 2
-9\&. The analysis phase of the factorization failed; the return status from the factorization package is given in the component inform\&.factor_status 
.IP "\(bu" 2
-10\&. The factorization failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-11\&. The solution of a set of linear equations using factors from the factorization package failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-16\&. The problem is so ill-conditioned that further progress is impossible\&. 
.IP "\(bu" 2
-18\&. Too many iterations have been performed\&. This may happen if control\&.maxit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-19\&. The CPU time limit has been reached\&. This may happen if control\&.cpu_time_limit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-82\&. The user has forced termination of solver by removing the file named control\&.alive_file from unit unit control\&.alive_unit\&.
.PP
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables
.br
\fIx\fP is a one-dimensional array of size n and type double, that holds the values x of the optimization variables\&. The j-th component of x, j = 0, \&.\&.\&. , n-1, contains x_j\&.
.br
\fIg\fP is a one-dimensional array of size n and type double, that holds the gradient g = nabla_xf(x) of the objective function\&. The j-th component of g, j = 0, \&.\&.\&. , n-1, contains g_j \&.
.br
\fIne\fP is a scalar variable of type int, that holds the number of entries in the lower triangular part of the Hessian matrix H\&.
.br
\fIeval_f\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_f( int n, const double x[], double *f, const void *userdata )

.fi
.PP
 The value of the objective function f(x) evaluated at x=x must be assigned to f, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_f\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_g\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_g( int n, const double x[], double g[], const void *userdata )

.fi
.PP
 The components of the gradient g = nabla_x f(x) of the objective function evaluated at x=x must be assigned to g, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_g\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_h\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_h( int n, int ne, const double x[], double h[],
            const void *userdata )

.fi
.PP
 The nonzeros of the Hessian H = nabla_{xx}f(x) of the objective function evaluated at x=x must be assigned to h in the same order as presented to trb_import, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_h\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_prec\fP is an optional user-supplied function that may be NULL\&. If non-NULL, it must have the following signature: 
.PP
.nf
int eval_prec( int n, const double x[], double u[], const double v[],
               const void *userdata )

.fi
.PP
 The product u = P(x) v of the user's preconditioner P(x) evaluated at x with the vector v = v, the result u must be retured in u, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_prec\fP via the structure \fCuserdata\fP\&. 
.RE
.PP

.SS "void trb_solve_without_mat (void ** data, void * userdata, int * status, int n, real_wp_ x[], real_wp_ g[], int(*)(int, const real_wp_[], real_wp_ *, const void *) eval_f, int(*)(int, const real_wp_[], real_wp_[], const void *) eval_g, int(*)(int, const real_wp_[], real_wp_[], const real_wp_[], bool, const void *) eval_hprod, int(*)(int, const real_wp_[], int, const int[], const real_wp_[], int *, int[], real_wp_[], bool, const void *) eval_shprod, int(*)(int, const real_wp_[], real_wp_[], const real_wp_[], const void *) eval_prec)"
Find a local minimizer of a given function subject to simple bounds on the variables using a trust-region method\&.
.PP
This call is for the case where access to H = nabla_{xx}f(x) is provided by Hessian-vector products, and all function/derivative information is available by function calls\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIuserdata\fP is a structure that allows data to be passed into the function and derivative evaluation programs\&.
.br
\fIstatus\fP is a scalar variable of type int, that gives the entry and exit status from the package\&. 
.br
 On initial entry, status must be set to 1\&. 
.br
 Possible exit are: 
.PD 0

.IP "\(bu" 2
0\&. The run was succesful
.PP
.PD 0
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restriction n > 0 or requirement that type contains its relevant string 'dense', 'coordinate', 'sparse_by_rows', 'diagonal' or 'absent' has been violated\&. 
.IP "\(bu" 2
-7\&. The objective function appears to be unbounded from below 
.IP "\(bu" 2
-9\&. The analysis phase of the factorization failed; the return status from the factorization package is given in the component inform\&.factor_status 
.IP "\(bu" 2
-10\&. The factorization failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-11\&. The solution of a set of linear equations using factors from the factorization package failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-16\&. The problem is so ill-conditioned that further progress is impossible\&. 
.IP "\(bu" 2
-18\&. Too many iterations have been performed\&. This may happen if control\&.maxit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-19\&. The CPU time limit has been reached\&. This may happen if control\&.cpu_time_limit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-82\&. The user has forced termination of solver by removing the file named control\&.alive_file from unit unit control\&.alive_unit\&.
.PP
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables
.br
\fIx\fP is a one-dimensional array of size n and type double, that holds the values x of the optimization variables\&. The j-th component of x, j = 0, \&.\&.\&. , n-1, contains x_j\&.
.br
\fIg\fP is a one-dimensional array of size n and type double, that holds the gradient g = nabla_xf(x) of the objective function\&. The j-th component of g, j = 0, \&.\&.\&. , n-1, contains g_j \&.
.br
\fIeval_f\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_f( int n, const double x[], double *f, const void *userdata )

.fi
.PP
 The value of the objective function f(x) evaluated at x=x must be assigned to f, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_f\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_g\fP is a user-supplied function that must have the following signature:
.RE
.PP
.PP
.nf
int eval_g( int n, const double x[], double g[], const void *userdata )
.fi
.PP
 The components of the gradient g = nabla_x f(x) of the objective function evaluated at x=x must be assigned to g, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_g\fP via the structure \fCuserdata\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIeval_hprod\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_hprod( int n, const double x[], double u[], const double v[],
                bool got_h, const void *userdata )

.fi
.PP
 The sum u + nabla_{xx}f(x) v of the product of the Hessian nabla_{xx}f(x) of the objective function evaluated at x=x with the vector v=v and the vector $u must be returned in u, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. The Hessian has already been evaluated or used at x if got_h is true\&. Data may be passed into \fCeval_hprod\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_shprod\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_shprod( int n, const double x[], int nnz_v,
                 const int index_nz_v[], const double v[],
                 int *nnz_u, int index_nz_u[], double u[],
                 bool got_h, const void *userdata )

.fi
.PP
 The product u = nabla_{xx}f(x) v of the Hessian nabla_{xx}f(x) of the objective function evaluated at x with the sparse vector v=v must be returned in u, and the function return value set to 0\&. Only the components index_nz_v[0:nnz_v-1] of v are nonzero, and the remaining components may not have been be set\&. On exit, the user must indicate the nnz_u indices of u that are nonzero in index_nz_u[0:nnz_u-1], and only these components of u need be set\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. The Hessian has already been evaluated or used at x if got_h is true\&. Data may be passed into \fCeval_prec\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_prec\fP is an optional user-supplied function that may be NULL\&. If non-NULL, it must have the following signature: 
.PP
.nf
int eval_prec( int n, const double x[], double u[], const double v[],
               const void *userdata )

.fi
.PP
 The product u = P(x) v of the user's preconditioner P(x) evaluated at x with the vector v = v, the result u must be retured in u, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_prec\fP via the structure \fCuserdata\fP\&. 
.RE
.PP

.SS "void trb_solve_reverse_with_mat (void ** data, int * status, int * eval_status, int n, real_wp_ x[], real_wp_ f, real_wp_ g[], int ne, real_wp_ H_val[], const real_wp_ u[], real_wp_ v[])"
Find a local minimizer of a given function subject to simple bounds on the variables using a trust-region method\&.
.PP
This call is for the case where H = nabla_{xx}f(x) is provided specifically, but function/derivative information is only available by returning to the calling procedure
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIstatus\fP is a scalar variable of type int, that gives the entry and exit status from the package\&. 
.br
 On initial entry, status must be set to 1\&. 
.br
 Possible exit are: 
.PD 0

.IP "\(bu" 2
0\&. The run was succesful
.PP
.PD 0
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restriction n > 0 or requirement that type contains its relevant string 'dense', 'coordinate', 'sparse_by_rows', 'diagonal' or 'absent' has been violated\&. 
.IP "\(bu" 2
-7\&. The objective function appears to be unbounded from below 
.IP "\(bu" 2
-9\&. The analysis phase of the factorization failed; the return status from the factorization package is given in the component inform\&.factor_status 
.IP "\(bu" 2
-10\&. The factorization failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-11\&. The solution of a set of linear equations using factors from the factorization package failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-16\&. The problem is so ill-conditioned that further progress is impossible\&. 
.IP "\(bu" 2
-18\&. Too many iterations have been performed\&. This may happen if control\&.maxit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-19\&. The CPU time limit has been reached\&. This may happen if control\&.cpu_time_limit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-82\&. The user has forced termination of solver by removing the file named control\&.alive_file from unit unit control\&.alive_unit\&.
.PP
.br
\fIstatus\fP (continued) 
.PD 0

.IP "\(bu" 2
2\&. The user should compute the objective function value f(x) at the point x indicated in x and then re-enter the function\&. The required value should be set in f, and eval_status should be set to 0\&. If the user is unable to evaluate f(x)--- for instance, if the function is undefined at x--- the user need not set f, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
3\&. The user should compute the gradient of the objective function nabla_x f(x) at the point x indicated in x and then re-enter the function\&. The value of the i-th component of the g radient should be set in g[i], for i = 0, \&.\&.\&., n-1 and eval_status should be set to 0\&. If the user is unable to evaluate a component of nabla_x f(x) --- for instance if a component of the gradient is undefined at x -the user need not set g, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
4\&. The user should compute the Hessian of the objective function nabla_{xx}f(x) at the point x indicated in x and then re-enter the function\&. The value l-th component of the Hessian stored according to the scheme input in the remainder of H should be set in H_val[l], for l = 0, \&.\&.\&., ne-1 and eval_status should be set to 0\&. If the user is unable to evaluate a component of nabla_{xx}f(x) --- for instance, if a component of the Hessian is undefined at x --- the user need not set H_val, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
6\&. The user should compute the product u = P(x)v of their preconditioner P(x) at the point x indicated in x with the vector v and then re-enter the function\&. The vector v is given in v, the resulting vector u = P(x)v should be set in u and eval_status should be set to 0\&. If the user is unable to evaluate the product--- for instance, if a component of the preconditioner is undefined at x --- the user need not set u, but should then set eval_status to a non-zero value\&.
.PP
.br
\fIeval_status\fP is a scalar variable of type int, that is used to indicate if objective function/gradient/Hessian values can be provided (see above)
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables
.br
\fIx\fP is a one-dimensional array of size n and type double, that holds the values x of the optimization variables\&. The j-th component of x, j = 0, \&.\&.\&. , n-1, contains x_j\&.
.br
\fIf\fP is a scalar variable pointer of type double, that holds the value of the objective function\&.
.br
\fIg\fP is a one-dimensional array of size n and type double, that holds the gradient g = nabla_xf(x) of the objective function\&. The j-th component of g, j = 0, \&.\&.\&. , n-1, contains g_j \&.
.br
\fIne\fP is a scalar variable of type int, that holds the number of entries in the lower triangular part of the Hessian matrix H\&.
.br
\fIH_val\fP is a one-dimensional array of size ne and type double, that holds the values of the entries of the lower triangular part of the Hessian matrix H in any of the available storage schemes\&.
.br
\fIu\fP is a one-dimensional array of size n and type double, that is used for reverse communication (see above for details)
.br
\fIv\fP is a one-dimensional array of size n and type double, that is used for reverse communication (see above for details) 
.RE
.PP

.SS "void trb_solve_reverse_without_mat (void ** data, int * status, int * eval_status, int n, real_wp_ x[], real_wp_ f, real_wp_ g[], real_wp_ u[], real_wp_ v[], int index_nz_v[], int * nnz_v, const int index_nz_u[], int nnz_u)"
Find a local minimizer of a given function subject to simple bounds on the variables using a trust-region method\&.
.PP
This call is for the case where access to H = nabla_{xx}f(x) is provided by Hessian-vector products, but function/derivative information is only available by returning to the calling procedure\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIstatus\fP is a scalar variable of type int, that gives the entry and exit status from the package\&. 
.br
 On initial entry, status must be set to 1\&. 
.br
 Possible exit are: 
.PD 0

.IP "\(bu" 2
0\&. The run was succesful
.PP
.PD 0
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restriction n > 0 or requirement that type contains its relevant string 'dense', 'coordinate', 'sparse_by_rows', 'diagonal' or 'absent' has been violated\&. 
.IP "\(bu" 2
-7\&. The objective function appears to be unbounded from below 
.IP "\(bu" 2
-9\&. The analysis phase of the factorization failed; the return status from the factorization package is given in the component inform\&.factor_status 
.IP "\(bu" 2
-10\&. The factorization failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-11\&. The solution of a set of linear equations using factors from the factorization package failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-16\&. The problem is so ill-conditioned that further progress is impossible\&. 
.IP "\(bu" 2
-18\&. Too many iterations have been performed\&. This may happen if control\&.maxit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-19\&. The CPU time limit has been reached\&. This may happen if control\&.cpu_time_limit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-82\&. The user has forced termination of solver by removing the file named control\&.alive_file from unit unit control\&.alive_unit\&.
.PP
.br
\fIstatus\fP (continued) 
.PD 0

.IP "\(bu" 2
2\&. The user should compute the objective function value f(x) at the point x indicated in x and then re-enter the function\&. The required value should be set in f, and eval_status should be set to 0\&. If the user is unable to evaluate f(x) --- for instance, if the function is undefined at x --- the user need not set f, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
3\&. The user should compute the gradient of the objective function nabla_x f(x) at the point x indicated in x and then re-enter the function\&. The value of the i-th component of the g radient should be set in g[i], for i = 0, \&.\&.\&., n-1 and eval_status should be set to 0\&. If the user is unable to evaluate a component of nabla_x f(x) --- for instance if a component of the gradient is undefined at x -the user need not set g, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
5\&. The user should compute the product nabla_{xx}f(x)v of the Hessian of the objective function nabla_{xx}f(x) at the point x indicated in x with the vector v, add the result to the vector u and then re-enter the function\&. The vectors u and v are given in u and v respectively, the resulting vector u + nabla_{xx}f(x)v should be set in u and eval_status should be set to 0\&. If the user is unable to evaluate the product--- for instance, if a component of the Hessian is undefined at x --- the user need not alter u, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
6\&. The user should compute the product u = P(x)v of their preconditioner P(x) at the point x indicated in x with the vector v and then re-enter the function\&. The vector v is given in v, the resulting vector u = P(x)v should be set in u and eval_status should be set to 0\&. If the user is unable to evaluate the product--- for instance, if a component of the preconditioner is undefined at x --- the user need not set u, but should then set eval_status to a non-zero value\&. 
.IP "\(bu" 2
7\&. The user should compute the product u = nabla_{xx}f(x)v of the Hessian of the objective function nabla_{xx}f(x) at the point x indicated in x with the \fBsparse\fP vector v=v and then re-enter the function\&. The nonzeros of v are stored in v[index_nz_v[0:nnz_v-1]] while the nonzeros of u should be returned in u[index_nz_u[0:nnz_u-1]]; the user must set nnz_u and index_nz_u accordingly, and set eval_status to 0\&. If the user is unable to evaluate the product--- for instance, if a component of the Hessian is undefined at x--- the user need not alter u, but should then set eval_status to a non-zero value\&.
.PP
.br
\fIeval_status\fP is a scalar variable of type int, that is used to indicate if objective function/gradient/Hessian values can be provided (see above)
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables
.br
\fIx\fP is a one-dimensional array of size n and type double, that holds the values x of the optimization variables\&. The j-th component of x, j = 0, \&.\&.\&. , n-1, contains x_j\&.
.br
\fIf\fP is a scalar variable pointer of type double, that holds the value of the objective function\&.
.br
\fIg\fP is a one-dimensional array of size n and type double, that holds the gradient g = nabla_xf(x) of the objective function\&. The j-th component of g, j = 0, \&.\&.\&. , n-1, contains g_j \&.
.br
\fIu\fP is a one-dimensional array of size n and type double, that is used for reverse communication (see status=5,6,7 above for details)
.br
\fIv\fP is a one-dimensional array of size n and type double, that is used for reverse communication (see status=5,6,7 above for details)
.br
\fIindex_nz_v\fP is a one-dimensional array of size n and type int, that is used for reverse communication (see status=7 above for details)
.br
\fInnz_v\fP is a scalar variable of type int, that is used for reverse communication (see status=7 above for details)
.br
\fIindex_nz_u\fP s a one-dimensional array of size n and type int, that is used for reverse communication (see status=7 above for details)
.br
\fInnz_u\fP is a scalar variable of type int, that is used for reverse communication (see status=7 above for details)\&. On initial (status=1) entry, nnz_u should be set to an (arbitrary) nonzero value, and nnz_u=0 is recommended 
.RE
.PP

.SS "void trb_information (void ** data, struct \fBtrb_inform_type\fP * inform, int * status)"
Provides output information
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIinform\fP is a struct containing output information (see \fBtrb_inform_type\fP)
.br
\fIstatus\fP is a scalar variable of type int, that gives the exit status from the package\&. Possible values are (currently): 
.PD 0

.IP "\(bu" 2
0\&. The values were recorded succesfully 
.PP
.RE
.PP

.SS "void trb_terminate (void ** data, struct \fBtrb_control_type\fP * control, struct \fBtrb_inform_type\fP * inform)"
Deallocate all internal private storage
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIcontrol\fP is a struct containing control information (see \fBtrb_control_type\fP)
.br
\fIinform\fP is a struct containing output information (see \fBtrb_inform_type\fP) 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for C interfaces to GALAHAD TRB from the source code\&.

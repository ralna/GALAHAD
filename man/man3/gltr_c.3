.TH "galahad_gltr.h" 3 "Thu Jun 22 2023" "C interfaces to GALAHAD GLTR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
galahad_gltr.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdbool\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include 'galahad_precision\&.h'\fP
.br
\fC#include 'galahad_cfunctions\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBgltr_control_type\fP"
.br
.ti -1c
.RI "struct \fBgltr_inform_type\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBgltr_initialize\fP (void **data, struct \fBgltr_control_type\fP *control, int *status)"
.br
.ti -1c
.RI "void \fBgltr_read_specfile\fP (struct \fBgltr_control_type\fP *control, const char specfile[])"
.br
.ti -1c
.RI "void \fBgltr_import_control\fP (struct \fBgltr_control_type\fP *control, void **data, int *status)"
.br
.ti -1c
.RI "void \fBgltr_solve_problem\fP (void **data, int *status, int n, const real_wp_ radius, real_wp_ x[], real_wp_ r[], real_wp_ vector[])"
.br
.ti -1c
.RI "void \fBgltr_information\fP (void **data, struct \fBgltr_inform_type\fP *inform, int *status)"
.br
.ti -1c
.RI "void \fBgltr_terminate\fP (void **data, struct \fBgltr_control_type\fP *control, struct \fBgltr_inform_type\fP *inform)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SH "Introduction"
.PP
.SS "Purpose"
Given real n by n symmetric matrices H and M (with M positive definite), a real n vector c and scalars Delta>0 and f_0, this package finds an \fB approximate minimizer of the quadratic objective function 1/2 x^T H x + c^T x + f_0, where the vector x is required to satisfy the constraint ||x||_M <= Delta\fP, and where the M-norm of x is ||x||_M = sqrt{x^T M x}\&. This problem commonly occurs as a trust-region subproblem in nonlinear optimization calculations\&. The method may be suitable for large n as no factorization of H is required\&. Reverse communication is used to obtain matrix-vector products of the form H z and M^{-1} z\&.
.PP
The package may also be used to solve the related problem in which x is instead required to satisfy the \fBequality constraint ||x||_M = Delta\fP\&.
.SS "Authors"
N\&. I\&. M\&. Gould, STFC-Rutherford Appleton Laboratory, England\&.
.PP
C interface, additionally J\&. Fowkes, STFC-Rutherford Appleton Laboratory\&.
.PP
Julia interface, additionally A\&. Montoison and D\&. Orban, Polytechnique MontrÃ©al\&.
.SS "Originally released"
April 1997, C interface December 2021\&.
.SS "Terminology"
.SS "Method"
The required solution x necessarily satisfies the optimality condition H x + lambda M x + c = 0, where lambda >= 0 is a Lagrange multiplier corresponding to the constraint ||x||_M <= Delta\&. In addition, the matrix H + lambda M will be positive definite\&.
.PP
The method is iterative\&. Starting with the vector M^{-1} c, a matrix of Lanczos vectors is built one column at a time so that the k-th column is generated during iteration k\&. These columns span a so-called Krylov space\&. The resulting n by k matrix Q_k has the property that Q_k^T H Q_k^{} = T_k^{}, where T_k is tridiagonal\&. An approximation to the required solution may then be expressed formally as \[x_{k+1} = Q_k y_k,\]  
\n
   x_{k+1}  =  Q_k y_k,
\n
 where y_k solves the ``tridiagonal'' subproblem of minimizing \[(1) \;\;\; 1/2 y^T T_k y + ||c||_{M^{-1}} e_1^T y\;\mbox{subject to the constraint}\; ||y||_2 <= Delta,\]  
\n
  (1)    1/2 y^T T_k y  + ||c||_M^{-1} e_1^T y
         subject to the constraint ||y||_2  leq  Delta,
\n
 and where e_1 is the first unit vector\&.
.PP
If the solution to (1) lies interior to the constraint, the required solution x_{k+1} may simply be found as the k-th (preconditioned) conjugate-gradient iterate\&. This solution can be obtained without the need to access the whole matrix Q_k\&. These conjugate-gradient iterates increase in M-norm, and thus once one of them exceeds Delta in M-norm, the solution must occur on the constraint boundary\&. Thereafter, the solution to (1) is less easy to obtain, but an efficient inner iteration to solve (1) is nonetheless achievable because T_k is tridiagonal\&. It is possible to observe the optimality measure ||H x + lambda M x + c||_{M^{-1}} without computing x_{k+1}, and thus without needing Q_k \&. Once this measure is sufficiently small, a second pass is required to obtain the estimate x_{k+1} from y_k \&. As this second pass is an additional expense, a record is kept of the optimal objective function values for each value of k, and the second pass is only performed so far as to ensure a given fraction of the final optimal objective value\&. Large savings may be made in the second pass by choosing the required fraction to be significantly smaller than one\&.
.PP
A cheaper alternative is to use the Steihuag-Toint strategy, which is simply to stop at the first boundary point encountered along the piecewise linear path generated by the conjugate-gradient iterates\&. Note that if H is significantly indefinite, this strategy often produces a far from optimal point, but is effective when H is positive definite or almost
.SS "Reference"
The method is described in detail in
.PP
N\&. I\&. M\&. Gould, S\&. Lucidi, M\&. Roma and Ph\&. L\&. Toint, Solving the trust-region subproblem using the Lanczos method\&. SIAM Journal on Optimization \fB9:2\fP (1999), 504-525\&.
.SS "Call order"
To solve a given problem, functions from the gltr package must be called in the following order:
.PP
.IP "\(bu" 2
\fBgltr_initialize\fP - provide default control parameters and set up initial data structures
.IP "\(bu" 2
\fBgltr_read_specfile\fP (optional) - override control values by reading replacement values from a file
.IP "\(bu" 2
\fBgltr_import_control\fP - import control parameters prior to solution
.IP "\(bu" 2
\fBgltr_solve_problem\fP - solve the problem by reverse communication, a sequence of calls are made under control of a status parameter, each exit either asks the user to provide additional informaton and to re-enter, or reports that either the solution has been found or that an error has occurred
.IP "\(bu" 2
\fBgltr_information\fP (optional) - recover information about the solution and solution process
.IP "\(bu" 2
\fBgltr_terminate\fP - deallocate data structures
.PP
.PP
   
  See the examples section for an illustration of use.
   
.SH "Data Structure Documentation"
.PP 
.SH "struct gltr_control_type"
.PP 
control derived type as a C struct 
.PP
\fBData Fields:\fP
.RS 4
bool \fIf_indexing\fP use C or Fortran sparse matrix indexing 
.br
.PP
int \fIerror\fP error and warning diagnostics occur on stream error 
.br
.PP
int \fIout\fP general output occurs on stream out 
.br
.PP
int \fIprint_level\fP the level of output required is specified by print_level 
.br
.PP
int \fIitmax\fP the maximum number of iterations allowed (-ve = no bound) 
.br
.PP
int \fILanczos_itmax\fP the maximum number of iterations allowed once the boundary has been encountered (-ve = no bound) 
.br
.PP
int \fIextra_vectors\fP the number of extra work vectors of length n used 
.br
.PP
int \fIritz_printout_device\fP the unit number for writing debug Ritz values 
.br
.PP
real_wp_ \fIstop_relative\fP the iteration stops successfully when the gradient in the M(inverse) nor is smaller than max( stop_relative * initial M(inverse) gradient norm, stop_absolute ) 
.br
.PP
real_wp_ \fIstop_absolute\fP see stop_relative 
.br
.PP
real_wp_ \fIfraction_opt\fP an estimate of the solution that gives at least \&.fraction_opt times the optimal objective value will be found 
.br
.PP
real_wp_ \fIf_min\fP the iteration stops if the objective-function value is lower than f_min 
.br
.PP
real_wp_ \fIrminvr_zero\fP the smallest value that the square of the M norm of the gradient of the the objective may be before it is considered to be zero 
.br
.PP
real_wp_ \fIf_0\fP the constant term, f_0, in the objective function 
.br
.PP
bool \fIunitm\fP is M the identity matrix ? 
.br
.PP
bool \fIsteihaug_toint\fP should the iteration stop when the Trust-region is first encountered ? 
.br
.PP
bool \fIboundary\fP is the solution thought to lie on the constraint boundary ? 
.br
.PP
bool \fIequality_problem\fP is the solution required to lie on the constraint boundary ? 
.br
.PP
bool \fIspace_critical\fP if \&.space_critical true, every effort will be made to use as little space as possible\&. This may result in longer computation time 
.br
.PP
bool \fIdeallocate_error_fatal\fP if \&.deallocate_error_fatal is true, any array/pointer deallocation error will terminate execution\&. Otherwise, computation will continue 
.br
.PP
bool \fIprint_ritz_values\fP should the Ritz values be written to the debug stream? 
.br
.PP
char \fIritz_file_name[31]\fP name of debug file containing the Ritz values 
.br
.PP
char \fIprefix[31]\fP all output lines will be prefixed by \&.prefix(2:LEN(TRIM(\&.prefix))-1) where \&.prefix contains the required string enclosed in quotes, e\&.g\&. 'string' or 'string' 
.br
.PP
.RE
.PP
.SH "struct gltr_inform_type"
.PP 
inform derived type as a C struct 
.PP
\fBData Fields:\fP
.RS 4
int \fIstatus\fP return status\&. See \fBgltr_solve_problem\fP for details 
.br
.PP
int \fIalloc_status\fP the status of the last attempted allocation/deallocation 
.br
.PP
char \fIbad_alloc[81]\fP the name of the array for which an allocation/deallocation error occurred 
.br
.PP
int \fIiter\fP the total number of iterations required 
.br
.PP
int \fIiter_pass2\fP the total number of pass-2 iterations required if the solution lies on the trust-region boundary 
.br
.PP
real_wp_ \fIobj\fP the value of the quadratic function 
.br
.PP
real_wp_ \fImultiplier\fP the Lagrange multiplier corresponding to the trust-region constraint 
.br
.PP
real_wp_ \fImnormx\fP the M-norm of x 
.br
.PP
real_wp_ \fIpiv\fP the latest pivot in the Cholesky factorization of the Lanczos tridiagona 
.br
.PP
real_wp_ \fIcurv\fP the most negative cuurvature encountered 
.br
.PP
real_wp_ \fIrayleigh\fP the current Rayleigh quotient 
.br
.PP
real_wp_ \fIleftmost\fP an estimate of the leftmost generalized eigenvalue of the pencil (H,M) 
.br
.PP
bool \fInegative_curvature\fP was negative curvature encountered ? 
.br
.PP
bool \fIhard_case\fP did the hard case occur ? 
.br
.PP
.RE
.PP
.SH "Function Documentation"
.PP 
.SS "void gltr_initialize (void ** data, struct \fBgltr_control_type\fP * control, int * status)"
Set default control values and initialize private data
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIcontrol\fP is a struct containing control information (see \fBgltr_control_type\fP)
.br
\fIstatus\fP is a scalar variable of type int, that gives the exit status from the package\&. Possible values are (currently): 
.PD 0

.IP "\(bu" 2
0\&. The import was succesful\&. 
.PP
.RE
.PP

.SS "void gltr_read_specfile (struct \fBgltr_control_type\fP * control, const char specfile[])"
Read the content of a specification file, and assign values associated with given keywords to the corresponding control parameters\&. By default, the spcification file will be named RUNGLTR\&.SPC and lie in the current directory\&. Refer to Table 2\&.1 in the fortran documentation provided in $GALAHAD/doc/gltr\&.pdf for a list of keywords that may be set\&.
.PP
\fBParameters\fP
.RS 4
\fIcontrol\fP is a struct containing control information (see \fBgltr_control_type\fP) 
.br
\fIspecfile\fP is a character string containing the name of the specification file 
.RE
.PP

.SS "void gltr_import_control (struct \fBgltr_control_type\fP * control, void ** data, int * status)"
Import control parameters prior to solution\&.
.PP
\fBParameters\fP
.RS 4
\fIcontrol\fP is a struct whose members provide control paramters for the remaining prcedures (see \fBgltr_control_type\fP)
.br
\fIdata\fP holds private internal data
.br
\fIstatus\fP is a scalar variable of type int, that gives the exit status from the package\&. Possible values are (currently): 
.PD 0

.IP "\(bu" 2
1\&. The import was succesful, and the package is ready for the solve phase 
.PP
.RE
.PP

.SS "void gltr_solve_problem (void ** data, int * status, int n, const real_wp_ radius, real_wp_ x[], real_wp_ r[], real_wp_ vector[])"
Solve the trust-region problem using reverse communication\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIstatus\fP is a scalar variable of type int, that gives the entry and exit status from the package\&. 
.br
 This must be set to 
.PD 0

.IP "\(bu" 2
1\&. on initial entry\&. Set r (below) to c for this entry\&. 
.IP "\(bu" 2
4\&. the iteration is to be restarted with a smaller radius but with all other data unchanged\&. Set r (below) to c for this entry\&.
.PP
Possible exit values are: 
.PD 0

.IP "\(bu" 2
0\&. the solution has been found 
.IP "\(bu" 2
2\&. the inverse of M must be applied to vector with the result returned in vector and the function re-entered with all other data unchanged\&. This will only happen if control\&.unitm is false 
.IP "\(bu" 2
3\&. the product H * vector must be formed, with the result returned in vector and the function re-entered with all other data unchanged 
.IP "\(bu" 2
5\&. The iteration must be restarted\&. Reset r (below) to c and re-enter with all other data unchanged\&. This exit will only occur if control\&.steihaug_toint is false and the solution lies on the trust-region boundary 
.IP "\(bu" 2
-1\&. an array allocation has failed 
.IP "\(bu" 2
-2\&. an array deallocation has failed 
.IP "\(bu" 2
-3\&. n and/or radius is not positive 
.IP "\(bu" 2
-15\&. the matrix M appears to be indefinite 
.IP "\(bu" 2
-18\&. the iteration limit has been exceeded 
.IP "\(bu" 2
-30\&. the trust-region has been encountered in Steihaug-Toint mode 
.IP "\(bu" 2
-31\&. the function value is smaller than control\&.f_min
.PP
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables
.br
\fIradius\fP is a scalar of type double, that holds the trust-region radius, Delta, used\&. radius must be strictly positive
.br
\fIx\fP is a one-dimensional array of size n and type double, that holds the solution x\&. The j-th component of x, j = 0, \&.\&.\&. , n-1, contains x_j \&.
.br
\fIr\fP is a one-dimensional array of size n and type double, that that must be set to c on entry (status = 1) and re-entry ! (status = 4, 5)\&. On exit, r contains the resiual H x + c\&.
.br
\fIvector\fP is a one-dimensional array of size n and type double, that should be used and reset appropriately when status = 2 and 3 as directed\&. 
.RE
.PP

.SS "void gltr_information (void ** data, struct \fBgltr_inform_type\fP * inform, int * status)"
Provides output information
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIinform\fP is a struct containing output information (see \fBgltr_inform_type\fP)
.br
\fIstatus\fP is a scalar variable of type int, that gives the exit status from the package\&. Possible values are (currently): 
.PD 0

.IP "\(bu" 2
0\&. The values were recorded succesfully 
.PP
.RE
.PP

.SS "void gltr_terminate (void ** data, struct \fBgltr_control_type\fP * control, struct \fBgltr_inform_type\fP * inform)"
Deallocate all internal private storage
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIcontrol\fP is a struct containing control information (see \fBgltr_control_type\fP)
.br
\fIinform\fP is a struct containing output information (see \fBgltr_inform_type\fP) 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for C interfaces to GALAHAD GLTR from the source code\&.

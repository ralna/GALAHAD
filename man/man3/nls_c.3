.TH "galahad_nls.h" 3 "Sun Apr 16 2023" "C interfaces to GALAHAD NLS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
galahad_nls.h
.SH SYNOPSIS
.br
.PP
\fC#include <stdbool\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include 'galahad_precision\&.h'\fP
.br
\fC#include 'galahad_cfunctions\&.h'\fP
.br
\fC#include 'galahad_rqs\&.h'\fP
.br
\fC#include 'galahad_glrt\&.h'\fP
.br
\fC#include 'galahad_psls\&.h'\fP
.br
\fC#include 'galahad_bsc\&.h'\fP
.br
\fC#include 'galahad_roots\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBnls_subproblem_control_type\fP"
.br
.ti -1c
.RI "struct \fBnls_control_type\fP"
.br
.ti -1c
.RI "struct \fBnls_time_type\fP"
.br
.ti -1c
.RI "struct \fBnls_subproblem_inform_type\fP"
.br
.ti -1c
.RI "struct \fBnls_inform_type\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBnls_initialize\fP (void **data, struct \fBnls_control_type\fP *control, struct \fBnls_inform_type\fP *inform)"
.br
.ti -1c
.RI "void \fBnls_read_specfile\fP (struct \fBnls_control_type\fP *control, const char specfile[])"
.br
.ti -1c
.RI "void \fBnls_import\fP (struct \fBnls_control_type\fP *control, void **data, int *status, int n, int m, const char J_type[], int J_ne, const int J_row[], const int J_col[], const int J_ptr[], const char H_type[], int H_ne, const int H_row[], const int H_col[], const int H_ptr[], const char P_type[], int P_ne, const int P_row[], const int P_col[], const int P_ptr[], const real_wp_ w[])"
.br
.ti -1c
.RI "void \fBnls_reset_control\fP (struct \fBnls_control_type\fP *control, void **data, int *status)"
.br
.ti -1c
.RI "void \fBnls_solve_with_mat\fP (void **data, void *userdata, int *status, int n, int m, real_wp_ x[], real_wp_ c[], real_wp_ g[], int(*eval_c)(int, int, const real_wp_[], real_wp_[], const void *), int j_ne, int(*eval_j)(int, int, int, const real_wp_[], real_wp_[], const void *), int h_ne, int(*eval_h)(int, int, int, const real_wp_[], const real_wp_[], real_wp_[], const void *), int p_ne, int(*eval_hprods)(int, int, int, const real_wp_[], const real_wp_[], real_wp_[], bool, const void *))"
.br
.ti -1c
.RI "void \fBnls_solve_without_mat\fP (void **data, void *userdata, int *status, int n, int m, real_wp_ x[], real_wp_ c[], real_wp_ g[], int(*eval_c)(int, int, const real_wp_[], real_wp_[], const void *), int(*eval_jprod)(int, int, const real_wp_[], const bool, real_wp_[], const real_wp_[], bool, const void *), int(*eval_hprod)(int, int, const real_wp_[], const real_wp_[], real_wp_[], const real_wp_[], bool, const void *), int p_ne, int(*eval_hprods)(int, int, int, const real_wp_[], const real_wp_[], real_wp_[], bool, const void *))"
.br
.ti -1c
.RI "void \fBnls_solve_reverse_with_mat\fP (void **data, int *status, int *eval_status, int n, int m, real_wp_ x[], real_wp_ c[], real_wp_ g[], int j_ne, real_wp_ J_val[], const real_wp_ y[], int h_ne, real_wp_ H_val[], real_wp_ v[], int p_ne, real_wp_ P_val[])"
.br
.ti -1c
.RI "void \fBnls_solve_reverse_without_mat\fP (void **data, int *status, int *eval_status, int n, int m, real_wp_ x[], real_wp_ c[], real_wp_ g[], bool *transpose, real_wp_ u[], real_wp_ v[], real_wp_ y[], int p_ne, real_wp_ P_val[])"
.br
.ti -1c
.RI "void \fBnls_information\fP (void **data, struct \fBnls_inform_type\fP *inform, int *status)"
.br
.ti -1c
.RI "void \fBnls_terminate\fP (void **data, struct \fBnls_control_type\fP *control, struct \fBnls_inform_type\fP *inform)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SH "Introduction"
.PP
.SS "Purpose"
This package uses a \fBregularization method to find a (local) unconstrained minimizer of a differentiable weighted sum-of-squares objective function \[{f(x) := 1/2 \sum_{i=1}^m w_i^{} c_i^2(x) = 1/2 ||c(x)||^2_W}\]  
  \n
  f(x):= 1/2 sum_{i=1}^m w_i c_i^2(x) = 1/2 ||c(x)||^2_W
  \n
 of many variables x involving positive weights w_i, {i=1,\&.\&.\&.,m}\&.\fP The method offers the choice of direct and iterative solution of the key regularization subproblems, and is most suitable for large problems\&. First derivatives of the \fIresidual function\fP c(x) are required, and if second derivatives of the c_i(x) can be calculated, they may be exploited---if suitable products of the first or second derivatives with a vector may be found but not the derivatives themselves, that can also be used to advantage\&.
.SS "Authors"
N\&. I\&. M\&. Gould, STFC-Rutherford Appleton Laboratory, England\&.
.PP
C interface, additionally J\&. Fowkes, STFC-Rutherford Appleton Laboratory\&.
.PP
Julia interface, additionally A\&. Montoison and D\&. Orban, Polytechnique MontrÃ©al\&.
.SS "Originally released"
October 2016, C interface August 2021\&.
.SS "Terminology"
The \fIgradient\fP nabla_x f(x) of a function f(x) is the vector whose i-th component is partial f(x)/partial x_i\&. The \fIHessian\fP nabla_{xx} f(x) of f(x) is the symmetric matrix whose i,j-th entry is partial^2 f(x)/partial x_i partial x_j\&. The Hessian is \fIsparse\fP if a significant and useful proportion of the entries are universally zero\&.
.PP
The algorithm used by the package is iterative\&. From the current best estimate of the minimizer x_k, a trial improved point x_k + s_k is sought\&. The correction s_k is chosen to improve a model m_k(s) of the stabilised objective function f_{rho,p}(x_k+s) built around the objective function f(x_k+s) built around x_k\&. The model is the sum of two basic components, a suitable approximation t_k(s) of f(x_k+s), another approximation of (rho/r) ||x_k+s||_r^r (if rho > 0), and a regularization term (sigma_k/p) ||s||_{S_k}^p involving a weight sigma_k, power p and a norm ||s||_{S_k} := sqrt{s^T S_k s} for a given positive definite scaling matrix S_k that is included to prevent large corrections\&. The weight sigma_k is adjusted as the algorithm progresses to ensure convergence\&.
.PP
The model t_k(s) is a truncated Taylor-series approximation, and this relies on being able to compute or estimate derivatives of c(x)\&. Various models are provided, and each has different derivative requirements\&. We denote the m by n \fIresidual Jacobian\fP J(x) = nabla_x c(x) as the matrix whose i,j-th component \[J(x)_{i,j} := partial c_i(x) / partial x_j \;\; \mbox{for $i=1,...,m$ and $j=1,...,n$.}\]  
  \n
  J(x)_{i,j} := partial c_i(x) / partial x_j
  \n
  for i=1,...,m and j=1,...,n. For a given m-vector y, the \fIweighted-residual Hessian\fP is the sum \[H(x,y) := \sum_{l=1}^m y_l H_l(x), \;\; \mbox{where}\;\; H_l(x)_{i,j} := partial^2 c_l(x) / partial x_i partial x_j \;\; \mbox{for $i,j=1,...,n$}\]  
  \n
  H(x,y) := sum_{l=1}^m y_l H_l(x), where
  \n
  H_l(x)_{i,j} := partial^2 c_l(x) / partial x_i partial x_j
  \n
for i,j=1,...,n is the Hessian of c_l(x)\&. Finally, for a given vector v, we define the \fIresidual-Hessians-vector product matrix\fP \[P(x,v) := (H_1(x) v, ..., H_m(x) v).\]  
  \n
  P(x,v) := (H_1(x) v, ..., H_m(x) v).
  \n
 The models t_k(s) provided are,
.IP "1." 4
the first-order Taylor approximation f(x_k) + g(x_k)^T s, where g(x) = J^T(x) W c(x),
.IP "2." 4
a barely second-order approximation f(x_k) + g(x_k)^T s + 1/2 s^T W s,
.IP "3." 4
the Gauss-Newton approximation 1/2 || c(x_k) + J(x_k) s||^2_W,
.IP "4." 4
the Newton (second-order Taylor) approximation f(x_k) + g(x_k)^T s + 1/2 s^T [ J^T(x_k) W J(x_k) + H(x_k,W c(x_k))] s, and
.IP "5." 4
the tensor Gauss-Newton approximation 1/2 || c(x_k) + J(x_k) s + 1/2 s^T * P(x_k,s) ||^2_W, where the i-th component of s^T * P(x_k,s) is shorthand for the scalar s^T H_i(x_k) s, where W is the diagonal matrix of weights w_i, i = 1, \&.\&.\&. m\&.
.PP
.PP
Access to a particular model requires that the user is either able to provide the derivatives needed (``\fImatrix available\fP'') or that the products of these derivatives (and their transposes) with specified vectors are possible (``\fImatrix free\fP'')\&.
.SS "Method"
An adaptive regularization method is used\&. In this, an improvement to a current estimate of the required minimizer, x_k is sought by computing a step s_k\&. The step is chosen to approximately minimize a model t_k(s) of f_{rho,r}(x_k+s) that includes a weighted regularization term (sigma_k/p) ||s||_{S_k}^p for some specified positive weight sigma_k\&. The quality of the resulting step s_k is assessed by computing the 'ratio' %(f_{rho,p}(x_k) - f_{rho,p}(x_k+s_k))/(t_k(0)-t_k(s_k))\&. (f(x_k) - f(x_k + s_k))/(t_k(0) - t_k(s_k))\&. The step is deemed to have succeeded if the ratio exceeds a given eta_s > 0, and in this case x_{k+1} = x_k + s_k\&. Otherwise x_{k+1} = x_k, and the weight is increased by powers of a given increase factor up to a given limit\&. If the ratio is larger than eta_v >= eta_d, the weight will be decreased by powers of a given decrease factor again up to a given limit\&. The method will terminate as soon as f(x_k) or ||nabla_x f(x_k)|| is smaller than a specified value\&.
.PP
A choice of linear, quadratic or quartic models t_k(s) is available (see the \fBTerminology\fP section), and normally a two-norm regularization will be used, but this may change if preconditioning is employed\&.
.PP
If linear or quadratic models are employed, an appropriate, approximate model minimizer is found using either a direct approach involving factorization of a shift of the model Hessian B_k or an iterative (conjugate-gradient/Lanczos) approach based on approximations to the required solution from a so-called Krlov subspace\&. The direct approach is based on the knowledge that the required solution satisfies the linear system of equations (B_k + lambda_k I) s_k = - nabla_x f(x_k) involving a scalar Lagrange multiplier lambda_k\&. This multiplier is found by uni-variate root finding, using a safeguarded Newton-like process, by the GALAHAD packages RQS\&. The iterative approach uses the GALAHAD packag GLRT, and is best accelerated by preconditioning with good approximations to the Hessian of the model using GALAHAD's PSLS\&. The iterative approach has the advantage that only Hessian matrix-vector products are required, and thus the Hessian B_k is not required explicitly\&. However when factorizations of the Hessian are possible, the direct approach is often more efficient\&.
.PP
When a quartic model is used, the model is itself of least-squares form, and the package calls itself recursively to approximately minimize its model\&. The quartic model often gives a better approximation, but at the cost of more involved derivative requirements\&.
.SS "Reference"
The generic adaptive cubic regularization method is described in detail in
.PP
C\&. Cartis, N\&. I\&. M\&. Gould and Ph\&. L\&. Toint, ``Adaptive cubic regularisation methods for unconstrained optimization\&. Part I: motivation, convergence and numerical results'', Mathematical Programming 127(2) (2011) 245-295,
.PP
and uses ``tricks'' as suggested in
.PP
N\&. I\&. M\&. Gould, M\&. Porcelli and Ph\&. L\&. Toint, ``Updating the regularization parameter in the adaptive cubic regularization algorithm''\&. Computational Optimization and Applications 53(1) (2012) 1-22\&.
.PP
The specific methods employed here are discussed in
.PP
N\&. I\&. M\&. Gould, J\&. A\&. Scott and T\&. Rees, ``Convergence and evaluation-complexity analysis of a regularized tensor-Newton method for solving nonlinear least-squares problems''\&. Computational Optimization and Applications 73(1) (2019) 1â35\&.
.SS "Call order"
To solve a given problem, functions from the nls package must be called in the following order:
.PP
.IP "\(bu" 2
\fBnls_initialize\fP - provide default control parameters and set up initial data structures
.IP "\(bu" 2
\fBnls_read_specfile\fP (optional) - override control values by reading replacement values from a file
.IP "\(bu" 2
\fBnls_import\fP - set up problem data structures and fixed values
.IP "\(bu" 2
\fBnls_reset_control\fP (optional) - possibly change control parameters if a sequence of problems are being solved
.IP "\(bu" 2
solve the problem by calling one of
.IP "  \(bu" 4
\fBnls_solve_with_mat\fP - solve using function calls to evaluate function, gradient and Hessian values
.IP "  \(bu" 4
\fBnls_solve_without_mat\fP - solve using function calls to evaluate function and gradient values and Hessian-vector products
.IP "  \(bu" 4
\fBnls_solve_reverse_with_mat\fP - solve returning to the calling program to obtain function, gradient and Hessian values, or
.IP "  \(bu" 4
\fBnls_solve_reverse_without_mat\fP - solve returning to the calling prorgram to obtain function and gradient values and Hessian-vector products
.PP

.IP "\(bu" 2
\fBnls_information\fP (optional) - recover information about the solution and solution process
.IP "\(bu" 2
\fBnls_terminate\fP - deallocate data structures
.PP
.PP
   
  See the examples section for illustrations of use.
  
.SS "Unsymmetric matrix storage formats"
The unsymmetric m by n Jacobian matrix J = nabla_x c(x) and the residual-Hessians-vector product matrix $P(x,v)$ may be presented and stored in a variety of convenient input formats\&. Let A be J or P as appropriate\&.
.PP
Both C-style (0 based) and fortran-style (1-based) indexing is allowed\&. Choose \fCcontrol\&.f_indexing\fP as \fCfalse\fP for C style and \fCtrue\fP for fortran style; the discussion below presumes C style, but add 1 to indices for the corresponding fortran version\&.
.PP
Wrappers will automatically convert between 0-based (C) and 1-based (fortran) array indexing, so may be used transparently from C\&. This conversion involves both time and memory overheads that may be avoided by supplying data that is already stored using 1-based indexing\&.
.SS "Dense storage format"
The matrix A is stored as a compact dense matrix by rows, that is, the values of the entries of each row in turn are stored in order within an appropriate real one-dimensional array\&. In this case, component n * i + j of the storage array A_val will hold the value A_{ij} for 0 <= i <= m-1, 0 <= j <= n-1\&.
.SS "Dense by columns storage format"
The matrix A is stored as a compact dense matrix by columns, that is, the values of the entries of each column in turn are stored in order within an appropriate real one-dimensional array\&. In this case, component m * j + i of the storage array A_val will hold the value A_{ij} for 0 <= i <= m-1, 0 <= j <= n-1\&.
.SS "Sparse co-ordinate storage format"
Only the nonzero entries of the matrices are stored\&. For the l-th entry, 0 <= l <= ne-1, of A, its row index i, column index j and value A_{ij}, 0 <= i <= m-1, 0 <= j <= n-1, are stored as the l-th components of the integer arrays A_row and A_col and real array A_val, respectively, while the number of nonzeros is recorded as A_ne = ne\&.
.SS "Sparse row-wise storage format"
Again only the nonzero entries are stored, but this time they are ordered so that those in row i appear directly before those in row i+1\&. For the i-th row of A the i-th component of the integer array A_ptr holds the position of the first entry in this row, while A_ptr(m) holds the total number of entries\&. The column indices j, 0 <= j <= n-1, and values A_{ij} of the nonzero entries in the i-th row are stored in components l = A_ptr(i), \&.\&.\&., A_ptr(i+1)-1, 0 <= i <= m-1, of the integer array A_col, and real array A_val, respectively\&. For sparse matrices, this scheme almost always requires less storage than its predecessor\&.
.SS "Sparse column-wise storage format"
Once again only the nonzero entries are stored, but this time they are ordered so that those in column j appear directly before those in column j+1\&. For the j-th column of A the j-th component of the integer array A_ptr holds the position of the first entry in this column, while A_ptr(n) holds the total number of entries\&. The row indices i, 0 <= i <= m-1, and values A_{ij} of the nonzero entries in the j-th columnsare stored in components l = A_ptr(j), \&.\&.\&., A_ptr(j+1)-1, 0 <= j <= n-1, of the integer array A_row, and real array A_val, respectively\&. As before, for sparse matrices, this scheme almost always requires less storage than the co-ordinate format\&.
.SS "Symmetric matrix storage formats"
Likewise, the symmetric n by n weighted-residual Hessian matrix H = H(x,y) may be presented and stored in a variety of formats\&. But crucially symmetry is exploited by only storing values from the lower triangular part (i\&.e, those entries that lie on or below the leading diagonal)\&.
.SS "Dense storage format"
The matrix H is stored as a compact dense matrix by rows, that is, the values of the entries of each row in turn are stored in order within an appropriate real one-dimensional array\&. Since H is symmetric, only the lower triangular part (that is the part h_{ij} for 0 <= j <= i <= n-1) need be held\&. In this case the lower triangle should be stored by rows, that is component i * i / 2 + j of the storage array H_val will hold the value h_{ij} (and, by symmetry, h_{ji}) for 0 <= j <= i <= n-1\&.
.SS "Sparse co-ordinate storage format"
Only the nonzero entries of the matrices are stored\&. For the l-th entry, 0 <= l <= ne-1, of H, its row index i, column index j and value h_{ij}, 0 <= j <= i <= n-1, are stored as the l-th components of the integer arrays H_row and H_col and real array H_val, respectively, while the number of nonzeros is recorded as H_ne = ne\&. Note that only the entries in the lower triangle should be stored\&.
.SS "Sparse row-wise storage format"
Again only the nonzero entries are stored, but this time they are ordered so that those in row i appear directly before those in row i+1\&. For the i-th row of H the i-th component of the integer array H_ptr holds the position of the first entry in this row, while H_ptr(n) holds the total number of entries\&. The column indices j, 0 <= j <= i, and values h_{ij} of the entries in the i-th row are stored in components l = H_ptr(i), \&.\&.\&., H_ptr(i+1)-1 of the integer array H_col, and real array H_val, respectively\&. Note that as before only the entries in the lower triangle should be stored\&. For sparse matrices, this scheme almost always requires less storage than its predecessor\&.
.SS "Diagonal storage format"
If H is diagonal (i\&.e\&., H_{ij} = 0 for all 0 <= i /= j <= n-1) only the diagonals entries H_{ii}, 0 <= i <= n-1 need be stored, and the first n components of the array H_val may be used for the purpose\&.
.SS "Multiples of the identity storage format"
If H is a multiple of the identity matrix, (i\&.e\&., H = alpha I where I is the n by n identity matrix and alpha is a scalar), it suffices to store alpha as the first component of H_val\&.
.SS "The identity matrix format"
If H is the identity matrix, no values need be stored\&.
.SS "The zero matrix format"
The same is true if H is the zero matrix\&. 
.SH "Data Structure Documentation"
.PP 
.SH "struct nls_subproblem_control_type"
.PP 
control derived type as a C struct 
.PP
\fBData Fields:\fP
.RS 4
int \fIerror\fP error and warning diagnostics occur on stream error 
.br
.PP
int \fIout\fP general output occurs on stream out 
.br
.PP
int \fIprint_level\fP the level of output required\&. 
.PD 0

.IP "\(bu" 2
<= 0 gives no output, 
.IP "\(bu" 2
= 1 gives a one-line summary for every iteration, 
.IP "\(bu" 2
= 2 gives a summary of the inner iteration for each iteration, 
.IP "\(bu" 2
>= 3 gives increasingly verbose (debugging) output 
.PP

.br
.PP
int \fIstart_print\fP any printing will start on this iteration 
.br
.PP
int \fIstop_print\fP any printing will stop on this iteration 
.br
.PP
int \fIprint_gap\fP the number of iterations between printing 
.br
.PP
int \fImaxit\fP the maximum number of iterations performed 
.br
.PP
int \fIalive_unit\fP removal of the file alive_file from unit alive_unit terminates execution 
.br
.PP
char \fIalive_file[31]\fP see alive_unit 
.br
.PP
int \fIjacobian_available\fP is the Jacobian matrix of first derivatives available (>= 2), is access only via matrix-vector products (=1) or is it not available (<= 0) ? 
.br
.PP
int \fIhessian_available\fP is the Hessian matrix of second derivatives available (>= 2), is access only via matrix-vector products (=1) or is it not available (<= 0) ? 
.br
.PP
int \fImodel\fP the model used\&. Possible values are 
.PD 0

.IP "\(bu" 2
0 dynamic (\fInot yet implemented\fP) 
.IP "\(bu" 2
1 first-order (no Hessian) 
.IP "\(bu" 2
2 barely second-order (identity Hessian) 
.IP "\(bu" 2
3 Gauss-Newton (J^T J Hessian) 
.IP "\(bu" 2
4 second-order (exact Hessian) 
.IP "\(bu" 2
5 Gauss-Newton to Newton transition 
.IP "\(bu" 2
6 tensor Gauss-Newton treated as a least-squares model 
.IP "\(bu" 2
7 tensor Gauss-Newton treated as a general model 
.IP "\(bu" 2
8 tensor Gauss-Newton transition from a least-squares to a general mode 
.PP

.br
.PP
int \fInorm\fP the regularization norm used\&. The norm is defined via ||v||^2 = v^T S v, and will define the preconditioner used for iterative methods\&. Possible values for S are
.PP
.PD 0
.IP "\(bu" 2
-3 user's own regularization norm 
.IP "\(bu" 2
-2 S = limited-memory BFGS matrix (with \&.PSLS_control\&.lbfgs_vectors history) (\fInot yet implemented\fP) 
.IP "\(bu" 2
-1 identity (= Euclidan two-norm) 
.IP "\(bu" 2
0 automatic (\fInot yet implemented\fP) 
.IP "\(bu" 2
1 diagonal, S = diag( max( J^TJ Hessian, \&.PSLS_control\&.min_diagonal ) ) 
.IP "\(bu" 2
2 diagonal, S = diag( max( Hessian, \&.PSLS_control\&.min_diagonal ) ) 
.IP "\(bu" 2
3 banded, S = band( Hessian ) with semi-bandwidth \&.PSLS_control\&.semi_bandwidth 
.IP "\(bu" 2
4 re-ordered band, P=band(order(A)) with semi-bandwidth \&.PSLS_control\&.semi_bandwidth 
.IP "\(bu" 2
5 full factorization, S = Hessian, Schnabel-Eskow modification 
.IP "\(bu" 2
6 full factorization, S = Hessian, GMPS modification (\fInot yet implemented\fP) 
.IP "\(bu" 2
7 incomplete factorization of Hessian, Lin-More' 
.IP "\(bu" 2
8 incomplete factorization of Hessian, HSL_MI28 
.IP "\(bu" 2
9 incomplete factorization of Hessian, Munskgaard (\fInot yet implemented\fP) 
.IP "\(bu" 2
10 expanding band of Hessian (\fInot yet implemented\fP) 
.PP

.br
.PP
int \fInon_monotone\fP non-monotone <= 0 monotone strategy used, anything else non-monotone strategy with this history length used 
.br
.PP
int \fIweight_update_strategy\fP define the weight-update strategy: 1 (basic), 2 (reset to zero when very successful), 3 (imitate TR), 4 (increase lower bound), 5 (GPT) 
.br
.PP
real_wp_ \fIstop_c_absolute\fP overall convergence tolerances\&. The iteration will terminate when ||c(x)||_2 <= MAX( \&.stop_c_absolute, \&.stop_c_relative 
.IP "\(bu" 2
||c(x_{\\mbox{initial}})||_2, or when the norm of the gradient, g = J^T(x) c(x) / ||c(x)||_2, of ||c||_2, satisfies ||g||_2 <= MAX( \&.stop_g_absolute, \&.stop_g_relative
.IP "\(bu" 2
||g_{\\mbox{initial}}||_2, or if the step is less than \&.stop_s 
.PP

.br
.PP
real_wp_ \fIstop_c_relative\fP see stop_c_absolute 
.br
.PP
real_wp_ \fIstop_g_absolute\fP see stop_c_absolute 
.br
.PP
real_wp_ \fIstop_g_relative\fP see stop_c_absolute 
.br
.PP
real_wp_ \fIstop_s\fP see stop_c_absolute 
.br
.PP
real_wp_ \fIpower\fP the regularization power (<2 => chosen according to the model) 
.br
.PP
real_wp_ \fIinitial_weight\fP initial value for the regularization weight (-ve => 1/||g_0||)) 
.br
.PP
real_wp_ \fIminimum_weight\fP minimum permitted regularization weight 
.br
.PP
real_wp_ \fIinitial_inner_weight\fP initial value for the inner regularization weight for tensor GN (-ve => 0) 
.br
.PP
real_wp_ \fIeta_successful\fP a potential iterate will only be accepted if the actual decrease f - f(x_new) is larger than \&.eta_successful times that predicted by a quadratic model of the decrease\&. The regularization weight will be decreaed if this relative decrease is greater than \&.eta_very_successful but smaller than \&.eta_too_successful 
.br
.PP
real_wp_ \fIeta_very_successful\fP see eta_successful 
.br
.PP
real_wp_ \fIeta_too_successful\fP see eta_successful 
.br
.PP
real_wp_ \fIweight_decrease_min\fP on very successful iterations, the regularization weight will be reduced by the factor \&.weight_decrease but no more than \&.weight_decrease_min while if the iteration is unsucceful, the weight will be increased by a factor \&.weight_increase but no more than \&.weight_increase_max (these are delta_1, delta_2, delta3 and delta_max in Gould, Porcelli and Toint, 2011) 
.br
.PP
real_wp_ \fIweight_decrease\fP see weight_decrease_min 
.br
.PP
real_wp_ \fIweight_increase\fP see weight_decrease_min 
.br
.PP
real_wp_ \fIweight_increase_max\fP see weight_decrease_min 
.br
.PP
real_wp_ \fIreduce_gap\fP expert parameters as suggested in Gould, Porcelli and Toint, 'Updating t
regularization parameter in the adaptive cubic regularization algorithm' RAL-TR-2011-007, Rutherford Appleton Laboratory, England (2011), http://epubs.stfc.ac.uk/bitstream/6181/RAL-TR-2011-007.pdf (these are denoted beta, epsilon_chi and alpha_max in the paper) 
.br
.PP
real_wp_ \fItiny_gap\fP see reduce_gap 
.br
.PP
real_wp_ \fIlarge_root\fP see reduce_gap 
.br
.PP
real_wp_ \fIswitch_to_newton\fP if the Gauss-Newto to Newton model is specified, switch to Newton as soon as the norm of the gradient g is smaller than switch_to_newton 
.br
.PP
real_wp_ \fIcpu_time_limit\fP the maximum CPU time allowed (-ve means infinite) 
.br
.PP
real_wp_ \fIclock_time_limit\fP the maximum elapsed clock time allowed (-ve means infinite) 
.br
.PP
bool \fIsubproblem_direct\fP use a direct (factorization) or (preconditioned) iterative method to find the search direction 
.br
.PP
bool \fIrenormalize_weight\fP should the weight be renormalized to account for a change in scaling? 
.br
.PP
bool \fImagic_step\fP allow the user to perform a 'magic' step to improve the objective 
.br
.PP
bool \fIprint_obj\fP print values of the objective/gradient rather than ||c|| and its gradien 
.br
.PP
bool \fIspace_critical\fP if \&.space_critical true, every effort will be made to use as little space as possible\&. This may result in longer computation time 
.br
.PP
bool \fIdeallocate_error_fatal\fP if \&.deallocate_error_fatal is true, any array/pointer deallocation error will terminate execution\&. Otherwise, computation will continue 
.br
.PP
char \fIprefix[31]\fP all output lines will be prefixed by \&.prefix(2:LEN(TRIM(\&.prefix))-1) where \&.prefix contains the required string enclosed in quotes, e\&.g\&. 'string' or 'string' 
.br
.PP
struct rqs_control_type \fIrqs_control\fP control parameters for RQS 
.br
.PP
struct glrt_control_type \fIglrt_control\fP control parameters for GLRT 
.br
.PP
struct psls_control_type \fIpsls_control\fP control parameters for PSLS 
.br
.PP
struct bsc_control_type \fIbsc_control\fP control parameters for BSC 
.br
.PP
struct roots_control_type \fIroots_control\fP control parameters for ROOTS 
.br
.PP
.RE
.PP
.SH "struct nls_control_type"
.PP 
control derived type as a C struct 
.PP
\fBData Fields:\fP
.RS 4
bool \fIf_indexing\fP use C or Fortran sparse matrix indexing 
.br
.PP
int \fIerror\fP error and warning diagnostics occur on stream error 
.br
.PP
int \fIout\fP general output occurs on stream out 
.br
.PP
int \fIprint_level\fP the level of output required\&. 
.PD 0

.IP "\(bu" 2
<= 0 gives no output, 
.IP "\(bu" 2
= 1 gives a one-line summary for every iteration, 
.IP "\(bu" 2
= 2 gives a summary of the inner iteration for each iteration, 
.IP "\(bu" 2
>= 3 gives increasingly verbose (debugging) output 
.PP

.br
.PP
int \fIstart_print\fP any printing will start on this iteration 
.br
.PP
int \fIstop_print\fP any printing will stop on this iteration 
.br
.PP
int \fIprint_gap\fP the number of iterations between printing 
.br
.PP
int \fImaxit\fP the maximum number of iterations performed 
.br
.PP
int \fIalive_unit\fP removal of the file alive_file from unit alive_unit terminates execution 
.br
.PP
char \fIalive_file[31]\fP see alive_unit 
.br
.PP
int \fIjacobian_available\fP is the Jacobian matrix of first derivatives available (>= 2), is access only via matrix-vector products (=1) or is it not available (<= 0) ? 
.br
.PP
int \fIhessian_available\fP is the Hessian matrix of second derivatives available (>= 2), is access only via matrix-vector products (=1) or is it not available (<= 0) ? 
.br
.PP
int \fImodel\fP the model used\&. Possible values are 
.PD 0

.IP "\(bu" 2
0 dynamic (\fInot yet implemented\fP) 
.IP "\(bu" 2
1 first-order (no Hessian) 
.IP "\(bu" 2
2 barely second-order (identity Hessian) 
.IP "\(bu" 2
3 Gauss-Newton (J^T J Hessian) 
.IP "\(bu" 2
4 second-order (exact Hessian) 
.IP "\(bu" 2
5 Gauss-Newton to Newton transition 
.IP "\(bu" 2
6 tensor Gauss-Newton treated as a least-squares model 
.IP "\(bu" 2
7 tensor Gauss-Newton treated as a general model 
.IP "\(bu" 2
8 tensor Gauss-Newton transition from a least-squares to a general mode 
.PP

.br
.PP
int \fInorm\fP the regularization norm used\&. The norm is defined via ||v||^2 = v^T S v, and will define the preconditioner used for iterative methods\&. Possible values for S are
.PP
.PD 0
.IP "\(bu" 2
-3 user's own regularization norm 
.IP "\(bu" 2
-2 S = limited-memory BFGS matrix (with \&.PSLS_control\&.lbfgs_vectors history) (\fInot yet implemented\fP) 
.IP "\(bu" 2
-1 identity (= Euclidan two-norm) 
.IP "\(bu" 2
0 automatic (\fInot yet implemented\fP) 
.IP "\(bu" 2
1 diagonal, S = diag( max( J^TJ Hessian, \&.PSLS_control\&.min_diagonal ) ) 
.IP "\(bu" 2
2 diagonal, S = diag( max( Hessian, \&.PSLS_control\&.min_diagonal ) ) 
.IP "\(bu" 2
3 banded, S = band( Hessian ) with semi-bandwidth \&.PSLS_control\&.semi_bandwidth 
.IP "\(bu" 2
4 re-ordered band, P=band(order(A)) with semi-bandwidth \&.PSLS_control\&.semi_bandwidth 
.IP "\(bu" 2
5 full factorization, S = Hessian, Schnabel-Eskow modification 
.IP "\(bu" 2
6 full factorization, S = Hessian, GMPS modification (\fInot yet implemented\fP) 
.IP "\(bu" 2
7 incomplete factorization of Hessian, Lin-More' 
.IP "\(bu" 2
8 incomplete factorization of Hessian, HSL_MI28 
.IP "\(bu" 2
9 incomplete factorization of Hessian, Munskgaard (\fInot yet implemented\fP) 
.IP "\(bu" 2
10 expanding band of Hessian (\fInot yet implemented\fP) 
.PP

.br
.PP
int \fInon_monotone\fP non-monotone <= 0 monotone strategy used, anything else non-monotone strategy with this history length used 
.br
.PP
int \fIweight_update_strategy\fP define the weight-update strategy: 1 (basic), 2 (reset to zero when very successful), 3 (imitate TR), 4 (increase lower bound), 5 (GPT) 
.br
.PP
real_wp_ \fIstop_c_absolute\fP overall convergence tolerances\&. The iteration will terminate when ||c(x)||_2 <= MAX( \&.stop_c_absolute, \&.stop_c_relative 
.IP "\(bu" 2
||c(x_{\\mbox{initial}})||_2 or when the norm of the gradient, g = J^T(x) c(x) / ||c(x)||_2, of ||c(x)||_2 satisfies ||g||_2 <= MAX( \&.stop_g_absolute, \&.stop_g_relative
.IP "\(bu" 2
||g_{\\mbox{initial}}||_2, or if the step is less than \&.stop_s 
.PP

.br
.PP
real_wp_ \fIstop_c_relative\fP see stop_c_absolute 
.br
.PP
real_wp_ \fIstop_g_absolute\fP see stop_c_absolute 
.br
.PP
real_wp_ \fIstop_g_relative\fP see stop_c_absolute 
.br
.PP
real_wp_ \fIstop_s\fP see stop_c_absolute 
.br
.PP
real_wp_ \fIpower\fP the regularization power (<2 => chosen according to the model) 
.br
.PP
real_wp_ \fIinitial_weight\fP initial value for the regularization weight (-ve => 1/||g_0||)) 
.br
.PP
real_wp_ \fIminimum_weight\fP minimum permitted regularization weight 
.br
.PP
real_wp_ \fIinitial_inner_weight\fP initial value for the inner regularization weight for tensor GN (-ve => 0) 
.br
.PP
real_wp_ \fIeta_successful\fP a potential iterate will only be accepted if the actual decrease f - f(x_new) is larger than \&.eta_successful times that predicted by a quadratic model of the decrease\&. The regularization weight will be decreaed if this relative decrease is greater than \&.eta_very_successful but smaller than \&.eta_too_successful 
.br
.PP
real_wp_ \fIeta_very_successful\fP see eta_successful 
.br
.PP
real_wp_ \fIeta_too_successful\fP see eta_successful 
.br
.PP
real_wp_ \fIweight_decrease_min\fP on very successful iterations, the regularization weight will be reduced by the factor \&.weight_decrease but no more than \&.weight_decrease_min while if the iteration is unsucceful, the weight will be increased by a factor \&.weight_increase but no more than \&.weight_increase_max (these are delta_1, delta_2, delta3 and delta_max in Gould, Porcelli and Toint, 2011) 
.br
.PP
real_wp_ \fIweight_decrease\fP see weight_decrease_min 
.br
.PP
real_wp_ \fIweight_increase\fP see weight_decrease_min 
.br
.PP
real_wp_ \fIweight_increase_max\fP see weight_decrease_min 
.br
.PP
real_wp_ \fIreduce_gap\fP expert parameters as suggested in Gould, Porcelli and Toint, 'Updating the regularization parameter in the adaptive cubic
 regularization algorithm', RAL-TR-2011-007, Rutherford Appleton Laboratory, England (2011), http://epubs.stfc.ac.uk/bitstream/6181/RAL-TR-2011-007.pdf (these are denoted beta, epsilon_chi and alpha_max in the paper) 
.br
.PP
real_wp_ \fItiny_gap\fP see reduce_gap 
.br
.PP
real_wp_ \fIlarge_root\fP see reduce_gap 
.br
.PP
real_wp_ \fIswitch_to_newton\fP if the Gauss-Newto to Newton model is specified, switch to Newton as soon as the norm of the gradient g is smaller than switch_to_newton 
.br
.PP
real_wp_ \fIcpu_time_limit\fP the maximum CPU time allowed (-ve means infinite) 
.br
.PP
real_wp_ \fIclock_time_limit\fP the maximum elapsed clock time allowed (-ve means infinite) 
.br
.PP
bool \fIsubproblem_direct\fP use a direct (factorization) or (preconditioned) iterative method to find the search direction 
.br
.PP
bool \fIrenormalize_weight\fP should the weight be renormalized to account for a change in scaling? 
.br
.PP
bool \fImagic_step\fP allow the user to perform a 'magic' step to improve the objective 
.br
.PP
bool \fIprint_obj\fP print values of the objective/gradient rather than ||c|| and its gradient 
.br
.PP
bool \fIspace_critical\fP if \&.space_critical true, every effort will be made to use as little space as possible\&. This may result in longer computation time 
.br
.PP
bool \fIdeallocate_error_fatal\fP if \&.deallocate_error_fatal is true, any array/pointer deallocation error will terminate execution\&. Otherwise, computation will continue 
.br
.PP
char \fIprefix[31]\fP all output lines will be prefixed by \&.prefix(2:LEN(TRIM(\&.prefix))-1) where \&.prefix contains the required string enclosed in quotes, e\&.g\&. 'string' or 'string' 
.br
.PP
struct rqs_control_type \fIrqs_control\fP control parameters for RQS 
.br
.PP
struct glrt_control_type \fIglrt_control\fP control parameters for GLRT 
.br
.PP
struct psls_control_type \fIpsls_control\fP control parameters for PSLS 
.br
.PP
struct bsc_control_type \fIbsc_control\fP control parameters for BSC 
.br
.PP
struct roots_control_type \fIroots_control\fP control parameters for ROOTS 
.br
.PP
struct \fBnls_subproblem_control_type\fP \fIsubproblem_control\fP control parameters for the step-finding subproblem 
.br
.PP
.RE
.PP
.SH "struct nls_time_type"
.PP 
time derived type as a C struct 
.PP
\fBData Fields:\fP
.RS 4
real_sp_ \fItotal\fP the total CPU time spent in the package 
.br
.PP
real_sp_ \fIpreprocess\fP the CPU time spent preprocessing the problem 
.br
.PP
real_sp_ \fIanalyse\fP the CPU time spent analysing the required matrices prior to factorization 
.br
.PP
real_sp_ \fIfactorize\fP the CPU time spent factorizing the required matrices 
.br
.PP
real_sp_ \fIsolve\fP the CPU time spent computing the search direction 
.br
.PP
real_wp_ \fIclock_total\fP the total clock time spent in the package 
.br
.PP
real_wp_ \fIclock_preprocess\fP the clock time spent preprocessing the problem 
.br
.PP
real_wp_ \fIclock_analyse\fP the clock time spent analysing the required matrices prior to factorization 
.br
.PP
real_wp_ \fIclock_factorize\fP the clock time spent factorizing the required matrices 
.br
.PP
real_wp_ \fIclock_solve\fP the clock time spent computing the search direction 
.br
.PP
.RE
.PP
.SH "struct nls_subproblem_inform_type"
.PP 
inform derived type as a C struct 
.PP
\fBData Fields:\fP
.RS 4
int \fIstatus\fP return status\&. See NLS_solve for details 
.br
.PP
int \fIalloc_status\fP the status of the last attempted allocation/deallocation 
.br
.PP
char \fIbad_alloc[81]\fP the name of the array for which an allocation/deallocation error ocurred 
.br
.PP
char \fIbad_eval[13]\fP the name of the user-supplied evaluation routine for which an error ocurred 
.br
.PP
int \fIiter\fP the total number of iterations performed 
.br
.PP
int \fIcg_iter\fP the total number of CG iterations performed 
.br
.PP
int \fIc_eval\fP the total number of evaluations of the residual function c(x) 
.br
.PP
int \fIj_eval\fP the total number of evaluations of the Jacobian J(x) of c(x) 
.br
.PP
int \fIh_eval\fP the total number of evaluations of the scaled Hessian H(x,y) of c(x) 
.br
.PP
int \fIfactorization_max\fP the maximum number of factorizations in a sub-problem solve 
.br
.PP
int \fIfactorization_status\fP the return status from the factorization 
.br
.PP
int64_t \fImax_entries_factors\fP the maximum number of entries in the factors 
.br
.PP
int64_t \fIfactorization_integer\fP the total integer workspace required for the factorization 
.br
.PP
int64_t \fIfactorization_real\fP the total real workspace required for the factorization 
.br
.PP
real_wp_ \fIfactorization_average\fP the average number of factorizations per sub-problem solve 
.br
.PP
real_wp_ \fIobj\fP the value of the objective function 1/2||c(x)||^2_W at the best estimate the solution, x, determined by NLS_solve 
.br
.PP
real_wp_ \fInorm_c\fP the norm of the residual ||c(x)||_W at the best estimate of the solution x, determined by NLS_solve 
.br
.PP
real_wp_ \fInorm_g\fP the norm of the gradient of ||c(x)||_W of the objective function at the best estimate, x, of the solution determined by NLS_solve 
.br
.PP
real_wp_ \fIweight\fP the final regularization weight used 
.br
.PP
struct \fBnls_time_type\fP \fItime\fP timings (see above) 
.br
.PP
struct rqs_inform_type \fIrqs_inform\fP inform parameters for RQS 
.br
.PP
struct glrt_inform_type \fIglrt_inform\fP inform parameters for GLRT 
.br
.PP
struct psls_inform_type \fIpsls_inform\fP inform parameters for PSLS 
.br
.PP
struct bsc_inform_type \fIbsc_inform\fP inform parameters for BSC 
.br
.PP
struct roots_inform_type \fIroots_inform\fP inform parameters for ROOTS 
.br
.PP
.RE
.PP
.SH "struct nls_inform_type"
.PP 
inform derived type as a C struct 
.PP
\fBData Fields:\fP
.RS 4
int \fIstatus\fP return status\&. See NLS_solve for details 
.br
.PP
int \fIalloc_status\fP the status of the last attempted allocation/deallocation 
.br
.PP
char \fIbad_alloc[81]\fP the name of the array for which an allocation/deallocation error ocurred 
.br
.PP
char \fIbad_eval[13]\fP the name of the user-supplied evaluation routine for which an error ocurred 
.br
.PP
int \fIiter\fP the total number of iterations performed 
.br
.PP
int \fIcg_iter\fP the total number of CG iterations performed 
.br
.PP
int \fIc_eval\fP the total number of evaluations of the residual function c(x) 
.br
.PP
int \fIj_eval\fP the total number of evaluations of the Jacobian J(x) of c(x) 
.br
.PP
int \fIh_eval\fP the total number of evaluations of the scaled Hessian H(x,y) of c(x) 
.br
.PP
int \fIfactorization_max\fP the maximum number of factorizations in a sub-problem solve 
.br
.PP
int \fIfactorization_status\fP the return status from the factorization 
.br
.PP
int64_t \fImax_entries_factors\fP the maximum number of entries in the factors 
.br
.PP
int64_t \fIfactorization_integer\fP the total integer workspace required for the factorization 
.br
.PP
int64_t \fIfactorization_real\fP the total real workspace required for the factorization 
.br
.PP
real_wp_ \fIfactorization_average\fP the average number of factorizations per sub-problem solve 
.br
.PP
real_wp_ \fIobj\fP the value of the objective function 1/2||c(x)||^2_W at the best estimate the solution, x, determined by NLS_solve 
.br
.PP
real_wp_ \fInorm_c\fP the norm of the residual ||c(x)||_W at the best estimate of the solution x, determined by NLS_solve 
.br
.PP
real_wp_ \fInorm_g\fP the norm of the gradient of ||c(x)||_W of the objective function at the best estimate, x, of the solution determined by NLS_solve 
.br
.PP
real_wp_ \fIweight\fP the final regularization weight used 
.br
.PP
struct \fBnls_time_type\fP \fItime\fP timings (see above) 
.br
.PP
struct \fBnls_subproblem_inform_type\fP \fIsubproblem_inform\fP inform parameters for subproblem 
.br
.PP
struct rqs_inform_type \fIrqs_inform\fP inform parameters for RQS 
.br
.PP
struct glrt_inform_type \fIglrt_inform\fP inform parameters for GLRT 
.br
.PP
struct psls_inform_type \fIpsls_inform\fP inform parameters for PSLS 
.br
.PP
struct bsc_inform_type \fIbsc_inform\fP inform parameters for BSC 
.br
.PP
struct roots_inform_type \fIroots_inform\fP inform parameters for ROOTS 
.br
.PP
.RE
.PP
.SH "Function Documentation"
.PP 
.SS "void nls_initialize (void ** data, struct \fBnls_control_type\fP * control, struct \fBnls_inform_type\fP * inform)"
Set default control values and initialize private data
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data 
.br
\fIcontrol\fP is a struct containing control information (see \fBnls_control_type\fP) 
.br
\fIinform\fP is a struct containing output information (see \fBnls_inform_type\fP) 
.RE
.PP

.SS "void nls_read_specfile (struct \fBnls_control_type\fP * control, const char specfile[])"
Read the content of a specification file, and assign values associated with given keywords to the corresponding control parameters\&. By default, the spcification file will be named RUNNLS\&.SPC and lie in the current directory\&. Refer to Table 2\&.1 in the fortran documentation provided in $GALAHAD/doc/nls\&.pdf for a list of keywords that may be set\&.
.PP
\fBParameters\fP
.RS 4
\fIcontrol\fP is a struct containing control information (see \fBnls_control_type\fP) 
.br
\fIspecfile\fP is a character string containing the name of the specification file 
.RE
.PP

.SS "void nls_import (struct \fBnls_control_type\fP * control, void ** data, int * status, int n, int m, const char J_type[], int J_ne, const int J_row[], const int J_col[], const int J_ptr[], const char H_type[], int H_ne, const int H_row[], const int H_col[], const int H_ptr[], const char P_type[], int P_ne, const int P_row[], const int P_col[], const int P_ptr[], const real_wp_ w[])"
Import problem data into internal storage prior to solution\&.
.PP
\fBParameters\fP
.RS 4
\fIcontrol\fP is a struct whose members provide control paramters for the remaining prcedures (see \fBnls_control_type\fP)
.br
\fIdata\fP holds private internal data
.br
\fIstatus\fP is a scalar variable of type int, that gives the exit status from the package\&. Possible values are: 
.PD 0

.IP "\(bu" 2
1\&. The import was succesful, and the package is ready for the solve phase 
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restrictions n > 0, m > 0 or requirement that J/H/P_type contains its relevant string 'dense', 'dense_by_columns', 'coordinate', 'sparse_by_rows', 'sparse_by_columns', 'diagonal' or 'absent' has been violated\&.
.PP
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables\&.
.br
\fIm\fP is a scalar variable of type int, that holds the number of residuals\&.
.br
\fIJ_type\fP is a one-dimensional array of type char that specifies the \fBunsymmetric storage scheme \fP used for the Jacobian, J\&. It should be one of 'coordinate', 'sparse_by_rows', 'dense' or 'absent', the latter if access to the Jacobian is via matrix-vector products; lower or upper case variants are allowed\&.
.br
\fIJ_ne\fP is a scalar variable of type int, that holds the number of entries in J in the sparse co-ordinate storage scheme\&. It need not be set for any of the other schemes\&.
.br
\fIJ_row\fP is a one-dimensional array of size J_ne and type int, that holds the row indices of J in the sparse co-ordinate storage scheme\&. It need not be set for any of the other schemes, and in this case can be NULL\&.
.br
\fIJ_col\fP is a one-dimensional array of size J_ne and type int, that holds the column indices of J in either the sparse co-ordinate, or the sparse row-wise storage scheme\&. It need not be set when the dense or diagonal storage schemes are used, and in this case can be NULL\&.
.br
\fIJ_ptr\fP is a one-dimensional array of size m+1 and type int, that holds the starting position of each row of J, as well as the total number of entries, in the sparse row-wise storage scheme\&. It need not be set when the other schemes are used, and in this case can be NULL\&.
.br
\fIH_type\fP is a one-dimensional array of type char that specifies the \fBsymmetric storage scheme \fP used for the Hessian, H\&. It should be one of 'coordinate', 'sparse_by_rows', 'dense', 'diagonal' or 'absent', the latter if access to H is via matrix-vector products; lower or upper case variants are allowed\&.
.br
\fIH_ne\fP is a scalar variable of type int, that holds the number of entries in the lower triangular part of H in the sparse co-ordinate storage scheme\&. It need not be set for any of the other three schemes\&.
.br
\fIH_row\fP is a one-dimensional array of size H_ne and type int, that holds the row indices of the lower triangular part of H in the sparse co-ordinate storage scheme\&. It need not be set for any of the other three schemes, and in this case can be NULL\&.
.br
\fIH_col\fP is a one-dimensional array of size H_ne and type int, that holds the column indices of the lower triangular part of H in either the sparse co-ordinate, or the sparse row-wise storage scheme\&. It need not be set when the dense or diagonal storage schemes are used, and in this case can be NULL\&.
.br
\fIH_ptr\fP is a one-dimensional array of size n+1 and type int, that holds the starting position of each row of the lower triangular part of H, as well as the total number of entries, in the sparse row-wise storage scheme\&. It need not be set when the other schemes are used, and in this case can be NULL\&.
.br
\fIP_type\fP is a one-dimensional array of type char that specifies the \fBunsymmetric storage scheme \fP used for the residual-Hessians-vector product matrix, P\&. It should be one of 'coordinate', 'sparse_by_columns', 'dense_by_columns' or 'absent', the latter if access to P is via matrix-vector products; lower or upper case variants are allowed\&.
.br
\fIP_ne\fP is a scalar variable of type int, that holds the number of entries in P in the sparse co-ordinate storage scheme\&. It need not be set for any of the other schemes\&.
.br
\fIP_row\fP is a one-dimensional array of size P_ne and type int, that holds the row indices of P in either the sparse co-ordinate, or the sparse column-wise storage scheme\&. It need not be set when the dense storage scheme is used, and in this case can be NULL\&.
.br
\fIP_col\fP is a one-dimensional array of size P_ne and type int, that holds the row indices of P in the sparse co-ordinate storage scheme\&. It need not be set for any of the other schemes, and in this case can be NULL\&.
.br
\fIP_ptr\fP is a one-dimensional array of size n+1 and type int, that holds the starting position of each row of P, as well as the total number of entries, in the sparse row-wise storage scheme\&. It need not be set when the other schemes are used, and in this case can be NULL\&.
.br
\fIw\fP is a one-dimensional array of size m and type double, that holds the values w of the weights on the residuals in the least-squares objective function\&. It need not be set if the weights are all ones, and in this case can be NULL\&. 
.RE
.PP

.SS "void nls_reset_control (struct \fBnls_control_type\fP * control, void ** data, int * status)"
Reset control parameters after import if required\&.
.PP
\fBParameters\fP
.RS 4
\fIcontrol\fP is a struct whose members provide control paramters for the remaining prcedures (see \fBnls_control_type\fP)
.br
\fIdata\fP holds private internal data
.br
\fIstatus\fP is a scalar variable of type int, that gives the exit status from the package\&. Possible values are: 
.PD 0

.IP "\(bu" 2
1\&. The import was succesful, and the package is ready for the solve phase 
.PP
.RE
.PP

.SS "void nls_solve_with_mat (void ** data, void * userdata, int * status, int n, int m, real_wp_ x[], real_wp_ c[], real_wp_ g[], int(*)(int, int, const real_wp_[], real_wp_[], const void *) eval_c, int j_ne, int(*)(int, int, int, const real_wp_[], real_wp_[], const void *) eval_j, int h_ne, int(*)(int, int, int, const real_wp_[], const real_wp_[], real_wp_[], const void *) eval_h, int p_ne, int(*)(int, int, int, const real_wp_[], const real_wp_[], real_wp_[], bool, const void *) eval_hprods)"
Find a local minimizer of a given function using a trust-region method\&.
.PP
This call is for the case where H = nabla_{xx}f(x) is provided specifically, and all function/derivative information is available by function calls\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIuserdata\fP is a structure that allows data to be passed into the function and derivative evaluation programs\&.
.br
\fIstatus\fP is a scalar variable of type int, that gives the entry and exit status from the package\&. 
.br
 On initial entry, status must be set to 1\&. 
.br
 Possible exit are: 
.PD 0

.IP "\(bu" 2
0\&. The run was succesful
.PP
.PD 0
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restriction n > 0 or requirement that type contains its relevant string 'dense', 'coordinate', 'sparse_by_rows', 'diagonal' or 'absent' has been violated\&. 
.IP "\(bu" 2
-9\&. The analysis phase of the factorization failed; the return status from the factorization package is given in the component inform\&.factor_status 
.IP "\(bu" 2
-10\&. The factorization failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-11\&. The solution of a set of linear equations using factors from the factorization package failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-16\&. The problem is so ill-conditioned that further progress is impossible\&. 
.IP "\(bu" 2
-17\&. The step is too small to make further impact\&. 
.IP "\(bu" 2
-18\&. Too many iterations have been performed\&. This may happen if control\&.maxit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-19\&. The CPU time limit has been reached\&. This may happen if control\&.cpu_time_limit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-82\&. The user has forced termination of solver by removing the file named control\&.alive_file from unit unit control\&.alive_unit\&.
.PP
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables\&.
.br
\fIm\fP is a scalar variable of type int, that holds the number of residuals\&.
.br
\fIx\fP is a one-dimensional array of size n and type double, that holds the values x of the optimization variables\&. The j-th component of x, j = 0, \&.\&.\&. , n-1, contains x_j\&.
.br
\fIc\fP is a one-dimensional array of size m and type double, that holds the residual c(x)\&. The i-th component of c, j = 0, \&.\&.\&. , n-1, contains c_j(x) \&.
.br
\fIg\fP is a one-dimensional array of size n and type double, that holds the gradient g = nabla_xf(x) of the objective function\&. The j-th component of g, j = 0, \&.\&.\&. , n-1, contains g_j \&.
.br
\fIeval_c\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_c( int n, const double x[], double c[], const void *userdata )

.fi
.PP
 The componnts of the residual function c(x) evaluated at x=x must be assigned to c, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_c\fP via the structure \fCuserdata\fP\&.
.br
\fIj_ne\fP is a scalar variable of type int, that holds the number of entries in the Jacobian matrix J\&.
.br
\fIeval_j\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_j( int n, int m, int jne, const double x[], double j[],
            const void *userdata )

.fi
.PP
 The components of the Jacobian J = nabla_x c(x) of the residuals must be assigned to j in the same order as presented to nls_import, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_j\fP via the structure \fCuserdata\fP\&.
.br
\fIh_ne\fP is a scalar variable of type int, that holds the number of entries in the lower triangular part of the Hessian matrix H if it is used\&.
.br
\fIeval_h\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_h( int n, int m, int hne, const double x[], const double y[],
            double h[], const void *userdata )

.fi
.PP
 The nonzeros of the matrix H = \\sum_{i=1}^m y_i nabla_{xx}c_i(x) of the weighted residual Hessian evaluated at x=x and y=y must be assigned to h in the same order as presented to nls_import, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_h\fP via the structure \fCuserdata\fP\&.
.br
\fIp_ne\fP is a scalar variable of type int, that holds the number of entries in the residual-Hessians-vector product matrix P if it is used\&.
.br
\fIeval_hprods\fP is an optional user-supplied function that may be NULL\&. If non-NULL, it must have the following signature: 
.PP
.nf
int eval_hprods( int n, int m, int pne, const double x[],
                    const double v[], double p[], bool got_h,
                    const void *userdata ) );

.fi
.PP
 The entries of the matrix P, whose i-th column is the product nabla_{xx}c_i(x) v between nabla_{xx}c_i(x), the Hessian of the i-th component of the residual c(x) at x=x, and v=v must be returned in p and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_hprods\fP via the structure \fCuserdata\fP\&. 
.RE
.PP

.SS "void nls_solve_without_mat (void ** data, void * userdata, int * status, int n, int m, real_wp_ x[], real_wp_ c[], real_wp_ g[], int(*)(int, int, const real_wp_[], real_wp_[], const void *) eval_c, int(*)(int, int, const real_wp_[], const bool, real_wp_[], const real_wp_[], bool, const void *) eval_jprod, int(*)(int, int, const real_wp_[], const real_wp_[], real_wp_[], const real_wp_[], bool, const void *) eval_hprod, int p_ne, int(*)(int, int, int, const real_wp_[], const real_wp_[], real_wp_[], bool, const void *) eval_hprods)"
Find a local minimizer of a given function using a trust-region method\&.
.PP
This call is for the case where access to H = nabla_{xx}f(x) is provided by Hessian-vector products, and all function/derivative information is available by function calls\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIuserdata\fP is a structure that allows data to be passed into the function and derivative evaluation programs\&.
.br
\fIstatus\fP is a scalar variable of type int, that gives the entry and exit status from the package\&. 
.br
 On initial entry, status must be set to 1\&. 
.br
 Possible exit are: 
.PD 0

.IP "\(bu" 2
0\&. The run was succesful
.PP
.PD 0
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restriction n > 0 or requirement that type contains its relevant string 'dense', 'coordinate', 'sparse_by_rows', 'diagonal' or 'absent' has been violated\&. 
.IP "\(bu" 2
-9\&. The analysis phase of the factorization failed; the return status from the factorization package is given in the component inform\&.factor_status 
.IP "\(bu" 2
-10\&. The factorization failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-11\&. The solution of a set of linear equations using factors from the factorization package failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-16\&. The problem is so ill-conditioned that further progress is impossible\&. 
.IP "\(bu" 2
-17\&. The step is too small to make further impact\&. 
.IP "\(bu" 2
-18\&. Too many iterations have been performed\&. This may happen if control\&.maxit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-19\&. The CPU time limit has been reached\&. This may happen if control\&.cpu_time_limit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-82\&. The user has forced termination of solver by removing the file named control\&.alive_file from unit unit control\&.alive_unit\&.
.PP
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables
.br
\fIm\fP is a scalar variable of type int, that holds the number of residuals\&.
.br
\fIx\fP is a one-dimensional array of size n and type double, that holds the values x of the optimization variables\&. The j-th component of x, j = 0, \&.\&.\&. , n-1, contains x_j\&.
.br
\fIc\fP is a one-dimensional array of size m and type double, that holds the residual c(x)\&. The i-th component of c, j = 0, \&.\&.\&. , n-1, contains c_j(x) \&.
.br
\fIg\fP is a one-dimensional array of size n and type double, that holds the gradient g = nabla_xf(x) of the objective function\&. The j-th component of g, j = 0, \&.\&.\&. , n-1, contains g_j \&.
.br
\fIeval_c\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_c( int n, const double x[], double c[], const void *userdata )

.fi
.PP
 The componnts of the residual function c(x) evaluated at x=x must be assigned to c, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_c\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_jprod\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_jprod( int n, int m, const double x[], bool transpose,
                double u[], const double v[], bool got_j,
                const void *userdata )

.fi
.PP
 The sum u + nabla_{x}c_(x) v (if tranpose is false) or The sum u + (nabla_{x}c_(x))^T v (if tranpose is true) bewteen the product of the Jacobian nabla_{x}c_(x) or its tranpose with the vector v=v and the vector $u must be returned in u, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_jprod\fP via the structure \fCuserdata\fP\&.
.br
\fIeval_hprod\fP is a user-supplied function that must have the following signature: 
.PP
.nf
int eval_hprod( int n, int m, const double x[], const double y[],
                double u[], const double v[], bool got_h,
                const void *userdata )

.fi
.PP
 The sum u + \\sum_{i=1}^m y_i nabla_{xx}c_i(x) v of the product of the weighted residual Hessian H = \\sum_{i=1}^m y_i nabla_{xx}c_i(x) evaluated at x=x and y=y with the vector v=v and the vector $u must be returned in u, and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. The Hessians have already been evaluated or used at x if got_h is true\&. Data may be passed into \fCeval_hprod\fP via the structure \fCuserdata\fP\&.
.br
\fIp_ne\fP is a scalar variable of type int, that holds the number of entries in the residual-Hessians-vector product matrix P if it is used\&.
.br
\fIeval_hprods\fP is an optional user-supplied function that may be NULL\&. If non-NULL, it must have the following signature: 
.PP
.nf
int eval_hprods( int n, int m, int p_ne, const double x[],
                 const double v[], double pval[], bool got_h,
                 const void *userdata )

.fi
.PP
 The entries of the matrix P, whose i-th column is the product nabla_{xx}c_i(x) v between nabla_{xx}c_i(x), the Hessian of the i-th component of the residual c(x) at x=x, and v=v must be returned in pval and the function return value set to 0\&. If the evaluation is impossible at x, return should be set to a nonzero value\&. Data may be passed into \fCeval_hprods\fP via the structure \fCuserdata\fP\&. 
.RE
.PP

.SS "void nls_solve_reverse_with_mat (void ** data, int * status, int * eval_status, int n, int m, real_wp_ x[], real_wp_ c[], real_wp_ g[], int j_ne, real_wp_ J_val[], const real_wp_ y[], int h_ne, real_wp_ H_val[], real_wp_ v[], int p_ne, real_wp_ P_val[])"
Find a local minimizer of a given function using a trust-region method\&.
.PP
This call is for the case where H = nabla_{xx}f(x) is provided specifically, but function/derivative information is only available by returning to the calling procedure
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIstatus\fP is a scalar variable of type int, that gives the entry and exit status from the package\&. 
.br
 On initial entry, status must be set to 1\&. 
.br
 Possible exit are: 
.PD 0

.IP "\(bu" 2
0\&. The run was succesful
.PP
.PD 0
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restriction n > 0 or requirement that type contains its relevant string 'dense', 'coordinate', 'sparse_by_rows', 'diagonal' or 'absent' has been violated\&. 
.IP "\(bu" 2
-9\&. The analysis phase of the factorization failed; the return status from the factorization package is given in the component inform\&.factor_status 
.IP "\(bu" 2
-10\&. The factorization failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-11\&. The solution of a set of linear equations using factors from the factorization package failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-16\&. The problem is so ill-conditioned that further progress is impossible\&. 
.IP "\(bu" 2
-17\&. The step is too small to make further impact\&. 
.IP "\(bu" 2
-18\&. Too many iterations have been performed\&. This may happen if control\&.maxit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-19\&. The CPU time limit has been reached\&. This may happen if control\&.cpu_time_limit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-82\&. The user has forced termination of solver by removing the file named control\&.alive_file from unit unit control\&.alive_unit\&.
.PP
.PD 0
.IP "\(bu" 2
2\&. The user should compute the vector of residuals c(x) at the point x indicated in x and then re-enter the function\&. The required value should be set in c, and eval_status should be set to 0\&. If the user is unable to evaluate c(x)--- for instance, if the function is undefined at x--- the user need not set c, but should then set eval_status to a non-zero value\&.
.PP
.PD 0
.IP "\(bu" 2
3\&. The user should compute the Jacobian of the vector of residual functions, nabla_x c(x), at the point x indicated in x and then re-enter the function\&. The l-th component of the Jacobian stored according to the scheme specified for the remainder of J in the earlier call to nls_import should be set in J_val[l], for l = 0, \&.\&.\&., J_ne-1 and eval_status should be set to 0\&. If the user is unable to evaluate a component of J --- for instance, if a component of the matrix is undefined at x --- the user need not set J_val, but should then set eval_status to a non-zero value\&.
.PP
.br
\fIstatus\fP (continued) 
.PD 0

.IP "\(bu" 2
4\&. The user should compute the matrix H = \\sum_{i=1}^m v_i nabla_{xx}c_i(x) of weighted residual Hessian evaluated at x=x and v=v and then re-enter the function\&. The l-th component of the matrix stored according to the scheme specified for the remainder of H in the earlier call to nls_import should be set in H_val[l], for l = 0, \&.\&.\&., H_ne-1 and eval_status should be set to 0\&. If the user is unable to evaluate a component of H --- for instance, if a component of the matrix is undefined at x --- the user need not set H_val, but should then set eval_status to a non-zero value\&. \fBNote\fP that this return will not happen if the Gauss-Newton model is selected\&. 
.IP "\(bu" 2
7\&. The user should compute the entries of the matrix P, whose i-th column is the product nabla_{xx}c_i(x) v between nabla_{xx}c_i(x), the Hessian of the i-th component of the residual c(x) at x=x, and v=v and then re-enter the function\&. The l-th component of the matrix stored according to the scheme specified for the remainder of P in the earlier call to nls_import should be set in P_val[l], for l = 0, \&.\&.\&., P_ne-1 and eval_status should be set to 0\&. If the user is unable to evaluate a component of P --- for instance, if a component of the matrix is undefined at x --- the user need not set P_val, but should then set eval_status to a non-zero value\&. \fBNote\fP that this return will not happen if either the Gauss-Newton or Newton models is selected\&.
.PP
.br
\fIeval_status\fP is a scalar variable of type int, that is used to indicate if objective function/gradient/Hessian values can be provided (see above)
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables
.br
\fIm\fP is a scalar variable of type int, that holds the number of residuals\&.
.br
\fIx\fP is a one-dimensional array of size n and type double, that holds the values x of the optimization variables\&. The j-th component of x, j = 0, \&.\&.\&. , n-1, contains x_j\&.
.br
\fIc\fP is a one-dimensional array of size m and type double, that holds the residual c(x)\&. The i-th component of c, j = 0, \&.\&.\&. , n-1, contains c_j(x) \&. See status = 2, above, for more details\&.
.br
\fIg\fP is a one-dimensional array of size n and type double, that holds the gradient g = nabla_xf(x) of the objective function\&. The j-th component of g, j = 0, \&.\&.\&. , n-1, contains g_j \&.
.br
\fIj_ne\fP is a scalar variable of type int, that holds the number of entries in the Jacobian matrix J\&.
.br
\fIJ_val\fP is a one-dimensional array of size j_ne and type double, that holds the values of the entries of the Jacobian matrix J in any of the available storage schemes\&. See status = 3, above, for more details\&.
.br
\fIy\fP is a one-dimensional array of size m and type double, that is used for reverse communication\&. See status = 4 above for more details\&.
.br
\fIh_ne\fP is a scalar variable of type int, that holds the number of entries in the lower triangular part of the Hessian matrix H\&.
.br
\fIH_val\fP is a one-dimensional array of size h_ne and type double, that holds the values of the entries of the lower triangular part of the Hessian matrix H in any of the available storage schemes\&. See status = 4, above, for more details\&.
.br
\fIv\fP is a one-dimensional array of size n and type double, that is used for reverse communication\&. See status = 7, above, for more details\&.
.br
\fIp_ne\fP is a scalar variable of type int, that holds the number of entries in the residual-Hessians-vector product matrix, P\&.
.br
\fIP_val\fP is a one-dimensional array of size p_ne and type double, that holds the values of the entries of the residual-Hessians-vector product matrix, P\&. See status = 7, above, for more details\&. 
.RE
.PP

.SS "void nls_solve_reverse_without_mat (void ** data, int * status, int * eval_status, int n, int m, real_wp_ x[], real_wp_ c[], real_wp_ g[], bool * transpose, real_wp_ u[], real_wp_ v[], real_wp_ y[], int p_ne, real_wp_ P_val[])"
Find a local minimizer of a given function using a trust-region method\&.
.PP
This call is for the case where access to H = nabla_{xx}f(x) is provided by Hessian-vector products, but function/derivative information is only available by returning to the calling procedure\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIstatus\fP is a scalar variable of type int, that gives the entry and exit status from the package\&. 
.br
 On initial entry, status must be set to 1\&. 
.br
 Possible exit are: 
.PD 0

.IP "\(bu" 2
0\&. The run was succesful
.PP
.PD 0
.IP "\(bu" 2
-1\&. An allocation error occurred\&. A message indicating the offending array is written on unit control\&.error, and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-2\&. A deallocation error occurred\&. A message indicating the offending array is written on unit control\&.error and the returned allocation status and a string containing the name of the offending array are held in inform\&.alloc_status and inform\&.bad_alloc respectively\&. 
.IP "\(bu" 2
-3\&. The restriction n > 0 or requirement that type contains its relevant string 'dense', 'coordinate', 'sparse_by_rows', 'diagonal' or 'absent' has been violated\&. 
.IP "\(bu" 2
-9\&. The analysis phase of the factorization failed; the return status from the factorization package is given in the component inform\&.factor_status
.PP
.br
\fIstatus\fP (continued) 
.PD 0

.IP "\(bu" 2
-10\&. The factorization failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-11\&. The solution of a set of linear equations using factors from the factorization package failed; the return status from the factorization package is given in the component inform\&.factor_status\&. 
.IP "\(bu" 2
-16\&. The problem is so ill-conditioned that further progress is impossible\&.
.PP
.PD 0
.IP "\(bu" 2
-17\&. The step is too small to make further impact\&. 
.IP "\(bu" 2
-18\&. Too many iterations have been performed\&. This may happen if control\&.maxit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-19\&. The CPU time limit has been reached\&. This may happen if control\&.cpu_time_limit is too small, but may also be symptomatic of a badly scaled problem\&. 
.IP "\(bu" 2
-82\&. The user has forced termination of solver by removing the file named control\&.alive_file from unit unit control\&.alive_unit\&.
.PP
.PD 0
.IP "\(bu" 2
2\&. The user should compute the vector of residuals c(x) at the point x indicated in x and then re-enter the function\&. The required value should be set in c, and eval_status should be set to 0\&. If the user is unable to evaluate c(x)--- for instance, if the function is undefined at x--- the user need not set c, but should then set eval_status to a non-zero value\&.
.PP
.PD 0
.IP "\(bu" 2
5\&. The user should compute the sum u + nabla_{x}c_(x) v (if tranpose is false) or u + (nabla_{x}c_(x))^T v (if tranpose is true) between the product of the Jacobian nabla_{x}c_(x) or its tranpose with the vector v=v and the vector u = $u, and then re-enter the function\&. The result should be set in u, and eval_status should be set to 0\&. If the user is unable to evaluate the sum --- for instance, if the Jacobian is undefined at x --- the user need not set u, but should then set eval_status to a non-zero value\&.
.PP
.PD 0
.IP "\(bu" 2
6\&. The user should compute the sum u + \\sum_{i=1}^m y_i nabla_{xx}c_i(x) v between the product of the weighted residual Hessian H = \\sum_{i=1}^m y_i nabla_{xx}c_i(x) evaluated at x=x and y=y with the vector v=v and the the vector u = $u, and then re-enter the function\&. The result should be set in u, and eval_status should be set to 0\&. If the user is unable to evaluate the sum --- for instance, if the weifghted residual Hessian is undefined at x --- the user need not set u, but should then set eval_status to a non-zero value\&.
.PP
.PD 0
.IP "\(bu" 2
7\&. The user should compute the entries of the matrix P, whose i-th column is the product nabla_{xx}c_i(x) v between nabla_{xx}c_i(x), the Hessian of the i-th component of the residual c(x) at x=x, and v=v and then re-enter the function\&. The l-th component of the matrix stored according to the scheme specified for the remainder of P in the earlier call to nls_import should be set in P_val[l], for l = 0, \&.\&.\&., P_ne-1 and eval_status should be set to 0\&. If the user is unable to evaluate a component of P --- for instance, if a component of the matrix is undefined at x --- the user need not set P_val, but should then set eval_status to a non-zero value\&. \fBNote\fP that this return will not happen if either the Gauss-Newton or Newton models is selected\&.
.PP
.br
\fIeval_status\fP is a scalar variable of type int, that is used to indicate if objective function/gradient/Hessian values can be provided (see above)
.br
\fIn\fP is a scalar variable of type int, that holds the number of variables
.br
\fIm\fP is a scalar variable of type int, that holds the number of residuals\&.
.br
\fIx\fP is a one-dimensional array of size n and type double, that holds the values x of the optimization variables\&. The j-th component of x, j = 0, \&.\&.\&. , n-1, contains x_j\&.
.br
\fIc\fP is a one-dimensional array of size m and type double, that holds the residual c(x)\&. The i-th component of c, j = 0, \&.\&.\&. , n-1, contains c_j(x) \&. See status = 2, above, for more details\&.
.br
\fIg\fP is a one-dimensional array of size n and type double, that holds the gradient g = nabla_xf(x) of the objective function\&. The j-th component of g, j = 0, \&.\&.\&. , n-1, contains g_j \&.
.br
\fItranspose\fP is a scalar variable of type bool, that indicates whether the product with Jacobian or its transpose should be obtained when status=5\&.
.br
\fIu\fP is a one-dimensional array of size max(n,m) and type double, that is used for reverse communication\&. See status = 5,6 above for more details\&.
.br
\fIv\fP is a one-dimensional array of size max(n,m) and type double, that is used for reverse communication\&. See status = 5,6,7 above for more details\&.
.br
\fIy\fP is a one-dimensional array of size m and type double, that is used for reverse communication\&. See status = 6 above for more details\&.
.br
\fIp_ne\fP is a scalar variable of type int, that holds the number of entries in the residual-Hessians-vector product matrix, P\&.
.br
\fIP_val\fP is a one-dimensional array of size P_ne and type double, that holds the values of the entries of the residual-Hessians-vector product matrix, P\&. See status = 7, above, for more details\&. 
.RE
.PP

.SS "void nls_information (void ** data, struct \fBnls_inform_type\fP * inform, int * status)"
Provides output information
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIinform\fP is a struct containing output information (see \fBnls_inform_type\fP)
.br
\fIstatus\fP is a scalar variable of type int, that gives the exit status from the package\&. Possible values are (currently): 
.PD 0

.IP "\(bu" 2
0\&. The values were recorded succesfully 
.PP
.RE
.PP

.SS "void nls_terminate (void ** data, struct \fBnls_control_type\fP * control, struct \fBnls_inform_type\fP * inform)"
Deallocate all internal private storage
.PP
\fBParameters\fP
.RS 4
\fIdata\fP holds private internal data
.br
\fIcontrol\fP is a struct containing control information (see \fBnls_control_type\fP)
.br
\fIinform\fP is a struct containing output information (see \fBnls_inform_type\fP) 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for C interfaces to GALAHAD NLS from the source code\&.

! THIS VERSION: GALAHAD 4.1 - 2022-12-17 AT 09:30 GMT.

#include "galahad_modules.h"

!-*-*-*-*-*-*-*-*-*-  G A L A H A D   U S E _ N L S  -*-*-*-*-*-*-*-*-*-*-

!  Nick Gould, for GALAHAD productions
!  Copyright reserved
!  October 27th 2015

   MODULE GALAHAD_USENLS_precision
            
     USE GALAHAD_PRECISION

!  This is the driver program for running NLS for a variety of computing
!  systems. It opens and closes all the files, allocate arrays, reads and
!  checks data, and calls the appropriate minimizers

!    USE GALAHAD_CLOCK
     USE GALAHAD_NLS_precision
     USE GALAHAD_SYMBOLS
     USE GALAHAD_SPECFILE_precision
     USE GALAHAD_COPYRIGHT
     USE GALAHAD_SPACE_precision
     USE GALAHAD_CUTEST_FUNCTIONS_precision
     USE GALAHAD_STRING

     IMPLICIT NONE

     PRIVATE
     PUBLIC :: USE_NLS

   CONTAINS

!-*-*-*-*-*-*-*-*-*-  U S E _ N L S   S U B R O U T I N E  -*-*-*-*-*-*-*-

     SUBROUTINE USE_NLS( input )

!  Dummy argument

     INTEGER ( KIND = ip_ ), INTENT( IN ) :: input

!  Set precision


!-------------------------------
!   D e r i v e d   T y p e s
!-------------------------------

     TYPE ( NLS_control_type ) :: control
     TYPE ( NLS_inform_type ) :: inform
     TYPE ( NLS_data_type ) :: data
     TYPE ( NLPT_problem_type ) :: nlp
     TYPE ( GALAHAD_userdata_type ) :: userdata
     TYPE ( CUTEST_FUNCTIONS_control_type ) :: cutest_control
     TYPE ( CUTEST_FUNCTIONS_inform_type ) :: cutest_inform

!-----------------------------------------------
!   L o c a l   P a r a m e t e r s
!-----------------------------------------------

!  Problem input characteristics

     INTEGER ( KIND = ip_ ) :: iores, i, j, ir, ic, l, status
     LOGICAL :: filexx, is_specfile, hessian_pattern_required
!    REAL :: timeo, timet
!    REAL ( KIND = rp_ ) :: clocko, clockt
     REAL ( KIND = rp_ ) :: cutest_time
     CHARACTER ( LEN = 10 ) :: name

!  Functions

!$    INTEGER ( KIND = ip_ ) :: OMP_GET_MAX_THREADS

!  Specfile characteristics

     INTEGER ( KIND = ip_ ), PARAMETER :: input_specfile = 34
     INTEGER ( KIND = ip_ ), PARAMETER :: lspec = 29
     CHARACTER ( LEN = 16 ) :: specname = 'RUNNLS'
     TYPE ( SPECFILE_item_type ), DIMENSION( lspec ) :: spec
     CHARACTER ( LEN = 16 ) :: runspec = 'RUNNLS.SPC'

!  Default values for specfile-defined parameters

     INTEGER ( KIND = ip_ ) :: dfiledevice = 26
     INTEGER ( KIND = ip_ ) :: rfiledevice = 47
     INTEGER ( KIND = ip_ ) :: sfiledevice = 62
     INTEGER ( KIND = ip_ ) :: wfiledevice = 59
     LOGICAL :: fulsol = .FALSE.
     LOGICAL :: write_problem_data   = .FALSE.
     LOGICAL :: write_solution       = .FALSE.
!    LOGICAL :: write_result_summary = .FALSE.
     LOGICAL :: write_result_summary = .TRUE.
     CHARACTER ( LEN = 30 ) :: dfilename = 'NLS.data'
     CHARACTER ( LEN = 30 ) :: rfilename = 'NLSRES.d'
     CHARACTER ( LEN = 30 ) :: sfilename = 'NLSSOL.d'
     CHARACTER ( LEN = 30 ) :: wfilename = 'NLSSAVE.d'
     LOGICAL :: testal = .FALSE.
     LOGICAL :: dechk  = .FALSE.
     LOGICAL :: dechke = .FALSE.
     LOGICAL :: dechkg = .FALSE.
     LOGICAL :: not_fatal  = .FALSE.
     LOGICAL :: not_fatale = .FALSE.
     LOGICAL :: not_fatalg = .FALSE.
     LOGICAL :: getsca = .FALSE.
     INTEGER ( KIND = ip_ ) :: print_level_scaling = 0
     LOGICAL :: scale  = .FALSE.
     LOGICAL :: scaleg = .FALSE.
     LOGICAL :: scalev = .FALSE.
     LOGICAL :: get_max = .FALSE.
     LOGICAL :: warm_start = .FALSE.
     INTEGER ( KIND = ip_ ) :: istore = 0

!  Output file characteristics

     INTEGER ( KIND = ip_ ) :: out  = 6
     INTEGER ( KIND = ip_ ) :: errout = 6
     CHARACTER ( LEN =  6 ) :: solv = 'NLS '

!  ------------------ Open the specfile for nls ----------------

     INQUIRE( FILE = runspec, EXIST = is_specfile )
     IF ( is_specfile ) THEN
       OPEN( input_specfile, FILE = runspec, FORM = 'FORMATTED', STATUS = 'OLD')

!   Define the keywords

       spec( 1 )%keyword  = 'write-problem-data'
       spec( 2 )%keyword  = 'problem-data-file-name'
       spec( 3 )%keyword  = 'problem-data-file-device'
       spec( 4 )%keyword  = 'print-full-solution'
       spec( 5 )%keyword  = 'write-solution'
       spec( 6 )%keyword  = 'solution-file-name'
       spec( 7 )%keyword  = 'solution-file-device'
       spec( 8 )%keyword  = 'write-result-summary'
       spec( 9 )%keyword  = 'result-summary-file-name'
       spec( 10 )%keyword = 'result-summary-file-device'
       spec( 11 )%keyword = 'check-all-derivatives'
       spec( 12 )%keyword = 'check-derivatives'
       spec( 13 )%keyword = 'check-element-derivatives'
       spec( 14 )%keyword = 'check-group-derivatives'
       spec( 15 )%keyword = 'ignore-derivative-bugs'
       spec( 16 )%keyword = 'ignore-element-derivative-bugs'
       spec( 17 )%keyword = 'ignore-group-derivative-bugs'
       spec( 18 )%keyword = 'get-scaling-factors'
       spec( 19 )%keyword = 'scaling-print-level'
       spec( 20 )%keyword = 'use-scaling-factors'
       spec( 21 )%keyword = 'use-constraint-scaling-factors'
       spec( 22 )%keyword = 'use-variable-scaling-factors'
       spec( 23 )%keyword = 'maximizer-sought'
       spec( 24 )%keyword = 'restart-from-previous-point'
       spec( 25 )%keyword = 'restart-data-file-name'
       spec( 26 )%keyword = 'restart-data-file-device'
       spec( 27 )%keyword = 'save-data-for-restart-every'

!   Read the specfile

       CALL SPECFILE_read( input_specfile, specname, spec, lspec, errout )

!   Interpret the result

       CALL SPECFILE_assign_logical( spec( 1 ), write_problem_data, errout )
       CALL SPECFILE_assign_string ( spec( 2 ), dfilename, errout )
       CALL SPECFILE_assign_integer( spec( 3 ), dfiledevice, errout )
       CALL SPECFILE_assign_logical( spec( 4 ), fulsol, errout )
       CALL SPECFILE_assign_logical( spec( 5 ), write_solution, errout )
       CALL SPECFILE_assign_string ( spec( 6 ), sfilename, errout )
       CALL SPECFILE_assign_integer( spec( 7 ), sfiledevice, errout )
       CALL SPECFILE_assign_logical( spec( 8 ), write_result_summary, errout )
       CALL SPECFILE_assign_string ( spec( 9 ), rfilename, errout )
       CALL SPECFILE_assign_integer( spec( 10 ), rfiledevice, errout )
       CALL SPECFILE_assign_logical( spec( 11 ), testal, errout )
       CALL SPECFILE_assign_logical( spec( 12 ), dechk, errout )
       CALL SPECFILE_assign_logical( spec( 13 ), dechke, errout )
       CALL SPECFILE_assign_logical( spec( 14 ), dechkg, errout )
       CALL SPECFILE_assign_logical( spec( 15 ), not_fatal, errout )
       CALL SPECFILE_assign_logical( spec( 16 ), not_fatale, errout )
       CALL SPECFILE_assign_logical( spec( 17 ), not_fatalg, errout )
       CALL SPECFILE_assign_logical( spec( 18 ), getsca, errout )
       CALL SPECFILE_assign_integer( spec( 19 ), print_level_scaling, errout )
       CALL SPECFILE_assign_logical( spec( 20 ), scale, errout )
       CALL SPECFILE_assign_logical( spec( 21 ), scaleg, errout )
       CALL SPECFILE_assign_logical( spec( 22 ), scalev, errout )
       CALL SPECFILE_assign_logical( spec( 23 ), get_max, errout )
       CALL SPECFILE_assign_logical( spec( 24 ), warm_start, errout )
       CALL SPECFILE_assign_string ( spec( 25 ), wfilename, errout )
       CALL SPECFILE_assign_integer( spec( 26 ), wfiledevice, errout )
       CALL SPECFILE_assign_integer( spec( 27 ), istore, errout )
     END IF

     IF ( dechk .OR. testal ) THEN ; dechke = .TRUE. ; dechkg = .TRUE. ; END IF
     IF ( not_fatal ) THEN ; not_fatale = .TRUE. ; not_fatalg = .TRUE. ; END IF
     IF ( scale ) THEN ; scaleg = .TRUE. ; scalev = .TRUE. ; END IF

!  If required, open a file for the results

     IF ( write_result_summary ) THEN
       INQUIRE( FILE = rfilename, EXIST = filexx )
       IF ( filexx ) THEN
          OPEN( rfiledevice, FILE = rfilename, FORM = 'FORMATTED',             &
                STATUS = 'OLD', POSITION = 'APPEND', IOSTAT = iores )
       ELSE
          OPEN( rfiledevice, FILE = rfilename, FORM = 'FORMATTED',             &
                STATUS = 'NEW', IOSTAT = iores )
       END IF
       IF ( iores /= 0 ) THEN
         write( errout, 2030 ) iores, rfilename
         STOP
       END IF
       READ( INPUT, "( /, I2, A8  )" ) iores, nlp%pname
       REWIND( input )
       WRITE( rfiledevice, "( A10 )" ) nlp%pname
     END IF

!  Set copyright

     IF ( out > 0 ) CALL COPYRIGHT( out, '2015' )

!  Set up control parameters prior to the next solution

     CALL NLS_initialize( data, control, inform )
     IF ( is_specfile ) CALL NLS_read_specfile( control, input_specfile )
     control%jacobian_available = 2
     control%hessian_available = 2

!  Initialize the problem data

     hessian_pattern_required                                                  &
       = control%hessian_available >= 1 .OR. control%model == 4

     cutest_control%input = input ; cutest_control%error = control%error
     CALL CUTEST_initialize( nlp, cutest_control, cutest_inform, userdata,     &
                             no_hessian = .NOT. hessian_pattern_required,      &
                             hessian_products = .TRUE. )

!  Read a previous solution file for a re-entry

     IF ( warm_start .AND. wfiledevice > 0 ) THEN
       OPEN( wfiledevice, FILE = wfilename, FORM = 'FORMATTED',                &
             STATUS = 'OLD', IOSTAT = iores )
       IF ( iores /= 0 ) THEN
         WRITE( out, 2030 ) iores, wfilename
         STOP
       END IF

       REWIND( wfiledevice )
       READ( wfiledevice, "( A10 )" ) name
       IF ( name /= nlp%pname ) THEN
         WRITE( out, "( /, ' *** Exit from usenls: re-entry requested with',   &
        &         ' data for problem ', A10, /,                                &
        &         '     but the most recently decoded problem is ', A10 )" )   &
          name, nlp%pname
         STOP
       END IF
       READ( wfiledevice, "( I8 )" )i
       IF ( i /= nlp%n ) THEN
         WRITE( out, "( /, ' *** Exit from usenls: number of variables'      , &
        &        ' changed from ', I0,' to ', I0,' on re-entry ' )" ) nlp%n, i
         STOP
       END IF
       READ( wfiledevice, "( I8 )" )i
       IF ( i /= nlp%m ) THEN
         WRITE( out, "( /, ' *** Exit from usenls: number of residuals',       &
        &        ' changed from ', I0, ' to ', I0, ' on re-entry ' )" ) nlp%m, i
         STOP
       END IF
       READ( wfiledevice, "( ES24.16 )" ) control%initial_weight
       DO i = 1, nlp%n
         READ( wfiledevice, "( ES24.16, 2X, A10 )" ) nlp%X( i ), name
         IF ( name /= nlp%VNAMES( i ) ) THEN
           WRITE( out, "( /, ' *** Exit from usenls: variable named ',         &
          &  A, ' out of order on re-entry ' )" ) TRIM( name )
           STOP
         END IF
       END DO
       CLOSE( wfiledevice )
     END IF

!  find the tensor model at the initial point

     IF ( .FALSE. ) THEN
       write(78,"( A8, 1X, A8 )" )  ADJUSTL( STRING_trim_integer_8( nlp%n ) ), &
        ADJUSTL( STRING_trim_integer_8( nlp%m ) )
       CALL CUTEST_eval_C( data%eval_status, nlp%X( : nlp%n ), userdata,       &
                    nlp%C( : nlp%m ) )
       write(78,"( ( A8, 1X, A12 ) )" )                                        &
         ( ADJUSTL( STRING_trim_integer_8( i ) ),                              &
           STRING_real_12( nlp%C( i ) ), i = 1, nlp%m )
       CALL CUTEST_eval_J( data%eval_status, nlp%X( : nlp%n ), userdata,       &
                    nlp%J%val )
       DO i = 1, nlp%J%ne
         write(78,"( A8, 1X, A8, 1X, A12 )" )                                  &
           ADJUSTL( STRING_trim_integer_8( nlp%J%row( i ) ) ),                 &
           ADJUSTL( STRING_trim_integer_8( nlp%J%col( i ) ) ),                 &
             STRING_real_12( nlp%J%val( i ) )
       END DO
       ALLOCATE( data%W( nlp%n ), stat = i )
       data%W( : nlp%n ) = 0.0_rp_
       DO j = 1, nlp%n
         data%W( j ) = 1.0_rp_
         CALL CUTEST_eval_HCPRODS( data%eval_status, nlp%X( : nlp%n ),         &
                                   data%W( : nlp%n ), userdata,                &
                                   nlp%P%val, got_h = .FALSE. )
         data%W( j ) = 0.0_rp_
         DO i = 1, nlp%m
           DO l = nlp%P%ptr( i ), nlp%P%ptr( i + 1 ) - 1
             IF ( nlp%P%row( l ) <= j ) &
             write(78,"( A8, 1X, A8, 1X, A8, 1X, A12 )" )                      &
               ADJUSTL( STRING_trim_integer_8( i ) ),                          &
               ADJUSTL( STRING_trim_integer_8( nlp%P%row( l ) ) ),             &
               ADJUSTL( STRING_trim_integer_8( j ) ),                          &
               STRING_real_12( nlp%J%val( l ) )
           END DO
         END DO
       END DO
       DEALLOCATE( data%W )
     END IF

     CALL CUTEst_start_timing( status )

!  =================
!  Solve the problem
!  =================

     inform%status = 1
!    CALL CPU_TIME( timeo ) ; CALL CLOCK_time( clocko )
     CALL NLS_solve( nlp, control, inform, data, userdata,                     &
                     eval_C = CUTEST_eval_C,                                   &
                     eval_J = CUTEST_eval_J,                                   &
                     eval_H = CUTEST_eval_HLC,                                 &
                     eval_JPROD = CUTEST_eval_JPROD,                           &
                     eval_HPROD = CUTEST_eval_HLCPROD,                         &
                     eval_HPRODS = CUTEST_eval_HCPRODS )
!    CALL CPU_TIME( timet ) ; CALL CLOCK_time( clockt )

!$    WRITE( out, "( ' number of threads = ', I0 )" ) OMP_GET_MAX_THREADS( )

      CALL CUTEst_timing( status, userdata, 'CUTEST_eval_C', cutest_time )
      WRITE( 6, "( ' CUTEST_eval_C time =   ', F8.2 )" ) cutest_time
      CALL CUTEst_timing( status, userdata, 'CUTEST_eval_J', cutest_time )
      WRITE( 6, "( ' CUTEST_eval_J time =   ', F8.2 )" ) cutest_time
      CALL CUTEst_timing( status, userdata, 'CUTEST_eval_HLC', cutest_time )
      WRITE( 6, "( ' CUTEST_eval_HLC time = ', F8.2 )" ) cutest_time
      WRITE( 6, "( ' total time =           ', F8.2 )" )inform%time%total
      IF (  control%subproblem_direct ) THEN
        IF ( control%model == 6 ) THEN
          WRITE( 6, "(' m, n, nnz(lower[J^TJ]), density =', 3( ' ', I0, ',' ), &
         &  F5.2, / )" ) nlp%m, nlp%n,                                         &
            inform%subproblem_inform%RQS_inform%SLS_inform%entries,            &
            REAL( inform%subproblem_inform%RQS_inform%SLS_inform%entries       &
              - nlp%n ) / ( REAL( nlp%n, rp_ ) * REAL( nlp%n + 1, rp_ ) / 2.0_rp_ )
        ELSE
          WRITE( 6, "(' m, n, nnz(lower[J^TJ]), density =', 3( ' ', I0, ',' ), &
         &  F5.2, / )" ) nlp%m, nlp%n, inform%RQS_inform%SLS_inform%entries,   &
             REAL( inform%RQS_inform%SLS_inform%entries - nlp%n )              &
              / ( REAL( nlp%n, rp_ ) * REAL( nlp%n + 1, rp_ ) / 2.0_rp_ )
        END IF

!write(6,*) REAL( inform%subproblem_inform%RQS_inform%SLS_inform%entries       &
!  - nlp%n ) / ( REAL( nlp%n, rp_ ) * REAL( nlp%n + 1, rp_ ) / 2.0_rp_ )
      END IF

!  ================
!  Solution details
!  ================

!  If required, append results to a file,

      IF ( write_result_summary ) THEN
        BACKSPACE( rfiledevice )
        IF ( control%subproblem_direct ) THEN
          IF ( inform%status == GALAHAD_ok .OR.                                &
               inform%status == GALAHAD_error_unbounded ) THEN
            WRITE( rfiledevice, 2040 ) nlp%pname, nlp%m, nlp%n,                &
              inform%norm_c, inform%norm_g, inform%iter,                       &
              inform%j_eval, inform%factorization_average,                     &
              inform%factorization_max,                                        &
              inform%time%clock_total, inform%status
          ELSE
            WRITE( rfiledevice, 2040 ) nlp%pname, nlp%m, nlp%n,                &
              inform%norm_c, inform%norm_g, - inform%iter,                     &
              - inform%j_eval, inform%factorization_average,                   &
              inform%factorization_max, - inform%time%clock_total,             &
              inform%status
          END IF
        ELSE
          IF ( inform%status == GALAHAD_ok .OR.                                &
               inform%status == GALAHAD_error_unbounded ) THEN
            WRITE( rfiledevice, 2050 ) nlp%pname, nlp%m, nlp%n,                &
              inform%norm_c, inform%norm_g, inform%iter,                       &
              inform%j_eval, inform%cg_iter,                                   &
              inform%time%clock_total, inform%status
          ELSE
            WRITE( rfiledevice, 2050 ) nlp%pname, nlp%m, nlp%n,                &
              inform%norm_c, inform%norm_g, - inform%iter,                     &
              - inform%j_eval, inform%cg_iter,                                 &
              - inform%time%clock_total, inform%status
          END IF
        END IF
      END IF

!  If required, write the solution

      l = 2
      IF ( fulsol ) l = nlp%n
      IF ( control%print_level >= 10 ) l = nlp%n

      WRITE( errout, 2000 )
      DO j = 1, 2
        IF ( j == 1 ) THEN
          ir = 1 ; ic = MIN( l, nlp%n )
          IF ( ic + 1 == nlp%n - l ) ic = ic + 1
        ELSE
          IF ( ic < nlp%n - l ) WRITE( errout, 2010 )
          ir = MAX( ic + 1, nlp%n - ic + 1 ) ; ic = nlp%n
        END IF
        DO i = ir, ic
          WRITE( errout, 2020 ) i, nlp%VNAMES( i ), nlp%X( i ), nlp%X_l( i ),  &
            nlp%X_u( i ), nlp%G( i )
        END DO
      END DO

      IF ( control%subproblem_direct ) THEN
        WRITE( errout, "( /, 'name           m     n      ||c||    ',          &
       &  ' ||J''c/c||   its     #g   av fac   time  st' )" )
        IF ( inform%status == GALAHAD_ok .OR.                                  &
             inform%status == GALAHAD_error_unbounded ) THEN
          WRITE( errout, 2040 ) nlp%pname, nlp%m, nlp%n, inform%norm_c,        &
            inform%norm_g, inform%iter, inform%j_eval,                         &
            inform%factorization_average, inform%factorization_max,            &
            inform%time%clock_total, inform%status
        ELSE
          WRITE( errout, 2040 ) nlp%pname, nlp%m, nlp%n, inform%norm_c,        &
            inform%norm_g, - inform%iter, - inform%j_eval,                     &
            inform%factorization_average, inform%factorization_max,            &
            - inform%time%clock_total, inform%status
        END IF
      ELSE
        WRITE( errout, "( /, 'name           m     n      ||c||    ',          &
       &  ' ||J''c/c||   its     #g      #cg   time stat' )" )
        IF ( inform%status == GALAHAD_ok .OR.                                  &
             inform%status == GALAHAD_error_unbounded ) THEN
          WRITE( errout, 2050 ) nlp%pname, nlp%m, nlp%n, inform%norm_c,        &
            inform%norm_g, inform%iter, inform%j_eval,                         &
            inform%cg_iter, inform%time%clock_total, inform%status
        ELSE
          WRITE( errout, 2050 ) nlp%pname, nlp%m, nlp%n, inform%norm_c,        &
            inform%norm_g, - inform%iter, - inform%j_eval,                     &
            inform%cg_iter, - inform%time%clock_total, inform%status
        END IF
      END IF

      IF ( write_solution ) THEN
!     IF ( write_solution .AND.                                                &
!         ( inform%status == 0  .OR. inform%status == - 10 ) ) THEN

        INQUIRE( FILE = sfilename, EXIST = filexx )
        IF ( filexx ) THEN
           OPEN( sfiledevice, FILE = sfilename, FORM = 'FORMATTED',            &
               STATUS = 'OLD', IOSTAT = iores )
        ELSE
           OPEN( sfiledevice, FILE = sfilename, FORM = 'FORMATTED',            &
                STATUS = 'NEW', IOSTAT = iores )
        END IF
        IF ( iores /= 0 ) THEN
          WRITE( out, 2030 ) iores, sfilename
          STOP
        END IF

        WRITE( sfiledevice, "( /, ' Problem:    ', A10, /, ' Solver :    ', A, &
       &       /, ' Objective:', ES24.16 )" ) nlp%pname, solv, inform%obj

        WRITE( sfiledevice, 2100 )
        DO i = 1, nlp%n
          WRITE( sfiledevice, 2120 ) i, nlp%VNAMES( i ), nlp%X( i ),           &
            nlp%X_l( i ), nlp%X_u( i ), nlp%G( i )
        END DO

     END IF
!do i = 1, nlp%n
!write(6,*)  nlp%X( i )
!end do

!  if required, save the solution for a future re-entry

     IF ( wfiledevice > 0 .AND. ( ( istore > 0 .AND.                           &
            ( inform%status == GALAHAD_ok .OR.                                 &
              inform%status == GALAHAD_error_ill_conditioned .OR.              &
              inform%status == GALAHAD_error_tiny_step .OR.                    &
              inform%status == GALAHAD_error_max_iterations .OR.               &
              inform%status == GALAHAD_error_time_limit .OR.                   &
              inform%status == GALAHAD_error_alive ) ) .OR.                    &
            inform%status == GALAHAD_error_alive ) ) THEN
       INQUIRE( FILE = wfilename, OPENED = filexx )
       IF ( .NOT. filexx ) THEN
         INQUIRE( FILE = wfilename, EXIST = filexx )
         IF ( filexx ) THEN
            OPEN( wfiledevice, FILE = wfilename, FORM = 'FORMATTED',           &
                  STATUS = 'OLD', POSITION = 'APPEND', IOSTAT = iores )
         ELSE
            OPEN( wfiledevice, FILE = wfilename, FORM = 'FORMATTED',           &
                  STATUS = 'NEW', IOSTAT = iores )
         END IF
         IF ( iores /= 0 ) THEN
           WRITE( out, 2030 ) iores, wfilename
           STOP
         END IF
       END IF
       REWIND( wfiledevice )
       WRITE( wfiledevice, "( A10, ' problem name ', /,                        &
      &                       I8,  ' number of variables', /,                  &
      &                       I8,  ' number of residuals', /,                  &
      &                       ES24.16, ' weight ... and now variables' )" )    &
       nlp%pname, nlp%n, nlp%m, inform%weight
       DO i = 1, nlp%n
         WRITE( wfiledevice, "( ES24.16, 2X, A10 )" )                          &
          nlp%X( i ), nlp%VNAMES( i )
       END DO
       CLOSE( wfiledevice )
     END IF

!  Close any opened files and deallocate arrays

     IF ( is_specfile ) CLOSE( input_specfile )
     CALL CUTEST_terminate( nlp, cutest_inform, userdata )
     RETURN

!  Non-executable statements

 2000 FORMAT( ' Solution: ', /,'                        ',                     &
              '        <------ Bounds ------> ', /                             &
              '      # name          value   ',                                &
              '    Lower       Upper       Dual ' )
 2010 FORMAT( 6X, '. .', 9X, 4( 2X, 10( '.' ) ) )
 2020 FORMAT( I7, 1X, A10, 4ES12.4 )
 2030 FORMAT( ' IOSTAT = ', I6, ' when opening file ', A9, '. Stopping ' )
 2040 FORMAT( A10, 2I6, ES16.8, ES8.1, bn, 2I7, F5.1, I4, F7.2, I4 )
 2050 FORMAT( A10, 2I6, ES16.8, ES8.1, bn, 2I7, I9, F7.2, I4 )
 2100 FORMAT( ' Solution: ', /,'                        ',                     &
              '                    <------ Bounds ------> ', /                 &
              '      # name                value          ',                   &
              '    Lower       Upper       Dual ' )
 2120 FORMAT( I7, 1X, A10, ES24.16, 3ES12.4 )

!  End of subroutine USE_NLS

  contains
     FUNCTION STRING_trim_integer_8( i )
     CHARACTER ( LEN = 8 ) :: STRING_trim_integer_8
     INTEGER ( KIND = ip_ ) :: i

!  write integer as a left shifted length 8 character

     STRING_trim_integer_8 = REPEAT( ' ', 8 )
     WRITE( STRING_trim_integer_8, "( I0 )" ) i
     RETURN

!  end of function STRING_trim_integer_8

     END FUNCTION STRING_trim_integer_8

     END SUBROUTINE USE_NLS

!  End of module USENLS

   END MODULE GALAHAD_USENLS_precision

! COPYRIGHT (c) 1995 Council for the Central Laboratory
!         of the Research Councils, RMCS, and NAG
! Original date 7 Nov 2001
! 7 November 2001 Made threadsafe.

! 12th July 2004 Version 1.0.0. Version numbering added.

! 20th December 2005 Version 1.1.0. STAT initialized in FINALIZE.

MODULE HSL_AD02_FORWARD_DOUBLE
! This module allows small changes to be made to a program to convert it
! to one that calculates the derivatives of variables with respect to
! other variables.

  IMPLICIT NONE
  PRIVATE

  INTEGER, PARAMETER :: WP = KIND(0D0) ! Type of real we are using
  INTEGER, PARAMETER :: HEAP_SIZE=1000 ! Initial size of heaps

! Parameters that define which errors/warnings have occurred
  INTEGER, PARAMETER :: INIT_ERR = 1
  INTEGER, PARAMETER :: ALLOC_ERR = 3
  INTEGER, PARAMETER :: SQRT_ERR = 5
  INTEGER, PARAMETER :: POW1_ERR = 6
  INTEGER, PARAMETER :: POW2_ERR = 7
  INTEGER, PARAMETER :: SIGN_WARN = 8
  INTEGER, PARAMETER :: ABS_WARN = 9
  INTEGER, PARAMETER :: INT_WARN = 10
  INTEGER, PARAMETER :: AINT_WARN = 11
  INTEGER, PARAMETER :: NINT_WARN = 12
  INTEGER, PARAMETER :: ANINT_WARN = 13
  INTEGER, PARAMETER :: MAX_WARN = 14
  INTEGER, PARAMETER :: MIN_WARN = 15
  INTEGER, PARAMETER :: EQ_WARN = 16
  INTEGER, PARAMETER :: NE_WARN = 17
  INTEGER, PARAMETER :: GT_WARN = 18
  INTEGER, PARAMETER :: LT_WARN = 19
  INTEGER, PARAMETER :: GE_WARN = 20
  INTEGER, PARAMETER :: LE_WARN = 21
  INTEGER, PARAMETER :: UNDEF_WARN = 33
  INTEGER, PARAMETER :: ASSIGNMENT_WARN = 34

! Error Flags and error handling
    INTEGER :: AD02_FLAG(40)=0  ! Error/warning flags
    INTEGER :: ERROR_MESSAGE_UNIT=6  ! Output unit for errors
    INTEGER :: WARNING_MESSAGE_UNIT=6  ! Output unit for warnings
    INTEGER :: ERROR_PRINT_LEVEL=1   ! Controls printing of messages
    INTEGER :: ERROR_STOP_LEVEL=1   ! Controls execution after error/warn

! Forward method AD02_DATA structure
  TYPE, PUBLIC :: AD02_DATA
!????    PRIVATE
    INTEGER LEVEL ! Highest degree of derivatives reqd.
    INTEGER, POINTER :: IBINCO(:,:)=>NULL() ! Holds binomial coefficients iCj.
! Error Flags and error handling
    INTEGER, POINTER :: FLAGS(:)=>NULL()  ! Error/warning flags
    INTEGER :: ERROR_MESSAGE_UNIT = 6  ! Output unit for errors
    INTEGER :: WARNING_MESSAGE_UNIT = 6  ! Output unit for warnings
    INTEGER :: ERROR_PRINT_LEVEL = 1  ! Controls printing of messages
    INTEGER :: ERROR_STOP_LEVEL = 1  ! Controls execution after error/warn
! The heaps and stack
    REAL (WP), POINTER :: RHEAP(:)=>NULL() ! The heap for reals
    INTEGER, POINTER :: IHEAP(:)=>NULL() ! The heap for integers
    INTEGER, POINTER :: IPONT(:)=>NULL() ! Pointers to entries in IHEAP
    INTEGER, POINTER :: RPTR(:)=>NULL() ! Pointers to entries in RHEAP
    INTEGER, POINTER :: RLENG(:)=>NULL() ! Length of structure on RHEAP
    INTEGER, POINTER :: NVARS(:)=>NULL() ! No. of variables in structure
! The pointers into the various heaps
    INTEGER DEAD_POINTER ! Pointer to the last structure made DEAD
    INTEGER IPTOS ! First free structure index
    INTEGER IHTOS ! First free IHEAP index
    INTEGER IRTOS ! First free RHEAP index
    INTEGER SIZE_X ! no. of independent variables
    INTEGER REAL_STRUCT_SIZE ! The size for the reals in full storage
    INTEGER SWITCH_POINT !  The sparse mode / full mode SWITCH point
    INTEGER :: CASE = -1 ! 0  if in motoring mode;
                         ! -1 if undefined (finalized)
    INTEGER :: MAX_CASE = 1 ! Largest case value used
  END TYPE AD02_DATA

! Type definition for new type AD02_REAL
  TYPE, PUBLIC :: AD02_REAL
    PRIVATE
    INTEGER :: P = -1 ! Position in IPONT, NVARS, RLENG, RPTR;
                      ! -1 if undefined or data-undefined
    INTEGER :: CASE ! Negative for a temporary variable
    TYPE(AD02_DATA), POINTER :: DATA => NULL()
    ! Variable V of this type is data-undefined if V%DATA has a
    !     target and either V%P = -1 or ABS(V%CASE) /= V%DATA%CASE
    ! Variable V of this type is undefined if V%DATA has no target
    ! If V%P/= -1, V%DATA is associated
  END TYPE AD02_REAL

! Redefine the operators (+, -, * , /, **, .EQ., .NE., .LT.,
! .GT., .LE., .GT. and assignment(=)) to work with type AD02_REAL

  INTERFACE OPERATOR (+)
    MODULE PROCEDURE ADD_DD, ADD_RD, ADD_DR, ADD_ID, ADD_DI
    MODULE PROCEDURE ADD_DS, ADD_SD
  END INTERFACE
  PUBLIC OPERATOR (+)

  INTERFACE OPERATOR (-)
    MODULE PROCEDURE MINUS_D, MINUS_DD, MINUS_RD, MINUS_DR
    MODULE PROCEDURE MINUS_ID, MINUS_DI
    MODULE PROCEDURE MINUS_DS, MINUS_SD
  END INTERFACE
  PUBLIC OPERATOR (-)

  INTERFACE OPERATOR (*)
    MODULE PROCEDURE MULT_DD, MULT_RD, MULT_DR, MULT_ID, MULT_DI
    MODULE PROCEDURE MULT_DS, MULT_SD
  END INTERFACE
  PUBLIC OPERATOR (*)

  INTERFACE OPERATOR (/)
    MODULE PROCEDURE DIV_DD, DIV_RD, DIV_DR, DIV_ID, DIV_DI
    MODULE PROCEDURE DIV_DS, DIV_SD
  END INTERFACE
  PUBLIC OPERATOR (/)

  INTERFACE OPERATOR (**)
    MODULE PROCEDURE POW_DD, POW_RD, POW_DR, POW_DI, POW_ID
    MODULE PROCEDURE POW_DS, POW_SD
  END INTERFACE
  PUBLIC OPERATOR (**)

  INTERFACE OPERATOR (==)
    MODULE PROCEDURE EQ_DD, EQ_RD, EQ_DR, EQ_ID, EQ_DI
    MODULE PROCEDURE EQ_DS, EQ_SD
  END INTERFACE
  PUBLIC OPERATOR (==)

  INTERFACE OPERATOR (<=)
    MODULE PROCEDURE LE_DD, LE_RD, LE_DR, LE_ID, LE_DI
    MODULE PROCEDURE LE_DS, LE_SD
  END INTERFACE
  PUBLIC OPERATOR (<=)

  INTERFACE OPERATOR (<)
    MODULE PROCEDURE LT_DD, LT_RD, LT_DR, LT_DI, LT_ID
    MODULE PROCEDURE LT_DS, LT_SD
  END INTERFACE
  PUBLIC OPERATOR (<)

  INTERFACE OPERATOR (>=)
    MODULE PROCEDURE GE_DD, GE_RD, GE_DR, GE_ID, GE_DI
    MODULE PROCEDURE GE_DS, GE_SD
  END INTERFACE
  PUBLIC OPERATOR (>=)

  INTERFACE OPERATOR (>)
    MODULE PROCEDURE GT_DD, GT_RD, GT_DR, GT_DI, GT_ID
    MODULE PROCEDURE GT_DS, GT_SD
  END INTERFACE
  PUBLIC OPERATOR (>)

  INTERFACE OPERATOR (/=)
    MODULE PROCEDURE NE_DD, NE_RD, NE_DR, NE_ID, NE_DI
    MODULE PROCEDURE NE_DS, NE_SD
  END INTERFACE
  PUBLIC OPERATOR (/=)

  INTERFACE ASSIGNMENT (=)
    MODULE PROCEDURE ASSIGN_DR, ASSIGN_DD, ASSIGN_DI, ASSIGN_ID
    MODULE PROCEDURE ASSIGN_DS
    MODULE PROCEDURE ASSIGN_DD1, ASSIGN_DD2, ASSIGN_DD3
    MODULE PROCEDURE ASSIGN_DD4, ASSIGN_DD5, ASSIGN_DD6, ASSIGN_DD7
    MODULE PROCEDURE ASSIGN_DD10, ASSIGN_DD20, ASSIGN_DD30
    MODULE PROCEDURE ASSIGN_DD40, ASSIGN_DD50, ASSIGN_DD60, ASSIGN_DD70
  END INTERFACE
  PUBLIC ASSIGNMENT (=)

! Interfaces to AD02 routines

  INTERFACE AD02_CONTROL
    MODULE PROCEDURE CONTROL1,CONTROL2
  END INTERFACE
  PUBLIC AD02_CONTROL

  INTERFACE AD02_FLAGS
    MODULE PROCEDURE FLAGS1,FLAGS2,FLAGS3,FLAGS4
  END INTERFACE
  PUBLIC AD02_FLAGS

  INTERFACE AD02_DATA_UNDEFINED
    MODULE PROCEDURE DATA_UNDEFINED
  END INTERFACE
  PUBLIC AD02_DATA_UNDEFINED

  INTERFACE AD02_DERIVS
    MODULE PROCEDURE DERIVS_S
  END INTERFACE
  PUBLIC AD02_DERIVS

  INTERFACE AD02_FINALIZE_DATA
    MODULE PROCEDURE FINALIZE
  END INTERFACE
  PUBLIC AD02_FINALIZE_DATA

  INTERFACE AD02_GRAD
    MODULE PROCEDURE GRAD0, GRAD1
  END INTERFACE
  PUBLIC AD02_GRAD

  INTERFACE AD02_HESSIAN
    MODULE PROCEDURE HESSIAN0, HESSIAN1
  END INTERFACE
  PUBLIC AD02_HESSIAN

  INTERFACE AD02_INITIALIZE_COMP
    MODULE PROCEDURE INITIALIZE_0, INITIALIZE_11, INITIALIZE_10
  END INTERFACE
  PUBLIC AD02_INITIALIZE_COMP

  INTERFACE AD02_INITIALIZE_DATA
    MODULE PROCEDURE INITIALIZE_DATA
  END INTERFACE
  PUBLIC AD02_INITIALIZE_DATA

  INTERFACE AD02_TEMP
    MODULE PROCEDURE MAKE_TEMP
  END INTERFACE
  PUBLIC AD02_TEMP

  INTERFACE AD02_UNDEFINE
    MODULE PROCEDURE UNDEFINE_REAL0, UNDEFINE_REAL1
    MODULE PROCEDURE UNDEFINE_REAL2, UNDEFINE_REAL3
    MODULE PROCEDURE UNDEFINE_REAL4, UNDEFINE_REAL5
    MODULE PROCEDURE UNDEFINE_REAL6, UNDEFINE_REAL7
  END INTERFACE
  PUBLIC AD02_UNDEFINE

  INTERFACE AD02_UNDEFINED
    MODULE PROCEDURE UNDEFINED
  END INTERFACE
  PUBLIC AD02_UNDEFINED

  INTERFACE AD02_USER
    MODULE PROCEDURE USER
  END INTERFACE
  PUBLIC AD02_USER

  INTERFACE AD02_VALUE
    MODULE PROCEDURE VALUE_SCALAR, VALUE_ARRAY
  END INTERFACE
  PUBLIC AD02_VALUE

! Intrinsic functions which now work with Type AD02_REAL

  INTERFACE ABS
    MODULE PROCEDURE ABS_D
  END INTERFACE
  PUBLIC ABS

  INTERFACE ACOS
    MODULE PROCEDURE ACOS_D
  END INTERFACE
  PUBLIC ACOS

  INTERFACE AINT
    MODULE PROCEDURE AINT_D
  END INTERFACE
  PUBLIC AINT

  INTERFACE ANINT
    MODULE PROCEDURE ANINT_D
  END INTERFACE
  PUBLIC ANINT

  INTERFACE ASIN
    MODULE PROCEDURE ASIN_D
  END INTERFACE
  PUBLIC ASIN

  INTERFACE ATAN
    MODULE PROCEDURE ATAN_D
  END INTERFACE
  PUBLIC ATAN

  INTERFACE ATAN2
    MODULE PROCEDURE ATAN2_DD, ATAN2_RD, ATAN2_DR
    MODULE PROCEDURE ATAN2_DS, ATAN2_SD
  END INTERFACE
  PUBLIC ATAN2

  INTERFACE COS
    MODULE PROCEDURE COS_D
  END INTERFACE
  PUBLIC COS

  INTERFACE COSH
    MODULE PROCEDURE COSH_D
  END INTERFACE
  PUBLIC COSH

  INTERFACE DERIVS
    MODULE PROCEDURE DERIVS_R, DERIVS_I
  END INTERFACE

  INTERFACE EXP
    MODULE PROCEDURE EXP_D
  END INTERFACE
  PUBLIC EXP

  INTERFACE INT
    MODULE PROCEDURE INT_D
  END INTERFACE
  PUBLIC INT

  INTERFACE LOG10
    MODULE PROCEDURE LOG10_D
  END INTERFACE
  PUBLIC LOG10

  INTERFACE LOG
    MODULE PROCEDURE LOG_D
  END INTERFACE
  PUBLIC LOG

  INTERFACE MAX
    MODULE PROCEDURE MAX_DD, MAX_DR, MAX_RD
    MODULE PROCEDURE MAX_DS, MAX_SD
  END INTERFACE
  PUBLIC MAX

  INTERFACE MIN
    MODULE PROCEDURE MIN_DD, MIN_DR, MIN_RD
    MODULE PROCEDURE MIN_DS, MIN_SD
  END INTERFACE
  PUBLIC MIN

  INTERFACE NINT
    MODULE PROCEDURE NINT_D
  END INTERFACE
  PUBLIC NINT

  INTERFACE SIGN
    MODULE PROCEDURE SIGN_DD, SIGN_DR, SIGN_RD
    MODULE PROCEDURE SIGN_DS, SIGN_SD
  END INTERFACE
  PUBLIC SIGN

  INTERFACE SIN
    MODULE PROCEDURE SIN_D
  END INTERFACE
  PUBLIC SIN

  INTERFACE SINH
    MODULE PROCEDURE SINH_D
  END INTERFACE
  PUBLIC SINH

  INTERFACE SQRT
    MODULE PROCEDURE SQRT_D
  END INTERFACE
  PUBLIC SQRT

  INTERFACE TAN
    MODULE PROCEDURE TAN_D
  END INTERFACE
  PUBLIC TAN

  INTERFACE TANH
    MODULE PROCEDURE TANH_D
  END INTERFACE
  PUBLIC TANH

! Interfaces for double precision version

  INTERFACE DABS
    MODULE PROCEDURE ABS_D
  END INTERFACE
  PUBLIC DABS

  INTERFACE DACOS
    MODULE PROCEDURE ACOS_D
  END INTERFACE
  PUBLIC DACOS

  INTERFACE DASIN
    MODULE PROCEDURE ASIN_D
  END INTERFACE
  PUBLIC DASIN

  INTERFACE DATAN
    MODULE PROCEDURE ATAN_D
  END INTERFACE
  PUBLIC DATAN

  INTERFACE DATAN2
    MODULE PROCEDURE ATAN2_DD, ATAN2_RD, ATAN2_DR
    MODULE PROCEDURE ATAN2_DS, ATAN2_SD
  END INTERFACE
  PUBLIC DATAN2

  INTERFACE DBLE
    MODULE PROCEDURE REAL_D
  END INTERFACE
  PUBLIC DBLE

  INTERFACE DCOS
    MODULE PROCEDURE COS_D
  END INTERFACE
  PUBLIC DCOS

  INTERFACE DCOSH
    MODULE PROCEDURE COSH_D
  END INTERFACE
  PUBLIC DCOSH

  INTERFACE DEXP
    MODULE PROCEDURE EXP_D
  END INTERFACE
  PUBLIC DEXP

  INTERFACE DINT
    MODULE PROCEDURE AINT_D
  END INTERFACE
  PUBLIC DINT

  INTERFACE DLOG10
    MODULE PROCEDURE LOG10_D
  END INTERFACE
  PUBLIC DLOG10

  INTERFACE DLOG
    MODULE PROCEDURE LOG_D
  END INTERFACE
  PUBLIC DLOG

  INTERFACE DMAX1
    MODULE PROCEDURE MAX_DD, MAX_DR, MAX_RD
    MODULE PROCEDURE MAX_DS, MAX_SD
  END INTERFACE
  PUBLIC DMAX1

  INTERFACE DMIN1
    MODULE PROCEDURE MIN_DD, MIN_DR, MIN_RD
    MODULE PROCEDURE MIN_DS, MIN_SD
  END INTERFACE
  PUBLIC DMIN1

  INTERFACE DNINT
    MODULE PROCEDURE ANINT_D
  END INTERFACE
  PUBLIC DNINT

  INTERFACE DSIGN
    MODULE PROCEDURE SIGN_DD, SIGN_DR, SIGN_RD
    MODULE PROCEDURE SIGN_DS, SIGN_SD
  END INTERFACE
  PUBLIC DSIGN

  INTERFACE DSIN
    MODULE PROCEDURE SIN_D
  END INTERFACE
  PUBLIC DSIN

  INTERFACE DSINH
    MODULE PROCEDURE SINH_D
  END INTERFACE
  PUBLIC DSINH

  INTERFACE DSQRT
    MODULE PROCEDURE SQRT_D
  END INTERFACE
  PUBLIC DSQRT

  INTERFACE DTAN
    MODULE PROCEDURE TAN_D
  END INTERFACE
  PUBLIC DTAN

  INTERFACE DTANH
    MODULE PROCEDURE TANH_D
  END INTERFACE
  PUBLIC DTANH

  INTERFACE IDINT
    MODULE PROCEDURE INT_D
  END INTERFACE
  PUBLIC IDINT

  INTERFACE IDNINT
    MODULE PROCEDURE NINT_D
  END INTERFACE
  PUBLIC IDNINT


CONTAINS

  FUNCTION ABS_D(A)
! Abs
    TYPE (AD02_REAL) :: ABS_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    REAL (WP), ALLOCATABLE :: DERF(:)
    DATA => A%DATA
! Check for undefined variable input
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(ABS_D,A,'ABS')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(ABS_D,A,'ABS')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VA = DATA%RHEAP(DATA%RPTR(A%P))
      DERF(0) = ABS(VA)
! Check for ABS(0)
      IF (ABS(VA)==0.0_WP) THEN
! Send warning message and give DERF(1) a random number in the range (-1,1)
        CALL ERROR_HANDLER(DATA,ABS_WARN)
        CALL RANDOM_NUMBER(DERF(1))
        DERF(1) = (DERF(1)-0.5_WP)*2.0_WP
      ELSE
        DERF(1) = SIGN(1.0_WP,VA)
      END IF
      DERF(2:DATA%LEVEL) = 0.0_WP
      CALL UNARY(A,ABS_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION ABS_D

  FUNCTION ACOS_D(X)
! Acos
    TYPE (AD02_REAL) :: ACOS_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I, N
    REAL (WP) VG, Z, ZH, T
    REAL (WP), ALLOCATABLE :: COEFF(:), NCOEFF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    REAL (WP), ALLOCATABLE :: DERF(:)
    DATA => X%DATA
! Check for undefined variable input
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ACOS_D,X,'ACOS')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ACOS_D,X,'ACOS')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      ALLOCATE(COEFF(DATA%LEVEL+1),NCOEFF(DATA%LEVEL+1))
      VG = DATA%RHEAP(DATA%RPTR(X%P))
! Calculate the derivative array DERF at VG
      DERF(0) = ACOS(VG)
      Z = (1.0_WP-VG**2)
      ZH = -1.0_WP/SQRT(Z)
      DERF(1) = ZH
      COEFF(1) = ZH
      DO N = 1, DATA%LEVEL - 1
        IF (MOD(N,2)==1) THEN
          NCOEFF(1) = COEFF(1)*N/Z
          DO I = 2, (N+1)/2 - 1
            NCOEFF(I) = COEFF(I)*(N+(I-1)*2)/Z + COEFF(I+1)*(I*2)
          END DO
          NCOEFF((N+1)/2) = COEFF((N+1)/2)*(2*N-1)/Z
        ELSE
          NCOEFF(1) = COEFF(1)
          DO I = 2, N/2
            NCOEFF(I) = COEFF(I-1)*(N+1+(I-2)*2)/Z + COEFF(I)*(I*2-1)
          END DO
          NCOEFF(N/2+1) = COEFF(N/2)*(2*N-1)/Z
        END IF
        T = 0.0_WP
        DO I = 1, N/2 + 1
          T = T + NCOEFF(I)*VG**(2*(I-1)+MOD(N,2))
          COEFF(I) = NCOEFF(I)
        END DO
        DERF(N+1) = T
      END DO
      CALL UNARY(X,ACOS_D,DERF)
      DEALLOCATE(DERF,COEFF,NCOEFF)
    END IF
  END FUNCTION ACOS_D

  FUNCTION ADD_DD(A,B)
! Add
    TYPE (AD02_REAL) :: ADD_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    INTEGER N1, N2, N3, I, J, I1, I2, I3, I4, I5, LEVEL, REAL_ST_SIZE
    INTEGER, ALLOCATABLE :: LVARS(:) ! Merged list
    INTEGER, ALLOCATABLE :: IREF1(:) ! Positions of list 1 in merged list
    INTEGER, ALLOCATABLE :: IREF2(:) ! Positions of list 2 in merged list
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    ADD_DD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(ADD_DD,A,B,'+')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(ADD_DD,A,B,'+')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(ADD_DD,A,B,'+')
    ELSE
      ADD_DD%CASE = -DATA%CASE

    LEVEL = DATA%LEVEL

    N1 = DATA%NVARS(A%P)
    N2 = DATA%NVARS(B%P)
    IF (N1==DATA%SIZE_X) THEN
      IF (N2==DATA%SIZE_X) THEN
! Add using full storage mode
      IF (A%CASE<0) THEN
! A a temporary variable
        I1 = DATA%RPTR(A%P) - 1
        I2 = DATA%RPTR(B%P) - 1
        DO I = 1, DATA%REAL_STRUCT_SIZE
          DATA%RHEAP(I1+I) = DATA%RHEAP(I1+I) + DATA%RHEAP(I2+I)
        END DO
        ADD_DD%P = A%P
        ADD_DD%CASE = -DATA%CASE
        DATA%RPTR(ADD_DD%P) = DATA%RPTR(A%P)
        CALL USED(B)
      ELSE IF (B%CASE<0) THEN
! B a temporary variable
        I1 = DATA%RPTR(A%P) - 1
        I2 = DATA%RPTR(B%P) - 1
        DO I = 1, DATA%REAL_STRUCT_SIZE
          DATA%RHEAP(I2+I) = DATA%RHEAP(I1+I) + DATA%RHEAP(I2+I)
        END DO
        ADD_DD%P = B%P
        ADD_DD%CASE = -DATA%CASE
        DATA%RPTR(ADD_DD%P) = DATA%RPTR(B%P)
      ELSE
! Both A and B permanent, require a new variable number
        CALL GETMEM(0,DATA%REAL_STRUCT_SIZE,ADD_DD)
        DATA%RHEAP => DATA%RHEAP
        DATA%RPTR => DATA%RPTR
        DO I = 0, DATA%REAL_STRUCT_SIZE-1
          DATA%RHEAP(DATA%RPTR(ADD_DD%P)+I) = &
             DATA%RHEAP(DATA%RPTR(A%P)+I) + DATA%RHEAP(DATA%RPTR(B%P)+I)
        END DO
      END IF
      RETURN
      ELSE IF (A%CASE<0 .AND. DATA%LEVEL<=2) THEN
! A a full temporary variable
        I1 = DATA%RPTR(A%P)
        I2 = DATA%RPTR(B%P)
        I3 = DATA%IPONT(B%P) - 1
        DATA%RHEAP(I1) = DATA%RHEAP(I1) + DATA%RHEAP(I2)
        DO I = 1, N2
          I4 = DATA%IHEAP(I3+I)
          I2 = I2 + 1
          DATA%RHEAP(I1+I4) = DATA%RHEAP(I1+I4) + DATA%RHEAP(I2)
        END DO
        IF(LEVEL==2)THEN
          DO I = 1, N2
            I5 = I1 + DATA%SIZE_X + (DATA%IHEAP(I3+I)*(DATA%IHEAP(I3+I)-1))/2
            DO J = 1, I
              I4 = DATA%IHEAP(I3+J)
              I2 = I2 + 1
              DATA%RHEAP(I5+I4) = DATA%RHEAP(I5+I4) + DATA%RHEAP(I2)
            END DO
          END DO
        END IF
        ADD_DD%P = A%P
        ADD_DD%CASE = -DATA%CASE
        DATA%RPTR(ADD_DD%P) = DATA%RPTR(A%P)
        CALL USED(B)
        RETURN
      ELSE
        GO TO 10
      END IF
    END IF
! Add using packed storage mode
10    I1 = DATA%IPONT(A%P)
      I2 = DATA%IPONT(B%P)
      ALLOCATE(LVARS(0:DATA%SIZE_X),IREF1(DATA%SIZE_X),IREF2(DATA%SIZE_X))
      CALL MERGE(I1,I2,N1,N2,DATA,LVARS,IREF1,IREF2)
      N3 = LVARS(0)
      REAL_ST_SIZE = DATA%IBINCO(LEVEL+N3,LEVEL)
      CALL GETMEM(N3,REAL_ST_SIZE,ADD_DD)
! Set up information block on iheap
      J = DATA%IPONT(ADD_DD%P)
      DO I = 1, N3
          DATA%IHEAP(J) = LVARS(I)
          J = J + 1
      END DO
! Calculate real derivative values
      J = DATA%RPTR(ADD_DD%P)
      DO I = 1, REAL_ST_SIZE
          DATA%RHEAP(J) = 0.0_WP
          J = J + 1
      END DO
      CALL EXPAND(IREF1(1:N1),N3,DATA)
      DO I = 1, DATA%RLENG(A%P)
        DATA%RHEAP(DATA%IHEAP(DATA%SIZE_X+I)+DATA%RPTR(ADD_DD%P)) = &
           DATA%RHEAP(DATA%RPTR(A%P)+I-1)
      END DO
      CALL EXPAND(IREF2(1:N2),N3,DATA)
      DO I = 1, DATA%RLENG(B%P)
         DATA%RHEAP(DATA%IHEAP(DATA%SIZE_X+I)+DATA%RPTR(ADD_DD%P)) = &
           DATA%RHEAP(DATA%IHEAP(DATA%SIZE_X+I)+DATA%RPTR(ADD_DD%P)) + &
           DATA%RHEAP(DATA%RPTR(B%P)+I-1)
     END DO
! Check to see if density threshold is exceeded
      IF ((N3>=DATA%SWITCH_POINT) .AND. (N3/=DATA%SIZE_X)) &
        CALL SPARSE_TO_FULL(ADD_DD)
! Finished, `use' the two arguments
      DEALLOCATE(LVARS,IREF1,IREF2)
      CALL USED(A)
      CALL USED(B)
    END IF
  END FUNCTION ADD_DD

  FUNCTION ADD_DI(A,B)
    TYPE (AD02_REAL) :: ADD_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    CALL COPY(ADD_DI,ADD_DR(A,REAL(B,WP)))
  END FUNCTION ADD_DI

  FUNCTION ADD_DR(A,B)
    TYPE (AD02_REAL) :: ADD_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    ADD_DR%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(ADD_DR,A,'+')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(ADD_DR,A,'+')
    ELSE
      ADD_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
! Alter the value of the temporary variable
        DATA%RHEAP(DATA%RPTR(A%P)) = DATA%RHEAP(DATA%RPTR(A%P)) + B
        ADD_DR%P = A%P
        ADD_DR%CASE = -DATA%CASE
      ELSE
        CALL ADD_CONST(A,B,ADD_DR)
      END IF
    END IF
  END FUNCTION ADD_DR

  FUNCTION ADD_DS(A,B)
    TYPE (AD02_REAL) :: ADD_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(ADD_DS,ADD_DR(A,REAL(B,WP)))
  END FUNCTION ADD_DS

  FUNCTION ADD_ID(A,B)
    TYPE (AD02_REAL) :: ADD_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ADD_ID,ADD_DR(B,REAL(A,WP)))
  END FUNCTION ADD_ID

  FUNCTION ADD_RD(A,B)
    TYPE (AD02_REAL) :: ADD_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ADD_RD,ADD_DR(B,A))
  END FUNCTION ADD_RD

  FUNCTION ADD_SD(A,B)
    TYPE (AD02_REAL) :: ADD_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ADD_SD,ADD_DR(B,REAL(A,WP)))
  END FUNCTION ADD_SD

  FUNCTION AINT_D(A)
! Aint
    TYPE (AD02_REAL) :: AINT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    AINT_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AINT')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AINT')
    ELSE
      AINT_D%CASE = -DATA%CASE
      VA = DATA%RHEAP(DATA%RPTR(A%P))
! Check for AINT(N), N an integer
      IF (VA==AINT(VA)) CALL ERROR_HANDLER(DATA,AINT_WARN)
      AINT_D = AINT(VA)
    END IF
  END FUNCTION AINT_D

! Anint
  FUNCTION ANINT_D(A)
    TYPE (AD02_REAL) ANINT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    ANINT_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'ANINT')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'ANINT')
    ELSE
      ANINT_D%CASE = -DATA%CASE
      VA = DATA%RHEAP(DATA%RPTR(A%P))
! Check for ANINT(N + 0.5), where N is an integer
      IF (ABS(VA-AINT(VA))*2.0_WP==1.0_WP) CALL ERROR_HANDLER(DATA,ANINT_WARN)
      ANINT_D = ANINT(VA)
    END IF
  END FUNCTION ANINT_D

  FUNCTION ASIN_D(X)
! Asin
    TYPE (AD02_REAL) :: ASIN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I, N
    REAL (WP) VG, Z, ZH, T
    REAL (WP),ALLOCATABLE :: COEFF(:), NCOEFF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    REAL (WP), ALLOCATABLE :: DERF(:)
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ASIN_D,X,'ASIN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ASIN_D,X,'ASIN')
    ELSE
    ALLOCATE(COEFF(DATA%LEVEL+1),NCOEFF(DATA%LEVEL+1))
    ALLOCATE(DERF(0:DATA%LEVEL+4))
    VG = DATA%RHEAP(DATA%RPTR(X%P))
! Calculate the derivative array DERF at VG
    DERF(0) = ASIN(VG)
    Z = (1.0_WP-VG**2)
    ZH = 1.0_WP/SQRT(Z)
    DERF(1) = ZH
    COEFF(1) = ZH
    DO N = 1, DATA%LEVEL - 1
      IF (MOD(N,2)==1) THEN
        NCOEFF(1) = COEFF(1)*N/Z
        DO I = 2, (N+1)/2 - 1
          NCOEFF(I) = COEFF(I)*(N+(I-1)*2)/Z + COEFF(I+1)*(I*2)
        END DO
        NCOEFF((N+1)/2) = COEFF((N+1)/2)*(2*N-1)/Z
      ELSE
        NCOEFF(1) = COEFF(1)
        DO I = 2, N/2
          NCOEFF(I) = COEFF(I-1)*(N+1+(I-2)*2)/Z + COEFF(I)*(I*2-1)
        END DO
        NCOEFF(N/2+1) = COEFF(N/2)*(2*N-1)/Z
      END IF
      T = 0.0_WP
      DO I = 1, N/2 + 1
        T = T + NCOEFF(I)*VG**(2*(I-1)+MOD(N,2))
        COEFF(I) = NCOEFF(I)
      END DO
      DERF(N+1) = T
    END DO
    CALL UNARY(X,ASIN_D,DERF)
    DEALLOCATE(DERF)
    END IF
  END FUNCTION ASIN_D

  SUBROUTINE ASSIGN_DD(A,B)
! Assignment. Note that assignment of a structure to a real is not
! provided since this is likely to be an error.
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    INTEGER I,J,NI, NR
    LOGICAL :: OVERWRITE ! True if old value of A is to be overwritten
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA

! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(A,B,'Assign')
      RETURN
    ELSE IF (DATA%CASE/=ABS(B%CASE) ) THEN
      CALL UNARY_WARNING(A,B,'Assign')
      RETURN
    END IF

    IF (A%P==-1) THEN
       OVERWRITE = .FALSE.
    ELSE IF (.NOT. ASSOCIATED(A%DATA,DATA)) THEN
       OVERWRITE = .FALSE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
       OVERWRITE = .FALSE.
    ELSE
       OVERWRITE = .TRUE.
    END IF

    IF (B%CASE<0) THEN
! B temporary
      IF (OVERWRITE) THEN
        DATA%IPONT(A%P) = DATA%DEAD_POINTER
        DATA%DEAD_POINTER = A%P
      END IF
      A%P = B%P
      A%CASE = DATA%CASE
      A%DATA => DATA
      RETURN
    END IF

    IF (.NOT.OVERWRITE) THEN
      A%DATA => DATA
      IF (DATA%DEAD_POINTER==-1) THEN
! Stack of dead variable numbers empty. Require new storage.
        IF (DATA%IPTOS>SIZE(DATA%IPONT)) CALL MORE_MEMORY(DATA)
        A%P = DATA%IPTOS
        DATA%IPTOS = DATA%IPTOS + 1
       ELSE
! Take variable number from the top of the stack of dead variable numbers
        A%P = DATA%DEAD_POINTER
        DATA%DEAD_POINTER = DATA%IPONT(DATA%DEAD_POINTER)
      END IF
    END IF

    A%CASE = DATA%CASE
    NI = DATA%NVARS(B%P)
    NR = DATA%RLENG(B%P)
    IF (NR+DATA%IRTOS>SIZE(DATA%RHEAP)) THEN
! Require more memory on DATA%RHEAP
      CALL GC(0,NR,DATA)
      IF (DATA%CASE==0) RETURN
    END IF
! Copy the required information from variable structure A to
! variable structure B
    DATA%RLENG(A%P) = NR
    DATA%NVARS(A%P) = NI
    DATA%IPONT(A%P) = 1
    DATA%RPTR(A%P) = DATA%IRTOS
    J =  DATA%RPTR(B%P)
    DO I = 1, NR
       DATA%RHEAP(DATA%IRTOS+I-1) = DATA%RHEAP(J)
       J = J + 1
    END DO
    DATA%IRTOS = DATA%IRTOS + NR
    IF (NI/=DATA%SIZE_X) THEN
      IF (NI+DATA%IHTOS>SIZE(DATA%IHEAP)) THEN
        CALL GC(NI,0,DATA)
        IF (DATA%CASE==0) RETURN
      END IF
      DATA%IPONT(A%P) = DATA%IHTOS
      J =  DATA%IPONT(B%P)
      DO I = 1, NI
         DATA%IHEAP(DATA%IHTOS+I-1) = DATA%IHEAP(J)
         J = J + 1
      END DO
      DATA%IHTOS = DATA%IHTOS + NI
    END IF
  END SUBROUTINE ASSIGN_DD

  SUBROUTINE ASSIGN_DD1(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:)
    CALL ERROR_HANDLER(B(1)%DATA,ASSIGNMENT_WARN)
    CALL AD02_UNDEFINE(A,B(1)%DATA)
  END SUBROUTINE ASSIGN_DD1

  SUBROUTINE ASSIGN_DD10(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
    CALL AD02_UNDEFINE(A,B%DATA)
  END SUBROUTINE ASSIGN_DD10

  SUBROUTINE ASSIGN_DD2(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:)
    CALL AD02_UNDEFINE(A,B(1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD2

  SUBROUTINE ASSIGN_DD20(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD20

  SUBROUTINE ASSIGN_DD3(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD3

  SUBROUTINE ASSIGN_DD30(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD30

  SUBROUTINE ASSIGN_DD4(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD4

  SUBROUTINE ASSIGN_DD40(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD40

  SUBROUTINE ASSIGN_DD5(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD5

  SUBROUTINE ASSIGN_DD50(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD50

  SUBROUTINE ASSIGN_DD6(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD6

  SUBROUTINE ASSIGN_DD60(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD60

  SUBROUTINE ASSIGN_DD7(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD7

  SUBROUTINE ASSIGN_DD70(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    A%P = -1
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD70

  SUBROUTINE ASSIGN_DI(A,B)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF(.NOT.ASSOCIATED(DATA))THEN
      CALL AD02_UNDEFINE(A)
      ! ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      !   CALL AD02_UNDEFINE(A)
    ELSE
      A = DERIVS(B,DATA)
    END IF
  END SUBROUTINE ASSIGN_DI

  SUBROUTINE ASSIGN_DR(A,B)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF(.NOT.ASSOCIATED(DATA))THEN
      CALL AD02_UNDEFINE(A)
    !   ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
    !     CALL AD02_UNDEFINE(A)
    ELSE
      A = DERIVS(B,DATA)
    END IF
  END SUBROUTINE ASSIGN_DR

  SUBROUTINE ASSIGN_DS(A,B)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    REAL, INTENT (IN) :: B
    CALL ASSIGN_DR(A,REAL(B,WP))
  END SUBROUTINE ASSIGN_DS

  SUBROUTINE ASSIGN_ID(A,B)
    INTEGER, INTENT (OUT) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'Assign')
      A = 0
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'Assign')
      A = 0
    ELSE
      A = INT(DATA%RHEAP(DATA%RPTR(B%P)))
      CALL USED(B)
    END IF
  END SUBROUTINE ASSIGN_ID

  FUNCTION ATAN_D(X)
! Atan
    TYPE (AD02_REAL) :: ATAN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG, VD1
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ATAN_D,X,'ATAN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ATAN_D,X,'ATAN')
    ELSE
      VG = DATA%RHEAP(DATA%RPTR(X%P))
      ALLOCATE(DERF(0:DATA%LEVEL+4))
! Calculate the derivative array DERF at VG
      DERF(0) = ATAN(VG)
      VD1 = 1.0_WP/(1.0_WP+VG*VG)
      DERF(1) = VD1
      DERF(2) = -2.0_WP*VG*VD1*VD1
      DO I = 3, DATA%LEVEL
        DERF(I) = -I*VD1*((I-1)*DERF(I-2)+2.0_WP*VG*DERF(I-1))
      END DO
      CALL UNARY(X,ATAN_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION ATAN_D

! Atan2

  FUNCTION ATAN2_DD(Y,X)
    TYPE (AD02_REAL) :: ATAN2_DD
    TYPE (AD02_REAL), INTENT (IN) :: Y, X
    REAL (WP) VY, VX
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1 .OR. Y%P==-1) THEN
      CALL BINARY_WARNING(ATAN2_DD,X,Y,'ATAN2')
    ELSE IF (.NOT.ASSOCIATED(DATA,Y%DATA)) THEN
      CALL BINARY_WARNING(ATAN2_DD,X,Y,'ATAN2')
    ELSE IF (DATA%CASE/=ABS(X%CASE) .OR.DATA%CASE/=ABS(Y%CASE) ) THEN
      CALL BINARY_WARNING(ATAN2_DD,X,Y,'ATAN2')
    ELSE
      ATAN2_DD%CASE = -DATA%CASE
      VY = DATA%RHEAP(DATA%RPTR(Y%P))
      VX = DATA%RHEAP(DATA%RPTR(X%P))
      IF (ABS(VX)>ABS(VY)) THEN
        CALL COPY(ATAN2_DD,ATAN(Y/X))
      ELSE
        CALL COPY(ATAN2_DD,-ATAN(X/Y))
      END IF
      DATA%RHEAP(DATA%RPTR(ATAN2_DD%P)) = ATAN2(VY,VX)
    END IF
  END FUNCTION ATAN2_DD

  FUNCTION ATAN2_DR(Y,X)
    TYPE (AD02_REAL) :: ATAN2_DR
    TYPE (AD02_REAL), INTENT (IN) :: Y
    REAL (WP), INTENT (IN) :: X
    REAL (WP) VY
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => Y%DATA
! Check for undefined variable input and if an error has occured
    IF (Y%P==-1) THEN
      CALL UNARY_WARNING(ATAN2_DR,Y,'ATAN2')
    ELSE IF (DATA%CASE/=ABS(Y%CASE)) THEN
      CALL UNARY_WARNING(ATAN2_DR,Y,'ATAN2')
    ELSE
      VY = DATA%RHEAP(DATA%RPTR(Y%P))
      IF (ABS(X)>ABS(VY)) THEN
        CALL COPY(ATAN2_DR,ATAN(Y/X))
      ELSE
        CALL COPY(ATAN2_DR,-ATAN(X/Y))
      END IF
      DATA%RHEAP(DATA%RPTR(ATAN2_DR%P)) = ATAN2(VY,X)
    END IF
  END FUNCTION ATAN2_DR

  FUNCTION ATAN2_DS(A,B)
    TYPE (AD02_REAL) :: ATAN2_DS
    REAL, INTENT (IN) :: B
    TYPE (AD02_REAL), INTENT (IN) :: A
    CALL COPY(ATAN2_DS,ATAN2_DR(A,REAL(B,WP)))
  END FUNCTION ATAN2_DS

  FUNCTION ATAN2_RD(Y,X)
    TYPE (AD02_REAL) :: ATAN2_RD
    REAL (WP), INTENT (IN) :: Y
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VX
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ATAN2_RD,X,'ATAN2')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ATAN2_RD,X,'ATAN2')
    ELSE
      VX = DATA%RHEAP(DATA%RPTR(X%P))
      IF (ABS(VX)>ABS(Y)) THEN
        CALL COPY(ATAN2_RD,ATAN(Y/X))
      ELSE
        CALL COPY(ATAN2_RD,-ATAN(X/Y))
      END IF
      DATA%RHEAP(DATA%RPTR(ATAN2_RD%P)) = ATAN2(Y,VX)
    END IF
  END FUNCTION ATAN2_RD

  FUNCTION ATAN2_SD(A,B)
    TYPE (AD02_REAL) :: ATAN2_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ATAN2_SD,ATAN2_RD(REAL(A,WP),B))
  END FUNCTION ATAN2_SD


! Cos
  FUNCTION COS_D(X)
    TYPE (AD02_REAL) :: COS_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG, VS, VC
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(COS_D,X,'COS')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(COS_D,X,'COS')
    ELSE
      VG = DATA%RHEAP(DATA%RPTR(X%P))
      ALLOCATE(DERF(0:DATA%LEVEL+4))
! Calculate the derivative array DERF at VG
      VS = SIN(VG)
      VC = COS(VG)
      DO I = 0, DATA%LEVEL, 4
        DERF(I) = VC
        DERF(I+1) = -VS
        DERF(I+2) = -VC
        DERF(I+3) = VS
      END DO
      CALL UNARY(X,COS_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION COS_D

! Cosh
  FUNCTION COSH_D(X)
    TYPE (AD02_REAL) :: COSH_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG, VS, VC
    TYPE(AD02_DATA), POINTER :: DATA
    REAL (WP), ALLOCATABLE :: DERF(:)
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(COSH_D,X,'COSH')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(COSH_D,X,'COSH')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VG = DATA%RHEAP(DATA%RPTR(X%P))
! Calculate the derivative array DERF at VG
      VS = SINH(VG)
      VC = COSH(VG)
      DO I = 0, DATA%LEVEL, 2
        DERF(I) = VC
        DERF(I+1) = VS
      END DO
      CALL UNARY(X,COSH_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION COSH_D

! Divide
  FUNCTION DIV_DD(A,B)
    TYPE (AD02_REAL) :: DIV_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    INTEGER I, IR, I1, I2, I3, LEVEL,N(3), P(3), PR, L2, LAMBDA, R, J, INDEX
    INTEGER PB2, PBASE2, PBASE3, INDEX_A, INDEX_B, INDEX_C
    REAL (WP) VG
    INTEGER, ALLOCATABLE :: LVARS(:) ! Merged list
    INTEGER, ALLOCATABLE :: IREF1(:) ! Positions of list 1 in merged list
    INTEGER, ALLOCATABLE :: IREF2(:) ! Positions of list 2 in merged list
    INTEGER, ALLOCATABLE :: INV_IREF2(:)
    INTEGER, ALLOCATABLE :: MI(:,:)
    LOGICAL, ALLOCATABLE :: A_PRES(:), B_PRES(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    DIV_DD%DATA => DATA

! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(DIV_DD,A,B,'/')
      RETURN
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(DIV_DD,A,B,'/')
      RETURN
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE) ) THEN
      CALL BINARY_WARNING(DIV_DD,A,B,'/')
      RETURN
    END IF
    DIV_DD%CASE = -DATA%CASE
    DATA%IHEAP => DATA%IHEAP
    LEVEL = DATA%LEVEL
    N(1) = DATA%NVARS(A%P)
    N(2) = DATA%NVARS(B%P)
    IF ((N(1)==DATA%SIZE_X) .AND. (N(2)==DATA%SIZE_X)) THEN
      CALL GETMEM(0,DATA%REAL_STRUCT_SIZE,DIV_DD)

      SELECT CASE (LEVEL)
      CASE (0)
! Function value
        DATA%RHEAP(DATA%RPTR(DIV_DD%P)) = &
           DATA%RHEAP(DATA%RPTR(A%P))/DATA%RHEAP(DATA%RPTR(B%P))
      CASE (1)
! Function value
        DATA%RHEAP(DATA%RPTR(DIV_DD%P)) = &
           DATA%RHEAP(DATA%RPTR(A%P))/DATA%RHEAP(DATA%RPTR(B%P))
! First derivatives
        DATA%RHEAP(DATA%RPTR(DIV_DD%P)+1:DATA%RPTR(DIV_DD%P)+DATA%SIZE_X) = &
           (DATA%RHEAP(DATA%RPTR(B%P))*&
           DATA%RHEAP(DATA%RPTR(A%P)+1:DATA%RPTR(A%P)+DATA%SIZE_X)-&
           DATA%RHEAP(DATA%RPTR( &
           A%P))*DATA%RHEAP(DATA%RPTR(B%P)+1:DATA%RPTR(B%P)+DATA%SIZE_X))/ &
           (DATA%RHEAP(DATA%RPTR(B%P))*DATA%RHEAP(DATA%RPTR(B%P)))
      CASE (2)
! Function value
        DATA%RHEAP(DATA%RPTR(DIV_DD%P)) = &
           DATA%RHEAP(DATA%RPTR(A%P))/DATA%RHEAP(DATA%RPTR(B%P))
! First derivatives
        DATA%RHEAP(DATA%RPTR(DIV_DD%P)+1:DATA%RPTR(DIV_DD%P)+DATA%SIZE_X) = &
          (DATA%RHEAP(DATA%RPTR( &
          B%P))*DATA%RHEAP(DATA%RPTR(A%P)+1:DATA%RPTR(A%P)+DATA%SIZE_X)-&
          DATA%RHEAP(DATA%RPTR( &
          A%P))*DATA%RHEAP(DATA%RPTR(B%P)+1:DATA%RPTR(B%P)+DATA%SIZE_X))/ &
          (DATA%RHEAP(DATA%RPTR(B%P))*DATA%RHEAP(DATA%RPTR(B%P)))
! Second derivatives
        INDEX = DATA%SIZE_X
        DO I = 1, DATA%SIZE_X
!       Calculate non-diagonal elements of hessian
          DO J = 1, I - 1
            INDEX = INDEX + 1
            DATA%RHEAP(DATA%RPTR(DIV_DD%P)+INDEX) = &
            (DATA%RHEAP(DATA%RPTR(A%P)+INDEX)-DATA%RHEAP(DATA%RPTR( &
             DIV_DD%P))*DATA%RHEAP(DATA%RPTR(B%P)+INDEX)-DATA%RHEAP(DATA%RPTR( &
             DIV_DD%P)+J)*DATA%RHEAP(DATA%RPTR(B%P)+I)-DATA%RHEAP(DATA%RPTR( &
             DIV_DD%P)+I)*DATA%RHEAP(DATA%RPTR(B%P)+J))/&
             DATA%RHEAP(DATA%RPTR(B%P))
          END DO
          INDEX = INDEX + 1
!       Calculate diagonal element of hessian
          DATA%RHEAP(DATA%RPTR(DIV_DD%P)+INDEX) = &
            (DATA%RHEAP(DATA%RPTR(A%P)+INDEX)-DATA%RHEAP(DATA%RPTR( &
            DIV_DD%P))*DATA%RHEAP(DATA%RPTR(B%P)+INDEX)-DATA%RHEAP(DATA%RPTR( &
            DIV_DD%P)+I)*DATA%RHEAP(DATA%RPTR(B%P)+I))/&
            DATA%RHEAP(DATA%RPTR(B%P))
        END DO
      CASE DEFAULT
        ALLOCATE(MI(0:DATA%LEVEL+1,4))
! set up information block on iheap
        P(1) = DATA%RPTR(A%P)
        P(2) = DATA%RPTR(B%P)
        P(3) = DATA%RPTR(DIV_DD%P)
        L2 = DATA%REAL_STRUCT_SIZE
! Set result to zero
        DATA%RHEAP(P(3):P(3)+L2-1) = 0.0_WP
        VG = DATA%RHEAP(P(2))
! add on f contributions
        MI(0,1) = 0
        DO I = 0, DATA%REAL_STRUCT_SIZE - 1
          DATA%RHEAP(P(3)+I) = DATA%RHEAP(P(1)+I)/VG
        END DO

! Now main loop
        PB2 = P(2) + 1
        DO LAMBDA = 1, LEVEL
          PBASE2 = PB2
          PBASE3 = P(3)

! create a multi-index of order 0 (to point into the result h)
          MI(0,3) = 0

          DO R = 0, LAMBDA - 1

            DO I3 = 0, DATA%IBINCO(R+DATA%SIZE_X-1,R) - 1
! create a multi-index of order LAMBDA-R (to point into g)
              MI(0,2) = LAMBDA - R
              DO I = 1, LAMBDA - R
                MI(I,2) = 1
              END DO

! loop over elements of g
              DO I2 = 0, DATA%IBINCO(LAMBDA-R+DATA%SIZE_X-1,LAMBDA-R) - 1
                CALL MIMERU(MI(1:MI(0,3),3),MI(1:MI(0,2),2),MI(0:LEVEL+1,4))
                PR = IRPOS(MI(0:LEVEL+1,4),DATA%SIZE_X,DATA) + P(3)
                DATA%RHEAP(PR) = DATA%RHEAP(PR) - &
                   DATA%RHEAP(PBASE2+I2)*DATA%RHEAP(PBASE3+I3)/VG
                CALL MIINC(LEVEL,MI(0:LEVEL+1,2),DATA%SIZE_X)
              END DO
              CALL MIINC(LEVEL,MI(0:LEVEL+1,3),DATA%SIZE_X)
            END DO

            PBASE3 = PBASE3 + DATA%IBINCO(R+DATA%SIZE_X-1,R)
            PBASE2 = PBASE2 - DATA%IBINCO(LAMBDA-R-2+DATA%SIZE_X,LAMBDA-R-1)
          END DO
          PB2 = PB2 + DATA%IBINCO(LAMBDA+DATA%SIZE_X-1,LAMBDA)
        END DO
        DEALLOCATE(MI)
      END SELECT

    ELSE
      ALLOCATE(LVARS(0:DATA%SIZE_X),IREF1(DATA%SIZE_X),IREF2(DATA%SIZE_X))
      I1 = DATA%IPONT(A%P)
      I2 = DATA%IPONT(B%P)
      CALL MERGE(I1,I2,N(1),N(2),DATA,LVARS,IREF1,IREF2)
      N(3) = LVARS(0)
      CALL GETMEM(N(3),DATA%IBINCO(LEVEL+N(3),LEVEL),DIV_DD)
! set up information block on iheap
      IR = DATA%IPONT(DIV_DD%P)
      DO I = 0, N(3) - 1
        DATA%IHEAP(IR+I) = LVARS(I+1)
      END DO
      P(1) = DATA%RPTR(A%P)
      P(2) = DATA%RPTR(B%P)
      P(3) = DATA%RPTR(DIV_DD%P)
      L2 = DATA%RLENG(B%P)
! Set result to zero
      DATA%RHEAP(P(3):P(3)+DATA%RLENG(DIV_DD%P)-1) = 0.0_WP
      VG = DATA%RHEAP(P(2))

      SELECT CASE (LEVEL)
      CASE (0)
! Function value
        DATA%RHEAP(P(3)) = DATA%RHEAP(P(1))/VG
      CASE (1)
! Function value
        DATA%RHEAP(P(3)) = DATA%RHEAP(P(1))/VG
! First derivatives
        DO I = 1, N(1)
          DATA%RHEAP(P(3)+IREF1(I)) = VG*DATA%RHEAP(P(1)+I)
        END DO
        DO I = 1, N(2)
          DATA%RHEAP(P(3)+IREF2(I)) = DATA%RHEAP(P(3)+IREF2(I)) - &
            DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+I)
        END DO
        DATA%RHEAP(P(3)+1:P(3)+N(3)) = DATA%RHEAP(P(3)+1:P(3)+N(3))/(VG*VG)
      CASE (2)
        ALLOCATE (INV_IREF2(DATA%SIZE_X),A_PRES(DATA%SIZE_X),&
                 B_PRES(DATA%SIZE_X))
        A_PRES = .FALSE.
        DO I = 1, N(1)
          A_PRES(IREF1(I)) = .TRUE.
        END DO
        B_PRES = .FALSE.
        DO I = 1, N(2)
          B_PRES(IREF2(I)) = .TRUE.
          INV_IREF2(IREF2(I)) = I
        END DO
! Function value
        DATA%RHEAP(P(3)) = DATA%RHEAP(P(1))/VG
! First derivatives
        DO I = 1, N(1)
          DATA%RHEAP(P(3)+IREF1(I)) = VG*DATA%RHEAP(P(1)+I)
        END DO
        DO I = 1, N(2)
          DATA%RHEAP(P(3)+IREF2(I)) = DATA%RHEAP(P(3)+IREF2(I)) - &
            DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+I)
        END DO
        DATA%RHEAP(P(3)+1:P(3)+N(3)) = DATA%RHEAP(P(3)+1:P(3)+N(3))/(VG*VG)

! Second derivatives
        INDEX_A = 1 + N(1)
        INDEX_B = 1 + N(2)
        INDEX_C = 1 + N(3)

        DO I = 1, N(3)
!       Calculate non-diagonal elements of hessian
          DO J = 1, I - 1
            DATA%RHEAP(P(3)+INDEX_C) = 0.0_WP
            IF ((A_PRES(I)) .AND. (A_PRES(J))) THEN
              DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                 DATA%RHEAP(P(1)+INDEX_A)
              IF (B_PRES(I)) THEN
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) - &
                  DATA%RHEAP(P(3)+J)*DATA%RHEAP(P(2)+INV_IREF2(I))
                IF (B_PRES(J)) THEN
                  DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) - &
                    DATA%RHEAP(P(3))*DATA%RHEAP(P(2)+INDEX_B) - &
                    DATA%RHEAP(P(3)+I)*DATA%RHEAP(P(2)+INV_IREF2(J))
                  INDEX_B = INDEX_B + 1
                END IF
              ELSE IF (B_PRES(J)) THEN
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) - &
                  DATA%RHEAP(P(3)+I)*DATA%RHEAP(P(2)+INV_IREF2(J))
              END IF
              INDEX_A = INDEX_A + 1
            ELSE
              IF (B_PRES(J)) THEN
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) - &
                  DATA%RHEAP(P(3)+I)*DATA%RHEAP(P(2)+INV_IREF2(J))
                IF (B_PRES(I)) THEN
                  DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) - &
                    DATA%RHEAP(P(3))*DATA%RHEAP(P(2)+INDEX_B) - &
                    DATA%RHEAP(P(3)+J)*DATA%RHEAP(P(2)+INV_IREF2(I))
                  INDEX_B = INDEX_B + 1
                END IF
              ELSE
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) - &
                  DATA%RHEAP(P(3)+J)*DATA%RHEAP(P(2)+INV_IREF2(I))
              END IF
            END IF
            DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C)/VG
            INDEX_C = INDEX_C + 1
          END DO
!       Calculate diagonal element of hessian
          IF (A_PRES(I)) THEN
            IF (B_PRES(I)) THEN
              DATA%RHEAP(P(3)+INDEX_C) = (DATA%RHEAP(P(1)+INDEX_A)-&
                DATA%RHEAP(P(2)+INDEX_B)*DATA%RHEAP(P(3))-DATA%RHEAP(P(3)+I)&
                *DATA%RHEAP(P(2)+INV_IREF2(I)))/VG
              INDEX_A = INDEX_A + 1
              INDEX_B = INDEX_B + 1
            ELSE
              DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(1)+INDEX_A)/VG
              INDEX_A = INDEX_A + 1
            END IF
          ELSE
            DATA%RHEAP(P(3)+INDEX_C) = &
              -(DATA%RHEAP(P(2)+INDEX_B)*DATA%RHEAP(P(3))+DATA%RHEAP(P(3) &
              +I)*DATA%RHEAP(P(2)+INV_IREF2(I)))/VG
            INDEX_B = INDEX_B + 1
          END IF
          INDEX_C = INDEX_C + 1
        END DO
        DEALLOCATE(INV_IREF2,A_PRES, B_PRES)

      CASE DEFAULT
        ALLOCATE(MI(0:DATA%LEVEL+1,4))

! add on f contributions
        MI(0,1) = 0

        DO I = 0, DATA%RLENG(A%P) - 1
          PR = IRPOS2(MI(0:LEVEL+1,1),N(3),IREF1,DATA) + P(3)
          DATA%RHEAP(PR) = DATA%RHEAP(P(1)+I)/VG
          CALL MIINC(LEVEL,MI(0:LEVEL+1,1),N(1))
        END DO

! Now main loop
        PB2 = P(2) + 1

        DO LAMBDA = 1, LEVEL
          PBASE2 = PB2
          PBASE3 = P(3) + 0

! create a multi-index of order 0 (to point into the result h)
          MI(0,3) = 0

          DO R = 0, LAMBDA - 1
            DO I3 = 0, DATA%IBINCO(R+N(3)-1,R) - 1
! create a multi-index of order LAMBDA-R (to point into g)
              MI(0,2) = LAMBDA - R

              DO I = 1, LAMBDA - R
                MI(I,2) = 1
              END DO

! loop over elements of g
              DO I2 = 0, DATA%IBINCO(LAMBDA-R+N(2)-1,LAMBDA-R) - 1

                CALL MIMERU &
                    (MI(1:MI(0,3),3),IREF2(MI(1:MI(0,2),2)),MI(0:LEVEL+1,4))
                PR = IRPOS(MI(0:LEVEL+1,4),N(3),DATA) + P(3)
                DATA%RHEAP(PR) = DATA%RHEAP(PR) - &
                  DATA%RHEAP(PBASE2+I2)*DATA%RHEAP(PBASE3+I3)/VG
                CALL MIINC(LEVEL,MI(0:LEVEL+1,2),N(2))
              END DO

              CALL MIINC(LEVEL,MI(0:LEVEL+1,3),N(3))
            END DO
            PBASE3 = PBASE3 + DATA%IBINCO(R+N(3)-1,R)
            PBASE2 = PBASE2 - DATA%IBINCO(LAMBDA-R-2+N(2),LAMBDA-R-1)
          END DO
          PB2 = PB2 + DATA%IBINCO(LAMBDA+N(2)-1,LAMBDA)
        END DO
        DEALLOCATE(MI)
      END SELECT
      DEALLOCATE(LVARS,IREF1,IREF2)

! Test to see if output variable exceeds the density threshold
      IF ((DATA%NVARS(DIV_DD%P)>=DATA%SWITCH_POINT) .AND. (DATA%NVARS( &
        DIV_DD%P)/=DATA%SIZE_X)) &
        CALL SPARSE_TO_FULL(DIV_DD)
    END IF
    CALL USED(A)
    CALL USED(B)
  END FUNCTION DIV_DD

  FUNCTION DIV_DI(A,B)
    TYPE (AD02_REAL) :: DIV_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
      CALL COPY(DIV_DI,DIV_DR(A,REAL(B,WP)))
  END FUNCTION DIV_DI

  FUNCTION DIV_DR(A,B)
    TYPE (AD02_REAL) :: DIV_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    INTEGER I, NV, RL, IP1, IP2
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    DIV_DR%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(DIV_DR,A,'/')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(DIV_DR,A,'/')
    ELSE
      DIV_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
        DIV_DR%P = A%P
        DIV_DR%CASE = -DATA%CASE
        DO I = 1, DATA%RLENG(A%P)
          DATA%RHEAP(DATA%RPTR(A%P)+I-1) = DATA%RHEAP(DATA%RPTR(A%P)+I-1)/B
        END DO
      ELSE
        NV = DATA%NVARS(A%P)
        RL = DATA%RLENG(A%P)
        IF (NV/=DATA%SIZE_X) THEN
          CALL GETMEM(NV,RL,DIV_DR)
          IP1 = DATA%IPONT(A%P)
          IP2 = DATA%IPONT(DIV_DR%P)
! Set up information on iheap
          DATA%IHEAP(IP2:IP2+NV-1) = DATA%IHEAP(IP1:IP1+NV-1)
        ELSE
          CALL GETMEM(0,RL,DIV_DR)
        END IF
! Calculate results
        DATA%RHEAP(DATA%RPTR(DIV_DR%P):DATA%RPTR(DIV_DR%P)+RL-1) = &
           DATA%RHEAP(DATA%RPTR(A%P):DATA%RPTR(A%P)+RL-1)/B
        CALL USED(A)
      END IF
    END IF
  END FUNCTION DIV_DR

  FUNCTION DIV_DS(A,B)
    TYPE (AD02_REAL) :: DIV_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(DIV_DS,DIV_DR(A,REAL(B,WP)))
  END FUNCTION DIV_DS

  FUNCTION DIV_ID(A,B)
    TYPE (AD02_REAL) :: DIV_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(DIV_ID,DIV_RD(REAL(A,WP),B))
  END FUNCTION DIV_ID

  FUNCTION DIV_RD(A,B)
    TYPE (AD02_REAL) :: DIV_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL (WP) RV
    INTEGER I
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    DIV_RD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(DIV_RD,B,'/')
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(DIV_RD,B,'/')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      RV = 1.0_WP/DATA%RHEAP(DATA%RPTR(B%P))
! Calculate the derivative array DERF
      DERF(0) = A*RV
      DO I = 1, DATA%LEVEL
        DERF(I) = -(DERF(I-1)*RV*I)
      END DO
      CALL UNARY(B,DIV_RD,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION DIV_RD

  FUNCTION DIV_SD(A,B)
    TYPE (AD02_REAL) :: DIV_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(DIV_SD,DIV_RD(REAL(A,WP),B))
  END FUNCTION DIV_SD

! .eq.
  FUNCTION EQ_DD(A,B)
    LOGICAL :: EQ_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DD = .TRUE.
    ELSE
      EQ_DD = DATA%RHEAP(DATA%RPTR(A%P)) == DATA%RHEAP(DATA%RPTR(B%P))
      IF (EQ_DD) CALL ERROR_HANDLER(DATA,EQ_WARN)
      CALL USED(A)
      CALL USED(B)
    END IF
  END FUNCTION EQ_DD

  FUNCTION EQ_DI(A,B)
    LOGICAL :: EQ_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DI = .TRUE.
    ELSE
      EQ_DI = DATA%RHEAP(DATA%RPTR(A%P)) == B
      IF (EQ_DI) CALL ERROR_HANDLER(DATA,EQ_WARN)
      CALL USED(A)
    END IF
  END FUNCTION EQ_DI

  FUNCTION EQ_DR(A,B)
    LOGICAL :: EQ_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DR = .TRUE.
    ELSE
      EQ_DR = DATA%RHEAP(DATA%RPTR(A%P)) == B
      IF (EQ_DR) CALL ERROR_HANDLER(DATA,EQ_WARN)
      CALL USED(A)
    END IF
  END FUNCTION EQ_DR

  FUNCTION EQ_DS(A,B)
    LOGICAL :: EQ_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DS = .TRUE.
    ELSE
      EQ_DS = DATA%RHEAP(DATA%RPTR(A%P)) == B
      IF (EQ_DS) CALL ERROR_HANDLER(DATA,EQ_WARN)
      CALL USED(A)
    END IF
  END FUNCTION EQ_DS

  FUNCTION EQ_ID(A,B)
    LOGICAL :: EQ_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_ID = .TRUE.
    ELSE
      EQ_ID = A == DATA%RHEAP(DATA%RPTR(B%P))
      IF (EQ_ID) CALL ERROR_HANDLER(DATA,EQ_WARN)
      CALL USED(B)
    END IF
  END FUNCTION EQ_ID

  FUNCTION EQ_RD(A,B)
    LOGICAL :: EQ_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_RD = .TRUE.
    ELSE
      EQ_RD = A == DATA%RHEAP(DATA%RPTR(B%P))
      IF (EQ_RD) CALL ERROR_HANDLER(DATA,EQ_WARN)
      CALL USED(B)
    END IF
  END FUNCTION EQ_RD

  FUNCTION EQ_SD(A,B)
    LOGICAL :: EQ_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_SD = .TRUE.
    ELSE
      EQ_SD = A == DATA%RHEAP(DATA%RPTR(B%P))
      IF (EQ_SD) CALL ERROR_HANDLER(DATA,EQ_WARN)
      CALL USED(B)
    END IF
  END FUNCTION EQ_SD

! Exp
  FUNCTION EXP_D(X)
    TYPE (AD02_REAL) :: EXP_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(EXP_D,X,'EXP')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(EXP_D,X,'EXP')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      DERF(0:DATA%LEVEL) = EXP(DATA%RHEAP(DATA%RPTR(X%P)))
      CALL UNARY(X,EXP_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION EXP_D

! .ge.
  FUNCTION GE_DD(A,B)
    LOGICAL :: GE_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
     ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DD = .TRUE.
    ELSE
          GE_DD = DATA%RHEAP(DATA%RPTR(A%P)) >= DATA%RHEAP(DATA%RPTR(B%P))
      IF (DATA%RHEAP(DATA%RPTR(A%P))==DATA%RHEAP(DATA%RPTR(B%P))) &
         CALL ERROR_HANDLER(DATA,GE_WARN)
      CALL USED(A)
      CALL USED(B)
    END IF
  END FUNCTION GE_DD

  FUNCTION GE_DI(A,B)
    LOGICAL :: GE_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_DI = .TRUE.
          GE_DI = DATA%RHEAP(DATA%RPTR(A%P)) >= B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,GE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION GE_DI

  FUNCTION GE_DR(A,B)
    LOGICAL :: GE_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_DR = .TRUE.
          GE_DR = DATA%RHEAP(DATA%RPTR(A%P)) >= B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,GE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION GE_DR

  FUNCTION GE_DS(A,B)
    LOGICAL :: GE_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_DS = .TRUE.
          GE_DS = DATA%RHEAP(DATA%RPTR(A%P)) >= B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,GE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION GE_DS

  FUNCTION GE_ID(A,B)
    LOGICAL :: GE_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_ID = .TRUE.
          GE_ID = A >= DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,GE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION GE_ID

  FUNCTION GE_RD(A,B)
    LOGICAL :: GE_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_RD = .TRUE.
          GE_RD = A >= DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,GE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION GE_RD

  FUNCTION GE_SD(A,B)
    LOGICAL :: GE_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_SD = .TRUE.
          GE_SD = A >= DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,GE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION GE_SD

! .gt.
  FUNCTION GT_DD(A,B)
    LOGICAL :: GT_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DD = .TRUE.
    ELSE IF ( DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DD = .TRUE.
    ELSE
          GT_DD = DATA%RHEAP(DATA%RPTR(A%P)) > DATA%RHEAP(DATA%RPTR(B%P))
      IF (DATA%RHEAP(DATA%RPTR(A%P))==DATA%RHEAP(DATA%RPTR(B%P))) &
         CALL ERROR_HANDLER(DATA,GT_WARN)
      CALL USED(A)
      CALL USED(B)
    END IF
  END FUNCTION GT_DD

  FUNCTION GT_DI(A,B)
    LOGICAL :: GT_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DI = .TRUE.
    ELSE
      GT_DI = DATA%RHEAP(DATA%RPTR(A%P)) > B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,GT_WARN)
      CALL USED(A)
    END IF
  END FUNCTION GT_DI

  FUNCTION GT_DR(A,B)
    LOGICAL :: GT_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DR = .TRUE.
    ELSE
          GT_DR = DATA%RHEAP(DATA%RPTR(A%P)) > B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,GT_WARN)
      CALL USED(A)
    END IF
  END FUNCTION GT_DR

  FUNCTION GT_DS(A,B)
    LOGICAL :: GT_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DS = .TRUE.
    ELSE
          GT_DS = DATA%RHEAP(DATA%RPTR(A%P)) > B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,GT_WARN)
      CALL USED(A)
    END IF
  END FUNCTION GT_DS

  FUNCTION GT_ID(A,B)
    LOGICAL :: GT_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_ID = .TRUE.
    ELSE
          GT_ID = A > DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,GT_WARN)
      CALL USED(B)
    END IF
  END FUNCTION GT_ID

  FUNCTION GT_RD(A,B)
    LOGICAL :: GT_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_RD = .TRUE.
    ELSE
          GT_RD = A > DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,GT_WARN)
      CALL USED(B)
    END IF
  END FUNCTION GT_RD

  FUNCTION GT_SD(A,B)
    LOGICAL :: GT_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_SD = .TRUE.
    ELSE
          GT_SD = A > DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,GT_WARN)
      CALL USED(B)
    END IF
  END FUNCTION GT_SD

! Int
  FUNCTION INT_D(A)
    TYPE (AD02_REAL) INT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    INT_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'INT')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'INT')
    ELSE
      VA = DATA%RHEAP(DATA%RPTR(A%P))
      IF (VA==AINT(VA)) THEN
        CALL ERROR_HANDLER(DATA,INT_WARN)
      END IF
      INT_D%CASE = -DATA%CASE
      INT_D = INT(VA)
      INT_D%CASE = -DATA%CASE
    END IF
  END FUNCTION INT_D

! Log
  FUNCTION LOG_D(X)
    TYPE (AD02_REAL) :: LOG_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(LOG_D,X,'LOG')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(LOG_D,X,'LOG')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VG = DATA%RHEAP(DATA%RPTR(X%P))
! Calculate the derivative array DERF at VG
      DERF(0) = LOG(VG)
      DERF(1) = 1.0_WP/VG
      DO I = 2, DATA%LEVEL
        DERF(I) = -DERF(I-1)*(I-1)/VG
      END DO
      CALL UNARY(X,LOG_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION LOG_D

! Log10
  FUNCTION LOG10_D(X)
    TYPE (AD02_REAL) :: LOG10_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(LOG10_D,X,'LOG10')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(LOG10_D,X,'LOG10')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VG = DATA%RHEAP(DATA%RPTR(X%P))
! Calculate the derivative array DERF at VG
      DERF(0) = LOG10(VG)
      DERF(1) = 1.0_WP/(VG*LOG(10.0_WP))
      DO I = 2, DATA%LEVEL
        DERF(I) = -DERF(I-1)*(I-1)/VG
      END DO
      CALL UNARY(X,LOG10_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION LOG10_D

! .le.
  FUNCTION LE_DD(A,B)
    LOGICAL :: LE_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE).OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DD = .TRUE.
    ELSE
          LE_DD = DATA%RHEAP(DATA%RPTR(A%P)) <= DATA%RHEAP(DATA%RPTR(B%P))
      IF (DATA%RHEAP(DATA%RPTR(A%P))==DATA%RHEAP(DATA%RPTR(B%P))) &
          CALL ERROR_HANDLER(DATA,LE_WARN)
      CALL USED(A)
      CALL USED(B)
    END IF
  END FUNCTION LE_DD

  FUNCTION LE_DI(A,B)
    LOGICAL :: LE_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DI = .TRUE.
    ELSE
          LE_DI = DATA%RHEAP(DATA%RPTR(A%P)) <= B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,LE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION LE_DI

  FUNCTION LE_DR(A,B)
    LOGICAL :: LE_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DR = .TRUE.
    ELSE
          LE_DR = DATA%RHEAP(DATA%RPTR(A%P)) <= B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,LE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION LE_DR

  FUNCTION LE_DS(A,B)
    LOGICAL :: LE_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DS = .TRUE.
    ELSE
          LE_DS = DATA%RHEAP(DATA%RPTR(A%P)) <= B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,LE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION LE_DS

  FUNCTION LE_ID(A,B)
    LOGICAL :: LE_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_ID = .TRUE.
    ELSE
          LE_ID = A <= DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,LE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION LE_ID

  FUNCTION LE_RD(A,B)
    LOGICAL :: LE_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_RD = .TRUE.
    ELSE
          LE_RD = A <= DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,LE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION LE_RD

  FUNCTION LE_SD(A,B)
    LOGICAL :: LE_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_SD = .TRUE.
    ELSE
          LE_SD = A <= DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,LE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION LE_SD

! .lt.
  FUNCTION LT_DD(A,B)
    LOGICAL :: LT_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DD = .TRUE.
    ELSE
          LT_DD = DATA%RHEAP(DATA%RPTR(A%P)) < DATA%RHEAP(DATA%RPTR(B%P))
      IF (DATA%RHEAP(DATA%RPTR(A%P))==DATA%RHEAP(DATA%RPTR(B%P)))&
          CALL ERROR_HANDLER(DATA,LT_WARN)
      CALL USED(A)
      CALL USED(B)
    END IF
  END FUNCTION LT_DD

  FUNCTION LT_DI(A,B)
    LOGICAL :: LT_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DI = .TRUE.
    ELSE
          LT_DI = DATA%RHEAP(DATA%RPTR(A%P)) < B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,LT_WARN)
      CALL USED(A)
    END IF
  END FUNCTION LT_DI

  FUNCTION LT_DR(A,B)
    LOGICAL :: LT_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
    ELSE
      LT_DR = .TRUE.
          LT_DR = DATA%RHEAP(DATA%RPTR(A%P)) < B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,LT_WARN)
      CALL USED(A)
    END IF
  END FUNCTION LT_DR

  FUNCTION LT_DS(A,B)
    LOGICAL :: LT_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
    ELSE
      LT_DS = .TRUE.
          LT_DS = DATA%RHEAP(DATA%RPTR(A%P)) < B
      IF (DATA%RHEAP(DATA%RPTR(A%P))==B) CALL ERROR_HANDLER(DATA,LT_WARN)
      CALL USED(A)
    END IF
  END FUNCTION LT_DS

  FUNCTION LT_ID(A,B)
    LOGICAL :: LT_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
 ! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_ID = .TRUE.
    ELSE
          LT_ID = A < DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,LT_WARN)
      CALL USED(B)
    END IF
  END FUNCTION LT_ID

  FUNCTION LT_RD(A,B)
    LOGICAL :: LT_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_RD = .TRUE.
    ELSE
          LT_RD = A < DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,LT_WARN)
      CALL USED(B)
    END IF
  END FUNCTION LT_RD

  FUNCTION LT_SD(A,B)
    LOGICAL :: LT_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_SD = .TRUE.
    ELSE
          LT_SD = A < DATA%RHEAP(DATA%RPTR(B%P))
      IF (A==DATA%RHEAP(DATA%RPTR(B%P))) CALL ERROR_HANDLER(DATA,LT_WARN)
      CALL USED(B)
    END IF
  END FUNCTION LT_SD

! Max
  FUNCTION MAX_DD(A1,A2)
    TYPE (AD02_REAL) :: MAX_DD
    TYPE (AD02_REAL), INTENT (IN) :: A1, A2
    REAL(WP) RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
! Check for undefined variable input and if an error has occured
    IF (A1%P==-1 .OR. A2%P==-1) THEN
      CALL BINARY_WARNING(MAX_DD,A1,A2,'MAX')
    ELSE IF (.NOT.ASSOCIATED(DATA,A2%DATA)) THEN
      CALL BINARY_WARNING(MAX_DD,A1,A2,'MAX')
    ELSE IF (DATA%CASE/=ABS(A1%CASE) .OR. DATA%CASE/=ABS(A2%CASE)) THEN
      CALL BINARY_WARNING(MAX_DD,A1,A2,'MAX')
    ELSE
    ! A1>A2
      IF (DATA%RHEAP(DATA%RPTR(A1%P))>DATA%RHEAP(DATA%RPTR(A2%P))) THEN
        IF (A1%CASE<0) THEN
          CALL COPY(MAX_DD,A1)
        ELSE
          CALL COPY(MAX_DD,REAL_D(A1))
        END IF
        CALL USED(A2)
      ELSE IF (DATA%RHEAP(DATA%RPTR(A1%P))<DATA%RHEAP(DATA%RPTR(A2%P))) THEN
! A1<A2
        IF (A2%CASE<0) THEN
          CALL COPY(MAX_DD,A2)
        ELSE
          CALL COPY(MAX_DD,REAL_D(A2))
        END IF
        CALL USED(A1)
      ELSE
! Send warning message, A1=A2.
        CALL ERROR_HANDLER(DATA,MAX_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(MAX_DD,A1*RAND+A2*(1.0_WP-RAND))
      END IF
    END IF
  END FUNCTION MAX_DD

  FUNCTION MAX_DR(A1,A2)
    TYPE (AD02_REAL) :: MAX_DR
    TYPE (AD02_REAL), INTENT (IN) :: A1
    REAL (WP), INTENT (IN) :: A2
    REAL(WP) RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
! Check for undefined variable input and if an error has occured
    IF (A1%P==-1) THEN
      CALL UNARY_WARNING(MAX_DR,A1,'MAX')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL UNARY_WARNING(MAX_DR,A1,'MAX')
    ELSE
      IF (DATA%RHEAP(DATA%RPTR(A1%P))>A2) THEN
! A1>A2
        IF (A1%CASE<0) THEN
          CALL COPY(MAX_DR,A1)
        ELSE
          CALL COPY(MAX_DR,REAL_D(A1))
        END IF
      ELSE IF (DATA%RHEAP(DATA%RPTR(A1%P))<A2) THEN
! A1<A2
        CALL COPY(MAX_DR,DERIVS(A2,DATA))
        CALL USED(A1)
      ELSE
! Send warning message, A1=A2.
        CALL ERROR_HANDLER(DATA,MAX_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(MAX_DR,A1*RAND+A2*(1.0_WP-RAND))
      END IF
    END IF
  END FUNCTION MAX_DR

  FUNCTION MAX_DS(A,B)
    TYPE (AD02_REAL) :: MAX_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MAX_DS,MAX_DR(A,REAL(B,WP)))
  END FUNCTION MAX_DS

  FUNCTION MAX_RD(A1,A2)
    TYPE (AD02_REAL) :: MAX_RD
    REAL (WP), INTENT (IN) :: A1
    TYPE (AD02_REAL), INTENT (IN) :: A2
    CALL COPY(MAX_RD,MAX_DR(A2,REAL(A1,WP)))
  END FUNCTION MAX_RD

  FUNCTION MAX_SD(A,B)
    TYPE (AD02_REAL) :: MAX_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(MAX_SD,MAX_RD(REAL(A,WP),B))
  END FUNCTION MAX_SD

! Min
  FUNCTION MIN_DD(A1,A2)
    TYPE (AD02_REAL) :: MIN_DD
    TYPE (AD02_REAL), INTENT (IN) :: A1, A2
    REAL(WP) RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
! Check for undefined variable input and if an error has occured
    IF (A1%P==-1 .OR. A2%P==-1) THEN
      CALL BINARY_WARNING(MIN_DD,A1,A2,'MIN')
    ELSE IF (.NOT.ASSOCIATED(DATA,A2%DATA)) THEN
      CALL BINARY_WARNING(MIN_DD,A1,A2,'MIN')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL BINARY_WARNING(MIN_DD,A1,A2,'MIN')
    ELSE
      IF (DATA%RHEAP(DATA%RPTR(A1%P))<DATA%RHEAP(DATA%RPTR(A2%P))) THEN
! A1<A2
        IF (A1%CASE<0) THEN
          CALL COPY(MIN_DD,A1)
        ELSE
          CALL COPY(MIN_DD,REAL_D(A1))
        END IF
        CALL USED(A2)
      ELSE IF (DATA%RHEAP(DATA%RPTR(A1%P))>DATA%RHEAP(DATA%RPTR(A2%P))) THEN
! A1>A2
        IF (A2%CASE<0) THEN
          CALL COPY(MIN_DD,A2)
        ELSE
          CALL COPY(MIN_DD,REAL_D(A2))
        END IF
        CALL USED(A1)
      ELSE
! Send warning message, A1=A2.
        CALL ERROR_HANDLER(DATA,MIN_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(MIN_DD,A1*RAND+A2*(1.0_WP-RAND))
      END IF
    END IF
  END FUNCTION MIN_DD

  FUNCTION MIN_DR(A1,A2)
    TYPE (AD02_REAL) :: MIN_DR
    TYPE (AD02_REAL), INTENT (IN) :: A1
    REAL (WP), INTENT (IN) :: A2
    REAL(WP) RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
! Check for undefined variable input and if an error has occured
    IF (A1%P==-1) THEN
      CALL UNARY_WARNING(MIN_DR,A1,'MIN')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL UNARY_WARNING(MIN_DR,A1,'MIN')
    ELSE
      IF (DATA%RHEAP(DATA%RPTR(A1%P))<A2) THEN
! A1<A2
        IF (A1%CASE<0) THEN
          CALL COPY(MIN_DR,A1)
        ELSE
          CALL COPY(MIN_DR,REAL_D(A1))
        END IF
      ELSE IF (DATA%RHEAP(DATA%RPTR(A1%P))>A2) THEN
! A1>A2
        CALL COPY(MIN_DR,DERIVS(A2,DATA))
        CALL USED(A1)
      ELSE
! Send warning message, A1=A2.
        CALL ERROR_HANDLER(DATA,MIN_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(MIN_DR,A1*RAND+A2*(1.0_WP-RAND))
      END IF
    END IF
  END FUNCTION MIN_DR

  FUNCTION MIN_DS(A,B)
    TYPE (AD02_REAL) :: MIN_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MIN_DS,MIN_DR(A,REAL(B,WP)))
  END FUNCTION MIN_DS

  FUNCTION MIN_RD(A1,A2)
    TYPE (AD02_REAL) :: MIN_RD
    REAL (WP), INTENT (IN) :: A1
    TYPE (AD02_REAL), INTENT (IN) :: A2
    CALL COPY(MIN_RD,MIN_DR(A2,REAL(A1,WP)))
  END FUNCTION MIN_RD

  FUNCTION MIN_SD(A,B)
    TYPE (AD02_REAL) :: MIN_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(MIN_SD,MIN_RD(REAL(A,WP),B))
  END FUNCTION MIN_SD


! Unary minus
  FUNCTION MINUS_D(A1)
    TYPE (AD02_REAL) :: MINUS_D
    TYPE (AD02_REAL), INTENT (IN) :: A1
    INTEGER I, I1, I2, NR, NV, P1, P2
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    MINUS_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A1%P==-1) THEN
      CALL UNARY_WARNING(MINUS_D,A1,'Unary -')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL UNARY_WARNING(MINUS_D,A1,'-')
    ELSE
      MINUS_D%CASE = -DATA%CASE
      NR = DATA%RLENG(A1%P)
! Check IA, and if it's temporary, then overwrite it
      IF (A1%CASE<0) THEN
        MINUS_D%P = A1%P
        MINUS_D%CASE = -DATA%CASE
        P1 = DATA%RPTR(A1%P)
        DATA%RHEAP(P1:P1+NR-1) = -DATA%RHEAP(P1:P1+NR-1)
      ELSE
        NV = DATA%NVARS(A1%P)
        IF (NV/=DATA%SIZE_X) THEN
          CALL GETMEM(NV,NR,MINUS_D)
          I1 = DATA%IPONT(A1%P)
          I2 = DATA%IPONT(MINUS_D%P)
! set up information block on iheap
          DATA%IHEAP(I2:I2+NV-1) = DATA%IHEAP(I1:I1+NV-1)
        ELSE
          CALL GETMEM(0,NR,MINUS_D)
        END IF
        P1 = DATA%RPTR(A1%P)
        P2 = DATA%RPTR(MINUS_D%P)
!       DATA%RHEAP(P2:P2+NR-1) = -DATA%RHEAP(P1:P1+NR-1)
        DO I = 1,NR
           DATA%RHEAP(P2+I-1) = -DATA%RHEAP(P1+I-1)
        END DO
        CALL USED(A1)
      END IF
    END IF
  END FUNCTION MINUS_D

! Binary minus
  FUNCTION MINUS_DD(A,B)
    TYPE (AD02_REAL) :: MINUS_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MINUS_DD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(MINUS_DD,A,B,'-')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(MINUS_DD,A,B,'-')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(MINUS_DD,A,B,'-')
    ELSE
      CALL COPY(MINUS_DD,A+(-B))
    END IF
  END FUNCTION MINUS_DD

  FUNCTION MINUS_DI(A,B)
    TYPE (AD02_REAL) :: MINUS_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MINUS_DI%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(MINUS_DI,A,'-')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(MINUS_DI,A,'-')
    ELSE
      MINUS_DI%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
! Alter value of temporary variable
        DATA%RHEAP(DATA%RPTR(A%P)) = DATA%RHEAP(DATA%RPTR(A%P)) - B
        MINUS_DI%P = A%P
      ELSE
        CALL ADD_CONST(A,-REAL(B,WP),MINUS_DI)
      END IF
    END IF
  END FUNCTION MINUS_DI

  FUNCTION MINUS_DR(A,B)
    TYPE (AD02_REAL) :: MINUS_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MINUS_DR%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(MINUS_DR,A,'-')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(MINUS_DR,A,'-')
    ELSE
      MINUS_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
! Alter value of temporary variable
        DATA%RHEAP(DATA%RPTR(A%P)) = DATA%RHEAP(DATA%RPTR(A%P)) - B
        MINUS_DR%P = A%P
      ELSE
        CALL ADD_CONST(A,-B,MINUS_DR)
      END IF
    END IF
  END FUNCTION MINUS_DR

  FUNCTION MINUS_DS(A,B)
    TYPE (AD02_REAL) :: MINUS_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MINUS_DS,MINUS_DR(A,REAL(B,WP)))
  END FUNCTION MINUS_DS

  FUNCTION MINUS_ID(A,B)
    TYPE (AD02_REAL) :: MINUS_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
      CALL COPY(MINUS_ID,MINUS_RD(REAL(A,WP),B))
  END  FUNCTION MINUS_ID

  FUNCTION MINUS_RD(A,B)
    TYPE (AD02_REAL) :: MINUS_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(MINUS_RD,B,'-')
    ELSE IF (B%DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(MINUS_RD,B,'-')
    ELSE
      CALL COPY(MINUS_RD,A+(-B))
    END IF
  END FUNCTION MINUS_RD

  FUNCTION MINUS_SD(A,B)
    TYPE (AD02_REAL) :: MINUS_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MINUS_SD,MINUS_RD(REAL(A,WP),B))
  END FUNCTION MINUS_SD

! Multiply
  FUNCTION MULT_DD(A,B)
    TYPE (AD02_REAL) :: MULT_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(MULT_DD,A,B,'*')
    ELSE IF (.NOT.ASSOCIATED(A%DATA,B%DATA)) THEN
      CALL BINARY_WARNING(MULT_DD,A,B,'*')
    ELSE IF (A%DATA%CASE/=ABS(A%CASE)  .OR. A%DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(MULT_DD,A,B,'*')
    ELSE
      MULT_DD%CASE = -A%DATA%CASE
      CALL MULT(A,B,MULT_DD)
    END IF
  END FUNCTION MULT_DD

  FUNCTION MULT_DI(A,B)
    TYPE (AD02_REAL) :: MULT_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    CALL COPY(MULT_DI,MULT_DR(A,REAL(B,WP)))
  END FUNCTION MULT_DI

  FUNCTION MULT_DR(A,B)
    TYPE (AD02_REAL) MULT_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    INTEGER NV, I, J, IP1, IP2, RL
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MULT_DR%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(MULT_DR,A,'*')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(MULT_DR,A,'*')
    ELSE
      MULT_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
! Alter value of temporary variable
        MULT_DR%P = A%P
        J = DATA%RPTR(A%P)
        DO I = 1,DATA%RLENG(A%P)
            DATA%RHEAP(J) = DATA%RHEAP(J)*B
            J = J + 1
        END DO
      ELSE
        NV = DATA%NVARS(A%P)
        RL = DATA%RLENG(A%P)
        IF (NV/=DATA%SIZE_X) THEN
          CALL GETMEM(NV,RL,MULT_DR)
          IP1 = DATA%IPONT(A%P)
          IP2 = DATA%IPONT(MULT_DR%P)
! Set up information on iheap
          DATA%IHEAP(IP2:IP2+NV-1) = DATA%IHEAP(IP1:IP1+NV-1)
        ELSE
          CALL GETMEM(0,RL,MULT_DR)
        END IF
! Calculate results
        IP1 = DATA%RPTR(MULT_DR%P)
        IP2 = DATA%RPTR(A%P)
        DO I = 1, RL
           DATA%RHEAP(IP1+I-1) = DATA%RHEAP(IP2+I-1)*B
        END DO
        CALL USED(A)
      END IF
    END IF
  END FUNCTION MULT_DR

  FUNCTION MULT_DS(A,B)
    TYPE (AD02_REAL) :: MULT_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MULT_DS,MULT_DR(A,REAL(B,WP)))
  END FUNCTION MULT_DS

  FUNCTION MULT_ID(A,B)
    TYPE (AD02_REAL) :: MULT_ID
    INTEGER, INTENT (IN):: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MULT_ID,MULT_DR(B,REAL(A,WP)))
  END FUNCTION MULT_ID

  FUNCTION MULT_RD(A,B)
    TYPE (AD02_REAL) :: MULT_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MULT_RD,MULT_DR(B,A))
  END FUNCTION MULT_RD

  FUNCTION MULT_SD(A,B)
    TYPE (AD02_REAL) MULT_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MULT_SD,MULT_DR(B,REAL(A,WP)))
  END FUNCTION MULT_SD

! .ne.
  FUNCTION NE_DD(A,B)
    LOGICAL :: NE_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DD = .TRUE.
    ELSE
      NE_DD = DATA%RHEAP(DATA%RPTR(A%P)) /= DATA%RHEAP(DATA%RPTR(B%P))
      IF ( .NOT. (NE_DD)) CALL ERROR_HANDLER(DATA,NE_WARN)
      CALL USED(A)
      CALL USED(B)
    END IF
  END FUNCTION NE_DD

  FUNCTION NE_DI(A,B)
    LOGICAL :: NE_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DI = .TRUE.
    ELSE
      NE_DI = DATA%RHEAP(DATA%RPTR(A%P)) /= B
      IF ( .NOT. (NE_DI)) CALL ERROR_HANDLER(DATA,NE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION NE_DI

  FUNCTION NE_DR(A,B)
    LOGICAL :: NE_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DR = .TRUE.
    ELSE
      NE_DR = DATA%RHEAP(DATA%RPTR(A%P)) /= B
      IF ( .NOT. (NE_DR)) CALL ERROR_HANDLER(DATA,NE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION NE_DR

  FUNCTION NE_DS(A,B)
    LOGICAL :: NE_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DS = .TRUE.
    ELSE
      NE_DS = DATA%RHEAP(DATA%RPTR(A%P)) /= B
      IF ( .NOT. (NE_DS)) CALL ERROR_HANDLER(DATA,NE_WARN)
      CALL USED(A)
    END IF
  END FUNCTION NE_DS

  FUNCTION NE_ID(A,B)
    LOGICAL :: NE_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_ID = .TRUE.
    ELSE
      NE_ID = A /= DATA%RHEAP(DATA%RPTR(B%P))
      IF ( .NOT. (NE_ID)) CALL ERROR_HANDLER(DATA,NE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION NE_ID

  FUNCTION NE_RD(A,B)
    LOGICAL :: NE_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_RD = .TRUE.
    ELSE
      NE_RD = A /= DATA%RHEAP(DATA%RPTR(B%P))
      IF ( .NOT. (NE_RD)) CALL ERROR_HANDLER(DATA,NE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION NE_RD

  FUNCTION NE_SD(A,B)
    LOGICAL :: NE_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_SD = .TRUE.
    ELSE
      NE_SD = A /= DATA%RHEAP(DATA%RPTR(B%P))
      IF ( .NOT. (NE_SD)) CALL ERROR_HANDLER(DATA,NE_WARN)
      CALL USED(B)
    END IF
  END FUNCTION NE_SD

! Nint
  FUNCTION NINT_D(A)
    TYPE (AD02_REAL) :: NINT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    NINT_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'NINT')
     ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'NINT')
    ELSE
      VA = DATA%RHEAP(DATA%RPTR(A%P))
! Check for A being of the form N + 0.5, N integer
      IF (ABS(VA-AINT(VA))*2.0_WP==1.0_WP) THEN
        CALL ERROR_HANDLER(DATA,NINT_WARN)
      END IF
      NINT_D%CASE = -DATA%CASE
      NINT_D = NINT(VA)
      NINT_D%CASE = -DATA%CASE
    END IF
  END FUNCTION NINT_D

! Power
  FUNCTION POW_DD(A,B)
    TYPE (AD02_REAL) :: POW_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    POW_DD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(POW_DD,A,B,'**')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(POW_DD,A,B,'**')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(POW_DD,A,B,'**')
    ELSE
! A**B where A and B are both type AD02_REAL
! Check for A<=0
      IF (DATA%RHEAP(DATA%RPTR(A%P))<=0.0_WP) THEN
        CALL ERROR_HANDLER(DATA,POW1_ERR)
        POW_DD%P = -1
        RETURN
      END IF
      CALL COPY(POW_DD,EXP(LOG(A)*B))
    END IF
  END FUNCTION POW_DD

  FUNCTION POW_DI(A,B)
    TYPE (AD02_REAL) :: POW_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(POW_DI,A,'**')
    ELSE IF (A%DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(POW_DI,A,'**')
    ELSE
      POW_DI%CASE = -A%DATA%CASE
      CALL UPOW(A,REAL(B,WP),POW_DI)
    END IF
  END FUNCTION POW_DI

  FUNCTION POW_DR(A,B)
    TYPE (AD02_REAL) :: POW_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(POW_DR,A,'**')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(POW_DR,A,'**')
    ELSE
      POW_DR%CASE = -DATA%CASE
      VA = DATA%RHEAP(DATA%RPTR(A%P))
! Raise to the power of a constant
! Check for VA=0 and B not an integer and B<DEGREE
      IF ((VA==0.0_WP) .AND. (REAL(INT(B),WP)/=B) .AND. (B<DATA%LEVEL)) THEN
        CALL ERROR_HANDLER(DATA,POW2_ERR)
        POW_DR%P = -1
      ELSE
        CALL UPOW(A,B,POW_DR)
      END IF
    END IF
  END FUNCTION POW_DR

  FUNCTION POW_DS(A,B)
    TYPE (AD02_REAL) :: POW_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(POW_DS,POW_DR(A,REAL(B,WP)))
  END FUNCTION POW_DS

  FUNCTION POW_ID(A,B)
    TYPE (AD02_REAL) :: POW_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
      CALL COPY(POW_ID,POW_RD(REAL(A,WP),B))
  END FUNCTION POW_ID

  FUNCTION POW_RD(A,B)
    TYPE (AD02_REAL) :: POW_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(POW_RD,B,'**')
    ELSE IF (B%DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(POW_RD,B,'**')
    ELSE
      CALL COPY(POW_RD,EXP(LOG(A)*B))
    END IF
  END FUNCTION POW_RD

  FUNCTION POW_SD(A,B)
    TYPE (AD02_REAL) :: POW_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(POW_SD,POW_RD(REAL(A,WP),B))
  END FUNCTION POW_SD

! A do nothing function for DBLE
  FUNCTION REAL_D(A)
    TYPE (AD02_REAL), INTENT (IN) :: A
    TYPE (AD02_REAL) REAL_D
    INTEGER I1, I2, NR, NV, P1, P2
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    REAL_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(REAL_D,A,'DBLE')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(REAL_D,A,'DBLE')
    ELSE
    REAL_D%CASE = -DATA%CASE
    IF (A%CASE<0) THEN
! A is temporary variable no need to create a new variable
      REAL_D%P = A%P
    ELSE
! Create a new variable
      NR = DATA%RLENG(A%P)
      NV = DATA%NVARS(A%P)
      IF (NV/=DATA%SIZE_X) THEN
        CALL GETMEM(NV,NR,REAL_D)
        I1 = DATA%IPONT(A%P)
        I2 = DATA%IPONT(REAL_D%P)
        DATA%IHEAP(I2:I2+NV-1) = DATA%IHEAP(I1:I1+NV-1)
      ELSE
        CALL GETMEM(0,NR,REAL_D)
      END IF
      P1 = DATA%RPTR(A%P)
      P2 = DATA%RPTR(REAL_D%P)
      DATA%RHEAP(P2:P2+NR-1) = DATA%RHEAP(P1:P1+NR-1)
    END IF
    END IF
  END FUNCTION REAL_D

! Sign
  FUNCTION SIGN_DD(A,B)
    TYPE (AD02_REAL) :: SIGN_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    REAL (WP) VB,RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(SIGN_DD,A,B,'SIGN')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(SIGN_DD,A,B,'SIGN')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(SIGN_DD,A,B,'SIGN')
    ELSE
! Check for SIGN(A,0)
      VB = DATA%RHEAP(DATA%RPTR(B%P))
      IF (VB==0.0_WP) THEN
         CALL ERROR_HANDLER(DATA,SIGN_WARN)
         CALL RANDOM_NUMBER(RAND)
         CALL COPY(SIGN_DD,(RAND+RAND-1.0_WP)*ABS(A))
      ELSE
         CALL COPY(SIGN_DD,ABS(A)*SIGN(1.0_WP,VB))
      END IF
      CALL USED(B)
    END IF
  END FUNCTION SIGN_DD

  FUNCTION SIGN_DR(A,B)
    TYPE (AD02_REAL) :: SIGN_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(SIGN_DR,A,'SIGN')
    ELSE IF (A%DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(SIGN_DR,A,'SIGN')
    ELSE
      CALL COPY(SIGN_DR,ABS(A)*SIGN(1.0_WP,B))
    ENDIF
  END FUNCTION SIGN_DR

  FUNCTION SIGN_DS(A,B)
    TYPE (AD02_REAL) :: SIGN_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(SIGN_DS,SIGN_DR(A,REAL(B,WP)))
  END FUNCTION SIGN_DS

  FUNCTION SIGN_RD(A,B)
    TYPE (AD02_REAL) :: SIGN_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL (WP) VB, RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(SIGN_RD,B,'SIGN')
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(SIGN_RD,B,'SIGN')
    ELSE
      SIGN_RD%CASE = -DATA%CASE
      VB = DATA%RHEAP(DATA%RPTR(B%P))
      IF (VB>0.0_WP) THEN
        CALL COPY(SIGN_RD,DERIVS(ABS(A),DATA))
      ELSE IF (VB<0.0_WP) THEN
        CALL COPY(SIGN_RD,DERIVS(-ABS(A),DATA))
      ELSE
        CALL ERROR_HANDLER(DATA,SIGN_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(SIGN_RD,DERIVS((RAND+RAND-1.0_WP)*ABS(A),DATA))
      END IF
      CALL USED(B)
    END IF
  END FUNCTION SIGN_RD

  FUNCTION SIGN_SD(A,B)
    TYPE (AD02_REAL) :: SIGN_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(SIGN_SD,SIGN_RD(REAL(A,WP),B))
  END FUNCTION SIGN_SD

! Sine
  FUNCTION SIN_D(X)
    TYPE (AD02_REAL) :: SIN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG, VS, VC
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(SIN_D,X,'SIN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(SIN_D,X,'SIN')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VG = DATA%RHEAP(DATA%RPTR(X%P))
! Calculate the derivative array DERF at VG
      VS = SIN(VG)
      VC = COS(VG)
      DO I = 0, DATA%LEVEL, 4
        DERF(I) = VS
        DERF(I+1) = VC
        DERF(I+2) = -VS
        DERF(I+3) = -VC
      END DO
      CALL UNARY(X,SIN_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION SIN_D

! Sinh
  FUNCTION SINH_D(X)
    TYPE (AD02_REAL) :: SINH_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG, VS, VC
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(SINH_D,X,'SINH')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(SINH_D,X,'SINH')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VG = DATA%RHEAP(DATA%RPTR(X%P))
! Calculate the derivative array DERF at VG
      VS = SINH(VG)
      VC = COSH(VG)
      DO I = 0, DATA%LEVEL, 2
        DERF(I) = VS
        DERF(I+1) = VC
      END DO
      CALL UNARY(X,SINH_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION SINH_D

! Sqrt
  FUNCTION SQRT_D(X)
    TYPE (AD02_REAL) :: SQRT_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    INTEGER I
    REAL (WP) VG, D, T
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(SQRT_D,X,'SQRT')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(SQRT_D,X,'SQRT')
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      VG = DATA%RHEAP(DATA%RPTR(X%P))
      T = 0.5_WP
! Check for SQRT(0)
      IF (VG==0.0_WP) THEN
        CALL ERROR_HANDLER(DATA,SQRT_ERR)
        CALL AD02_UNDEFINE(SQRT_D,DATA)
        RETURN
      END IF
! Calculate the derivative array DERF at VG
      D = SQRT(VG)
      DERF(0) = D
      DO I = 1, DATA%LEVEL
        D = T*D/VG
        T = T - 1.0_WP
        DERF(I) = D
      END DO
      CALL UNARY(X,SQRT_D,DERF)
      DEALLOCATE(DERF)
    END IF
  END FUNCTION SQRT_D

! Tan
  FUNCTION TAN_D(X)
    TYPE (AD02_REAL) :: TAN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    TYPE (AD02_REAL) :: A
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(TAN_D,X,'TAN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(TAN_D,X,'TAN')
    ELSE
      A = X
      CALL COPY(TAN_D,SIN(A)/COS(A))
      DATA%RHEAP(DATA%RPTR(TAN_D%P)) = TAN(DATA%RHEAP(DATA%RPTR(A%P)))
    END IF
  END FUNCTION TAN_D

! Tanh
  FUNCTION TANH_D(X)
    TYPE (AD02_REAL) :: TANH_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    TYPE (AD02_REAL) :: A
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(TANH_D,X,'TANH')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(TANH_D,X,'TANH')
    ELSE
      A = X
      CALL COPY(TANH_D,SINH(A)/COSH(A))
      DATA%RHEAP(DATA%RPTR(TANH_D%P)) = TANH(DATA%RHEAP(DATA%RPTR(A%P)))
    END IF
  END FUNCTION TANH_D


! The main routines

  SUBROUTINE ADD_CONST(INPUT,CONST,OUTPUT)
! Add an AD02_REAL variable to a constant
    TYPE (AD02_REAL), INTENT (IN) :: INPUT
    REAL (WP), INTENT (IN) :: CONST
    TYPE (AD02_REAL), INTENT (OUT) :: OUTPUT
    INTEGER I, I1, I2, RLEN, ILEN
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => INPUT%DATA
    OUTPUT%DATA => DATA
    RLEN = DATA%RLENG(INPUT%P)
    ILEN = DATA%NVARS(INPUT%P)
    IF (ILEN/=DATA%SIZE_X) THEN
      CALL GETMEM(ILEN,RLEN,OUTPUT)
! set up information block on iheap
      I1 = DATA%IPONT(INPUT%P)
      I2 = DATA%IPONT(OUTPUT%P)
      DO I = 0, DATA%NVARS(INPUT%P) - 1
        DATA%IHEAP(I2+I) = DATA%IHEAP(I1+I)
      END DO
    ELSE
      CALL GETMEM(0,RLEN,OUTPUT)
    END IF
! set up information block on rheap
    I1 = DATA%RPTR(INPUT%P)
    I2 = DATA%RPTR(OUTPUT%P)
    DATA%RHEAP(I2) = DATA%RHEAP(I1) + CONST
    DO I = 1, DATA%RLENG(INPUT%P) - 1
      DATA%RHEAP(I2+I) = DATA%RHEAP(I1+I)
    END DO
    CALL USED(INPUT)
  END SUBROUTINE ADD_CONST

  SUBROUTINE BINARY_WARNING(FUN,A,B,PROC)
    TYPE (AD02_REAL), INTENT (OUT) :: FUN
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    CHARACTER(*), OPTIONAL, INTENT(IN) :: PROC
    IF (ASSOCIATED(A%DATA) ) THEN
      CALL ERROR_HANDLER(A%DATA,UNDEF_WARN,PROC)
      FUN%DATA => A%DATA
    END IF
    IF (.NOT.ASSOCIATED(A%DATA,B%DATA) )THEN
      CALL ERROR_HANDLER(B%DATA,UNDEF_WARN,PROC)
      IF (ASSOCIATED(B%DATA) ) FUN%DATA => B%DATA
    END IF
    FUN%P = -1
  END SUBROUTINE BINARY_WARNING

  SUBROUTINE CONTROL1(LP,MP,PRINT_LEVEL,STOP_LEVEL)
! This gives the user control over the error handling
    INTEGER, OPTIONAL, INTENT (IN) :: LP
    INTEGER, OPTIONAL, INTENT (IN) :: MP
    INTEGER, OPTIONAL, INTENT (IN) :: PRINT_LEVEL
    INTEGER, OPTIONAL, INTENT (IN) :: STOP_LEVEL
    IF (PRESENT(LP)) ERROR_MESSAGE_UNIT = LP
    IF (PRESENT(MP)) WARNING_MESSAGE_UNIT = MP
    IF (PRESENT(PRINT_LEVEL)) ERROR_PRINT_LEVEL = PRINT_LEVEL
    IF (PRESENT(STOP_LEVEL)) ERROR_STOP_LEVEL = STOP_LEVEL
  END SUBROUTINE CONTROL1

  SUBROUTINE CONTROL2(DATA,ERROR,LP,MP,PRINT_LEVEL,STOP_LEVEL)
! This gives the user control over the error handling
    TYPE(AD02_DATA),POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: LP
    INTEGER, OPTIONAL, INTENT (IN) :: MP
    INTEGER, OPTIONAL, INTENT (IN) :: PRINT_LEVEL
    INTEGER, OPTIONAL, INTENT (IN) :: STOP_LEVEL
    IF(ASSOCIATED(DATA))THEN
      ERROR = 0
      IF (PRESENT(LP)) DATA%ERROR_MESSAGE_UNIT = LP
      IF (PRESENT(MP)) DATA%WARNING_MESSAGE_UNIT = MP
      IF (PRESENT(PRINT_LEVEL)) DATA%ERROR_PRINT_LEVEL = PRINT_LEVEL
      IF (PRESENT(STOP_LEVEL)) DATA%ERROR_STOP_LEVEL = STOP_LEVEL
    ELSE
      ERROR = 2
    END IF
  END SUBROUTINE CONTROL2

  SUBROUTINE COPY(A,B)
! Subroutine to copy a variables value without the creation of new
! variable
    TYPE (AD02_REAL), INTENT (OUT) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    A%P = B%P
    A%CASE = B%CASE
    A%DATA => B%DATA
  END SUBROUTINE COPY

  LOGICAL FUNCTION DATA_UNDEFINED(X)
    TYPE (AD02_REAL), INTENT (IN) :: X
    IF(ASSOCIATED(X%DATA)) THEN
      DATA_UNDEFINED = X%P==-1 .OR. X%DATA%CASE/=ABS(X%CASE)
      IF (X%DATA%CASE==-1) DATA_UNDEFINED = .FALSE.
    ELSE
      DATA_UNDEFINED = .FALSE.
    END IF
  END FUNCTION DATA_UNDEFINED

  FUNCTION DERIVS_I(A,DATA)
! Convert to a structure
    TYPE (AD02_REAL) :: DERIVS_I
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_DATA),POINTER :: DATA
    DERIVS_I%DATA => DATA
    CALL PACCNT(REAL(A,WP),DERIVS_I)
  END FUNCTION DERIVS_I

  FUNCTION DERIVS_R(A,DATA)
    TYPE (AD02_REAL) :: DERIVS_R
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_DATA),POINTER  :: DATA
    DERIVS_R%DATA => DATA
    CALL PACCNT(A,DERIVS_R)
  END FUNCTION DERIVS_R

  SUBROUTINE DERIVS_S(A,R,INDEX,DERIVS,ERROR)
!?? To obtain the derivatives of a dependant variable in a packed form.
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: R
    INTEGER, POINTER, DIMENSION (:) :: INDEX
    REAL (WP), POINTER, DIMENSION (:) :: DERIVS
    INTEGER, INTENT (OUT) :: ERROR
    ! 0 Successful
    ! 1 Undefined
    ! 2 Data undefined
    ! 3 Allocate failure
    ! 4 R out of range
    INTEGER LENGTH_INDEX, LENGTH_DERIVS, I, J
    TYPE(AD02_DATA), POINTER :: DATA

    ERROR = 0
! Check that the independent variables have been initialized
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    ELSE IF (R<0 .OR. R>A%DATA%LEVEL) THEN
      ERROR = 4
    END IF
    IF(ERROR>0)RETURN

    DATA => A%DATA

    IF (DATA%NVARS(A%P)==0) THEN
        ALLOCATE (INDEX(0))
        IF (R==0) THEN
          ALLOCATE (DERIVS(1))
          DERIVS(1) = DATA%RHEAP(DATA%RPTR(A%P))
        ELSE
          ALLOCATE (DERIVS(0))
        END IF
    ELSE
! Allocate INDEX and DERIVS
        LENGTH_DERIVS = DATA%IBINCO(R+DATA%NVARS(A%P)-1,R)
        ALLOCATE (INDEX(DATA%NVARS(A%P)))
        ALLOCATE (DERIVS(LENGTH_DERIVS))
! Retrieve INDEX
        IF (DATA%NVARS(A%P)==DATA%SIZE_X) THEN
          DO I = 1, DATA%SIZE_X
            INDEX(I) = I
          END DO
          LENGTH_INDEX = DATA%SIZE_X
        ELSE
          LENGTH_INDEX = DATA%NVARS(A%P)
       ! INDEX = DATA%IHEAP(DATA%IPONT(A%P):DATA%IPONT(A%P)+LENGTH_INDEX-1)
          J = DATA%IPONT(A%P)
          DO I = 1, LENGTH_INDEX
            INDEX(I) = DATA%IHEAP(J)
            J = J + 1
          END DO
        END IF
! Retrieve DERIVS
        IF (R>0) THEN
          DERIVS=DATA%RHEAP(DATA%RPTR(A%P)+DATA%IBINCO(R-1+LENGTH_INDEX,R-1):&
            DATA%RPTR(A%P)+DATA%IBINCO(R-1+LENGTH_INDEX,R-1)+LENGTH_DERIVS-1)
        ELSE
          DERIVS = DATA%RHEAP(DATA%RPTR(A%P))
        END IF
    END IF

  END SUBROUTINE DERIVS_S

  SUBROUTINE ERROR_HANDLER(DATA,ERROR_NUMBER,PROC)
! Error handling routine
    TYPE(AD02_DATA),POINTER :: DATA
    INTEGER, INTENT(IN) :: ERROR_NUMBER
    CHARACTER(*), OPTIONAL, INTENT(IN) :: PROC
    IF(ASSOCIATED(DATA))THEN
      DATA%FLAGS(ERROR_NUMBER) = DATA%FLAGS(ERROR_NUMBER) + 1
    ELSE
      AD02_FLAG(ERROR_NUMBER) = AD02_FLAG(ERROR_NUMBER) + 1
    END IF
    SELECT CASE (ERROR_NUMBER)
    CASE (1)
      CALL ERR_MESS_PRINT(DATA,'ERROR: Invalid call of AD02_INITIALIZE.', &
       .FALSE.)
    CASE (2)
      CALL ERR_MESS_PRINT(DATA, &
        'ERROR: Procedure call without prior AD02_INITIALIZE call.',.FALSE.)
    CASE (3)
      CALL ERR_MESS_PRINT(DATA, &
        'ERROR: Insufficient storage(failure of an ALLOCATE statment).', &
        .FALSE.)
    CASE (4)
      CALL ERR_MESS_PRINT(DATA,'ERROR: Invalid call of AD02_RESTORE',.FALSE.)
    CASE (5)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of SQRT(A) when A is of type AD02_REAL and has     &
     &         value 0.',.TRUE.)
    CASE (6)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of A**B when A and B are of type AD02_REAL, and A  &
     &         has a non-positive value.',.TRUE.)
    CASE (7)
      CALL ERR_MESS_PRINT(DATA, &
     'WARNING: Calculation of A**B when A is of type AD02_REAL, and B is of   &
     &         type REAL, A has value 0, and b has a non-integer value less   &
     &         than DEGREE.',.TRUE.)
    CASE (8)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of SIGN(A,B) when B is of type AD02_REAL and has   &
     &         value 0.',.TRUE.)
    CASE (9)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of ABS(A) or SIGN(A,B) when A is of type AD02_REAL &
     &         and has value 0.',.TRUE.)
    CASE (10)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of INT(A) when A is of type AD02_REAL and has an   &
     &         integer value.',.TRUE.)
    CASE (11)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of AINT(A) when A is of type AD02_REAL and has an  &
     &         integer value.',.TRUE.)
    CASE (12)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of NINT(A) when A is of type AD02_REAL and has a   &
     &         value n + 0.5, where n is an integer.',.TRUE.)
    CASE (13)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of ANINT(A) when A is of type AD02_REAL and has a  &
     &         value n + 0.5, where n is an integer.',.TRUE.)
    CASE (14)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of MAX(A,B) when at least one of A and B is of     &
     &         type AD02_REAL and A has the same value as B.', .TRUE.)
    CASE (15)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of MIN(A,B) when at least one of A and B is of     &
     &         type AD02_REAL and A has the same value as B.', .TRUE.)
    CASE (16)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A==B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (17)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A/=B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (18)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A>B when at least one of A and B is of type      &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (19)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A<B when at least one of A and B is of type      &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (20)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A>=B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (21)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A<=B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (33)
      CALL ERR_MESS_PRINT(DATA, &
        'WARNING: Execution of '//PROC//' for value AD02_UNDEFINED.', .TRUE.)
    CASE (34)
      CALL ERR_MESS_PRINT(DATA, &
        'WARNING: Assignment to array of type AD02_REAL', .TRUE.)
    END SELECT

  CONTAINS

    SUBROUTINE ERR_MESS_PRINT(DATA,ERROR_MESSAGE,WARNING)
! This subroutine prints out the error/warning message on the
! specified output unit and halts execution, when specified to,
! by the user inputs DATA%ERROR_PRINT_LEVEL and DATA%ERROR_STOP_LEVEL
      TYPE(AD02_DATA),POINTER :: DATA
      CHARACTER (LEN=*), INTENT (IN) :: ERROR_MESSAGE
      LOGICAL, INTENT (IN) :: WARNING
      INTEGER :: I,J
      IF(ASSOCIATED(DATA))THEN
        IF (WARNING) THEN
          IF (DATA%ERROR_PRINT_LEVEL==2) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (DATA%ERROR_STOP_LEVEL==2) STOP 'AD02 EXECUTION HALTED'
        ELSE
          IF (DATA%ERROR_PRINT_LEVEL/=0) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (DATA%ERROR_STOP_LEVEL/=0) STOP 'AD02 EXECUTION HALTED'
        END IF
      ELSE
        IF (WARNING) THEN
          IF (ERROR_PRINT_LEVEL==2) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (ERROR_STOP_LEVEL==2) STOP 'AD02 EXECUTION HALTED'
        ELSE
          IF (ERROR_PRINT_LEVEL/=0) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (ERROR_STOP_LEVEL/=0) STOP 'AD02 EXECUTION HALTED'
        END IF
      END IF
    END SUBROUTINE ERR_MESS_PRINT

  END SUBROUTINE ERROR_HANDLER

  SUBROUTINE EXPAND(INDEX_LIST_TO_EXP_ST,EXP_ST_SIZE,DATA)
! Given an index list and an expand size, construct an array of
! positions of the packed list in the expanded list.
    INTEGER, INTENT (IN) :: INDEX_LIST_TO_EXP_ST(:), EXP_ST_SIZE
    TYPE(AD02_DATA) :: DATA
    INTEGER START_POS, I, J, K, SIZE_INDEX_LIST, OLD_POS, BIN, LEVEL_SIZE
    INTEGER OLD_POS_FUTURE
    SIZE_INDEX_LIST = SIZE(INDEX_LIST_TO_EXP_ST)
    START_POS = DATA%SIZE_X + 1
    DATA%IHEAP(START_POS) = 0
    START_POS = DATA%SIZE_X + 2
    IF (DATA%LEVEL>0) THEN
      DO I = 1,SIZE_INDEX_LIST
         DATA%IHEAP(START_POS+I-1) = INDEX_LIST_TO_EXP_ST(I)
      END DO
      OLD_POS = START_POS
      START_POS = START_POS + SIZE_INDEX_LIST

      DO I = 2, DATA%LEVEL
        OLD_POS_FUTURE = START_POS
        LEVEL_SIZE = DATA%IBINCO(I+EXP_ST_SIZE-2,I-1)
        DO J = 1, SIZE_INDEX_LIST
          BIN = DATA%IBINCO(J+I-2,I-1)
          DO K = 1,BIN
            DATA%IHEAP(START_POS+K-1) = DATA%IHEAP(OLD_POS+K-1) + &
              DATA%IBINCO(INDEX_LIST_TO_EXP_ST(J)+I-2,I) + LEVEL_SIZE
          END DO
          START_POS = START_POS + BIN
        END DO
        OLD_POS = OLD_POS_FUTURE
      END DO
    END IF
  END SUBROUTINE EXPAND

  SUBROUTINE FINALIZE(DATA,ERROR)
     TYPE(AD02_DATA), POINTER :: DATA
     INTEGER, INTENT (OUT) :: ERROR
     INTEGER STAT(2)
     ERROR = 0
     IF(.NOT.ASSOCIATED(DATA))THEN
        ERROR = 1
        RETURN
     END IF
     IF(DATA%CASE/=-1)THEN
       DEALLOCATE (DATA%IPONT,DATA%RPTR,DATA%RLENG,DATA%NVARS,STAT=STAT(1))
       DEALLOCATE (DATA%RHEAP,DATA%IHEAP,DATA%FLAGS,STAT=STAT(1))
       DATA%CASE = -1
       IF(ANY(STAT/=0))ERROR = 3
     END IF
  END SUBROUTINE FINALIZE

  SUBROUTINE FLAGS1(L,FLAG,ERROR,RESET)
     INTEGER, INTENT(IN) :: L
     INTEGER, INTENT(OUT) :: FLAG,ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40) THEN
        ERROR = 1
     ELSE
        ERROR = 0
        FLAG = AD02_FLAG(L)
        IF(PRESENT(RESET)) THEN
          IF(RESET)AD02_FLAG(L)=0
        END IF
     END IF
  END SUBROUTINE FLAGS1

  SUBROUTINE FLAGS2(L,U,FLAG,ERROR,RESET)
     INTEGER, INTENT(IN) :: L,U
     INTEGER, INTENT(OUT) :: FLAG(L:U),ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40 .OR. U<1 .OR. U>40) THEN
        ERROR = 1
     ELSE
        ERROR = 0
        FLAG(L:U) = AD02_FLAG(L:U)
        IF(PRESENT(RESET)) THEN
          IF(RESET)AD02_FLAG(L:U)=0
        END IF
     END IF
  END SUBROUTINE FLAGS2

  SUBROUTINE FLAGS3(DATA,L,FLAG,ERROR,RESET)
     TYPE(AD02_DATA),POINTER :: DATA
     INTEGER, INTENT(IN) :: L
     INTEGER, INTENT(OUT) :: FLAG,ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40) THEN
        ERROR = 1
     ELSE IF (.NOT.ASSOCIATED(DATA))THEN
        ERROR = 2
     ELSE IF (.NOT.ASSOCIATED(DATA%FLAGS))THEN
        ERROR = 3
     ELSE
        ERROR = 0
        FLAG = DATA%FLAGS(L)
        IF(PRESENT(RESET)) THEN
          IF(RESET)DATA%FLAGS(L)=0
        END IF
     END IF
  END SUBROUTINE FLAGS3

  SUBROUTINE FLAGS4(DATA,L,U,FLAG,ERROR,RESET)
     TYPE(AD02_DATA),POINTER :: DATA
     INTEGER, INTENT(IN) :: L,U
     INTEGER, INTENT(OUT) :: FLAG(L:U),ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40 .OR. U<1 .OR. U>40) THEN
        ERROR = 1
     ELSE IF (.NOT.ASSOCIATED(DATA))THEN
        ERROR = 2
     ELSE IF (.NOT.ASSOCIATED(DATA%FLAGS))THEN
        ERROR = 3
     ELSE
        ERROR = 0
        FLAG(L:U) = DATA%FLAGS(L:U)
        IF(PRESENT(RESET)) THEN
          IF(RESET)DATA%FLAGS(L:U)=0
        END IF
     END IF
  END SUBROUTINE FLAGS4

  SUBROUTINE GC(NO_INT,NO_REAL,DATA)
! We compress all the data on the heaps, correcting pointers on DATA%IPONT
! and DATA%RPTR
    INTEGER, INTENT (IN) :: NO_INT, NO_REAL
    TYPE(AD02_DATA),POINTER :: DATA
    INTEGER, ALLOCATABLE :: ADDR(:), TEMP(:)
    INTEGER, POINTER :: ITEMP(:)
    REAL (WP), POINTER :: RTEMP(:)
    INTEGER I, IP, IR, J, NF, NI, NR, STAT, D_POINTER
    INTEGER :: IHSZ,IRSZ  ! Size of DATA%IHEAP, DATA%RHEAP
    INTEGER :: IPSZ  ! Size of DATA%IPONT, DATA%RPTR, RLENG, DATA%NVARS
    IHSZ = SIZE(DATA%IHEAP)
    IRSZ = SIZE(DATA%RHEAP)
    IPSZ = SIZE(DATA%IPONT)

! We apply a compression algorithm.
    IF ((DATA%IHTOS>2*DATA%SIZE_X+DATA%REAL_STRUCT_SIZE+1 .AND. &
         DATA%SWITCH_POINT> 0) .OR. &
        (DATA%IRTOS>DATA%REAL_STRUCT_SIZE*DATA%SIZE_X .AND. &
         DATA%SWITCH_POINT<1))  THEN
      ALLOCATE (ADDR(IPSZ), TEMP(IPSZ),STAT=STAT)
! Check for memory allocation error
      IF (STAT/=0) THEN
        CALL ERROR_HANDLER(DATA,ALLOC_ERR)
        RETURN
      END IF
      NF = 0
! Get a list of the numbers of the variables of the calculation
! in the order they appear on DATA%RHEAP
      DO I = DATA%SIZE_X + 1, DATA%IPTOS - 1
        NF = NF + 1
        TEMP(NF) = DATA%RPTR(I)
      END DO
      IF (NF>0) CALL KB07AI(TEMP,NF,ADDR)
      DO I = 1,NF
        ADDR(I) = ADDR(I)+DATA%SIZE_X
      END DO

! We now have a list, ADDR, of NF variable nos, 1..NF, of items
! which we want to move down.  So we move the data down the arrays
! DATA%IHEAP and DATA%RHEAP one at a time, changing the pointers on
! DATA%IPONT and DATA%RPTR.
! If the ordering on DATA%RHEAP is different from that on DATA%IHEAP
! then everything will be mucked up---so if you change it, change this
! too.

! Make sure the dead variables are not included in the garbage collection
      D_POINTER = DATA%DEAD_POINTER
      DO
        IF (D_POINTER==-1) THEN
          EXIT
        ELSE
          DATA%NVARS(D_POINTER) = 0
          DATA%RLENG(D_POINTER) = 0
          D_POINTER = DATA%IPONT(D_POINTER)
        END IF
      END DO

! Set DATA%IHTOS and DATA%IRTOS to the value they had immediately after
! the AD02_INITIALIZE call
      IF (DATA%SWITCH_POINT>0) THEN
        DATA%IHTOS = 2*DATA%SIZE_X + DATA%REAL_STRUCT_SIZE + 1
        DATA%IRTOS = ((1+DATA%LEVEL)*DATA%SIZE_X) + 1
      ELSE
        DATA%IHTOS = DATA%SIZE_X + 1
        DATA%IRTOS = DATA%REAL_STRUCT_SIZE*DATA%SIZE_X + 1
      END IF

! Move the blocks of data down the arrays DATA%IHEAP and DATA%RHEAP one at a
! time
      DO I = 1, NF
        IR = DATA%RPTR(ADDR(I))
        IP = DATA%IPONT(ADDR(I))
        NI = DATA%NVARS(ADDR(I))
        NR = DATA%RLENG(ADDR(I))

        IF (IP>DATA%IHTOS) THEN
          DO J = 0, NI - 1
            DATA%IHEAP(DATA%IHTOS+J) = DATA%IHEAP(IP+J)
          END DO
          IF (NI/=0) DATA%IPONT(ADDR(I)) = DATA%IHTOS
          DATA%IHTOS = DATA%IHTOS + NI
        ELSE IF (IP==DATA%IHTOS) THEN
          DATA%IHTOS = DATA%IHTOS + NI
        END IF
        IF (IR>DATA%IRTOS) THEN
          DO J = 0, NR - 1
            DATA%RHEAP(DATA%IRTOS+J) = DATA%RHEAP(IR+J)
          END DO
          DATA%RPTR(ADDR(I)) = DATA%IRTOS
          DATA%IRTOS = DATA%IRTOS + NR
        ELSE IF (IR==DATA%IRTOS) THEN
          DATA%IRTOS = DATA%IRTOS + NR
        END IF
      END DO
      DEALLOCATE (ADDR, TEMP)

    END IF
    IF ((DATA%IHTOS+NO_INT)*10>IHSZ) THEN
! Increase the size of the integer stack
      IHSZ = MAX(IHSZ*2,(DATA%IHTOS+NO_INT)*5)
      ALLOCATE (ITEMP(IHSZ),STAT=STAT)
! Check for memory allocation error
      IF (STAT/=0) THEN
        CALL ERROR_HANDLER(DATA,ALLOC_ERR)
        RETURN
      END IF
      ITEMP(1:DATA%IHTOS-1) = DATA%IHEAP(1:DATA%IHTOS-1)
      DEALLOCATE (DATA%IHEAP)
      DATA%IHEAP => ITEMP
    END IF

    IF ((DATA%IRTOS+NO_REAL)*10>IRSZ) THEN
! Increase the size of the real stack
      IRSZ = MAX(IRSZ*2,(DATA%IRTOS+NO_REAL)*5)
      ALLOCATE (RTEMP(IRSZ),STAT=STAT)
! Check for memory allocation error
      IF (STAT/=0) THEN
        CALL ERROR_HANDLER(DATA,ALLOC_ERR)
        RETURN
      END IF
      RTEMP(1:DATA%IRTOS-1) = DATA%RHEAP(1:DATA%IRTOS-1)
      DEALLOCATE (DATA%RHEAP)
      DATA%RHEAP => RTEMP
    END IF

  END SUBROUTINE GC


  SUBROUTINE GETMEM(NI,NR,VAR)

    INTEGER, INTENT (IN) :: NI, NR
    TYPE (AD02_REAL), INTENT (INOUT) :: VAR
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => VAR%DATA
! Tries to get NI integers on DATA%IHEAP and NR elements on DATA%RHEAP,
! returning pointer to DATA%IHEAP as top of stack on DATA%IPONT.
    IF (NI+DATA%IHTOS>SIZE(DATA%IHEAP).OR.NR+DATA%IRTOS>SIZE(DATA%RHEAP))THEN
      CALL GC(NI,NR,DATA)
      IF (DATA%CASE==0) RETURN
    END IF

    IF (DATA%DEAD_POINTER==-1) THEN
      IF (DATA%IPTOS>SIZE(DATA%IPONT)) CALL MORE_MEMORY(DATA)
! Get a new variable number for variable (no dead variables)
      VAR%P = DATA%IPTOS
      DATA%IPTOS = DATA%IPTOS + 1
    ELSE
! Get old variable number number from list of dead variables
      VAR%P = DATA%DEAD_POINTER
      DATA%DEAD_POINTER = DATA%IPONT(DATA%DEAD_POINTER)
    END IF
! Make this space a temporary object
    VAR%CASE = -DATA%CASE
! Set real information
    DATA%RPTR(VAR%P) = DATA%IRTOS
    DATA%IRTOS = DATA%IRTOS + NR
    DATA%RLENG(VAR%P) = NR

! Set integer information
    IF (NI>0) THEN
      DATA%IPONT(VAR%P) = DATA%IHTOS
      DATA%NVARS(VAR%P) = NI
      DATA%IHTOS = DATA%IHTOS + NI
    ELSE IF (NR/=1 .OR. DATA%LEVEL==0) THEN
      DATA%NVARS(VAR%P) = DATA%SIZE_X
      DATA%IPONT(VAR%P) = 1
    ELSE
      DATA%IPONT(VAR%P) = DATA%IHTOS
      DATA%NVARS(VAR%P) = NI
      DATA%IHTOS = DATA%IHTOS + NI
    END IF

  END SUBROUTINE GETMEM

! Gradient (first derivative)
  SUBROUTINE GRAD0(A,GRAD,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: GRAD
    INTEGER, INTENT (OUT) :: ERROR
    REAL (WP) X1(1)
    CALL GRAD1(A,X1,ERROR)
    GRAD = X1(1)
  END SUBROUTINE GRAD0

  SUBROUTINE GRAD1(A,GRAD,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: GRAD(:)
    INTEGER, INTENT (OUT) :: ERROR
    ! 0 Successful
    ! 1 Undefined
    ! 2 Data undefined
    ! 3 Allocate failure
    ! 4 First derivatives not being calculated
    ! 5 Array sizes differ
    TYPE(AD02_DATA), POINTER :: DATA
    INTEGER N, IP, IDER, NV, I
    ERROR = 0
    GRAD = 0.0_WP
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    ELSE
      DATA => A%DATA
      IF (DATA%LEVEL==0) THEN
        ERROR = 4
      ELSE IF (DATA%SIZE_X/=SIZE(GRAD)) THEN
        ERROR = 5
      END IF
    END IF
    IF(ERROR>0)RETURN

! Return in DF the first derivatives of IF with respect to the variables
! X. It stores them in DF
      IDER = DATA%RPTR(A%P)
      N = DATA%NVARS(A%P)
      IF (N==DATA%SIZE_X) THEN
        GRAD(1:N) = DATA%RHEAP(IDER+1:IDER+N)
      ELSE
! Find the integer information represented by IF
        IP = DATA%IPONT(A%P)
! Set the derivative values
        DO I = 1, N
! Variable number
          NV = DATA%IHEAP(IP+I-1)
          GRAD(NV) = DATA%RHEAP(IDER+I)
        END DO
      END IF
  END SUBROUTINE GRAD1

! Hessian (Second derivative)
  SUBROUTINE HESSIAN0(A,HESSIAN,ERROR,GRAD)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: HESSIAN
    INTEGER, INTENT (OUT) :: ERROR
    REAL (WP), OPTIONAL, INTENT (OUT) :: GRAD
    REAL (WP) :: H1(1,1), G1(1)
    IF (PRESENT(GRAD)) THEN
      CALL HESSIAN1(A,H1,ERROR,G1)
      HESSIAN = H1(1,1)
      GRAD = G1(1)
    ELSE
      CALL HESSIAN1(A,H1,ERROR)
      HESSIAN = H1(1,1)
    END IF
  END SUBROUTINE HESSIAN0

  SUBROUTINE HESSIAN1(A,HESSIAN,ERROR,GRAD)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: HESSIAN(:,:)
    INTEGER, INTENT (OUT) :: ERROR
    ! 0 Successful
    ! 1 Undefined
    ! 2 Data undefined
    ! 3 Allocate failure
    ! 4 Second derivatives not being calculated
    ! 5 GRAD has the wrong size
    ! 6 HESSIAN has the wrong shape
    REAL (WP), OPTIONAL, INTENT (OUT) :: GRAD(:)
    INTEGER I, K, L, NV, J
    TYPE(AD02_DATA), POINTER :: DATA
    INTEGER, ALLOCATABLE :: LVARS(:)
    HESSIAN = 0.0_WP
    ERROR = 0
    IF (PRESENT(GRAD)) CALL AD02_GRAD(A,GRAD,ERROR)
    IF(ERROR>0)RETURN
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    ELSE
      DATA => A%DATA
      IF (DATA%LEVEL<2) THEN
        ERROR = 4
      ELSE IF (SIZE(HESSIAN,1)/=DATA%SIZE_X .OR. &
             SIZE(HESSIAN,2)/=DATA%SIZE_X) THEN
        ERROR = 6
      END IF
    END IF
    IF(ERROR>0)RETURN

    ALLOCATE(LVARS(0:DATA%SIZE_X))
    NV = DATA%NVARS(A%P)
! Retrieve the Hessian value from the AD02 derivative structure
    IF (NV==DATA%SIZE_X) THEN
! Variable A depends on all the independent variables
        L = DATA%RPTR(A%P) + DATA%SIZE_X
        DO I = 1, DATA%SIZE_X
          K = L + I*(I-1)/2
          DO J = 1, I - 1
            HESSIAN(I,J) = DATA%RHEAP(K+J)
            HESSIAN(J,I) = HESSIAN(I,J)
          END DO
          HESSIAN(I,I) = DATA%RHEAP(K+I)*2.0_WP
        END DO
    ELSE
! Variable A depends on the independent variables stored in
! DATA%IHEAP(DATA%IPONT(A%P):DATA%IPONT(A%P)+NV-1)
        K = DATA%IPONT(A%P)
        L = DATA%RPTR(A%P) + NV
        K = K - 1
        DO I = 1, DATA%SIZE_X
          DO J = 1, NV
            IF (I==DATA%IHEAP(K+J)) EXIT
          END DO
          LVARS(I) = J
        END DO
        DO I = 1, DATA%SIZE_X
          IF (LVARS(I)>NV) CYCLE
          K = L + LVARS(I)*(LVARS(I)-1)/2
          DO J = 1, DATA%SIZE_X
            IF (LVARS(J)>LVARS(I)) CYCLE
            HESSIAN(I,J) = DATA%RHEAP(K+LVARS(J))
            HESSIAN(J,I) = HESSIAN(I,J)
          END DO
          HESSIAN(I,I) = HESSIAN(I,I)*2.0_WP
        END DO
    END IF

  END SUBROUTINE HESSIAN1

  SUBROUTINE INITIALIZE_DATA(DATA,ERROR)
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER STAT
    ALLOCATE (DATA,STAT=STAT)
    IF (STAT/=0) THEN
       ERROR = 3
       RETURN
    END IF
    ALLOCATE(DATA%FLAGS(40),STAT=STAT)
    IF (STAT/=0) THEN
       ERROR = 3
       RETURN
    END IF
    DATA%FLAGS = 0
    DATA%MAX_CASE = DATA%MAX_CASE + 1
    DATA%CASE = DATA%MAX_CASE
  END SUBROUTINE INITIALIZE_DATA

  SUBROUTINE INITIALIZE_11(DEGREE,X,VALUE,DATA,ERROR,FULL_THRESHOLD)
! Declare independent variable, give it a value and set order of
! derivatives required.
    INTEGER, INTENT (IN) :: DEGREE
    TYPE (AD02_REAL), INTENT (OUT) :: X(:)
    REAL (WP), INTENT (IN) :: VALUE(:)
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: FULL_THRESHOLD
    INTEGER STAT, I, J, UPPER, LOWER, MARKER, MAXVAR, NEW_MARKER
    INTEGER :: IHSZ,IRSZ  ! Size of DATA%IHEAP,DATA%RHEAP
    INTEGER :: IPSZ  ! Size of DATA%IPONT, DATA%RPTR, DATA%RLENG, DATA%NVARS
    INTEGER :: IBSH(2)  ! Shape of DATA%IBINCO

! Check for obvious errors
    ERROR = 0
    IF (SIZE(X)/=SIZE(VALUE)) THEN
       ERROR = 5
       RETURN
    ELSE IF (DEGREE<0) THEN
       ERROR = 4
       RETURN
    END IF

    IF(.NOT.ASSOCIATED(DATA)) THEN
       ALLOCATE (DATA,STAT=STAT)
       IF (STAT/=0) THEN
          ERROR = 3
          RETURN
       END IF
    ELSE IF (DATA%CASE==-1) THEN
       ALLOCATE (DATA,STAT=STAT)
       IF (STAT/=0) THEN
          ERROR = 3
          RETURN
       END IF
    END IF
    IF(.NOT.ASSOCIATED(DATA%FLAGS)) THEN
       ALLOCATE(DATA%FLAGS(40),STAT=STAT)
       IF (STAT/=0) THEN
          ERROR = 3
          RETURN
       END IF
       DATA%FLAGS = 0
    END IF
    DATA%MAX_CASE = DATA%MAX_CASE + 1
    DATA%CASE = DATA%MAX_CASE
    DO I = 1,SIZE(X)
      X(I)%DATA => DATA
      X(I)%CASE = DATA%CASE
    END DO
    DATA%SIZE_X = SIZE(X)
    DATA%LEVEL = DEGREE

! Initialize the list of DEAD structures to being empty
    DATA%DEAD_POINTER = -1

! Set other, unrelated variables which must be set somewhere
    MAXVAR = SIZE(X) + 1
    IPSZ = -1
    IF(ASSOCIATED(DATA%IPONT)) IPSZ = SIZE(DATA%IPONT)
    IF (IPSZ<MAXVAR*10) THEN
      IF(IPSZ>=0) DEALLOCATE (DATA%IPONT,DATA%RPTR,DATA%RLENG,DATA%NVARS)
      IPSZ = MAXVAR*10
      ALLOCATE (DATA%IPONT(IPSZ),DATA%RPTR(IPSZ),DATA%RLENG(IPSZ),&
             DATA%NVARS(IPSZ),STAT=STAT)
! Check for memory allocation error
      IF (STAT/=0) THEN
         ERROR = 3
         RETURN
      END IF
    END IF
    DATA%IPTOS = 2

    IRSZ = -1
    IF(ASSOCIATED(DATA%RHEAP)) IRSZ = SIZE(DATA%RHEAP)
    IF(IRSZ < HEAP_SIZE) THEN
      IF(IRSZ>=0) DEALLOCATE (DATA%RHEAP)
      IRSZ = HEAP_SIZE
      ALLOCATE (DATA%RHEAP(IRSZ),STAT=STAT)
! Check for memory allocation error
      IF (STAT/=0) THEN
        ERROR = 3
        RETURN
      END IF
    END IF
    DATA%IRTOS = 1

! Set up array of binomial coefficients nCr
    IBSH = -1
    IF(ASSOCIATED(DATA%IBINCO)) IBSH = SHAPE(DATA%IBINCO)
    IF ( MAX(DEGREE,DATA%SIZE_X)+2>IBSH(2) .OR. &
              DEGREE+DATA%SIZE_X+2>IBSH(1) ) THEN
      IF(ASSOCIATED(DATA%IBINCO)) DEALLOCATE (DATA%IBINCO)
      ALLOCATE (DATA%IBINCO(-1:DEGREE+DATA%SIZE_X,-1:DEGREE),STAT=STAT)
! Check for memory allocation error
      IF (STAT/=0) THEN
         ERROR = 3
         RETURN
      END IF
      DATA%IBINCO(0,:) = 0
      DATA%IBINCO(0,0) = 1
      DATA%IBINCO(-1,:) = 0
      DATA%IBINCO(:,-1) = 0
      DO I = 1, DEGREE + DATA%SIZE_X
        DATA%IBINCO(I,0) = 1
!       DO J = 1, MAX(DEGREE,DATA%SIZE_X)
        DO J = 1, DEGREE
          DATA%IBINCO(I,J) = DATA%IBINCO(I-1,J-1) + DATA%IBINCO(I-1,J)
        END DO
      END DO
    END IF

! The size of a full derivative structure
    DATA%REAL_STRUCT_SIZE = DATA%IBINCO(DEGREE+DATA%SIZE_X,DEGREE)

! Calculate the switch point
    IF (DEGREE==0) THEN
      DATA%SWITCH_POINT = 0
    ELSE IF ( (PRESENT(FULL_THRESHOLD))) THEN
      DATA%SWITCH_POINT = MIN(DATA%SIZE_X,FULL_THRESHOLD)
    ELSE IF (DATA%SIZE_X<=5) THEN
      DATA%SWITCH_POINT = 0
    ELSE
      LOWER = 1
      UPPER = DATA%SIZE_X
      MARKER = 1
      DO
        NEW_MARKER = (UPPER+LOWER+1)/2
        IF (MARKER==NEW_MARKER) EXIT
        MARKER = NEW_MARKER
        IF (DATA%REAL_STRUCT_SIZE>2*DATA%IBINCO(DEGREE+MARKER,DEGREE)) THEN
          LOWER = MARKER
        ELSE
          UPPER = MARKER
        END IF
      END DO
      DATA%SWITCH_POINT = MARKER
    END IF

    IHSZ = -1
    IF(ASSOCIATED(DATA%IHEAP)) IHSZ = SIZE(DATA%IHEAP)
    IF (IHSZ<HEAP_SIZE+DATA%SIZE_X+DATA%REAL_STRUCT_SIZE) THEN
      IF (IHSZ>0) DEALLOCATE (DATA%IHEAP)
      IHSZ = HEAP_SIZE + DATA%SIZE_X + DATA%REAL_STRUCT_SIZE
      ALLOCATE (DATA%IHEAP(IHSZ),STAT=STAT)
! Check for memory allocation error
      IF (STAT/=0) THEN
         ERROR = 3
        RETURN
      END IF
    END IF

! Place a full index list at start of DATA%IHEAP
      DATA%IHEAP(1:DATA%SIZE_X) = (/ (I,I=1,DATA%SIZE_X) /)
      IF (DATA%SWITCH_POINT>0) THEN
        DATA%IHTOS = DATA%REAL_STRUCT_SIZE + DATA%SIZE_X + 1
        DATA%IHEAP(DATA%SIZE_X+1:DATA%IHTOS-1) = 0
      ELSE
        DATA%IHTOS = DATA%SIZE_X + 1
      END IF

!        Set up independent variables
    IF (DATA%SWITCH_POINT>0) THEN
!        Sparse mode
      DO I = 1, DATA%SIZE_X
        CALL GETMEM(1,1+DEGREE,X(I))
        X(I)%CASE = DATA%CASE
        DATA%IHEAP(DATA%IPONT(X(I)%P)) = I
        DATA%RHEAP(DATA%RPTR(X(I)%P)) = VALUE(I)
        DATA%RHEAP(DATA%RPTR(X(I)%P)+1) = 1.0_WP
        DATA%RHEAP(DATA%RPTR(X(I)%P)+2:DATA%RPTR(X(I)%P)+DEGREE) = 0.0_WP
      END DO
    ELSE
!        Full mode
      DO I = 1, DATA%SIZE_X
        CALL GETMEM(0,DATA%REAL_STRUCT_SIZE,X(I))
        X(I)%CASE = DATA%CASE
        DATA%RHEAP(DATA%RPTR(X(I)%P)) = VALUE(I)
        IF (DEGREE>0) THEN
          DATA%RHEAP(DATA%RPTR(X(I)%P)+1:&
             DATA%RPTR(X(I)%P)+DATA%REAL_STRUCT_SIZE-1) = 0.0_WP
          DATA%RHEAP(DATA%RPTR(X(I)%P)+I) = 1.0_WP
        END IF
      END DO
    END IF
  END SUBROUTINE INITIALIZE_11

  SUBROUTINE INITIALIZE_10(DEGREE,X,VALUE,DATA,ERROR,FULL_THRESHOLD)
    INTEGER, INTENT (IN) :: DEGREE
    TYPE (AD02_REAL), INTENT (OUT) :: X(:)
    REAL (WP), INTENT (IN) :: VALUE
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: FULL_THRESHOLD
    REAL (WP), DIMENSION (SIZE(X)) :: VAL
    VAL = VALUE
    CALL INITIALIZE_11(DEGREE,X,VAL,DATA,ERROR,FULL_THRESHOLD)
  END SUBROUTINE INITIALIZE_10

  SUBROUTINE INITIALIZE_0(DEGREE,X,VALUE,DATA,ERROR,FULL_THRESHOLD)
    INTEGER, INTENT (IN) :: DEGREE
    TYPE (AD02_REAL), INTENT (OUT) :: X
    REAL (WP), INTENT (IN) :: VALUE
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: FULL_THRESHOLD
    REAL (WP) VAL(1)
    TYPE (AD02_REAL) :: A1(1)
    VAL(1) = VALUE
    CALL INITIALIZE_11(DEGREE,A1,VAL,DATA,ERROR,FULL_THRESHOLD)
    X%P = A1(1) %P
    IF(ASSOCIATED(DATA)) X%CASE = DATA%CASE
    X%DATA => DATA
  END SUBROUTINE INITIALIZE_0

  INTEGER FUNCTION IRPOS(MI,N,DATA)
! MI is a multi-index, REF maps it on to some structure with N
! variables
! this function computes its position in this second structure.
    INTEGER, INTENT (IN) :: N
    INTEGER, INTENT (IN) :: MI(0:)
    TYPE(AD02_DATA) :: DATA
    INTEGER I, P, LAMBDA
    LAMBDA = MI(0)
    IF (LAMBDA>0) THEN
      P = DATA%IBINCO(LAMBDA-1+N,LAMBDA-1)
    ELSE
      P = 0
    END IF
    DO I = 1, LAMBDA
      P = P + DATA%IBINCO(I+MI(I)-2,I)
    END DO
    IRPOS = P
  END FUNCTION IRPOS

  INTEGER FUNCTION IRPOS2(MI,N,IREF1,DATA)
! MI is a multi-index, REF maps it on to some structure with N
! variables
! this function computes its position in this second structure.
    INTEGER, INTENT (IN) :: N
    INTEGER, INTENT (IN) :: MI(0:),IREF1(*)
    TYPE(AD02_DATA) :: DATA
    INTEGER I, P, LAMBDA
    LAMBDA = MI(0)
    IF (LAMBDA>0) THEN
      P = DATA%IBINCO(LAMBDA-1+N,LAMBDA-1)
    ELSE
      P = 0
    END IF
    DO I = 1, LAMBDA
      P = P + DATA%IBINCO(I+IREF1(MI(I))-2,I)
    END DO
    IRPOS2 = P
  END FUNCTION IRPOS2

! Make variable temporary
  SUBROUTINE MAKE_TEMP(A)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    A%CASE = -ABS(A%CASE)
  END SUBROUTINE MAKE_TEMP

  SUBROUTINE MERGE(I1,I2,N1,N2,DATA,LVARS,IREF1,IREF2)
! Merge the index lists DATA%IHEAP(I1:I1+N1-1) and DATA%IHEAP(I2:I2+N2-1).
! The result is placed in LVARS and the positions in the merged list of
! the entries of the two lists are placed in IREF1 and IREF2.
    INTEGER, INTENT (IN) :: I1, I2, N1, N2
    TYPE(AD02_DATA) :: DATA
    INTEGER :: LVARS(0:*),IREF1(*),IREF2(*)
    INTEGER POINTER1, POINTER2, LVARS_POINTER
    INTEGER END_INDEX1, END_INDEX2, I
    END_INDEX1 = I1 + N1 - 1
    END_INDEX2 = I2 + N2 - 1
    POINTER1 = I1
    POINTER2 = I2
    LVARS_POINTER = 1
    IF (POINTER1>END_INDEX1) THEN
      LVARS(0) = LVARS_POINTER + END_INDEX2 - POINTER2
      LVARS(LVARS_POINTER:LVARS_POINTER+END_INDEX2-POINTER2) &
        = DATA%IHEAP(POINTER2:END_INDEX2)
      IREF2(POINTER2-I2+1:END_INDEX2-I2+1) = (/ (I,I=LVARS_POINTER, &
        LVARS_POINTER+END_INDEX2-POINTER2) /)
      RETURN
    END IF
    IF (POINTER2>END_INDEX2) THEN
      LVARS(0) = LVARS_POINTER + END_INDEX1 - POINTER1
      LVARS(LVARS_POINTER:LVARS_POINTER+END_INDEX1-POINTER1) &
        = DATA%IHEAP(POINTER1:END_INDEX1)
      IREF1(POINTER1-I1+1:END_INDEX1-I1+1) = (/ (I,I=LVARS_POINTER, &
        LVARS_POINTER+END_INDEX1-POINTER1) /)
      RETURN
    END IF
    DO
      IF (DATA%IHEAP(POINTER1)==DATA%IHEAP(POINTER2)) THEN
        IREF1(POINTER1-I1+1) = LVARS_POINTER
        IREF2(POINTER2-I2+1) = LVARS_POINTER
        LVARS(LVARS_POINTER) = DATA%IHEAP(POINTER1)
        LVARS_POINTER = LVARS_POINTER + 1
        POINTER1 = POINTER1 + 1
        POINTER2 = POINTER2 + 1
        IF (POINTER1>END_INDEX1) THEN
          LVARS(0) = LVARS_POINTER + END_INDEX2 - POINTER2
          LVARS(LVARS_POINTER:LVARS_POINTER+END_INDEX2-POINTER2) &
            = DATA%IHEAP(POINTER2:END_INDEX2)
          IREF2(POINTER2-I2+1:END_INDEX2-I2+1) = (/ (I,I=LVARS_POINTER, &
            LVARS_POINTER+END_INDEX2-POINTER2) /)
          EXIT
        END IF
        IF (POINTER2>END_INDEX2) THEN
          LVARS(0) = LVARS_POINTER + END_INDEX1 - POINTER1
          LVARS(LVARS_POINTER:LVARS_POINTER+END_INDEX1-POINTER1) &
            = DATA%IHEAP(POINTER1:END_INDEX1)
          IREF1(POINTER1-I1+1:END_INDEX1-I1+1) = (/ (I,I=LVARS_POINTER, &
            LVARS_POINTER+END_INDEX1-POINTER1) /)
          EXIT
        END IF
      ELSE IF (DATA%IHEAP(POINTER1)>DATA%IHEAP(POINTER2)) THEN
        IREF2(POINTER2-I2+1) = LVARS_POINTER
        LVARS(LVARS_POINTER) = DATA%IHEAP(POINTER2)
        LVARS_POINTER = LVARS_POINTER + 1
        POINTER2 = POINTER2 + 1
        IF (POINTER2>END_INDEX2) THEN
          LVARS(0) = LVARS_POINTER + END_INDEX1 - POINTER1
          LVARS(LVARS_POINTER:LVARS_POINTER+END_INDEX1-POINTER1) &
            = DATA%IHEAP(POINTER1:END_INDEX1)
          IREF1(POINTER1-I1+1:END_INDEX1-I1+1) = (/ (I,I=LVARS_POINTER, &
            LVARS_POINTER+END_INDEX1-POINTER1) /)
          EXIT
        END IF
      ELSE
        IREF1(POINTER1-I1+1) = LVARS_POINTER
        LVARS(LVARS_POINTER) = DATA%IHEAP(POINTER1)
        LVARS_POINTER = LVARS_POINTER + 1
        POINTER1 = POINTER1 + 1
        IF (POINTER1>END_INDEX1) THEN
          LVARS(0) = LVARS_POINTER + END_INDEX2 - POINTER2
          LVARS(LVARS_POINTER:LVARS_POINTER+END_INDEX2-POINTER2) &
            = DATA%IHEAP(POINTER2:END_INDEX2)
          IREF2(POINTER2-I2+1:END_INDEX2-I2+1) = (/ (I,I=LVARS_POINTER, &
            LVARS_POINTER+END_INDEX2-POINTER2) /)
          EXIT
        END IF
      END IF
    END DO
  END SUBROUTINE MERGE


  SUBROUTINE MIINC(LEVEL,MI,N)
! Increment multi-index MI
    INTEGER, INTENT (IN) :: LEVEL, N
    INTEGER, INTENT (INOUT) :: MI(0:LEVEL+1)
    INTEGER I, LAMBDA

    LAMBDA = MI(0)
    IF (LAMBDA==LEVEL+1) RETURN
    IF (N==0) RETURN

    IF (LAMBDA==2) THEN
      IF (MI(1)<MI(2)) THEN
        MI(1) = MI(1) + 1
        RETURN
      END IF
      MI(1) = 1
      IF (MI(2)==N) THEN
        MI(2) = 1
        MI(3) = 1
        MI(0) = 3
        RETURN
      END IF
      MI(2) = MI(2) + 1
      RETURN
    END IF

    IF (LAMBDA==1) THEN
      IF (MI(1)==N) THEN
        MI(0) = 2
        MI(1) = 1
        MI(2) = 1
        RETURN
      END IF
      MI(1) = MI(1) + 1
      RETURN
    END IF

    IF (LAMBDA==0) THEN
      MI(0) = 1
      MI(1) = 1
      RETURN
    END IF

    IF (MI(1)==N) THEN
      MI(0) = LAMBDA + 1
      DO I = 1, MI(0)
        MI(I) = 1
      END DO
      RETURN
    END IF

    I = 1
    DO
      IF (I>LAMBDA-1) EXIT
      IF (MI(I)<MI(I+1)) THEN
        MI(I) = MI(I) + 1
        RETURN
      END IF
      MI(I) = 1
      I = I + 1
    END DO
    MI(I) = MI(I) + 1

  END SUBROUTINE MIINC

  SUBROUTINE MIMERU(MI1,MI2,MI3)
! Merge two multi-indices MI1 and MI2 to produce multi-index MI3,
! The merge includes repetitions.
    INTEGER, INTENT (IN) :: MI1(1:), MI2(1:)
    INTEGER, INTENT (OUT) :: MI3(0:)
    INTEGER I1, I2, I3, K, N1, N2

    N1 = SIZE(MI1)
    N2 = SIZE(MI2)
    MI3(0) = N1 + N2
    I1 = 1
    I2 = 1
    I3 = 0

    IF (N1/=0 .AND. N2/=0) THEN
      DO
        IF (MI1(I1)<MI2(I2)) THEN
          I3 = I3 + 1
          MI3(I3) = MI1(I1)
          I1 = I1 + 1
          N1 = N1 - 1
          IF (N1==0) EXIT
        ELSE
          I3 = I3 + 1
          MI3(I3) = MI2(I2)
          I2 = I2 + 1
          N2 = N2 - 1
          IF (N2==0) EXIT
        END IF
      END DO
    END IF

    IF (N1>0) THEN
      DO K = 0, N1 - 1
        MI3(I3+K+1) = MI1(I1+K)
      END DO
    ELSE IF (N2>0) THEN
      DO K = 0, N2 - 1
        MI3(I3+K+1) = MI2(I2+K)
      END DO
    END IF

  END SUBROUTINE MIMERU


    SUBROUTINE MORE_MEMORY(DATA)
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, POINTER :: ITEMP1(:), ITEMP3(:), ITEMP4(:), ITEMP5(:)
    INTEGER STAT
    INTEGER :: IPSZ  ! Size of DATA%IPONT, DATA%RPTR, DATA%RLENG, DATA%NVARS
! Increase size of DATA%IPONT, ITEMP, DATA%RPTR, DATA%RLENG and DATA%NVARS
    IPSZ = DATA%IPTOS*2
    ALLOCATE (ITEMP1(IPSZ),ITEMP3(IPSZ),ITEMP4(IPSZ),ITEMP5(IPSZ),STAT=STAT)
! Check for memory allocation error
    IF (STAT/=0) THEN
      CALL ERROR_HANDLER(DATA,ALLOC_ERR)
      RETURN
    END IF
    ITEMP1(1:DATA%IPTOS-1) = DATA%IPONT(1:DATA%IPTOS-1)
    ITEMP3(1:DATA%IPTOS-1) = DATA%RPTR (1:DATA%IPTOS-1)
    ITEMP4(1:DATA%IPTOS-1) = DATA%RLENG(1:DATA%IPTOS-1)
    ITEMP5(1:DATA%IPTOS-1) = DATA%NVARS(1:DATA%IPTOS-1)
    DEALLOCATE (DATA%IPONT,DATA%RPTR,DATA%RLENG,DATA%NVARS)
    DATA%IPONT => ITEMP1
    DATA%RPTR  => ITEMP3
    DATA%RLENG => ITEMP4
    DATA%NVARS => ITEMP5
  END SUBROUTINE MORE_MEMORY


  SUBROUTINE MULT(A,B,C)
! Multiply the two structures IA and IB
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE (AD02_REAL), INTENT (OUT) :: C
    INTEGER I, IR, I1, I2, L1, L2, N(3), P(3), PR, J, INDEX
    INTEGER INDEX_A, INDEX_B, INDEX_C, LEVEL
    REAL (WP) V1
    TYPE(AD02_DATA), POINTER :: DATA
    INTEGER, ALLOCATABLE :: LVARS(:) ! Merged list
    INTEGER, ALLOCATABLE :: IREF1(:) ! Positions of list 1 in merged list
    INTEGER, ALLOCATABLE :: IREF2(:) ! Positions of list 2 in merged list
    INTEGER, ALLOCATABLE :: MI(:,:)
    INTEGER, ALLOCATABLE :: INV_IREF1(:),INV_IREF2(:)
    LOGICAL, ALLOCATABLE :: A_PRES(:), B_PRES(:)
    DATA => A%DATA
    C%DATA => DATA
    LEVEL = DATA%LEVEL

    N(1) = DATA%NVARS(A%P)
    N(2) = DATA%NVARS(B%P)

    IF ((N(1)==DATA%SIZE_X) .AND. (N(2)==DATA%SIZE_X)) THEN
      CALL GETMEM(0,DATA%REAL_STRUCT_SIZE,C)

      SELECT CASE (LEVEL)
      CASE (0)
! Function value
        DATA%RHEAP(DATA%RPTR(C%P)) =  &
            DATA%RHEAP(DATA%RPTR(A%P))*DATA%RHEAP(DATA%RPTR(B%P))
      CASE (1)
! Function value
        INDEX_A = DATA%RPTR(A%P)
        INDEX_B = DATA%RPTR(B%P)
        INDEX_C = DATA%RPTR(C%P)
        DATA%RHEAP(INDEX_C) = DATA%RHEAP(INDEX_A)*DATA%RHEAP(INDEX_B)
! Derivative value
        DO I = 1, DATA%SIZE_X
        DATA%RHEAP(INDEX_C+I) = DATA%RHEAP(INDEX_A)* &
          DATA%RHEAP(INDEX_B+I) + DATA%RHEAP(INDEX_B)*DATA%RHEAP(INDEX_A+I)
        END DO
      CASE (2)
! Function value
        DATA%RHEAP(DATA%RPTR(C%P)) = &
          DATA%RHEAP(DATA%RPTR(A%P))*DATA%RHEAP(DATA%RPTR(B%P))
! Derivative value
        DATA%RHEAP(DATA%RPTR(C%P)+1:DATA%RPTR(C%P)+DATA%SIZE_X) = &
          DATA%RHEAP(DATA%RPTR(B%P))* &
          DATA%RHEAP(DATA%RPTR(A%P)+1:DATA%RPTR(A%P)+DATA%SIZE_X) + &
          DATA%RHEAP(DATA%RPTR(A%P))*DATA%RHEAP(DATA%RPTR(B% &
          P)+1:DATA%RPTR(B%P)+DATA%SIZE_X)
        INDEX = 1 + DATA%SIZE_X
        DO I = 1, DATA%SIZE_X
!       Calculate non-diagonal elements of hessian
          DO J = 1, I - 1
            DATA%RHEAP(DATA%RPTR(C%P)+INDEX) = &
              DATA%RHEAP(DATA%RPTR(B%P))*DATA%RHEAP(DATA%RPTR(A%P)+INDEX) + &
              DATA%RHEAP(DATA%RPTR(A%P))*DATA%RHEAP(DATA%RPTR(B%P)+INDEX) + &
              (DATA%RHEAP(DATA%RPTR(A%P)+I)*DATA%RHEAP(DATA%RPTR(B%P)+J)+&
              DATA%RHEAP(DATA%RPTR(A%P)+J)*DATA%RHEAP(DATA%RPTR(B%P)+I))
            INDEX = INDEX + 1
          END DO
!       Calculate diagonal element of hessian
          DATA%RHEAP(DATA%RPTR(C%P)+INDEX) = &
            DATA%RHEAP(DATA%RPTR(A%P)+INDEX)*DATA%RHEAP(DATA%RPTR(B%P)) + &
            DATA%RHEAP(DATA%RPTR(B%P)+INDEX)*DATA%RHEAP(DATA%RPTR(A%P)) + &
            DATA%RHEAP(DATA%RPTR(B%P)+I)*DATA%RHEAP(DATA%RPTR(A%P)+I)
          INDEX = INDEX + 1
        END DO
      CASE DEFAULT
! set up information block on iheap
        ALLOCATE(MI(0:DATA%LEVEL+1,4))
        P(1) = DATA%RPTR(A%P)
        P(2) = DATA%RPTR(B%P)
        P(3) = DATA%RPTR(C%P)
! Set result to zero
        DATA%RHEAP(P(3):P(3)+DATA%REAL_STRUCT_SIZE-1) = 0.0_WP
! Start loop over first structure
        MI(0,1) = 0
        DO L1 = 0, DATA%REAL_STRUCT_SIZE - 1
          V1 = DATA%RHEAP(P(1)+L1)
! Start loop over second structure
          MI(0,2) = 0
          DO L2 = 0, DATA%REAL_STRUCT_SIZE - 1
            IF (MI(0,1)+MI(0,2)>LEVEL) EXIT
            CALL MIMERU(MI(1:MI(0,1),1),MI(1:MI(0,2),2),MI(0:LEVEL+1,3))
            PR = IRPOS(MI(0:LEVEL+1,3),DATA%SIZE_X,DATA) + P(3)
            DATA%RHEAP(PR) = DATA%RHEAP(PR) + V1*DATA%RHEAP(P(2)+L2)
            CALL MIINC(LEVEL,MI(0:LEVEL+1,2),DATA%SIZE_X)
          END DO
          CALL MIINC(LEVEL,MI(0:LEVEL+1,1),DATA%SIZE_X)
        END DO
! All done!  Now move result down
      END SELECT

    ELSE
      ALLOCATE(LVARS(0:DATA%SIZE_X),IREF1(DATA%SIZE_X),IREF2(DATA%SIZE_X))
      I1 = DATA%IPONT(A%P)
      I2 = DATA%IPONT(B%P)
      CALL MERGE(I1,I2,N(1),N(2),A%DATA,LVARS,IREF1,IREF2)
      N(3) = LVARS(0)
      CALL GETMEM(N(3),DATA%IBINCO(LEVEL+N(3),LEVEL),C)

! set up information block on iheap
      IR = DATA%IPONT(C%P)
      DO I = 0, N(3) - 1
        DATA%IHEAP(IR+I) = LVARS(I+1)
      END DO
      P(1) = DATA%RPTR(A%P)
      P(2) = DATA%RPTR(B%P)
      P(3) = DATA%RPTR(C%P)

! Set result to zero
      DO I = 0, DATA%RLENG(C%P) - 1
        DATA%RHEAP(P(3)+I) = 0.0_WP
      END DO

      SELECT CASE (LEVEL)

      CASE (0)
!         Function value
        DATA%RHEAP(P(3)) = DATA%RHEAP(P(1))*DATA%RHEAP(P(2))
      CASE (1)
!         Function value
        DATA%RHEAP(P(3)) = DATA%RHEAP(P(1))*DATA%RHEAP(P(2))
!         Derivative value
        DO I = 1, N(1)
          DATA%RHEAP(P(3)+IREF1(I)) = DATA%RHEAP(P(2))*DATA%RHEAP(P(1)+I)
        END DO
        DO I = 1, N(2)
          DATA%RHEAP(P(3)+IREF2(I)) = DATA%RHEAP(P(3)+IREF2(I)) + &
            DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+I)
        END DO

      CASE (2)

      ALLOCATE (INV_IREF1(DATA%SIZE_X),INV_IREF2(DATA%SIZE_X),&
         A_PRES(DATA%SIZE_X),B_PRES(DATA%SIZE_X))
        A_PRES = .FALSE.
        DO I = 1, N(1)
          A_PRES(IREF1(I)) = .TRUE.
          INV_IREF1(IREF1(I)) = I
        END DO
        B_PRES = .FALSE.
        DO I = 1, N(2)
          B_PRES(IREF2(I)) = .TRUE.
          INV_IREF2(IREF2(I)) = I
        END DO

!         Function value
        DATA%RHEAP(P(3)) = DATA%RHEAP(P(1))*DATA%RHEAP(P(2))
!         Derivative value
        DO I = 1, N(1)
          DATA%RHEAP(P(3)+IREF1(I)) = DATA%RHEAP(P(2))*DATA%RHEAP(P(1)+I)
        END DO
        DO I = 1, N(2)
          DATA%RHEAP(P(3)+IREF2(I)) = DATA%RHEAP(P(3)+IREF2(I)) + &
            DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+I)
        END DO

!         Hessian value
        INDEX_A = 1 + N(1)
        INDEX_B = 1 + N(2)
        INDEX_C = 1 + N(3)

        DO I = 1, N(3)
!       Calculate non-diagonal elements of hessian
          DO J = 1, I - 1
            DATA%RHEAP(P(3)+INDEX_C) = 0.0_WP
            IF ((A_PRES(I)) .AND. (A_PRES(J))) THEN
              DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                DATA%RHEAP(P(2))*DATA%RHEAP(P(1)+INDEX_A)
              IF (B_PRES(I)) THEN
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                  DATA%RHEAP(P(1)+INV_IREF1(J))*DATA%RHEAP(P(2)+INV_IREF2(I))
                IF (B_PRES(J)) THEN
                  DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                    DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+INDEX_B) + &
                    DATA%RHEAP(P(1)+INV_IREF1(I))*DATA%RHEAP(P(2)+INV_IREF2(J))
                  INDEX_B = INDEX_B + 1
                END IF

              ELSE IF (B_PRES(J)) THEN
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                  DATA%RHEAP(P(1)+INV_IREF1(I))*DATA%RHEAP(P(2)+INV_IREF2(J))
              END IF
              INDEX_A = INDEX_A + 1
            ELSE
              IF (A_PRES(I)) THEN
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                  DATA%RHEAP(P(1)+INV_IREF1(I))*DATA%RHEAP(P(2)+INV_IREF2(J))
                IF (B_PRES(I)) THEN
                  DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                    DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+INDEX_B)
                  INDEX_B = INDEX_B + 1
                END IF

              ELSE IF (A_PRES(J)) THEN
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                  DATA%RHEAP(P(1)+INV_IREF1(J))*DATA%RHEAP(P(2)+INV_IREF2(I))
                IF (B_PRES(J)) THEN
                  DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                    DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+INDEX_B)
                  INDEX_B = INDEX_B + 1
                END IF
              ELSE
                DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(3)+INDEX_C) + &
                  DATA%RHEAP(P(1))*DATA%RHEAP(P(2)+INDEX_B)
                INDEX_B = INDEX_B + 1
              END IF
            END IF

            INDEX_C = INDEX_C + 1

          END DO
!       Calculate diagonal element of hessian
          IF (A_PRES(I)) THEN
            IF (B_PRES(I)) THEN
              DATA%RHEAP(P(3)+INDEX_C) = &
                DATA%RHEAP(P(1)+INDEX_A)*DATA%RHEAP(P(2)) + &
                DATA%RHEAP(P(2)+INDEX_B)*DATA%RHEAP(P(1)) + &
                DATA%RHEAP(P(1)+INV_IREF1(I))* &
                DATA%RHEAP(P(2)+INV_IREF2(I))
              INDEX_A = INDEX_A + 1
              INDEX_B = INDEX_B + 1
              INDEX_C = INDEX_C + 1
            ELSE
              DATA%RHEAP(P(3)+INDEX_C) = &
                  DATA%RHEAP(P(1)+INDEX_A)*DATA%RHEAP(P(2))
              INDEX_A = INDEX_A + 1
              INDEX_C = INDEX_C + 1
            END IF
          ELSE
            DATA%RHEAP(P(3)+INDEX_C) = DATA%RHEAP(P(2)+INDEX_B)*DATA%RHEAP(P(1))
            INDEX_B = INDEX_B + 1
            INDEX_C = INDEX_C + 1
          END IF

        END DO

        DEALLOCATE (INV_IREF1,INV_IREF2,A_PRES,B_PRES)

      CASE DEFAULT

! Start loop over first structure
        ALLOCATE(MI(0:LEVEL+1,4))
        MI(0,1) = 0

        DO L1 = 0, DATA%RLENG(A%P) - 1
          V1 = DATA%RHEAP(P(1)+L1)

! Start loop over second structure
          MI(0,2) = 0

          DO L2 = 0, DATA%RLENG(B%P) - 1
            IF (MI(0,1)+MI(0,2)>LEVEL) EXIT
            CALL MIMERU &
               (IREF1(MI(1:MI(0,1),1)),IREF2(MI(1:MI(0,2),2)),MI(0:LEVEL+1,3))
            PR = IRPOS(MI(0:LEVEL+1,3),N(3),DATA) + P(3)
            DATA%RHEAP(PR) = DATA%RHEAP(PR) + V1*DATA%RHEAP(P(2)+L2)
            CALL MIINC(LEVEL,MI(0:LEVEL+1,2),N(2))
          END DO
          CALL MIINC(LEVEL,MI(0:LEVEL+1,1),N(1))
        END DO

      END SELECT
! All done!  Now move result down
      IF ((DATA%NVARS(C%P)>=DATA%SWITCH_POINT) .AND. &
        (DATA%NVARS(C%P)/=DATA%SIZE_X))  CALL SPARSE_TO_FULL(C)
      DEALLOCATE(LVARS,IREF1,IREF2)
    END IF
    CALL USED(A)
    CALL USED(B)

  END SUBROUTINE MULT


  SUBROUTINE PACCNT(V,OUT)
! Create a constant
    REAL (WP), INTENT (IN) :: V
    TYPE (AD02_REAL), INTENT (INOUT) :: OUT
    TYPE(AD02_DATA), POINTER :: DATA
    INTEGER :: MORE
    DATA => OUT%DATA

!        Set up constant structure
    MORE = 1
    IF (DATA%SWITCH_POINT<=0) MORE = DATA%REAL_STRUCT_SIZE
    IF (MORE+DATA%IRTOS>SIZE(DATA%RHEAP)) THEN
      CALL GC(0,MORE,DATA)
      IF (DATA%CASE==0) RETURN
    END IF
    IF (DATA%DEAD_POINTER==-1) THEN
      IF (DATA%IPTOS>SIZE(DATA%IPONT)) CALL MORE_MEMORY(DATA)
! Get a new variable number for variable (no dead variables)
      OUT%P = DATA%IPTOS
      DATA%IPTOS = DATA%IPTOS + 1
    ELSE
! Get old variable number number from list of dead variables
      OUT%P = DATA%DEAD_POINTER
      DATA%DEAD_POINTER = DATA%IPONT(DATA%DEAD_POINTER)
    END IF
! Make this space a temporary object
    OUT%CASE = -DATA%CASE
    DATA%RPTR(OUT%P) = DATA%IRTOS
    DATA%IRTOS = DATA%IRTOS + MORE
    DATA%RLENG(OUT%P) = MORE
    IF (DATA%SWITCH_POINT>0) THEN
! Sparse mode
! Set real information
      DATA%NVARS(OUT%P) = 0
      DATA%IPONT(OUT%P) = 0
      DATA%RHEAP(DATA%RPTR(OUT%P)) = V
    ELSE
! Full mode
      DATA%NVARS(OUT%P) = DATA%SIZE_X
      DATA%IPONT(OUT%P) = 1
      DATA%RHEAP(DATA%RPTR(OUT%P)) = V
      DATA%RHEAP(DATA%RPTR(OUT%P)+1:DATA%RPTR(OUT%P)+MORE-1) = 0.0_WP
    END IF
  END SUBROUTINE PACCNT

  SUBROUTINE SPARSE_TO_FULL(INPUT)
!  Convert sparse real structure to full real structure
    TYPE (AD02_REAL), INTENT (IN) :: INPUT
    INTEGER OLD_RPTR
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => INPUT%DATA
!     Get required memory from DATA%RHEAP
    IF (DATA%REAL_STRUCT_SIZE+DATA%IRTOS>SIZE(DATA%RHEAP)) THEN
      CALL GC(0,DATA%REAL_STRUCT_SIZE,DATA)
      IF (DATA%CASE==0) RETURN
    END IF
    OLD_RPTR = DATA%RPTR(INPUT%P)
    DATA%RPTR(INPUT%P) = DATA%IRTOS
!     Expand sparse variable structure
    DATA%RHEAP(DATA%IRTOS+1:DATA%IRTOS+DATA%REAL_STRUCT_SIZE-1) = 0.0_WP
!     Get mapping from sparse structure to full structure
    CALL EXPAND(DATA%IHEAP( &
        DATA%IPONT(INPUT%P):DATA%IPONT(INPUT%P)+DATA%NVARS(INPUT%P)-1),&
        DATA%SIZE_X, DATA)
!     Copy sparse real structure to full real structure
    DATA%RHEAP(DATA%IHEAP(DATA%SIZE_X+1:DATA%SIZE_X+DATA%RLENG(INPUT%P))+&
      DATA%IRTOS) = DATA%RHEAP(OLD_RPTR:OLD_RPTR+DATA%RLENG(INPUT%P)-1)
    DATA%RLENG(INPUT%P) = DATA%REAL_STRUCT_SIZE
    DATA%IRTOS = DATA%IRTOS + DATA%REAL_STRUCT_SIZE
    DATA%NVARS(INPUT%P) = DATA%SIZE_X
    DATA%IPONT(INPUT%P) = 1
  END SUBROUTINE SPARSE_TO_FULL

  SUBROUTINE UNARY(A,B,DERF)
! .......Declarations
    TYPE (AD02_REAL), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (OUT) :: B
    REAL (WP) :: DERF(0:*)
    INTEGER I, J, INDEX,LEVEL, NV, RECLEV, PR, PG, IG, IH, P(2), NOSAME
    REAL (WP) FACT
    TYPE(AD02_DATA), POINTER :: DATA
    INTEGER, ALLOCATABLE :: MI(:,:)
    REAL (WP), ALLOCATABLE :: RS(:) ! REAL stack
    INTEGER, ALLOCATABLE :: IS(:) ! INTEGER stack
    DATA => A%DATA
    B%DATA => DATA
    LEVEL = DATA%LEVEL

    NV = DATA%NVARS(A%P)
    IF ((A%CASE<0) .AND. (LEVEL<3)) THEN
      P(1) = DATA%RPTR(A%P)
      P(2) = P(1)
      B%P = A%P
      B%DATA => DATA
      B%CASE = A%CASE
    ELSE
      IF (NV/=DATA%SIZE_X) THEN
        CALL GETMEM(DATA%NVARS(A%P),DATA%RLENG(A%P),B)
        IG = DATA%IPONT(A%P)
        IH = DATA%IPONT(B%P)
        DATA%NVARS(B%P) = NV
!       DATA%IHEAP(IH:IH+NV-1) = DATA%IHEAP(IG:IG+NV-1)
        DO I = 1,NV
           DATA%IHEAP(IH+I-1) = DATA%IHEAP(IG+I-1)
        END DO
      ELSE
        CALL GETMEM(0,DATA%RLENG(A%P),B)
      END IF
      P(1) = DATA%RPTR(A%P)
      P(2) = DATA%RPTR(B%P)
    END IF
    SELECT CASE (LEVEL)
    CASE (0)
! Function value
      DATA%RHEAP(P(2)) = DERF(0)
    CASE (1)
! Derivative value
!     DATA%RHEAP(P(2)+1:P(2)+NV) = DATA%RHEAP(P(1)+1:P(1)+NV)*DERF(1)
      DO I = 1,NV
         DATA%RHEAP(P(2)+I) = DATA%RHEAP(P(1)+I)*DERF(1)
      END DO
! Function value
      DATA%RHEAP(P(2)) = DERF(0)
    CASE (2)
      INDEX = NV
      DO I = 1, NV
!       Calculate non-diagonal elements of hessian
        DO J = 1, I - 1
          INDEX = INDEX + 1
          DATA%RHEAP(P(2)+INDEX)=DERF(2)*DATA%RHEAP(P(1)+I)*DATA%RHEAP(P(1)+J)&
            + DERF(1)*DATA%RHEAP(P(1)+INDEX)
        END DO
        INDEX = INDEX + 1
!       Calculate diagonal element of hessian
        DATA%RHEAP(P(2)+INDEX) = 0.5_WP*DERF(2)*DATA%RHEAP(P(1)+I)**2 + &
          DERF(1)*DATA%RHEAP(P(1)+INDEX)
      END DO
! Derivative value
!     DATA%RHEAP(P(2)+1:P(2)+NV) = DATA%RHEAP(P(1)+1:P(1)+NV)*DERF(1)
      DO I = 1,NV
         DATA%RHEAP(P(2)+I) = DATA%RHEAP(P(1)+I)*DERF(1)
      END DO
! Function value
      DATA%RHEAP(P(2)) = DERF(0)

    CASE DEFAULT
      ALLOCATE(MI(0:LEVEL+1,4),IS((LEVEL+1)*(2*LEVEL*5)),RS(LEVEL+1))
      DATA%RHEAP(P(2)) = DERF(0)
      IF (NV/=0) THEN
! .......Set answer to zero
! zero answer
        DO I = 1, DATA%RLENG(B%P) - 1
          DATA%RHEAP(P(2)+I) = 0.0_WP
        END DO
! .end
! .......Initialize recursion
! start recursive procedure
        RECLEV = 1
        MI = 0
        MI(0,2) = 1
        MI(1,2) = 1
        PG = 1
        NOSAME = 1
        FACT = 1.0_WP
! .end
! begin recursion
        DO
          DO
            IF (MI(0,1)+MI(0,2)<=LEVEL) THEN
              CALL MIMERU(MI(1:MI(0,1),1),MI(1:MI(0,2),2),MI(0:LEVEL+1,3))
! .......Save items on stack

! save items on stack
              CALL UPUSH(LEVEL,MI(0:LEVEL+1,1),MI(0:LEVEL+1,2),&
                   PG,FACT,RECLEV,IS,RS)
! .end

! .......Accumulate answer
! add on contribution to answer
              FACT = FACT*DATA%RHEAP(P(1)+PG)/NOSAME
              PR = IRPOS(MI(0:LEVEL+1,3),NV,DATA) + P(2)
              DATA%RHEAP(PR) = DATA%RHEAP(PR) + FACT*DERF(RECLEV)
! .......Increase recursion depth
              DO I = 0, MI(0,3)
                MI(I,1) = MI(I,3)
              END DO

              RECLEV = RECLEV + 1
              NOSAME = NOSAME + 1
            ELSE
              EXIT
            END IF
! .end
          END DO

! Drop down one level
          RECLEV = RECLEV - 1
          CALL UPOP(LEVEL,MI(0:LEVEL+1,1),MI(0:LEVEL+1,2),PG,FACT,RECLEV,IS,RS)
          NOSAME = 1
! Try next element from g
          CALL MIINC(LEVEL,MI(0:LEVEL+1,2),NV)
          PG = PG + 1
          IF (MI(0,2)>LEVEL) EXIT
        END DO

      END IF
      CALL USED(A)
      DEALLOCATE(MI,IS,RS)

    END SELECT

  END SUBROUTINE UNARY

  SUBROUTINE UNARY_WARNING(FUN,A,PROC)
    TYPE (AD02_REAL), INTENT (OUT) :: FUN
    TYPE (AD02_REAL), INTENT (IN) :: A
    CHARACTER(*), OPTIONAL, INTENT(IN) :: PROC
    CALL ERROR_HANDLER(A%DATA,UNDEF_WARN,PROC)
    FUN%DATA => A%DATA
  END SUBROUTINE UNARY_WARNING

  LOGICAL FUNCTION UNDEFINED(X)
    TYPE (AD02_REAL), INTENT (IN) :: X
    IF(ASSOCIATED(X%DATA))THEN
      UNDEFINED = X%DATA%CASE==-1
    ELSE
      UNDEFINED = .TRUE.
    END IF
  END FUNCTION UNDEFINED

  SUBROUTINE UNDEFINE_REAL0(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    IF(PRESENT(DATA))then
       F%DATA => DATA
       IF(ASSOCIATED(DATA)) F%CASE = DATA%CASE
    ELSE
       NULLIFY(F%DATA)
       F%CASE = 0
    END IF
    F%P = -1
  END SUBROUTINE UNDEFINE_REAL0

  SUBROUTINE UNDEFINE_REAL1(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F)
      CALL AD02_UNDEFINE(F(I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL1

  SUBROUTINE UNDEFINE_REAL2(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,2)
      CALL AD02_UNDEFINE(F(:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL2

  SUBROUTINE UNDEFINE_REAL3(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,3)
      CALL AD02_UNDEFINE(F(:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL3

  SUBROUTINE UNDEFINE_REAL4(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,4)
      CALL AD02_UNDEFINE(F(:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL4

  SUBROUTINE UNDEFINE_REAL5(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,5)
      CALL AD02_UNDEFINE(F(:,:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL5

  SUBROUTINE UNDEFINE_REAL6(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,6)
      CALL AD02_UNDEFINE(F(:,:,:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL6

  SUBROUTINE UNDEFINE_REAL7(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,7)
      CALL AD02_UNDEFINE(F(:,:,:,:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL7

  SUBROUTINE UPOP(LEVEL,MI1,MI2,PG,FACT,RECLEV,IS,RS)
! Pop the given data off the stack
    INTEGER, INTENT (IN) :: LEVEL
    INTEGER, INTENT (OUT) :: MI1(0:LEVEL+1), MI2(0:LEVEL+1), PG
    INTEGER, INTENT (IN) :: RECLEV
    REAL (WP), INTENT (OUT) :: FACT
    INTEGER, INTENT (INOUT) :: IS(*)
    REAL (WP), INTENT (INOUT) :: RS(*)
    INTEGER I, J, WHERE
    J = 2*(LEVEL+1)
    WHERE = (RECLEV-1)*(J+1) + 1
    FACT = RS(RECLEV)
    DO I = 0, LEVEL
      MI1(I) = IS(WHERE+I)
      MI2(I) = IS(WHERE+LEVEL+1+I)
    END DO
    PG = IS(WHERE+J)
  END SUBROUTINE UPOP


  SUBROUTINE UPOW(A,P,B)
! Raise to a constant power.
    TYPE (AD02_REAL), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (INOUT) :: B
    REAL (WP), INTENT (IN) :: P
    INTEGER I,LEVEL
    REAL (WP) VG, D, T
    TYPE(AD02_DATA), POINTER :: DATA
    REAL (WP), ALLOCATABLE :: DERF(:)
    DATA => A%DATA
    ALLOCATE(DERF(0:DATA%LEVEL+4))
    LEVEL = DATA%LEVEL
    VG = DATA%RHEAP(DATA%RPTR(A%P))
! Special case when VG = 0.
    IF (VG==0.0_WP) THEN
      IF (P==ANINT(P)) THEN
        IF (NINT(P)>=0 .AND. NINT(P)<=LEVEL) THEN
          D = 1.0_WP
          DO I = 0, NINT(P) - 1
            D = D*(NINT(P)-I)
            DERF(I) = 0.0_WP
          END DO
          DERF(NINT(P)) = D
          DO I = NINT(P) + 1, LEVEL
            DERF(I) = 0.0_WP
          END DO
          CALL UNARY(A,B,DERF)
          RETURN
        END IF
      END IF
      DERF(0:LEVEL) = 0.0_WP
      CALL UNARY(A,B,DERF)
      RETURN
    END IF

    T = P
! This bit is intended to cope with (-ve)**p.  When p is an `integer',
! then it might be OK if done in integer arithmetic, but won't be when
! done in floating point.
    IF (VG<0.0) THEN
      IF (P==ANINT(P)) THEN
        D = VG**INT(P)
      ELSE
        D = VG**P
      END IF
    ELSE
      D = VG**P
    END IF
    DERF(0) = D
    DO I = 1, LEVEL
      D = D*T/VG
      T = T - 1.0_WP
      DERF(I) = D
    END DO
    CALL UNARY(A,B,DERF)
    DEALLOCATE(DERF)
  END SUBROUTINE UPOW

  SUBROUTINE UPUSH(LEVEL,MI1,MI2,PG,FACT,RECLEV,IS,RS)
! Push the given data on the stack
    INTEGER, INTENT (IN) :: LEVEL
    INTEGER, INTENT (IN) :: MI1(0:LEVEL+1), MI2(0:LEVEL+1), PG, RECLEV
    REAL (WP), INTENT (IN) :: FACT
    INTEGER, INTENT (INOUT) :: IS(*)
    REAL (WP), INTENT (INOUT) :: RS(*)
    INTEGER I, J, WHERE
    J = 2*(LEVEL+1)
    WHERE = (RECLEV-1)*(J+1) + 1
    RS(RECLEV) = FACT
    DO I = 0, LEVEL
      IS(WHERE+I) = MI1(I)
      IS(WHERE+LEVEL+1+I) = MI2(I)
    END DO
    IS(WHERE+J) = PG
  END SUBROUTINE UPUSH

  SUBROUTINE USED(A)
    TYPE (AD02_REAL) :: A
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    IF (A%CASE<0) THEN
      DATA%IPONT(A%P) = DATA%DEAD_POINTER
      DATA%DEAD_POINTER = A%P
    END IF
  END SUBROUTINE USED

  SUBROUTINE USER(D,X,F,NAME)
! A user-defined unary function
    TYPE (AD02_REAL), INTENT (IN) :: X
    TYPE (AD02_REAL), INTENT (OUT) :: F
    REAL (WP), INTENT (IN) :: D(0:)
    CHARACTER (LEN=*), INTENT (IN), OPTIONAL :: NAME
    INTEGER I
    REAL (WP), ALLOCATABLE :: DERF(:)
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      IF (PRESENT(NAME)) THEN
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,NAME)
      ELSE
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AD02_USER')
      END IF
      F%P = -1
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      IF (PRESENT(NAME)) THEN
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,NAME)
      ELSE
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AD02_USER')
      END IF
      F%P = -1
    ELSE
      ALLOCATE(DERF(0:DATA%LEVEL+4))
      DO I = 0, DATA%LEVEL
        DERF(I) = D(I)
      END DO
      CALL UNARY(X,F,DERF)
      DEALLOCATE(DERF)
    END IF
  END SUBROUTINE USER

! Returns the value of an AD02_REAL variable
  SUBROUTINE VALUE_SCALAR(A,VALUE,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: VALUE
    INTEGER, INTENT (OUT) :: ERROR
    ! 0 Successful
    ! 1 Undefined
    ! 2 Data undefined
    TYPE(AD02_DATA), POINTER :: DATA
    VALUE = 0.0_WP
    ERROR = 0
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    END IF
    IF(ERROR>0)RETURN

    DATA => A%DATA
    VALUE = DATA%RHEAP(DATA%RPTR(A%P))
  END SUBROUTINE VALUE_SCALAR

! Returns the values of an one-dimensional array of AD02_REAL variables
  SUBROUTINE VALUE_ARRAY(A,VALUE,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A(:)
    REAL (WP), INTENT (OUT) :: VALUE(:)
    INTEGER, INTENT (OUT) :: ERROR
    ! 0 Successful
    ! 1 An element is undefined
    ! 2 An element is data undefined
    INTEGER I,ERR
    ERROR = 0
    IF (SIZE(A)/=SIZE(VALUE)) ERROR = 5
    DO I = 1, MIN(SIZE(VALUE),SIZE(A))
       CALL VALUE_SCALAR(A(I),VALUE(I),ERR)
       IF(ERR>0)ERROR = ERR
    END DO
  END SUBROUTINE VALUE_ARRAY

END MODULE HSL_AD02_FORWARD_DOUBLE
! COPYRIGHT (c) 1995 Council for the Central Laboratory
!         of the Research Councils, RMCS, and NAG
! 7 November 2001 Made threadsafe.

MODULE HSL_AD02_BACKWARD_DOUBLE
! This module allows small changes to be made to a program to convert it
! to one that calculates the derivatives of variables with respect to
! other variables.

  IMPLICIT NONE
  PRIVATE

  INTEGER, PARAMETER :: WP = KIND(0D0) ! Type of real we are using
  REAL (WP), PARAMETER :: D0 = 0.0_WP, D1 = 1.0_WP, D2 = 2.0_WP
! The size that MAX_NODES is initialized to
  INTEGER, PARAMETER :: INIT_MAX_NODES = 10000

! Data structure for graph node
  TYPE NODE
    REAL (WP) RVAL ! Value of variable at node I
    REAL (WP) RVALS(0:1) ! The derivatives of node w.r.t. operands
    INTEGER ONUM ! No. of variables on which node  depends
    INTEGER IPTRS(0:1) ! Node numbers of operands
  END TYPE NODE
  PUBLIC NODE  !!?????

!     Parameter used in LOG10 routine
  REAL (WP) LN10 ! is set to the value LOG(10.0_WP) in INITIALIZE
!     Parameters that define which errors/warnings have occurred
  INTEGER, PARAMETER :: INIT_ERR = 1
  INTEGER, PARAMETER :: NO_INIT_ERR = 2
  INTEGER, PARAMETER :: ALLOC_ERR = 3
  INTEGER, PARAMETER :: SQRT_ERR = 5
  INTEGER, PARAMETER :: POW1_ERR = 6
  INTEGER, PARAMETER :: POW2_ERR = 7
  INTEGER, PARAMETER :: SIGN_WARN = 8
  INTEGER, PARAMETER :: ABS_WARN = 9
  INTEGER, PARAMETER :: INT_WARN = 10
  INTEGER, PARAMETER :: AINT_WARN = 11
  INTEGER, PARAMETER :: NINT_WARN = 12
  INTEGER, PARAMETER :: ANINT_WARN = 13
  INTEGER, PARAMETER :: MAX_WARN = 14
  INTEGER, PARAMETER :: MIN_WARN = 15
  INTEGER, PARAMETER :: EQ_WARN = 16
  INTEGER, PARAMETER :: NE_WARN = 17
  INTEGER, PARAMETER :: GT_WARN = 18
  INTEGER, PARAMETER :: LT_WARN = 19
  INTEGER, PARAMETER :: GE_WARN = 20
  INTEGER, PARAMETER :: LE_WARN = 21
  INTEGER, PARAMETER :: UNDEF_WARN = 33
  INTEGER, PARAMETER :: ASSIGNMENT_WARN = 34

! Error Flags and error handling
    INTEGER :: AD02_FLAG(40)=0  ! Error/warning flags
    INTEGER :: ERROR_MESSAGE_UNIT=6  ! Output unit for errors
    INTEGER :: WARNING_MESSAGE_UNIT=6  ! Output unit for warnings
    INTEGER :: ERROR_PRINT_LEVEL=1   ! Controls printing of messages
    INTEGER :: ERROR_STOP_LEVEL=1   ! Controls execution after error/warn

! Data structure for AD02_DATA in backwards method
  TYPE, PUBLIC :: AD02_DATA
!????    PRIVATE
    INTEGER :: LEVEL = -1 ! Highest degree of derivatives reqd.
! Error Flags and error handling
    INTEGER, POINTER :: FLAGS(:)=>NULL()  ! Error/warning flags
    INTEGER :: ERROR_MESSAGE_UNIT = 6  ! Output unit for errors
    INTEGER :: WARNING_MESSAGE_UNIT = 6  ! Output unit for warnings
    INTEGER :: ERROR_PRINT_LEVEL = 1  ! Controls printing of messages
    INTEGER :: ERROR_STOP_LEVEL = 1  ! Controls execution after error/warn
! Computional graph
    TYPE (NODE), POINTER :: GRAPH(:)=>NULL() ! Computional graph
    REAL (WP), POINTER :: DER2(:,:)=>NULL() ! Second derivatives
    INTEGER :: MAX_NODES = 0 ! Size of RVAL, ONUM, ...etc
    INTEGER :: MAX_NODES2 = 0 ! Size of DER2
    INTEGER NUM_NODES ! No. of nodes in computational graph
    INTEGER SIZE_X ! The no. of independent variables
    INTEGER :: CASE = -1 ! 0  if in motoring mode;
                         ! -1 if undefined (finalized)
    INTEGER :: MAX_CASE = 1 ! Largest case value used
  END TYPE AD02_DATA

! Type definition for new type AD02_REAL
  TYPE, PUBLIC :: AD02_REAL
    PRIVATE
    INTEGER :: P = -1 ! Pointer to position in ARRAYS.
    INTEGER :: CASE ! Negative for a temporary variable
    TYPE(AD02_DATA), POINTER :: DATA => NULL()
    ! Variable V of this type is data-undefined if V%DATA has a
    !     target and either V%P = -1 or ABS(V%CASE) /= V%DATA%CASE
    ! Variable V of this type is undefined if V%DATA has no target
    ! If V%P/= -1, V%DATA is associated
  END TYPE AD02_REAL


!     Redefine the operators (+, -, * , /, **, .EQ., .NE., .LT.,
!    .GT., .LE., .GE. and assignment(=)) to work with type AD02_REAL

  INTERFACE OPERATOR (+)
    MODULE PROCEDURE ADD_DD, ADD_RD, ADD_DR, ADD_ID, ADD_DI
    MODULE PROCEDURE ADD_DS, ADD_SD
  END INTERFACE
  PUBLIC OPERATOR (+)

  INTERFACE OPERATOR (-)
    MODULE PROCEDURE MINUS_D, MINUS_DD, MINUS_RD, MINUS_DR
    MODULE PROCEDURE MINUS_ID, MINUS_DI
    MODULE PROCEDURE MINUS_DS, MINUS_SD
  END INTERFACE
  PUBLIC OPERATOR (-)

  INTERFACE OPERATOR (*)
    MODULE PROCEDURE MULT_DD, MULT_RD, MULT_DR, MULT_ID, MULT_DI
    MODULE PROCEDURE MULT_DS, MULT_SD
  END INTERFACE
  PUBLIC OPERATOR (*)

  INTERFACE OPERATOR (/)
    MODULE PROCEDURE DIV_DD, DIV_RD, DIV_DR, DIV_ID, DIV_DI
    MODULE PROCEDURE DIV_DS, DIV_SD
  END INTERFACE
  PUBLIC OPERATOR (/)

  INTERFACE OPERATOR (**)
    MODULE PROCEDURE POW_DD, POW_RD, POW_DR, POW_DI, POW_ID
    MODULE PROCEDURE POW_DS, POW_SD
  END INTERFACE
  PUBLIC OPERATOR (**)

  INTERFACE OPERATOR (==)
    MODULE PROCEDURE EQ_DD, EQ_RD, EQ_DR, EQ_ID, EQ_DI
    MODULE PROCEDURE EQ_DS, EQ_SD
  END INTERFACE
  PUBLIC OPERATOR (==)

  INTERFACE OPERATOR (<=)
    MODULE PROCEDURE LE_DD, LE_RD, LE_DR, LE_ID, LE_DI
    MODULE PROCEDURE LE_DS, LE_SD
  END INTERFACE
  PUBLIC OPERATOR (<=)

  INTERFACE OPERATOR (<)
    MODULE PROCEDURE LT_DD, LT_RD, LT_DR, LT_DI, LT_ID
    MODULE PROCEDURE LT_DS, LT_SD
  END INTERFACE
  PUBLIC OPERATOR (<)

  INTERFACE OPERATOR (>=)
    MODULE PROCEDURE GE_DD, GE_RD, GE_DR, GE_ID, GE_DI
    MODULE PROCEDURE GE_DS, GE_SD
  END INTERFACE
  PUBLIC OPERATOR (>=)

  INTERFACE OPERATOR (>)
    MODULE PROCEDURE GT_DD, GT_RD, GT_DR, GT_DI, GT_ID
    MODULE PROCEDURE GT_DS, GT_SD
  END INTERFACE
  PUBLIC OPERATOR (>)

  INTERFACE OPERATOR (/=)
    MODULE PROCEDURE NE_DD, NE_RD, NE_DR, NE_ID, NE_DI
    MODULE PROCEDURE NE_DS, NE_SD
  END INTERFACE
  PUBLIC OPERATOR (/=)

  INTERFACE ASSIGNMENT (=)
    MODULE PROCEDURE ASSIGN_DR, ASSIGN_DD, ASSIGN_DI, ASSIGN_ID
    MODULE PROCEDURE ASSIGN_DS
    MODULE PROCEDURE ASSIGN_DD1, ASSIGN_DD2, ASSIGN_DD3
    MODULE PROCEDURE ASSIGN_DD4, ASSIGN_DD5, ASSIGN_DD6, ASSIGN_DD7
    MODULE PROCEDURE ASSIGN_DD10, ASSIGN_DD20, ASSIGN_DD30
    MODULE PROCEDURE ASSIGN_DD40, ASSIGN_DD50, ASSIGN_DD60, ASSIGN_DD70
  END INTERFACE
  PUBLIC ASSIGNMENT (=)

!     Interfaces to AD02 routines

  INTERFACE AD02_CONTROL
    MODULE PROCEDURE CONTROL1,CONTROL2
  END INTERFACE
  PUBLIC AD02_CONTROL

  INTERFACE AD02_DATA_UNDEFINED
    MODULE PROCEDURE DATA_UNDEFINED
  END INTERFACE
  PUBLIC AD02_DATA_UNDEFINED

  INTERFACE AD02_DERIVS
    MODULE PROCEDURE DERIVS_S
  END INTERFACE
  PUBLIC AD02_DERIVS

  INTERFACE AD02_FINALIZE_DATA
    MODULE PROCEDURE FINALIZE
  END INTERFACE
  PUBLIC AD02_FINALIZE_DATA

  INTERFACE AD02_FLAGS
    MODULE PROCEDURE FLAGS1,FLAGS2,FLAGS3,FLAGS4
  END INTERFACE
  PUBLIC AD02_FLAGS

  INTERFACE AD02_GRAD
    MODULE PROCEDURE GRAD0, GRAD1
  END INTERFACE
  PUBLIC AD02_GRAD

  INTERFACE AD02_HESSIAN
    MODULE PROCEDURE HESSIAN0, HESSIAN1
  END INTERFACE
  PUBLIC AD02_HESSIAN

  INTERFACE AD02_INITIALIZE_COMP
    MODULE PROCEDURE INITIALIZE_0, INITIALIZE_11, INITIALIZE_10
  END INTERFACE
  PUBLIC AD02_INITIALIZE_COMP

  INTERFACE AD02_INITIALIZE_DATA
    MODULE PROCEDURE INITIALIZE_DATA
  END INTERFACE
  PUBLIC AD02_INITIALIZE_DATA

  INTERFACE AD02_TEMP
    MODULE PROCEDURE MAKE_TEMP
  END INTERFACE
  PUBLIC AD02_TEMP

  INTERFACE AD02_UNDEFINE
    MODULE PROCEDURE UNDEFINE_REAL0, UNDEFINE_REAL1
    MODULE PROCEDURE UNDEFINE_REAL2, UNDEFINE_REAL3
    MODULE PROCEDURE UNDEFINE_REAL4, UNDEFINE_REAL5
    MODULE PROCEDURE UNDEFINE_REAL6, UNDEFINE_REAL7
  END INTERFACE
  PUBLIC AD02_UNDEFINE

  INTERFACE AD02_UNDEFINED
    MODULE PROCEDURE UNDEFINED
  END INTERFACE
  PUBLIC AD02_UNDEFINED

  INTERFACE AD02_USER
    MODULE PROCEDURE USER
  END INTERFACE
  PUBLIC AD02_USER

  INTERFACE AD02_VALUE
    MODULE PROCEDURE VALUE_SCALAR, VALUE_ARRAY
  END INTERFACE
  PUBLIC AD02_VALUE

!     Intrinsic functions which now work with Type AD02_REAL

  INTERFACE ABS
    MODULE PROCEDURE ABS_D
  END INTERFACE
  PUBLIC ABS

  INTERFACE ACOS
    MODULE PROCEDURE ACOS_D
  END INTERFACE
  PUBLIC ACOS

  INTERFACE AINT
    MODULE PROCEDURE AINT_D
  END INTERFACE
  PUBLIC AINT

  INTERFACE ANINT
    MODULE PROCEDURE ANINT_D
  END INTERFACE
  PUBLIC ANINT

  INTERFACE ASIN
    MODULE PROCEDURE ASIN_D
  END INTERFACE
  PUBLIC ASIN

  INTERFACE ATAN
    MODULE PROCEDURE ATAN_D
  END INTERFACE
  PUBLIC ATAN

  INTERFACE ATAN2
    MODULE PROCEDURE ATAN2_DD, ATAN2_RD, ATAN2_DR
    MODULE PROCEDURE ATAN2_DS, ATAN2_SD
  END INTERFACE
  PUBLIC ATAN2

  INTERFACE COS
    MODULE PROCEDURE COS_D
  END INTERFACE
  PUBLIC COS

  INTERFACE COSH
    MODULE PROCEDURE COSH_D
  END INTERFACE
  PUBLIC COSH

  INTERFACE EXP
    MODULE PROCEDURE EXP_D
  END INTERFACE
  PUBLIC EXP

  INTERFACE INT
    MODULE PROCEDURE INT_D
  END INTERFACE
  PUBLIC INT

  INTERFACE LOG10
    MODULE PROCEDURE LOG10_D
  END INTERFACE
  PUBLIC LOG10

  INTERFACE LOG
    MODULE PROCEDURE LOG_D
  END INTERFACE
  PUBLIC LOG

  INTERFACE MAX
    MODULE PROCEDURE MAX_DD, MAX_DR, MAX_RD
    MODULE PROCEDURE MAX_DS, MAX_SD
  END INTERFACE
  PUBLIC MAX

  INTERFACE MIN
    MODULE PROCEDURE MIN_DD, MIN_DR, MIN_RD
    MODULE PROCEDURE MIN_DS, MIN_SD
  END INTERFACE
  PUBLIC MIN

  INTERFACE NINT
    MODULE PROCEDURE NINT_D
  END INTERFACE
  PUBLIC NINT

  INTERFACE SIGN
    MODULE PROCEDURE SIGN_DD, SIGN_DR, SIGN_RD
    MODULE PROCEDURE SIGN_DS, SIGN_SD
  END INTERFACE
  PUBLIC SIGN

  INTERFACE SIN
    MODULE PROCEDURE SIN_D
  END INTERFACE
  PUBLIC SIN

  INTERFACE SINH
    MODULE PROCEDURE SINH_D
  END INTERFACE
  PUBLIC SINH

  INTERFACE SQRT
    MODULE PROCEDURE SQRT_D
  END INTERFACE
  PUBLIC SQRT

  INTERFACE TAN
    MODULE PROCEDURE TAN_D
  END INTERFACE
  PUBLIC TAN

  INTERFACE TANH
    MODULE PROCEDURE TANH_D
  END INTERFACE
  PUBLIC TANH

! Interfaces for double precision version

  INTERFACE DABS
    MODULE PROCEDURE ABS_D
  END INTERFACE
  PUBLIC DABS

  INTERFACE DACOS
    MODULE PROCEDURE ACOS_D
  END INTERFACE
  PUBLIC DACOS

  INTERFACE DASIN
    MODULE PROCEDURE ASIN_D
  END INTERFACE
  PUBLIC DASIN

  INTERFACE DATAN
    MODULE PROCEDURE ATAN_D
  END INTERFACE
  PUBLIC DATAN

  INTERFACE DATAN2
    MODULE PROCEDURE ATAN2_DD, ATAN2_RD, ATAN2_DR
    MODULE PROCEDURE ATAN2_DS, ATAN2_SD
  END INTERFACE
  PUBLIC DATAN2

  INTERFACE DBLE
    MODULE PROCEDURE REAL_D
  END INTERFACE
  PUBLIC DBLE

  INTERFACE DCOS
    MODULE PROCEDURE COS_D
  END INTERFACE
  PUBLIC DCOS

  INTERFACE DCOSH
    MODULE PROCEDURE COSH_D
  END INTERFACE
  PUBLIC DCOSH

  INTERFACE DEXP
    MODULE PROCEDURE EXP_D
  END INTERFACE
  PUBLIC DEXP

  INTERFACE DINT
    MODULE PROCEDURE AINT_D
  END INTERFACE
  PUBLIC DINT

  INTERFACE DLOG10
    MODULE PROCEDURE LOG10_D
  END INTERFACE
  PUBLIC DLOG10

  INTERFACE DLOG
    MODULE PROCEDURE LOG_D
  END INTERFACE
  PUBLIC DLOG

  INTERFACE DMAX1
    MODULE PROCEDURE MAX_DD, MAX_DR, MAX_RD
    MODULE PROCEDURE MAX_DS, MAX_SD
  END INTERFACE
  PUBLIC DMAX1

  INTERFACE DMIN1
    MODULE PROCEDURE MIN_DD, MIN_DR, MIN_RD
    MODULE PROCEDURE MIN_DS, MIN_SD
  END INTERFACE
  PUBLIC DMIN1

  INTERFACE DNINT
    MODULE PROCEDURE ANINT_D
  END INTERFACE
  PUBLIC DNINT

  INTERFACE DSIGN
    MODULE PROCEDURE SIGN_DD, SIGN_DR, SIGN_RD
    MODULE PROCEDURE SIGN_DS, SIGN_SD
  END INTERFACE
  PUBLIC DSIGN

  INTERFACE DSIN
    MODULE PROCEDURE SIN_D
  END INTERFACE
  PUBLIC DSIN

  INTERFACE DSINH
    MODULE PROCEDURE SINH_D
  END INTERFACE
  PUBLIC DSINH

  INTERFACE DSQRT
    MODULE PROCEDURE SQRT_D
  END INTERFACE
  PUBLIC DSQRT

  INTERFACE DTAN
    MODULE PROCEDURE TAN_D
  END INTERFACE
  PUBLIC DTAN

  INTERFACE DTANH
    MODULE PROCEDURE TANH_D
  END INTERFACE
  PUBLIC DTANH

  INTERFACE IDINT
    MODULE PROCEDURE INT_D
  END INTERFACE
  PUBLIC IDINT

  INTERFACE IDNINT
    MODULE PROCEDURE NINT_D
  END INTERFACE
  PUBLIC IDNINT


CONTAINS

! Abs
  FUNCTION ABS_D(A)
    TYPE (AD02_REAL) :: ABS_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA, DERF
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    ABS_D%DATA => DATA
! Check for undefined variable input
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(ABS_D,A,'ABS')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(ABS_D,A,'ABS')
    ELSE
      ABS_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      IF (VA<0.0_WP) THEN
        IF (A%CASE<0) THEN
!          No need to create a new graph node simply alter
!           derivative values of the node - DATA%GRAPH(A%P)
          DATA%GRAPH(A%P)%RVAL = -VA
          ABS_D%P = A%P
          IF (DATA%GRAPH(A%P)%ONUM==2) THEN
            DATA%GRAPH(A%P)%RVALS = -DATA%GRAPH(A%P)%RVALS
            IF (DATA%LEVEL==2) DATA%DER2(:,A%P)  = -DATA%DER2(:,A%P)
          ELSE
            IF (DATA%LEVEL==2) THEN
              DATA%GRAPH(A%P)%RVALS = -DATA%GRAPH(A%P)%RVALS
            ELSE
              DATA%GRAPH(A%P)%RVALS(0) = -DATA%GRAPH(A%P)%RVALS(0)
            END IF
          END IF
        ELSE
          ABS_D%P = DATA%NUM_NODES
!         DATA%GRAPH(DATA%NUM_NODES) = NODE(ABS(VA),(/-D1,0.0_WP/),1,(/A%P,0/))
          DATA%GRAPH(DATA%NUM_NODES)%RVAL = ABS(VA)
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = -D1
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
          DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
          IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE IF (VA>0.0_WP) THEN
        ABS_D = A
      ELSE
!         Check for ABS(0)
        CALL ERROR_HANDLER(DATA,ABS_WARN)
!         Give DERF a random number in the range (-1,1)
        CALL RANDOM_NUMBER(DERF)
        DERF = (DERF-0.5_WP)*2.0_WP
        IF (A%CASE<0) THEN
!          No need to create a new graph node simply alter
!           derivative values of the node - DATA%GRAPH(A%P)
          ABS_D%P = A%P
          DATA%GRAPH(A%P)%RVAL = DATA%GRAPH(A%P)%RVAL*DERF
          IF (DATA%GRAPH(A%P)%ONUM==2) THEN
            DATA%GRAPH(A%P)%RVALS = DATA%GRAPH(A%P)%RVALS*DERF
            IF (DATA%LEVEL==2) DATA%DER2(:,A%P) = DATA%DER2(:,A%P)*DERF
          ELSE
            IF (DATA%LEVEL==2) THEN
              DATA%GRAPH(A%P)%RVALS = DATA%GRAPH(A%P)%RVALS*DERF
            ELSE
              DATA%GRAPH(A%P)%RVALS(0) = DATA%GRAPH(A%P)%RVALS(0)*DERF
            END IF
          END IF
        ELSE
!         Create new node in computational graph
          ABS_D%P = DATA%NUM_NODES
!         DATA%GRAPH(DATA%NUM_NODES) = NODE(ABS(VA),(/DERF,0.0_WP/),1,(/A%P,0/))
          DATA%GRAPH(DATA%NUM_NODES)%RVAL = ABS(VA)
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = DERF
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
          DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
          IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION ABS_D

! Acos
  FUNCTION ACOS_D(X)
    TYPE (AD02_REAL) :: ACOS_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA, V, V2
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    ACOS_D%DATA => DATA
! Check for undefined variable input
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ACOS_D,X,'ACOS')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ACOS_D,X,'ACOS')
    ELSE
      ACOS_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      V = (D1-VA**2)
      V2 = SQRT(V)
      IF (DATA%LEVEL==2) THEN
        IF (X%CASE<0) THEN
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,ACOS(VA),X%P,-D1/V2,-VA/(V2*V),ACOS_D)
        ELSE
!           Create new node in computational graph
          ACOS_D%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES)%RVAL = ACOS(VA)
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = -D1/V2
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = -VA/(V2*V)
          DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = X%P
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        IF (X%CASE<0) THEN
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,ACOS(VA),X%P,-D1/V2,D0,ACOS_D)
        ELSE
!           Create new node in computational graph
          ACOS_D%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = &
                    NODE(ACOS(VA),(/-D1/V2,0.0_WP/),1,(/X%P,0/))
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF

  END FUNCTION ACOS_D

! Add
  FUNCTION ADD_DD(A,B)

    TYPE (AD02_REAL) :: ADD_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    ADD_DD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(ADD_DD,A,B,'+')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(ADD_DD,A,B,'+')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(ADD_DD,A,B,'+')
    ELSE
      ADD_DD%CASE = -DATA%CASE
! Code for adding
! Create new node in computational graph
      ADD_DD%P = DATA%NUM_NODES
      DATA%GRAPH(DATA%NUM_NODES)%RVAL = &
           DATA%GRAPH(A%P)%RVAL+DATA%GRAPH(B%P)%RVAL
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = 1.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 1.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%ONUM = 2
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = B%P
      IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
    END IF

  END FUNCTION ADD_DD

  FUNCTION ADD_DI(A,B)
    TYPE (AD02_REAL) :: ADD_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    CALL COPY(ADD_DI,ADD_DR(A,REAL(B,WP)))
  END FUNCTION ADD_DI

  FUNCTION ADD_DR(A,B)
    TYPE (AD02_REAL) :: ADD_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    ADD_DR%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(ADD_DR,A,'+')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(ADD_DR,A,'+')
    ELSE
      ADD_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
!         Condense node
        DATA%GRAPH(A%P)%RVAL = DATA%GRAPH(A%P)%RVAL + B
        ADD_DR%P = A%P
      ELSE
! Create new node in computational graph
        ADD_DR%P = DATA%NUM_NODES
      DATA%GRAPH(DATA%NUM_NODES)%RVAL = DATA%GRAPH(A%P)%RVAL+B
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = 1.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION ADD_DR

  FUNCTION ADD_DS(A,B)
    TYPE (AD02_REAL) :: ADD_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(ADD_DS,ADD_DR(A,REAL(B,WP)))
  END FUNCTION ADD_DS

  FUNCTION ADD_ID(A,B)
    TYPE (AD02_REAL) :: ADD_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ADD_ID,ADD_DR(B,REAL(A,WP)))
  END FUNCTION ADD_ID

  FUNCTION ADD_RD(A,B)
    TYPE (AD02_REAL) :: ADD_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ADD_RD,ADD_DR(B,A))
  END FUNCTION ADD_RD

  FUNCTION ADD_SD(A,B)
    TYPE (AD02_REAL) :: ADD_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ADD_SD,ADD_DR(B,REAL(A,WP)))
  END FUNCTION ADD_SD

! Aint
  FUNCTION AINT_D(A)
    TYPE (AD02_REAL) :: AINT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    AINT_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AINT')
      AINT_D = 0.0_WP
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AINT')
      AINT_D = 0.0_WP
    ELSE
      AINT_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
!       Check for AINT(N), N an integer
      IF (VA==AINT(VA)) CALL ERROR_HANDLER(DATA,AINT_WARN)
      AINT_D = AINT(VA)
    END IF
  END FUNCTION AINT_D

! Anint
  FUNCTION ANINT_D(A)
    TYPE (AD02_REAL) ANINT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    ANINT_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'ANINT')
      ANINT_D = 0.0_WP
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'ANINT')
      ANINT_D = 0.0_WP
    ELSE
      ANINT_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
!       Check for ANINT(N + 0.5), where N is an integer
      IF (ABS(VA-AINT(VA))-0.5_WP==0.0_WP) CALL ERROR_HANDLER(DATA,ANINT_WARN)
      ANINT_D = ANINT(VA)
    END IF
  END FUNCTION ANINT_D

! Asin
  FUNCTION ASIN_D(X)
    TYPE (AD02_REAL) :: ASIN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA, V, V2
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    ASIN_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ASIN_D,X,'ASIN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ASIN_D,X,'ASIN')
    ELSE
      ASIN_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      V = (D1-VA**2)
      V2 = SQRT(V)
      IF (DATA%LEVEL==2) THEN
        IF (X%CASE<0) THEN
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,ASIN(VA),X%P,D1/V2,VA/(V2*V),ASIN_D)
        ELSE
! Create new node in computational graph
          ASIN_D%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = &
               NODE(ASIN(VA),(/D1/V2,VA/(V2*V)/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        IF (X%CASE<0) THEN
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,ASIN(VA),X%P,D1/V2,D0,ASIN_D)
        ELSE
! Create new node in computational graph
          ASIN_D%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = &
              NODE(ASIN(VA),(/D1/V2,0.0_WP/),1,(/X%P,0/))
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION ASIN_D


  SUBROUTINE ASSIGN_DD(A,B)
! Assignment. Note that assignment of a structure to a real is not
! provided since this is likely to be an error.
    TYPE (AD02_REAL), INTENT (OUT) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    A%DATA => DATA

! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(A,B,'Assign')
      RETURN
    ELSE IF (DATA%CASE/=ABS(B%CASE) ) THEN
      CALL UNARY_WARNING(A,B,'Assign')
      RETURN
    ELSE
      A%P = B%P
      A%CASE = DATA%CASE
    END IF
  END SUBROUTINE ASSIGN_DD

  SUBROUTINE ASSIGN_DD1(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:)
    CALL ERROR_HANDLER(B(1)%DATA,ASSIGNMENT_WARN)
    CALL AD02_UNDEFINE(A,B(1)%DATA)
  END SUBROUTINE ASSIGN_DD1

  SUBROUTINE ASSIGN_DD10(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
    CALL AD02_UNDEFINE(A,B%DATA)
  END SUBROUTINE ASSIGN_DD10

  SUBROUTINE ASSIGN_DD2(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:)
    CALL AD02_UNDEFINE(A,B(1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD2

  SUBROUTINE ASSIGN_DD20(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD20

  SUBROUTINE ASSIGN_DD3(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD3

  SUBROUTINE ASSIGN_DD30(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD30

  SUBROUTINE ASSIGN_DD4(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD4

  SUBROUTINE ASSIGN_DD40(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD40

  SUBROUTINE ASSIGN_DD5(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD5

  SUBROUTINE ASSIGN_DD50(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD50

  SUBROUTINE ASSIGN_DD6(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD6

  SUBROUTINE ASSIGN_DD60(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL AD02_UNDEFINE(A,B%DATA)
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD60

  SUBROUTINE ASSIGN_DD7(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B(:,:,:,:,:,:,:)
    CALL AD02_UNDEFINE(A,B(1,1,1,1,1,1,1)%DATA)
    CALL ERROR_HANDLER(B(1,1,1,1,1,1,1)%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD7

  SUBROUTINE ASSIGN_DD70(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A(:,:,:,:,:,:,:)
    TYPE (AD02_REAL), INTENT (IN) :: B
    A%P = -1
    CALL ERROR_HANDLER(B%DATA,ASSIGNMENT_WARN)
  END SUBROUTINE ASSIGN_DD70

  SUBROUTINE ASSIGN_DI(A,B)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    INTEGER, INTENT (IN) :: B
    CALL ASSIGN_DR(A,REAL(B,WP))
  END SUBROUTINE ASSIGN_DI


  SUBROUTINE ASSIGN_DR(A,B)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF(.NOT.ASSOCIATED(DATA))THEN
      CALL AD02_UNDEFINE(A)
      ! ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      !   CALL AD02_UNDEFINE(A)
    ELSE
!     Create new node in computational graph
      A%P = DATA%NUM_NODES
      A%CASE = ABS(A%CASE)
!     DATA%GRAPH(DATA%NUM_NODES) = NODE(B,(/0.0_WP,0.0_WP/),0,(/1,0/))
      DATA%GRAPH(DATA%NUM_NODES)%RVAL = B
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = 0.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%ONUM = 0
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = 1
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
      IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
    END IF
  END SUBROUTINE ASSIGN_DR

  SUBROUTINE ASSIGN_DS(A,B)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    REAL, INTENT (IN) :: B
    CALL ASSIGN_DR(A,REAL(B,WP))
  END SUBROUTINE ASSIGN_DS

  SUBROUTINE ASSIGN_ID(A,B)
    INTEGER, INTENT (OUT) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'Assign')
      A = 0
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'Assign')
      A = 0
    ELSE
      A = INT(DATA%GRAPH(B%P)%RVAL)
    END IF
  END SUBROUTINE ASSIGN_ID

! Atan
  FUNCTION ATAN_D(X)
    TYPE (AD02_REAL) :: ATAN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA, V
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    ATAN_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ATAN_D,X,'ATAN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ATAN_D,X,'ATAN')
    ELSE
      ATAN_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      V = (D1+VA**2)
      IF (DATA%LEVEL==2) THEN
        IF (X%CASE<0) THEN
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,ATAN(VA),X%P,D1/V,-D2*VA/V**2,ATAN_D)
        ELSE
! Create new node in computational graph
          ATAN_D%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = &
               NODE(ATAN(VA),(/D1/V,-D2*VA/V**2/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        IF (X%CASE<0) THEN
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,ATAN(VA),X%P,D1/V,D0,ATAN_D)
        ELSE
! Create new node in computational graph
          ATAN_D%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = &
              NODE(ATAN(VA),(/D1/V,0.0_WP/),1,(/X%P,0/))
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION ATAN_D

! Atan2
  FUNCTION ATAN2_DD(Y,X)
    TYPE (AD02_REAL) :: ATAN2_DD
    TYPE (AD02_REAL), INTENT (IN) :: Y, X
    REAL (WP) VA, VB, V
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    ATAN2_DD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1 .OR. Y%P==-1) THEN
      CALL BINARY_WARNING(ATAN2_DD,X,Y,'ATAN2')
    ELSE IF (.NOT.ASSOCIATED(DATA,Y%DATA)) THEN
      CALL BINARY_WARNING(ATAN2_DD,X,Y,'ATAN2')
    ELSE IF (DATA%CASE/=ABS(X%CASE) .OR.DATA%CASE/=ABS(Y%CASE) ) THEN
      CALL BINARY_WARNING(ATAN2_DD,X,Y,'ATAN2')
    ELSE
      ATAN2_DD%CASE = -DATA%CASE
      VA = DATA%GRAPH(Y%P)%RVAL
      VB = DATA%GRAPH(X%P)%RVAL
      IF (ABS(VB)>ABS(VA)) THEN
        V = D1 + (VA/VB)**2
! Create new node in computational graph
        ATAN2_DD%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) = &
          NODE(ATAN2(VA,VB),(/D1/(VB*V),-VA/(VB**2*V)/),2,(/Y%P,X%P/))
        IF (DATA%LEVEL==2) THEN
          DATA%DER2(0,DATA%NUM_NODES) = -D2*VA/(VB**3*V**2)
          DATA%DER2(1,DATA%NUM_NODES) = -D1/(VB**2*V)+D2*VA**2/(VB**4*V**2)
          DATA%DER2(2,DATA%NUM_NODES) = D2*VA/(VB**3*V)-D2*VA**3/(VB**5*V**2)
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      ELSE
        V = D1 + (VB/VA)**2
! Create new node in computational graph
        ATAN2_DD%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) = &
          NODE(ATAN2(VA,VB),(/VB/(VA**2*V),-D1/(VA*V)/),2,(/Y%P,X%P/))
        IF (DATA%LEVEL==2) THEN
          DATA%DER2(0,DATA%NUM_NODES) = -D2*VB/(VA**3*V)+D2*VB**3/(VA**5*V**2)
          DATA%DER2(1,DATA%NUM_NODES) = D1/(VA**2*V)-D2*VB**2/(VA**4*V**2)
          DATA%DER2(2,DATA%NUM_NODES) = D2*VB/(VA**3*V**2)
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION ATAN2_DD


  FUNCTION ATAN2_DR(Y,X)
    TYPE (AD02_REAL) :: ATAN2_DR
    TYPE (AD02_REAL), INTENT (IN) :: Y
    REAL (WP), INTENT (IN) :: X
    REAL (WP) V, RY
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => Y%DATA
    ATAN2_DR%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (Y%P==-1) THEN
      CALL UNARY_WARNING(ATAN2_DR,Y,'ATAN2')
    ELSE IF (DATA%CASE/=ABS(Y%CASE)) THEN
      CALL UNARY_WARNING(ATAN2_DR,Y,'ATAN2')
    ELSE
      ATAN2_DR%CASE = -DATA%CASE
      RY = DATA%GRAPH(Y%P)%RVAL
      IF (ABS(X)>ABS(RY)) THEN
        V = D1 + RY**2/X**2
        IF (Y%CASE<0) THEN
          IF (DATA%LEVEL==2) THEN
! Alter value and derivative information of node Y%P
            CALL CONDENSE_NODE &
               (DATA,ATAN2(RY,X),Y%P,D1/(V*X),-D2*RY/(X**3*V**2),ATAN2_DR)
          ELSE
! Alter value and derivative information of node Y%P
            CALL CONDENSE_NODE(DATA,ATAN2(RY,X),Y%P,D1/(V*X),D0,ATAN2_DR)
          END IF
        ELSE
! Create new node in computational graph
          ATAN2_DR%P = DATA%NUM_NODES
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN2(RY,X),(/D1/(V*X), &
              -D2*RY/(X**3*V**2)/),1,(/Y%P,0/))
            DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          ELSE
            DATA%GRAPH(DATA%NUM_NODES) = &
                NODE(ATAN2(RY,X),(/D1/(V*X),0.0_WP/),1,(/Y%P,0/))
          END IF
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        V = D1 + X**2/RY**2
        IF (Y%CASE<0) THEN
          IF (DATA%LEVEL==2) THEN
! Alter value and derivative information of node Y%P
            CALL CONDENSE_NODE(DATA,ATAN2(RY,X),Y%P,X/(RY**2*V), &
              -D2*X/(RY**3*V)+D2*X**3/(RY**5*V**2),ATAN2_DR)
          ELSE
! Alter value and derivative information of node Y%P
            CALL CONDENSE_NODE(DATA,ATAN2(RY,X),Y%P,X/(RY**2*V),D0,ATAN2_DR)
          END IF
        ELSE
! Create new node in computational graph
          ATAN2_DR%P = DATA%NUM_NODES
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN2(RY,X),(/X/(RY**2*V), &
              -D2*X/(RY**3*V)+D2*X**3/(RY**5*V**2)/),1,(/Y%P,0/))
            DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          ELSE
            DATA%GRAPH(DATA%NUM_NODES) = &
                NODE(ATAN2(RY,X),(/X/(RY**2*V),0.0_WP/),1,(/Y%P,0/))
          END IF
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION ATAN2_DR

  FUNCTION ATAN2_DS(A,B)
    TYPE (AD02_REAL) :: ATAN2_DS
    REAL, INTENT (IN) :: B
    TYPE (AD02_REAL), INTENT (IN) :: A
    CALL COPY(ATAN2_DS,ATAN2_DR(A,REAL(B,WP)))
  END FUNCTION ATAN2_DS

  FUNCTION ATAN2_RD(Y,X)
    TYPE (AD02_REAL) :: ATAN2_RD
    REAL (WP), INTENT (IN) :: Y
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) V, RX
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    ATAN2_RD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(ATAN2_RD,X,'ATAN2')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(ATAN2_RD,X,'ATAN2')
    ELSE
      ATAN2_RD%CASE = -DATA%CASE
      RX = DATA%GRAPH(X%P)%RVAL
      IF (ABS(RX)>ABS(Y)) THEN
        V = D1 + Y**2/RX**2
        IF (X%CASE<0) THEN
          IF (DATA%LEVEL==2) THEN
! Alter value and derivative information of node X%P
            CALL CONDENSE_NODE(DATA,ATAN2(Y,RX),X%P,-Y/(RX**2*V), &
              D2*Y/(RX**3*V)-D2*Y**3/(RX**5*V**2),ATAN2_RD)
          ELSE
! Alter value and derivative information of node X%P
            CALL CONDENSE_NODE &
                (DATA,ATAN2(Y,RX),X%P,-Y/(RX**2*V),0.0_WP,ATAN2_RD)
          END IF
        ELSE
! Create new node in computational graph
          ATAN2_RD%P = DATA%NUM_NODES
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN2(Y,RX),(/-Y/(RX**2*V), &
              D2*Y/(RX**3*V)-D2*Y**3/(RX**5*V**2)/),1,(/X%P,0/))
            DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          ELSE
            DATA%GRAPH(DATA%NUM_NODES) = &
               NODE(ATAN2(Y,RX),(/-Y/(RX**2*V),0.0_WP/),1,(/X%P,0/))
          END IF
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        V = D1 + RX**2/Y**2
        IF (X%CASE<0) THEN
          IF (DATA%LEVEL==2) THEN
! Alter value and derivative information of node X%P
            CALL CONDENSE_NODE &
                (DATA,ATAN2(Y,RX),X%P,-D1/(Y*V),D2*RX/(Y**3*V**2),ATAN2_RD)
          ELSE
! Alter value and derivative information of node X%P
            CALL CONDENSE_NODE(DATA,ATAN2(Y,RX),X%P,-D1/(Y*V),0.0_WP,ATAN2_RD)
          END IF
        ELSE
! Create new node in computational graph
          ATAN2_RD%P = DATA%NUM_NODES
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(DATA%NUM_NODES) = NODE(ATAN2(Y,RX),(/-D1/(Y*V), &
              D2*RX/(Y**3*V**2)/),1,(/X%P,0/))
            DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          ELSE
            DATA%GRAPH(DATA%NUM_NODES) = &
              NODE(ATAN2(Y,RX),(/-D1/(Y*V),0.0_WP/),1,(/X%P,0/))
          END IF
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION ATAN2_RD

  FUNCTION ATAN2_SD(A,B)
    TYPE (AD02_REAL) :: ATAN2_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(ATAN2_SD,ATAN2_RD(REAL(A,WP),B))
  END FUNCTION ATAN2_SD

! Cos
  FUNCTION COS_D(X)
    TYPE (AD02_REAL) :: COS_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) V, VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    COS_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(COS_D,X,'COS')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(COS_D,X,'COS')
    ELSE
      COS_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      V = COS(VA)
      IF (X%CASE<0) THEN
! Alter value and derivative information of node X%P
        CALL CONDENSE_NODE(DATA,V,X%P,-SIN(VA),-V,COS_D)
      ELSE
! Create new node in computational graph
        COS_D%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/-SIN(VA),-V/),1,(/X%P,0/))
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION COS_D

! Cosh
  FUNCTION COSH_D(X)
    TYPE (AD02_REAL) :: COSH_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA, V
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    COSH_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(COSH_D,X,'COSH')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(COSH_D,X,'COSH')
    ELSE
      COSH_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      V = COSH(VA)
      IF (X%CASE<0) THEN
! Alter value and derivative information of node X%P
        CALL CONDENSE_NODE(DATA,V,X%P,SINH(VA),V,COSH_D)
      ELSE
! Create new node in computational graph
        COSH_D%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/SINH(VA),V/),1,(/X%P,0/))
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION COSH_D

! Divide
  FUNCTION DIV_DD(A,B)
    TYPE (AD02_REAL) :: DIV_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    REAL (WP) VA, VB, VC
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    DIV_DD%DATA => DATA

! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(DIV_DD,A,B,'/')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(DIV_DD,A,B,'/')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE) ) THEN
      CALL BINARY_WARNING(DIV_DD,A,B,'/')
    ELSE
      DIV_DD%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      VB = DATA%GRAPH(B%P)%RVAL
      VC = VA/VB
! Create new node in computational graph
      DIV_DD%P = DATA%NUM_NODES
!     DATA%GRAPH(DATA%NUM_NODES) = NODE(VC,(/D1/VB,-VC/VB/),2,(/A%P,B%P/))
      DATA%GRAPH(DATA%NUM_NODES)%RVAL = VC
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = D1/VB
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = -VC/VB
      DATA%GRAPH(DATA%NUM_NODES)%ONUM = 2
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = B%P
      IF (DATA%LEVEL==2) THEN
         DATA%DER2(0,DATA%NUM_NODES) = D0
         DATA%DER2(1,DATA%NUM_NODES) = -D1/VB**2
         DATA%DER2(2,DATA%NUM_NODES) = D2*VC/VB**2
      END IF
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
    END IF
  END FUNCTION DIV_DD


  FUNCTION DIV_DI(A,B)
    TYPE (AD02_REAL) :: DIV_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    CALL COPY(DIV_DI,DIV_DR(A,REAL(B,WP)))
  END FUNCTION DIV_DI


  FUNCTION DIV_DR(A,B)
    TYPE (AD02_REAL) :: DIV_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    DIV_DR%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(DIV_DR,A,'/')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(DIV_DR,A,'/')
    ELSE
      DIV_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
!          No need to create a new graph node simply alter
!           derivative values of the node - DATA%GRAPH(A%P)
        DIV_DR%P = A%P
        DATA%GRAPH(A%P)%RVAL = DATA%GRAPH(A%P)%RVAL/B
        IF (DATA%GRAPH(A%P)%ONUM==2) THEN
          DATA%GRAPH(A%P)%RVALS = DATA%GRAPH(A%P)%RVALS/B
          IF (DATA%LEVEL==2) DATA%DER2(:,A%P) = DATA%DER2(:,A%P)/B
        ELSE
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(A%P)%RVALS = DATA%GRAPH(A%P)%RVALS/B
          ELSE
            DATA%GRAPH(A%P)%RVALS(0) = DATA%GRAPH(A%P)%RVALS(0)/B
          END IF
        END IF
      ELSE
! Create new node in computational graph
        DIV_DR%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) = &
           NODE(DATA%GRAPH(A%P)%RVAL/B,(/D1/B,0.0_WP/),1,(/A%P,0/))
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION DIV_DR

  FUNCTION DIV_DS(A,B)
    TYPE (AD02_REAL) :: DIV_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(DIV_DS,DIV_DR(A,REAL(B,WP)))
  END FUNCTION DIV_DS

  FUNCTION DIV_ID(A,B)
    TYPE (AD02_REAL) :: DIV_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(DIV_ID,DIV_RD(REAL(A,WP),B))
  END FUNCTION DIV_ID


  FUNCTION DIV_RD(A,B)
    TYPE (AD02_REAL) :: DIV_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL (WP) AB, RB
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    DIV_RD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(DIV_RD,B,'/')
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(DIV_RD,B,'/')
    ELSE
      DIV_RD%CASE = -DATA%CASE
      RB = DATA%GRAPH(B%P)%RVAL
      AB = A/RB
      IF (B%CASE<0) THEN
        IF (DATA%LEVEL==2) THEN
! Alter value and derivative information of node B%P
          CALL CONDENSE_NODE(DATA,AB,B%P,-AB/RB,D2*AB/(RB*RB),DIV_RD)
        ELSE
! Alter value and derivative information of node B%P
          CALL CONDENSE_NODE(DATA,AB,B%P,-AB/RB,D0,DIV_RD)
        END IF
      ELSE
! Create new node in computational graph
        DIV_RD%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = &
             NODE(AB,(/-AB/RB,D2*AB/(RB*RB)/),1,(/B%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
!         DATA%GRAPH(DATA%NUM_NODES) = NODE(AB,(/-AB/RB,0.0_WP/),1,(/B%P,0/))
          DATA%GRAPH(DATA%NUM_NODES)%RVAL = AB
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = -AB/RB
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
          DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = B%P
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION DIV_RD

  FUNCTION DIV_SD(A,B)
    TYPE (AD02_REAL) :: DIV_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(DIV_SD,DIV_RD(REAL(A,WP),B))
  END FUNCTION DIV_SD

! .eq.
  FUNCTION EQ_DD(A,B)
    LOGICAL :: EQ_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DD = .TRUE.
    ELSE
      EQ_DD = DATA%GRAPH(A%P)%RVAL == DATA%GRAPH(B%P)%RVAL
      IF (EQ_DD) CALL ERROR_HANDLER(DATA,EQ_WARN)
    END IF
  END FUNCTION EQ_DD

  FUNCTION EQ_DI(A,B)
    LOGICAL :: EQ_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DI = .TRUE.
    ELSE
      EQ_DI = DATA%GRAPH(A%P)%RVAL == B
      IF (EQ_DI) CALL ERROR_HANDLER(DATA,EQ_WARN)
    END IF
  END FUNCTION EQ_DI

  FUNCTION EQ_DR(A,B)
    LOGICAL :: EQ_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DR = .TRUE.
    ELSE
      EQ_DR = DATA%GRAPH(A%P)%RVAL == B
      IF (EQ_DR) CALL ERROR_HANDLER(DATA,EQ_WARN)
    END IF
  END FUNCTION EQ_DR

  FUNCTION EQ_DS(A,B)
    LOGICAL :: EQ_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_DS = .TRUE.
    ELSE
      EQ_DS = DATA%GRAPH(A%P)%RVAL == B
      IF (EQ_DS) CALL ERROR_HANDLER(DATA,EQ_WARN)
    END IF
  END FUNCTION EQ_DS

  FUNCTION EQ_ID(A,B)
    LOGICAL :: EQ_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_ID = .TRUE.
    ELSE
      EQ_ID = A == DATA%GRAPH(B%P)%RVAL
      IF (EQ_ID) CALL ERROR_HANDLER(DATA,EQ_WARN)
    END IF
  END FUNCTION EQ_ID

  FUNCTION EQ_SD(A,B)
    LOGICAL :: EQ_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_SD = .TRUE.
    ELSE
      EQ_SD = A == DATA%GRAPH(B%P)%RVAL
      IF (EQ_SD) CALL ERROR_HANDLER(DATA,EQ_WARN)
    END IF
  END FUNCTION EQ_SD

  FUNCTION EQ_RD(A,B)
    LOGICAL :: EQ_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'==')
      EQ_RD = .TRUE.
    ELSE
      EQ_RD = A == DATA%GRAPH(B%P)%RVAL
      IF (EQ_RD) CALL ERROR_HANDLER(DATA,EQ_WARN)
    END IF
  END FUNCTION EQ_RD


! Exp
  FUNCTION EXP_D(X)
    TYPE (AD02_REAL) :: EXP_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VB
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    EXP_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(EXP_D,X,'EXP')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(EXP_D,X,'EXP')
    ELSE
      EXP_D%CASE = -DATA%CASE
      VB = EXP(DATA%GRAPH(X%P)%RVAL)
      IF (X%CASE<0) THEN
! Alter value and derivative information of node X%P
        CALL CONDENSE_NODE(DATA,VB,X%P,VB,VB,EXP_D)
      ELSE
! Create new node in computational graph
        EXP_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = NODE(VB,(/VB,VB/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES) = NODE(VB,(/VB,0.0_WP/),1,(/X%P,0/))
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION EXP_D

! .ge.
  FUNCTION GE_DD(A,B)
    LOGICAL :: GE_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DD = .TRUE.
     ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DD = .TRUE.
    ELSE
      GE_DD = DATA%GRAPH(A%P)%RVAL >= DATA%GRAPH(B%P)%RVAL
      IF (DATA%GRAPH(A%P)%RVAL==DATA%GRAPH(B%P)%RVAL) &
         CALL ERROR_HANDLER(DATA,GE_WARN)
    END IF
  END FUNCTION GE_DD

  FUNCTION GE_DI(A,B)
    LOGICAL :: GE_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_DI = DATA%GRAPH(A%P)%RVAL >= B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,GE_WARN)
    END IF
  END FUNCTION GE_DI

  FUNCTION GE_DR(A,B)
    LOGICAL :: GE_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_DR = DATA%GRAPH(A%P)%RVAL >= B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,GE_WARN)
    END IF
  END FUNCTION GE_DR

  FUNCTION GE_DS(A,B)
    LOGICAL :: GE_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_DS = DATA%GRAPH(A%P)%RVAL >= B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,GE_WARN)
    END IF
  END FUNCTION GE_DS

  FUNCTION GE_ID(A,B)
    LOGICAL :: GE_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_ID = A >= DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,GE_WARN)
    END IF
  END FUNCTION GE_ID

  FUNCTION GE_RD(A,B)
    LOGICAL :: GE_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_RD = A >= DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,GE_WARN)
    END IF
  END FUNCTION GE_RD

  FUNCTION GE_SD(A,B)
    LOGICAL :: GE_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
      GE_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>=')
    ELSE
      GE_SD = A >= DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,GE_WARN)
    END IF
  END FUNCTION GE_SD


! .gt.
  FUNCTION GT_DD(A,B)
    LOGICAL :: GT_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DD = .TRUE.
    ELSE IF ( DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DD = .TRUE.
    ELSE
      GT_DD = DATA%GRAPH(A%P)%RVAL > DATA%GRAPH(B%P)%RVAL
      IF (DATA%GRAPH(A%P)%RVAL==DATA%GRAPH(B%P)%RVAL) &
         CALL ERROR_HANDLER(DATA,GT_WARN)
    END IF
  END FUNCTION GT_DD

  FUNCTION GT_DI(A,B)
    LOGICAL :: GT_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DI = .TRUE.
    ELSE
      GT_DI = DATA%GRAPH(A%P)%RVAL > B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,GT_WARN)
    END IF
  END FUNCTION GT_DI

  FUNCTION GT_DR(A,B)
    LOGICAL :: GT_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DR = .TRUE.
    ELSE
      GT_DR = DATA%GRAPH(A%P)%RVAL > B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,GT_WARN)
    END IF
  END FUNCTION GT_DR

  FUNCTION GT_DS(A,B)
    LOGICAL :: GT_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_DS = .TRUE.
    ELSE
      GT_DS = DATA%GRAPH(A%P)%RVAL > B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,GT_WARN)
    END IF
  END FUNCTION GT_DS

  FUNCTION GT_ID(A,B)
    LOGICAL :: GT_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_ID = .TRUE.
    ELSE
      GT_ID = A > DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,GT_WARN)
    END IF
  END FUNCTION GT_ID

  FUNCTION GT_RD(A,B)
    LOGICAL :: GT_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_RD = .TRUE.
    ELSE
      GT_RD = A > DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,GT_WARN)
    END IF
  END FUNCTION GT_RD

  FUNCTION GT_SD(A,B)
    LOGICAL :: GT_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'>')
      GT_SD = .TRUE.
    ELSE
      GT_SD = A > DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,GT_WARN)
    END IF
  END FUNCTION GT_SD

! INT
  FUNCTION INT_D(A)
    TYPE (AD02_REAL) INT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    INT_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'INT')
      INT_D = 0
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'INT')
      INT_D = 0
    ELSE
      INT_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      IF (VA==AINT(VA)) CALL ERROR_HANDLER(DATA,INT_WARN)
      INT_D = INT(VA)
    END IF
  END FUNCTION INT_D

! Log
  FUNCTION LOG_D(X)
    TYPE (AD02_REAL) :: LOG_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    LOG_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(LOG_D,X,'LOG')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(LOG_D,X,'LOG')
    ELSE
      LOG_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      IF (X%CASE<0) THEN
        IF (DATA%LEVEL==2) THEN
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,LOG(VA),X%P,D1/VA,-D1/VA**2,LOG_D)
        ELSE
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,LOG(VA),X%P,D1/VA,D0,LOG_D)
        END IF
      ELSE
! Create new node in computational graph
        LOG_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = &
             NODE(LOG(VA),(/D1/VA,-D1/VA**2/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES) = &
             NODE(LOG(VA),(/D1/VA,0.0_WP/),1,(/X%P,0/))
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION LOG_D

! Log10
  FUNCTION LOG10_D(X)
    TYPE (AD02_REAL) :: LOG10_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    LOG10_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(LOG10_D,X,'LOG10')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(LOG10_D,X,'LOG10')
    ELSE
      LOG10_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      IF (X%CASE<0) THEN
        IF (DATA%LEVEL==2) THEN
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,LOG10(VA),X%P,D1/(VA*LN10),-D1/(VA**2*LN10), &
            LOG10_D)
        ELSE
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,LOG10(VA),X%P,D1/(VA*LN10),D0,LOG10_D)
        END IF
      ELSE
! Create new node in computational graph
        LOG10_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = &
            NODE(LOG10(VA),(/D1/(VA*LN10),-D1/(VA**2*LN10)/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES) = &
            NODE(LOG10(VA),(/D1/(VA*LN10),0.0_WP/),1,(/X%P,0/))
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION LOG10_D

! .le.
  FUNCTION LE_DD(A,B)
    LOGICAL :: LE_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE).OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DD = .TRUE.
    ELSE
      LE_DD = DATA%GRAPH(A%P)%RVAL <= DATA%GRAPH(B%P)%RVAL
      IF (DATA%GRAPH(A%P)%RVAL==DATA%GRAPH(B%P)%RVAL) &
            CALL ERROR_HANDLER(DATA,LE_WARN)
    END IF
  END FUNCTION LE_DD

  FUNCTION LE_DI(A,B)
    LOGICAL :: LE_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DI = .TRUE.
    ELSE
      LE_DI = DATA%GRAPH(A%P)%RVAL <= B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,LE_WARN)
    END IF
  END FUNCTION LE_DI

  FUNCTION LE_DR(A,B)
    LOGICAL :: LE_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DR = .TRUE.
    ELSE
      LE_DR = DATA%GRAPH(A%P)%RVAL <= B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,LE_WARN)
    END IF
  END FUNCTION LE_DR

  FUNCTION LE_DS(A,B)
    LOGICAL :: LE_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_DS = .TRUE.
    ELSE
      LE_DS = DATA%GRAPH(A%P)%RVAL <= B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,LE_WARN)
    END IF
  END FUNCTION LE_DS

  FUNCTION LE_ID(A,B)
    LOGICAL :: LE_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_ID = .TRUE.
    ELSE
      LE_ID = A <= DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,LE_WARN)
    END IF
  END FUNCTION LE_ID

  FUNCTION LE_RD(A,B)
    LOGICAL :: LE_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_RD = .TRUE.
    ELSE
      LE_RD = A <= DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,LE_WARN)
    END IF
  END FUNCTION LE_RD

  FUNCTION LE_SD(A,B)
    LOGICAL :: LE_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<=')
      LE_SD = .TRUE.
    ELSE
      LE_SD = A <= DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,LE_WARN)
    END IF
  END FUNCTION LE_SD

! .lt.
  FUNCTION LT_DD(A,B)
    LOGICAL :: LT_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DD = .TRUE.
    ELSE
      LT_DD = DATA%GRAPH(A%P)%RVAL < DATA%GRAPH(B%P)%RVAL
      IF (DATA%GRAPH(A%P)%RVAL==DATA%GRAPH(B%P)%RVAL) &
         CALL ERROR_HANDLER(DATA,LT_WARN)
    END IF
  END FUNCTION LT_DD

  FUNCTION LT_DI(A,B)
    LOGICAL :: LT_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DI = .TRUE.
    ELSE
      LT_DI = DATA%GRAPH(A%P)%RVAL < B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,LT_WARN)
    END IF
  END FUNCTION LT_DI

  FUNCTION LT_DR(A,B)
    LOGICAL :: LT_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
    ELSE
      LT_DR = DATA%GRAPH(A%P)%RVAL < B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,LT_WARN)
    END IF
  END FUNCTION LT_DR

  FUNCTION LT_DS(A,B)
    LOGICAL :: LT_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
    ELSE
      LT_DS = DATA%GRAPH(A%P)%RVAL < B
      IF (DATA%GRAPH(A%P)%RVAL==B) CALL ERROR_HANDLER(DATA,LT_WARN)
    END IF
  END FUNCTION LT_DS

  FUNCTION LT_ID(A,B)
    LOGICAL :: LT_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
 ! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_ID = .TRUE.
    ELSE
      LT_ID = A < DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,LT_WARN)
    END IF
  END FUNCTION LT_ID

  FUNCTION LT_RD(A,B)
    LOGICAL :: LT_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_RD = .TRUE.
    ELSE
      LT_RD = A < DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,LT_WARN)
    END IF
  END FUNCTION LT_RD

  FUNCTION LT_SD(A,B)
    LOGICAL :: LT_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'<')
      LT_SD = .TRUE.
    ELSE
      LT_SD = A < DATA%GRAPH(B%P)%RVAL
      IF (A==DATA%GRAPH(B%P)%RVAL) CALL ERROR_HANDLER(DATA,LT_WARN)
    END IF
  END FUNCTION LT_SD

! Max
  FUNCTION MAX_DD(A1,A2)
    TYPE (AD02_REAL) :: MAX_DD
    TYPE (AD02_REAL), INTENT (IN) :: A1, A2
    REAL (WP) VA, VB, RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    MAX_DD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A1%P==-1 .OR. A2%P==-1) THEN
      CALL BINARY_WARNING(MAX_DD,A1,A2,'MAX')
    ELSE IF (.NOT.ASSOCIATED(DATA,A2%DATA)) THEN
      CALL BINARY_WARNING(MAX_DD,A1,A2,'MAX')
    ELSE IF (DATA%CASE/=ABS(A1%CASE) .OR. DATA%CASE/=ABS(A2%CASE)) THEN
      CALL BINARY_WARNING(MAX_DD,A1,A2,'MAX')
    ELSE
      MAX_DD%CASE = -DATA%CASE
      VA = DATA%GRAPH(A1%P)%RVAL
      VB = DATA%GRAPH(A2%P)%RVAL
      IF (VA>VB) THEN
        MAX_DD%P = A1%P
        MAX_DD%CASE= A1%CASE
      ELSE IF (VB>VA) THEN
        MAX_DD%P = A2%P
        MAX_DD%CASE= A2%CASE
      ELSE
        CALL ERROR_HANDLER(DATA,MAX_WARN)
        CALL RANDOM_NUMBER(RAND)
! Create new node in computational graph
        MAX_DD%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) =  NODE( &
           RAND*DATA%GRAPH(A1%P)%RVAL+(1.0_WP-RAND)*DATA%GRAPH(A2%P)%RVAL, &
           (/RAND,1.0_WP-RAND/), 2, (/A1%P,A2%P/) )
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION MAX_DD

  FUNCTION MAX_DR(A1,A2)
    TYPE (AD02_REAL) :: MAX_DR
    TYPE (AD02_REAL), INTENT (IN) :: A1
    REAL (WP), INTENT (IN) :: A2
    REAL (WP) RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    MAX_DR%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A1%P==-1) THEN
      CALL UNARY_WARNING(MAX_DR,A1,'MAX')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL UNARY_WARNING(MAX_DR,A1,'MAX')
    ELSE
      IF (DATA%GRAPH(A1%P)%RVAL>A2) THEN
        MAX_DR%P = A1%P
        MAX_DR%CASE = A1%CASE
      ELSE IF (DATA%GRAPH(A1%P)%RVAL<A2) THEN
! Create new node in computational graph
        MAX_DR%P = DATA%NUM_NODES
        MAX_DR%CASE = -DATA%CASE
        DATA%GRAPH(DATA%NUM_NODES) = NODE(A2,(/0.0_WP,0.0_WP/),0,(/1,0/))
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      ELSE
        CALL ERROR_HANDLER(DATA,MAX_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(MAX_DR,A1*RAND+A2*(1.0_WP-RAND))
      END IF
    END IF
  END FUNCTION MAX_DR

  FUNCTION MAX_DS(A,B)
    TYPE (AD02_REAL) :: MAX_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MAX_DS,MAX_DR(A,REAL(B,WP)))
  END FUNCTION MAX_DS

  FUNCTION MAX_RD(A1,A2)
    TYPE (AD02_REAL) :: MAX_RD
    REAL (WP), INTENT (IN) :: A1
    TYPE (AD02_REAL), INTENT (IN) :: A2
    CALL COPY(MAX_RD,MAX_DR(A2,REAL(A1,WP)))
  END FUNCTION MAX_RD

  FUNCTION MAX_SD(A,B)
    TYPE (AD02_REAL) :: MAX_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(MAX_SD,MAX_RD(REAL(A,WP),B))
  END FUNCTION MAX_SD

! Min
  FUNCTION MIN_DD(A1,A2)
    TYPE (AD02_REAL) :: MIN_DD
    TYPE (AD02_REAL), INTENT (IN) :: A1, A2
    REAL (WP) VA, VB, RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    MIN_DD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A1%P==-1 .OR. A2%P==-1) THEN
      CALL BINARY_WARNING(MIN_DD,A1,A2,'MIN')
    ELSE IF (.NOT.ASSOCIATED(DATA,A2%DATA)) THEN
      CALL BINARY_WARNING(MIN_DD,A1,A2,'MIN')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL BINARY_WARNING(MIN_DD,A1,A2,'MIN')
    ELSE
      MIN_DD%CASE = -DATA%CASE
      VA = DATA%GRAPH(A1%P)%RVAL
      VB = DATA%GRAPH(A2%P)%RVAL
      IF (VA<VB) THEN
        MIN_DD%P = A1%P
        MIN_DD%CASE = A1%CASE
      ELSE IF (VB<VA) THEN
        MIN_DD%P = A2%P
        MIN_DD%CASE = A2%CASE
      ELSE
        CALL ERROR_HANDLER(DATA,MIN_WARN)
        CALL RANDOM_NUMBER(RAND)
! Create new node in computational graph
        MIN_DD%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) =  NODE( &
           RAND*DATA%GRAPH(A1%P)%RVAL+(1.0_WP-RAND)*DATA%GRAPH(A2%P)%RVAL, &
                (/RAND,1.0_WP-RAND/), 2, (/A1%P,A2%P/) )
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION MIN_DD

  FUNCTION MIN_DR(A1,A2)
    TYPE (AD02_REAL) :: MIN_DR
    TYPE (AD02_REAL), INTENT (IN) :: A1
    REAL (WP), INTENT (IN) :: A2
    REAL (WP) RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    MIN_DR%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A1%P==-1) THEN
      CALL UNARY_WARNING(MIN_DR,A1,'MIN')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL UNARY_WARNING(MIN_DR,A1,'MIN')
    ELSE
      IF (DATA%GRAPH(A1%P)%RVAL>A2) THEN
! Create new node in computational graph
        MIN_DR%CASE = -DATA%CASE
        MIN_DR%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) = NODE(A2,(/0.0_WP,0.0_WP/),0,(/1,0/))
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      ELSE IF (DATA%GRAPH(A1%P)%RVAL<A2) THEN
        MIN_DR%P = A1%P
        MIN_DR%CASE = A1%CASE
      ELSE
        CALL ERROR_HANDLER(DATA,MIN_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(MIN_DR,A1*RAND+A2*(1.0_WP-RAND))
      END IF
    END IF
  END FUNCTION MIN_DR

  FUNCTION MIN_DS(A,B)
    TYPE (AD02_REAL) :: MIN_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MIN_DS,MIN_DR(A,REAL(B,WP)))
  END FUNCTION MIN_DS

  FUNCTION MIN_RD(A1,A2)
    TYPE (AD02_REAL) :: MIN_RD
    REAL (WP), INTENT (IN) :: A1
    TYPE (AD02_REAL), INTENT (IN) :: A2
    CALL COPY(MIN_RD,MIN_DR(A2,REAL(A1,WP)))
  END FUNCTION MIN_RD

  FUNCTION MIN_SD(A,B)
    TYPE (AD02_REAL) :: MIN_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(MIN_SD,MIN_RD(REAL(A,WP),B))
  END FUNCTION MIN_SD

! Unary minus
  FUNCTION MINUS_D(A1)
    TYPE (AD02_REAL) :: MINUS_D
    TYPE (AD02_REAL), INTENT (IN) :: A1
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A1%DATA
    MINUS_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A1%P==-1) THEN
      CALL UNARY_WARNING(MINUS_D,A1,'Unary -')
    ELSE IF (DATA%CASE/=ABS(A1%CASE)) THEN
      CALL UNARY_WARNING(MINUS_D,A1,'-')
    ELSE
      MINUS_D%CASE = -DATA%CASE
      IF (A1%CASE<0) THEN
!          No need to create a new graph node simply alter
!           derivative values of the node - DATA%GRAPH(A%P)
        DATA%GRAPH(A1%P)%RVAL = -DATA%GRAPH(A1%P)%RVAL
        MINUS_D%P = A1%P
        IF (DATA%GRAPH(A1%P)%ONUM==2) THEN
          DATA%GRAPH(A1%P)%RVALS = -DATA%GRAPH(A1%P)%RVALS
          IF (DATA%LEVEL==2) DATA%DER2(:,A1%P) = -DATA%DER2(:,A1%P)
        ELSE
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(A1%P)%RVALS = -DATA%GRAPH(A1%P)%RVALS
          ELSE
            DATA%GRAPH(A1%P)%RVALS(0) = -DATA%GRAPH(A1%P)%RVALS(0)
          END IF
        END IF
      ELSE
! Create new node in computational graph
        MINUS_D%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) = &
              NODE(-DATA%GRAPH(A1%P)%RVAL,(/-D1,D0/),1,(/A1%P,0/))
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION MINUS_D

! Binary minus
  FUNCTION MINUS_DD(A,B)
    TYPE (AD02_REAL) :: MINUS_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MINUS_DD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL UNARY_WARNING(MINUS_DD,B,'-')
    ELSE IF (.NOT.ASSOCIATED(A%DATA,B%DATA)) THEN
      CALL UNARY_WARNING(MINUS_DD,B,'-')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(MINUS_DD,B,'-')
    ELSE
      MINUS_DD%CASE = -DATA%CASE
! Code for subtracting
! Create new node in computational graph
      MINUS_DD%P = DATA%NUM_NODES
!     DATA%GRAPH(DATA%NUM_NODES) = &
!         NODE(DATA%GRAPH(A%P)%RVAL-DATA%GRAPH(B%P)%RVAL,(/1.0_WP, &
!        -1.0_WP/),2,(/A%P,B%P/))
      DATA%GRAPH(DATA%NUM_NODES)%RVAL = &
          DATA%GRAPH(A%P)%RVAL-DATA%GRAPH(B%P)%RVAL
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = 1.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = -1.0_WP
      DATA%GRAPH(DATA%NUM_NODES)%ONUM = 2
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = B%P
      IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
    END IF
  END FUNCTION MINUS_DD

  FUNCTION MINUS_DI(A,B)
    TYPE (AD02_REAL) :: MINUS_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    CALL COPY(MINUS_DI,MINUS_DR(A,REAL(B,WP)))
  END FUNCTION MINUS_DI

  FUNCTION MINUS_DR(A,B)
    TYPE (AD02_REAL) :: MINUS_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MINUS_DR%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(MINUS_DR,A,'-')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(MINUS_DR,A,'-')
    ELSE
      MINUS_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
!         Condense node
        DATA%GRAPH(A%P)%RVAL = DATA%GRAPH(A%P)%RVAL - B
        MINUS_DR%P = A%P
        MINUS_DR%CASE = A%CASE
      ELSE
! Create new node in computational graph
        MINUS_DR%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES) =  NODE(DATA%GRAPH(A%P)%RVAL-B, &
                                    (/1.0_WP,0.0_WP/),1,(/A%P, 0/))
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION MINUS_DR

  FUNCTION MINUS_DS(A,B)
    TYPE (AD02_REAL) :: MINUS_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MINUS_DS,MINUS_DR(A,REAL(B,WP)))
  END FUNCTION MINUS_DS

  FUNCTION MINUS_ID(A,B)
    TYPE (AD02_REAL) :: MINUS_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MINUS_ID,MINUS_RD(REAL(A,WP),B))
  END FUNCTION MINUS_ID


  FUNCTION MINUS_RD(A,B)
    TYPE (AD02_REAL) :: MINUS_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    MINUS_RD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(MINUS_RD,B,'-')
    ELSE IF (B%DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(MINUS_RD,B,'-')
    ELSE
      MINUS_RD%CASE = -DATA%CASE
      IF (B%CASE<0) THEN
!          No need to create a new graph node simply alter
!           derivative values of the node - DATA%GRAPH(B%P)
        DATA%GRAPH(B%P)%RVAL = A - DATA%GRAPH(B%P)%RVAL
        MINUS_RD%P = B%P
        IF (DATA%GRAPH(B%P)%ONUM==2) THEN
          DATA%GRAPH(B%P)%RVALS = -DATA%GRAPH(B%P)%RVALS
          IF (DATA%LEVEL==2) DATA%DER2(:,B%P)  = -DATA%DER2(:,B%P)
        ELSE
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(B%P)%RVALS = -DATA%GRAPH(B%P)%RVALS
          ELSE
            DATA%GRAPH(B%P)%RVALS(0) = -DATA%GRAPH(B%P)%RVALS(0)
          END IF
        END IF
      ELSE
! Create new node in computational graph
        MINUS_RD%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES)%RVAL = A-DATA%GRAPH(B%P)%RVAL
        DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = -1.0_WP
        DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
        DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
        DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = B%P
        DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION MINUS_RD

  FUNCTION MINUS_SD(A,B)
    TYPE (AD02_REAL) :: MINUS_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MINUS_SD,MINUS_RD(REAL(A,WP),B))
  END FUNCTION MINUS_SD


! Multiply
  FUNCTION MULT_DD(A,B)
    TYPE (AD02_REAL) :: MULT_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    REAL (WP) VA, VB
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MULT_DD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(MULT_DD,A,B,'*')
    ELSE IF (.NOT.ASSOCIATED(A%DATA,B%DATA)) THEN
      CALL BINARY_WARNING(MULT_DD,A,B,'*')
    ELSE IF (DATA%CASE/=ABS(A%CASE)  .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(MULT_DD,A,B,'*')
    ELSE
      MULT_DD%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      VB = DATA%GRAPH(B%P)%RVAL
! Create new node in computational graph
      MULT_DD%P = DATA%NUM_NODES
!     DATA%GRAPH(DATA%NUM_NODES) = NODE(VA*VB,(/VB,VA/),2,(/A%P,B%P/))
      DATA%GRAPH(DATA%NUM_NODES)%RVAL = VA*VB
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = VB
      DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = VA
      DATA%GRAPH(DATA%NUM_NODES)%ONUM = 2
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
      DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = B%P
      IF (DATA%LEVEL==2) THEN
        DATA%DER2(0,DATA%NUM_NODES) = 0.0_WP
        DATA%DER2(1,DATA%NUM_NODES) = 1.0_WP
        DATA%DER2(2,DATA%NUM_NODES) = 0.0_WP
      END IF
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
    END IF
  END FUNCTION MULT_DD

  FUNCTION MULT_DI(A,B)
    TYPE (AD02_REAL) :: MULT_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    CALL COPY(MULT_DI,MULT_DR(A,REAL(B,WP)))
  END FUNCTION MULT_DI

  FUNCTION MULT_DR(A,B)
    TYPE (AD02_REAL) :: MULT_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    MULT_DR%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(MULT_DR,A,'*')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(MULT_DR,A,'*')
    ELSE
      MULT_DR%CASE = -DATA%CASE
      IF (A%CASE<0) THEN
!          No need to create a new graph node simply alter
!           derivative values of the node - DATA%GRAPH(A%P)
        MULT_DR%P = A%P
        DATA%GRAPH(A%P)%RVAL = DATA%GRAPH(A%P)%RVAL*B
        IF (DATA%GRAPH(A%P)%ONUM==2) THEN
          DATA%GRAPH(A%P)%RVALS = DATA%GRAPH(A%P)%RVALS*B
          IF (DATA%LEVEL==2) DATA%DER2(:,A%P)  = DATA%DER2(:,A%P) *B
        ELSE
          IF (DATA%LEVEL==2) THEN
            DATA%GRAPH(A%P)%RVALS = DATA%GRAPH(A%P)%RVALS*B
          ELSE
            DATA%GRAPH(A%P)%RVALS(0) = DATA%GRAPH(A%P)%RVALS(0)*B
          END IF
        END IF
      ELSE
! Create new node in computational graph
        MULT_DR%P = DATA%NUM_NODES
        DATA%GRAPH(DATA%NUM_NODES)%RVAL = DATA%GRAPH(A%P)%RVAL*B
        DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = B
        DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
        DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
        DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
        DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
        IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION MULT_DR

  FUNCTION MULT_DS(A,B)
    TYPE (AD02_REAL) :: MULT_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(MULT_DS,MULT_DR(A,REAL(B,WP)))
  END FUNCTION MULT_DS

  FUNCTION MULT_ID(A,B)
    TYPE (AD02_REAL) :: MULT_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MULT_ID,MULT_DR(B,REAL(A,WP)))
  END FUNCTION MULT_ID

  FUNCTION MULT_RD(A,B)
    TYPE (AD02_REAL) MULT_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MULT_RD,MULT_DR(B,A))
  END FUNCTION MULT_RD

  FUNCTION MULT_SD(A,B)
    TYPE (AD02_REAL) MULT_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(MULT_SD,MULT_DR(B,REAL(A,WP)))
  END FUNCTION MULT_SD

! .ne.
  FUNCTION NE_DD(A,B)
    LOGICAL :: NE_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DD = .TRUE.
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DD = .TRUE.
    ELSE
      NE_DD = DATA%GRAPH(A%P)%RVAL /= DATA%GRAPH(B%P)%RVAL
      IF ( .NOT.NE_DD) CALL ERROR_HANDLER(DATA,NE_WARN)
    END IF
  END FUNCTION NE_DD

  FUNCTION NE_DI(A,B)
    LOGICAL :: NE_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DI = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DI = .TRUE.
    ELSE
      NE_DI = DATA%GRAPH(A%P)%RVAL /= B
      IF ( .NOT. (NE_DI)) CALL ERROR_HANDLER(DATA,NE_WARN)
    END IF
  END FUNCTION NE_DI

  FUNCTION NE_DR(A,B)
    LOGICAL :: NE_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DR = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DR = .TRUE.
    ELSE
      NE_DR = DATA%GRAPH(A%P)%RVAL /= B
      IF ( .NOT. (NE_DR)) CALL ERROR_HANDLER(DATA,NE_WARN)
    END IF
  END FUNCTION NE_DR

  FUNCTION NE_DS(A,B)
    LOGICAL :: NE_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DS = .TRUE.
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_DS = .TRUE.
    ELSE
      NE_DS = DATA%GRAPH(A%P)%RVAL /= B
      IF ( .NOT. (NE_DS)) CALL ERROR_HANDLER(DATA,NE_WARN)
    END IF
  END FUNCTION NE_DS

  FUNCTION NE_ID(A,B)
    LOGICAL :: NE_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_ID = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_ID = .TRUE.
    ELSE
      NE_ID = A /= DATA%GRAPH(B%P)%RVAL
      IF ( .NOT. (NE_ID)) CALL ERROR_HANDLER(DATA,NE_WARN)
    END IF
  END FUNCTION NE_ID

  FUNCTION NE_RD(A,B)
    LOGICAL :: NE_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_RD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_RD = .TRUE.
    ELSE
      NE_RD = A /= DATA%GRAPH(B%P)%RVAL
      IF ( .NOT. (NE_RD)) CALL ERROR_HANDLER(DATA,NE_WARN)
    END IF
  END FUNCTION NE_RD

  FUNCTION NE_SD(A,B)
    LOGICAL :: NE_SD
    REAL, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_SD = .TRUE.
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'/=')
      NE_SD = .TRUE.
    ELSE
      NE_SD = A /= DATA%GRAPH(B%P)%RVAL
      IF ( .NOT. (NE_SD)) CALL ERROR_HANDLER(DATA,NE_WARN)
    END IF
  END FUNCTION NE_SD


! Nint
  FUNCTION NINT_D(A)
    TYPE (AD02_REAL) NINT_D
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP) VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    NINT_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'NINT')
      NINT_D = 0
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL ERROR_HANDLER(DATA,UNDEF_WARN,'NINT')
      NINT_D = 0
    ELSE
      NINT_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
!       Check for A being of the form N + 0.5, N integer
      IF (ABS(VA-AINT(VA))*2.0_WP==1.0_WP) CALL ERROR_HANDLER(DATA,NINT_WARN)
      NINT_D = NINT(VA)
    END IF
  END FUNCTION NINT_D

! Power
  FUNCTION POW_DD(A,B)
    TYPE (AD02_REAL) :: POW_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    INTEGER P
    REAL (WP) VA, VB, VC, LVA, FD
    LOGICAL INTEG
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    POW_DD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(POW_DD,A,B,'**')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(POW_DD,A,B,'**')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(POW_DD,A,B,'**')
    ELSE
      POW_DD%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      VB = DATA%GRAPH(B%P)%RVAL
!        A**B where A and B are both type AD02_REAL
!        Check for a<=0

      IF (VA<=0.0_WP) THEN
        CALL ERROR_HANDLER(DATA,POW1_ERR)
        CALL AD02_UNDEFINE(POW_DD,DATA)
        RETURN
      END IF
      IF (VB==ANINT(VB)) THEN
        P = NINT(VB)
        INTEG = .TRUE.
        VC = VA**P
      ELSE
        INTEG = .FALSE.
        VC = VA**VB
      END IF
      IF (INTEG) THEN
        FD = VB*VA**(P-1)
      ELSE
        FD = VB*VA**(VB-D1)
      END IF
      LVA = LOG(VA)
! Create new node in computational graph
      POW_DD%P = DATA%NUM_NODES
      DATA%GRAPH(DATA%NUM_NODES) = NODE(VC,(/FD,VC*LVA/),2,(/A%P,B%P/))
      IF (DATA%LEVEL==2) THEN
        DATA%DER2(0,DATA%NUM_NODES) = (VB*VB-VB)*VA**(VB-D2)
        DATA%DER2(1,DATA%NUM_NODES) = VA**(VB-D1)*(LVA*VB+D1)
        DATA%DER2(2,DATA%NUM_NODES) = VC*LVA*LVA
      END IF
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
    END IF
  END FUNCTION POW_DD


  FUNCTION POW_DI(A,B)
    TYPE (AD02_REAL) :: POW_DI
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: B
    REAL (WP) VA, SD, FD
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    POW_DI%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(POW_DI,A,'**')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(POW_DI,A,'**')
    ELSE
      POW_DI%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
      IF (B==1) THEN
        FD = 1
      ELSE
        FD = B*VA**(B-1)
      END IF
      IF (DATA%LEVEL==2) THEN
        IF (B==1) THEN
          SD = 0.0_WP
        ELSE IF (B==2) THEN
          SD = B*B - B
        ELSE
          SD = (B*B-B)*VA**(B-2)
        END IF
        IF (A%CASE<0) THEN
! Alter value and derivative information of node A%P
          CALL CONDENSE_NODE(DATA,VA**B,A%P,FD,SD,POW_DI)
        ELSE
! Create new node in computational graph
          POW_DI%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = NODE(VA**B,(/FD,SD/),1,(/A%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        IF (A%CASE<0) THEN
! Alter value and derivative information of node A%P
          CALL CONDENSE_NODE(DATA,VA**B,A%P,FD,D0,POW_DI)
        ELSE
! Create new node in computational graph
          POW_DI%P = DATA%NUM_NODES
!         DATA%GRAPH(DATA%NUM_NODES) = NODE(VA**B,(/FD,0.0_WP/),1,(/A%P,0/))
          DATA%GRAPH(DATA%NUM_NODES)%RVAL = VA**B
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = FD
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
          DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = A%P
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION POW_DI

  FUNCTION POW_DR(A,B)
    TYPE (AD02_REAL) :: POW_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
    REAL (WP) SD, FD, VA
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    POW_DR%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(POW_DR,A,'**')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(POW_DR,A,'**')
    ELSE
      POW_DR%CASE = -DATA%CASE
      VA = DATA%GRAPH(A%P)%RVAL
!       Check for A=0 and B not an integer and b<DEGREE.
      IF ((VA==0.0_WP) .AND. (B/=INT(B)) .AND. (B<DATA%LEVEL)) THEN
        CALL ERROR_HANDLER(DATA,POW2_ERR)
        CALL AD02_UNDEFINE(POW_DR,DATA)
        RETURN
      END IF
!       Raise to the power of a constant
      IF (B==1) THEN
        FD = 1
      ELSE
        FD = B*VA**(B-1)
      END IF
      IF (DATA%LEVEL==2) THEN
        IF (B==1) THEN
          SD = 0.0_WP
        ELSE IF (B==2) THEN
          SD = B*B - B
        ELSE
          SD = (B*B-B)*VA**(B-2)
        END IF
        IF (A%CASE<0) THEN
! Alter value and derivative information of node A%P
          CALL CONDENSE_NODE(DATA,VA**B,A%P,FD,SD,POW_DR)
        ELSE
! Create new node in computational graph
          POW_DR%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = NODE(VA**B,(/FD,SD/),1,(/A%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        IF (A%CASE<0) THEN
! Alter value and derivative information of node A%P
          CALL CONDENSE_NODE(DATA,VA**B,A%P,FD,D0,POW_DR)
        ELSE
! Create new node in computational graph
          POW_DR%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = NODE(VA**B,(/FD,0.0_WP/),1,(/A%P,0/))
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION POW_DR

  FUNCTION POW_DS(A,B)
    TYPE (AD02_REAL) :: POW_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(POW_DS,POW_DR(A,REAL(B,WP)))
  END FUNCTION POW_DS

  FUNCTION POW_ID(A,B)
    TYPE (AD02_REAL) :: POW_ID
    INTEGER, INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    CALL COPY(POW_ID,POW_RD(REAL(A,WP),B))
  END FUNCTION POW_ID

  FUNCTION POW_RD(A,B)
    TYPE (AD02_REAL) :: POW_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL (WP) RB, LVA, VC, FD
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    POW_RD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(POW_RD,B,'**')
    ELSE IF (B%DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(POW_RD,B,'**')
    ELSE
      POW_RD%CASE = -DATA%CASE
!       Check for a<=0
      IF (A<=0.0_WP) THEN
        CALL ERROR_HANDLER(DATA,POW1_ERR)
        CALL AD02_UNDEFINE(POW_RD,DATA)
        RETURN
      END IF
      RB = DATA%GRAPH(B%P)%RVAL
      VC = A**RB
      LVA = LOG(A)
      FD = VC*LVA
      IF (DATA%LEVEL==2) THEN
        IF (B%CASE<0) THEN
! Alter value and derivative information of node B%P
          CALL CONDENSE_NODE(DATA,VC,B%P,FD,FD*LVA,POW_RD)
        ELSE
! Create new node in computational graph
          POW_RD%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = NODE(VC,(/FD,FD*LVA/),1,(/B%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      ELSE
        IF (B%CASE<0) THEN
! Alter value and derivative information of node B%P
          CALL CONDENSE_NODE(DATA,VC,B%P,FD,0.0_WP,POW_RD)
        ELSE
! Create new node in computational graph
          POW_RD%P = DATA%NUM_NODES
          DATA%GRAPH(DATA%NUM_NODES) = NODE(VC,(/FD,0.0_WP/),1,(/B%P,0/))
          DATA%NUM_NODES = DATA%NUM_NODES + 1
          IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
        END IF
      END IF
    END IF
  END FUNCTION POW_RD

  FUNCTION POW_SD(A,B)
    TYPE (AD02_REAL) :: POW_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(POW_SD,POW_RD(REAL(A,WP),B))
  END FUNCTION POW_SD

! A do nothing function for DBLE
  FUNCTION REAL_D(A)
    TYPE (AD02_REAL), INTENT (IN) :: A
    TYPE (AD02_REAL) REAL_D
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    REAL_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(REAL_D,A,'DBLE')
    ELSE IF (DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(REAL_D,A,'DBLE')
    ELSE
      REAL_D = A
    END IF
  END FUNCTION REAL_D

! Sign
  FUNCTION SIGN_DD(A,B)
    TYPE (AD02_REAL) :: SIGN_DD
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    REAL (WP) VB,RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => A%DATA
    SIGN_DD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (A%P==-1 .OR. B%P==-1) THEN
      CALL BINARY_WARNING(SIGN_DD,A,B,'SIGN')
    ELSE IF (.NOT.ASSOCIATED(DATA,B%DATA)) THEN
      CALL BINARY_WARNING(SIGN_DD,A,B,'SIGN')
    ELSE IF (DATA%CASE/=ABS(A%CASE) .OR. DATA%CASE/=ABS(B%CASE)) THEN
      CALL BINARY_WARNING(SIGN_DD,A,B,'SIGN')
    ELSE
      SIGN_DD%CASE = -DATA%CASE
!       Check for SIGN(A,0)
      VB = DATA%GRAPH(B%P)%RVAL
      IF (VB>0.0_WP) THEN
        CALL COPY(SIGN_DD,ABS(A))
      ELSE IF (VB<0.0_WP) THEN
        CALL COPY(SIGN_DD,-ABS(A))
      ELSE
        CALL ERROR_HANDLER(DATA,SIGN_WARN)
        CALL RANDOM_NUMBER(RAND)
        CALL COPY(SIGN_DD,(RAND+RAND-1.0_WP)*ABS(A))
      END IF
    END IF
  END FUNCTION SIGN_DD

  FUNCTION SIGN_DR(A,B)
    TYPE (AD02_REAL) :: SIGN_DR
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (IN) :: B
! Check for undefined variable input and if an error has occured
    IF (A%P==-1) THEN
      CALL UNARY_WARNING(SIGN_DR,A,'SIGN')
    ELSE IF (A%DATA%CASE/=ABS(A%CASE)) THEN
      CALL UNARY_WARNING(SIGN_DR,A,'SIGN')
    ELSE
      IF (B>=0.0_WP) THEN
        CALL COPY(SIGN_DR,ABS(A))
      ELSE
        CALL COPY(SIGN_DR,-ABS(A))
      END IF
    END IF
  END FUNCTION SIGN_DR

  FUNCTION SIGN_DS(A,B)
    TYPE (AD02_REAL) :: SIGN_DS
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL, INTENT (IN) :: B
    CALL COPY(SIGN_DS,SIGN_DR(A,REAL(B,WP)))
  END FUNCTION SIGN_DS

  FUNCTION SIGN_RD(A,B)
    TYPE (AD02_REAL) :: SIGN_RD
    REAL (WP), INTENT (IN) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL (WP) VB, RAND
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => B%DATA
    SIGN_RD%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (B%P==-1) THEN
      CALL UNARY_WARNING(SIGN_RD,B,'SIGN')
    ELSE IF (DATA%CASE/=ABS(B%CASE)) THEN
      CALL UNARY_WARNING(SIGN_RD,B,'SIGN')
    ELSE
      SIGN_RD%CASE = -DATA%CASE
!       Check for SIGN(A,0)
      VB = DATA%GRAPH(B%P)%RVAL
! Create new node in computational graph
      SIGN_RD%P = DATA%NUM_NODES
      IF (VB>0.0_WP) THEN
        DATA%GRAPH(DATA%NUM_NODES) = NODE(ABS(A),(/0.0_WP,0.0_WP/),0,(/1,0/))
      ELSE IF (VB<0.0_WP) THEN
        DATA%GRAPH(DATA%NUM_NODES) = NODE(-ABS(A),(/0.0_WP,0.0_WP/),0,(/1,0/))
      ELSE
        CALL ERROR_HANDLER(DATA,SIGN_WARN)
        CALL RANDOM_NUMBER(RAND)
        DATA%GRAPH(DATA%NUM_NODES) =  NODE &
             ((RAND+RAND-1.0_WP)*ABS(A),(/0.0_WP,0.0_WP/),0,(/1,0/))
      END IF
      IF (DATA%LEVEL==2) DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
   END IF
  END FUNCTION SIGN_RD

  FUNCTION SIGN_SD(A,B)
    TYPE (AD02_REAL) :: SIGN_SD
    TYPE (AD02_REAL), INTENT (IN) :: B
    REAL, INTENT (IN) :: A
    CALL COPY(SIGN_SD,SIGN_RD(REAL(A,WP),B))
  END FUNCTION SIGN_SD

! Sine
  FUNCTION SIN_D(X)
    TYPE (AD02_REAL) :: SIN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA, V
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    SIN_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(SIN_D,X,'SIN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(SIN_D,X,'SIN')
    ELSE
      SIN_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      V = SIN(VA)
      IF (X%CASE<0) THEN
! Alter value and derivative information of node X%P
        CALL CONDENSE_NODE(DATA,V,X%P,COS(VA),-V,SIN_D)
      ELSE
! Create new node in computational graph
        SIN_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/COS(VA),-V/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/COS(VA),0.0_WP/),1,(/X%P,0/))
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION SIN_D


! Sinh
  FUNCTION SINH_D(X)
    TYPE (AD02_REAL) :: SINH_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA, V
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    SINH_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(SINH_D,X,'SINH')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(SINH_D,X,'SINH')
    ELSE
      SINH_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
      V = SINH(VA)
      IF (X%CASE<0) THEN
! Alter value and derivative information of node X%P
        CALL CONDENSE_NODE(DATA,V,X%P,COSH(VA),V,SINH_D)
      ELSE
! Create new node in computational graph
        SINH_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/COSH(VA),V/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/COSH(VA),0.0_WP/),1,(/X%P,0/))
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION SINH_D


! Sqrt
  FUNCTION SQRT_D(X)
    TYPE (AD02_REAL) :: SQRT_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) VA, VB
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    SQRT_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(SQRT_D,X,'SQRT')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(SQRT_D,X,'SQRT')
    ELSE
      SQRT_D%CASE = -DATA%CASE
      VA = DATA%GRAPH(X%P)%RVAL
!        Check for SQRT(0)
      IF (VA==D0) THEN
        CALL ERROR_HANDLER(DATA,SQRT_ERR)
        CALL AD02_UNDEFINE(SQRT_D,DATA)
        RETURN
      END IF
      VB = SQRT(VA)
      IF (X%CASE<0) THEN
        IF (DATA%LEVEL==2) THEN
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,VB,X%P,D1/(D2*VB),-D1/(4.0_WP*VB*VA),SQRT_D)
        ELSE
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,VB,X%P,D1/(D2*VB),D0,SQRT_D)
        END IF
      ELSE
! Create new node in computational graph
        SQRT_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) =  &
              NODE(VB,(/D1/(D2*VB),-D1/(4.0_WP*VB*VA)/),1, (/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES)%RVAL = VB
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = D1/(D2*VB)
          DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
          DATA%GRAPH(DATA%NUM_NODES)%ONUM = 1
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = X%P
          DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION SQRT_D


! Tan
  FUNCTION TAN_D(X)
    TYPE (AD02_REAL) :: TAN_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) V, V1
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    TAN_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(TAN_D,X,'TAN')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(TAN_D,X,'TAN')
    ELSE
      TAN_D%CASE = -DATA%CASE
      V = TAN(DATA%GRAPH(X%P)%RVAL)
      V1 = D1 + V**2
      IF (X%CASE<0) THEN
        IF (DATA%LEVEL==2) THEN
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,V,X%P,V1,D2*V*V1,TAN_D)
        ELSE
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,V,X%P,V1,D0,TAN_D)
        END IF
      ELSE
! Create new node in computational graph
        TAN_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/V1,D2*V*V1/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/V1,0.0_WP/),1,(/X%P,0/))
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION TAN_D


! Tanh
  FUNCTION TANH_D(X)
    TYPE (AD02_REAL) :: TANH_D
    TYPE (AD02_REAL), INTENT (IN) :: X
    REAL (WP) V, V2
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    TANH_D%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      CALL UNARY_WARNING(TANH_D,X,'TANH')
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      CALL UNARY_WARNING(TANH_D,X,'TANH')
    ELSE
      TANH_D%CASE = -DATA%CASE
      V = TANH(DATA%GRAPH(X%P)%RVAL)
      V2 = D1 - V*V
      IF (X%CASE<0) THEN
        IF (DATA%LEVEL==2) THEN
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,V,X%P,V2,-D2*V*V2,TANH_D)
        ELSE
! Alter value and derivative information of node X%P
          CALL CONDENSE_NODE(DATA,V,X%P,V2,D0,TANH_D)
        END IF
      ELSE
! Create new node in computational graph
        TANH_D%P = DATA%NUM_NODES
        IF (DATA%LEVEL==2) THEN
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/V2,-D2*V*V2/),1,(/X%P,0/))
          DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        ELSE
          DATA%GRAPH(DATA%NUM_NODES) = NODE(V,(/V2,0.0_WP/),1,(/X%P,0/))
        END IF
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END IF
    END IF
  END FUNCTION TANH_D


! The main routines

  SUBROUTINE BINARY_WARNING(FUN,A,B,PROC)
    TYPE (AD02_REAL), INTENT (OUT) :: FUN
    TYPE (AD02_REAL), INTENT (IN) :: A, B
    CHARACTER(*), OPTIONAL, INTENT(IN) :: PROC
    IF (ASSOCIATED(A%DATA) ) THEN
      CALL ERROR_HANDLER(A%DATA,UNDEF_WARN,PROC)
      FUN%DATA => A%DATA
    END IF
    IF (.NOT.ASSOCIATED(A%DATA,B%DATA) )THEN
      CALL ERROR_HANDLER(B%DATA,UNDEF_WARN,PROC)
      IF (ASSOCIATED(B%DATA) ) FUN%DATA => B%DATA
    END IF
    FUN%P = -1
  END SUBROUTINE BINARY_WARNING

! Node condensing routine
  SUBROUTINE CONDENSE_NODE(DATA,V,LHO,E1,E1D1,C)
    TYPE(AD02_DATA), INTENT(INOUT) :: DATA
    INTEGER, INTENT (IN) :: LHO
    REAL (WP), INTENT (IN) :: V, E1, E1D1
    TYPE (AD02_REAL), INTENT (INOUT) :: C
! Alter value of existing node
    DATA%GRAPH(LHO)%RVAL = V
! Alter derivative information of node
    IF (DATA%GRAPH(LHO)%ONUM==2) THEN
      IF (DATA%LEVEL==2) THEN
        DATA%DER2(1,LHO) = E1*DATA%DER2(1,LHO) + &
          E1D1*DATA%GRAPH(LHO)%RVALS(0)*DATA%GRAPH(LHO)%RVALS(1)
        DATA%DER2(0,LHO) = E1D1*DATA%GRAPH(LHO)%RVALS(0)**2 + &
                           E1*DATA%DER2(0,LHO)
        DATA%DER2(2,LHO) = E1D1*DATA%GRAPH(LHO)%RVALS(1)**2 + &
                           E1*DATA%DER2(2,LHO)
      END IF
      DATA%GRAPH(LHO)%RVALS = E1*DATA%GRAPH(LHO)%RVALS
    ELSE
      IF (DATA%LEVEL==2) DATA%GRAPH(LHO)%RVALS(1) = &
                         E1D1*DATA%GRAPH(LHO)%RVALS(0)**2 + &
                         DATA%GRAPH(LHO)%RVALS(1)*E1
      DATA%GRAPH(LHO)%RVALS(0) = E1*DATA%GRAPH(LHO)%RVALS(0)
    END IF
! Set values of AD02_REAL output variable
    C%P = LHO
  END SUBROUTINE CONDENSE_NODE


  SUBROUTINE CONTROL1(LP,MP,PRINT_LEVEL,STOP_LEVEL)
! This gives the user control over the error handling
    INTEGER, OPTIONAL, INTENT (IN) :: LP
    INTEGER, OPTIONAL, INTENT (IN) :: MP
    INTEGER, OPTIONAL, INTENT (IN) :: PRINT_LEVEL
    INTEGER, OPTIONAL, INTENT (IN) :: STOP_LEVEL
    IF (PRESENT(LP)) ERROR_MESSAGE_UNIT = LP
    IF (PRESENT(MP)) WARNING_MESSAGE_UNIT = MP
    IF (PRESENT(PRINT_LEVEL)) ERROR_PRINT_LEVEL = PRINT_LEVEL
    IF (PRESENT(STOP_LEVEL)) ERROR_STOP_LEVEL = STOP_LEVEL
  END SUBROUTINE CONTROL1

  SUBROUTINE CONTROL2(DATA,ERROR,LP,MP,PRINT_LEVEL,STOP_LEVEL)
! This gives the user control over the error handling
    TYPE(AD02_DATA),POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: LP
    INTEGER, OPTIONAL, INTENT (IN) :: MP
    INTEGER, OPTIONAL, INTENT (IN) :: PRINT_LEVEL
    INTEGER, OPTIONAL, INTENT (IN) :: STOP_LEVEL
    IF(ASSOCIATED(DATA))THEN
      ERROR = 0
      IF (PRESENT(LP)) DATA%ERROR_MESSAGE_UNIT = LP
      IF (PRESENT(MP)) DATA%WARNING_MESSAGE_UNIT = MP
      IF (PRESENT(PRINT_LEVEL)) DATA%ERROR_PRINT_LEVEL = PRINT_LEVEL
      IF (PRESENT(STOP_LEVEL)) DATA%ERROR_STOP_LEVEL = STOP_LEVEL
    ELSE
      ERROR = 2
    END IF
  END SUBROUTINE CONTROL2


! Subroutine to copy a variables value without the creation of new
! variable
  SUBROUTINE COPY(A,B)
    TYPE (AD02_REAL), INTENT (OUT) :: A
    TYPE (AD02_REAL), INTENT (IN) :: B
    A%P = B%P
    A%CASE = B%CASE
    A%DATA => B%DATA
  END SUBROUTINE COPY

  LOGICAL FUNCTION DATA_UNDEFINED(X)
    TYPE (AD02_REAL), INTENT (IN) :: X
    IF(ASSOCIATED(X%DATA)) THEN
      DATA_UNDEFINED = X%P==-1 .OR. X%DATA%CASE/=ABS(X%CASE)
      IF (X%DATA%CASE==-1) DATA_UNDEFINED = .FALSE.
    ELSE
      DATA_UNDEFINED = .FALSE.
    END IF
  END FUNCTION DATA_UNDEFINED

! To obtain the derivatives of a dependant variable in a packed form.
  SUBROUTINE DERIVS_S(A,R,INDEX,DERIVS,ERROR)
!?? To obtain the derivatives of a dependant variable in a packed form.
    TYPE (AD02_REAL), INTENT (IN) :: A
    INTEGER, INTENT (IN) :: R
    INTEGER, POINTER, DIMENSION (:) :: INDEX
    REAL (WP), POINTER, DIMENSION (:) :: DERIVS
    INTEGER, INTENT (OUT) :: ERROR
    ! 0 Successful
    ! 1 Undefined
    ! 2 Data undefined
    ! 3 Allocate failure
    ! 4 R out of range
    INTEGER I
    TYPE(AD02_DATA), POINTER :: DATA
    ERROR = 0
! Check that the independent variables have been initialized
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    ELSE IF (R<0 .OR. R>A%DATA%LEVEL) THEN
      ERROR = 4
    END IF
    IF(ERROR>0)RETURN

    DATA => A%DATA
! Allocate INDEX and DERIVS
    ALLOCATE (INDEX(DATA%SIZE_X))
! Set INDEX
    DO I = 1, DATA%SIZE_X
        INDEX(I) = I
    END DO
    IF (R==0) THEN
! Retrieve value
      ALLOCATE (DERIVS(1))
      CALL AD02_VALUE(A,DERIVS(1),ERROR)
    ELSE IF (R==1) THEN
! Retrieve gradient
      ALLOCATE (DERIVS(DATA%SIZE_X))
      CALL GETDER(DATA,A%P,DERIVS)
    ELSE
! Retrieve hessian
      ALLOCATE (DERIVS(DATA%SIZE_X*(DATA%SIZE_X+1)/2))
      CALL GETHES(DATA,A%P,DERIVS,SIZE(DERIVS),.TRUE.)
    END IF
  END SUBROUTINE DERIVS_S


  SUBROUTINE ERROR_HANDLER(DATA,ERROR_NUMBER,PROC)
! Error handling routine
    TYPE(AD02_DATA),POINTER :: DATA
    INTEGER, INTENT(IN) :: ERROR_NUMBER
    CHARACTER(*), OPTIONAL, INTENT(IN) :: PROC
    IF(ASSOCIATED(DATA))THEN
      DATA%FLAGS(ERROR_NUMBER) = DATA%FLAGS(ERROR_NUMBER) + 1
    ELSE
      AD02_FLAG(ERROR_NUMBER) = AD02_FLAG(ERROR_NUMBER) + 1
    END IF
    SELECT CASE (ERROR_NUMBER)
    CASE (1)
      CALL ERR_MESS_PRINT(DATA,'ERROR: Invalid call of AD02_INITIALIZE.', &
       .FALSE.)
    CASE (2)
      CALL ERR_MESS_PRINT(DATA, &
        'ERROR: Procedure call without prior AD02_INITIALIZE call.',.FALSE.)
    CASE (3)
      CALL ERR_MESS_PRINT(DATA, &
        'ERROR: Insufficient storage(failure of an ALLOCATE statment).', &
        .FALSE.)
    CASE (4)
      CALL ERR_MESS_PRINT(DATA,'ERROR: Invalid call of AD02_RESTORE',.FALSE.)
    CASE (5)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of SQRT(A) when A is of type AD02_REAL and has     &
     &         value 0.',.TRUE.)
    CASE (6)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of A**B when A and B are of type AD02_REAL, and A  &
     &         has a non-positive value.',.TRUE.)
    CASE (7)
      CALL ERR_MESS_PRINT(DATA, &
     'WARNING: Calculation of A**B when A is of type AD02_REAL, and B is of   &
     &         type REAL, A has value 0, and b has a non-integer value less   &
     &         than DEGREE.',.TRUE.)
    CASE (8)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of SIGN(A,B) when B is of type AD02_REAL and has   &
     &         value 0.',.TRUE.)
    CASE (9)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of ABS(A) or SIGN(A,B) when A is of type AD02_REAL &
     &         and has value 0.',.TRUE.)
    CASE (10)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of INT(A) when A is of type AD02_REAL and has an   &
     &         integer value.',.TRUE.)
    CASE (11)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of AINT(A) when A is of type AD02_REAL and has an  &
     &         integer value.',.TRUE.)
    CASE (12)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of NINT(A) when A is of type AD02_REAL and has a   &
     &         value n + 0.5, where n is an integer.',.TRUE.)
    CASE (13)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of ANINT(A) when A is of type AD02_REAL and has a  &
     &         value n + 0.5, where n is an integer.',.TRUE.)
    CASE (14)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of MAX(A,B) when at least one of A and B is of     &
     &         type AD02_REAL and A has the same value as B.', .TRUE.)
    CASE (15)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Calculation of MIN(A,B) when at least one of A and B is of     &
     &         type AD02_REAL and A has the same value as B.', .TRUE.)
    CASE (16)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A==B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (17)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A/=B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (18)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A>B when at least one of A and B is of type      &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (19)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A<B when at least one of A and B is of type      &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (20)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A>=B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (21)
      CALL ERR_MESS_PRINT(DATA,&
     'WARNING: Evaluation of A<=B when at least one of A and B is of type     &
     &         AD02_REAL and A has the same value as B.',.TRUE.)
    CASE (33)
      CALL ERR_MESS_PRINT(DATA, &
        'WARNING: Execution of '//PROC//' for value AD02_UNDEFINED.', .TRUE.)
    CASE (34)
      CALL ERR_MESS_PRINT(DATA, &
        'WARNING: Assignment to array of type AD02_REAL', .TRUE.)
    END SELECT

  CONTAINS

    SUBROUTINE ERR_MESS_PRINT(DATA,ERROR_MESSAGE,WARNING)
! This subroutine prints out the error/warning message on the
! specified output unit and halts execution, when specified to,
! by the user inputs DATA%ERROR_PRINT_LEVEL and DATA%ERROR_STOP_LEVEL
      TYPE(AD02_DATA),POINTER :: DATA
      CHARACTER (LEN=*), INTENT (IN) :: ERROR_MESSAGE
      LOGICAL, INTENT (IN) :: WARNING
      INTEGER :: I,J
      IF(ASSOCIATED(DATA))THEN
        IF (WARNING) THEN
          IF (DATA%ERROR_PRINT_LEVEL==2) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (DATA%ERROR_STOP_LEVEL==2) STOP 'AD02 EXECUTION HALTED'
        ELSE
          IF (DATA%ERROR_PRINT_LEVEL/=0) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (DATA%ERROR_STOP_LEVEL/=0) STOP 'AD02 EXECUTION HALTED'
        END IF
      ELSE
        IF (WARNING) THEN
          IF (ERROR_PRINT_LEVEL==2) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (ERROR_STOP_LEVEL==2) STOP 'AD02 EXECUTION HALTED'
        ELSE
          IF (ERROR_PRINT_LEVEL/=0) THEN
            DO I = 1,LEN(ERROR_MESSAGE),72
              J = MIN(I+71,LEN(ERROR_MESSAGE))
              WRITE (WARNING_MESSAGE_UNIT,'(A)') ERROR_MESSAGE(I:J)
            END DO
          END IF
          IF (ERROR_STOP_LEVEL/=0) STOP 'AD02 EXECUTION HALTED'
        END IF
      END IF
    END SUBROUTINE ERR_MESS_PRINT

  END SUBROUTINE ERROR_HANDLER

  SUBROUTINE FINALIZE(DATA,ERROR)
     TYPE(AD02_DATA), POINTER :: DATA
     INTEGER, INTENT (OUT) :: ERROR
     INTEGER STAT(3)
     ERROR = 0
     IF(.NOT.ASSOCIATED(DATA))THEN
        ERROR = 1
        RETURN
     END IF
     STAT = 0
     IF(ASSOCIATED(DATA%GRAPH)) DEALLOCATE(DATA%GRAPH,STAT=STAT(1))
     IF(ASSOCIATED(DATA%DER2)) DEALLOCATE(DATA%DER2,STAT=STAT(2))
     IF(ASSOCIATED(DATA%FLAGS)) DEALLOCATE(DATA%FLAGS,STAT=STAT(3))
     DATA%CASE = -1
     DATA%MAX_NODES = 0
     DATA%MAX_NODES2 = 0
     IF(ANY(STAT/=0))ERROR = 3
  END SUBROUTINE FINALIZE

  SUBROUTINE FLAGS1(L,FLAG,ERROR,RESET)
     INTEGER, INTENT(IN) :: L
     INTEGER, INTENT(OUT) :: FLAG,ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40) THEN
        ERROR = 1
     ELSE
        ERROR = 0
        FLAG = AD02_FLAG(L)
        IF(PRESENT(RESET)) THEN
          IF(RESET)AD02_FLAG(L)=0
        END IF
     END IF
  END SUBROUTINE FLAGS1

  SUBROUTINE FLAGS2(L,U,FLAG,ERROR,RESET)
     INTEGER, INTENT(IN) :: L,U
     INTEGER, INTENT(OUT) :: FLAG(L:U),ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40 .OR. U<1 .OR. U>40) THEN
        ERROR = 1
     ELSE
        ERROR = 0
        FLAG(L:U) = AD02_FLAG(L:U)
        IF(PRESENT(RESET)) THEN
          IF(RESET)AD02_FLAG(L:U)=0
        END IF
     END IF
  END SUBROUTINE FLAGS2

  SUBROUTINE FLAGS3(DATA,L,FLAG,ERROR,RESET)
     TYPE(AD02_DATA),POINTER :: DATA
     INTEGER, INTENT(IN) :: L
     INTEGER, INTENT(OUT) :: FLAG,ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40) THEN
        ERROR = 1
     ELSE IF (.NOT.ASSOCIATED(DATA))THEN
        ERROR = 2
     ELSE IF (.NOT.ASSOCIATED(DATA%FLAGS))THEN
        ERROR = 3
     ELSE
        ERROR = 0
        FLAG = DATA%FLAGS(L)
        IF(PRESENT(RESET)) THEN
          IF(RESET)DATA%FLAGS(L)=0
        END IF
     END IF
  END SUBROUTINE FLAGS3

  SUBROUTINE FLAGS4(DATA,L,U,FLAG,ERROR,RESET)
     TYPE(AD02_DATA),POINTER :: DATA
     INTEGER, INTENT(IN) :: L,U
     INTEGER, INTENT(OUT) :: FLAG(L:U),ERROR
     LOGICAL, INTENT(IN), OPTIONAL :: RESET
     IF(L<1 .OR. L>40 .OR. U<1 .OR. U>40) THEN
        ERROR = 1
     ELSE IF (.NOT.ASSOCIATED(DATA))THEN
        ERROR = 2
     ELSE IF (.NOT.ASSOCIATED(DATA%FLAGS))THEN
        ERROR = 3
     ELSE
        ERROR = 0
        FLAG(L:U) = DATA%FLAGS(L:U)
        IF(PRESENT(RESET)) THEN
          IF(RESET)DATA%FLAGS(L:U)=0
        END IF
     END IF
  END SUBROUTINE FLAGS4

! This routine calculates the derivatives from the computational graph
  SUBROUTINE GETDER(DATA,IF,DF)
    TYPE(AD02_DATA),POINTER :: DATA
    INTEGER, INTENT (IN) :: IF
    REAL (WP), INTENT (OUT) :: DF(:)
    REAL (WP), ALLOCATABLE :: RRES(:)
    INTEGER I, PC, STAT
    REAL (WP) R
!     Allocate workspace
    ALLOCATE (RRES(DATA%NUM_NODES),STAT=STAT)
!     Check for memory allocation error
    IF (STAT/=0) THEN
      CALL ERROR_HANDLER(DATA,ALLOC_ERR)
      RETURN
    END IF
!     Zero results
    RRES(1:DATA%SIZE_X) = D0       ! These cannot be combined in case
    RRES(DATA%SIZE_X+1:IF-1) = D0  ! DATA%SIZE_X = IF
! Calculate gradient vector of IF from computational graph
    RRES(IF) = D1
    DO I = IF, DATA%SIZE_X + 1, -1
      R = RRES(I)
      IF (R/=D0) THEN
        IF (DATA%GRAPH(I)%ONUM==2) THEN
          PC = DATA%GRAPH(I)%IPTRS(0)
          RRES(PC) = RRES(PC) + R*DATA%GRAPH(I)%RVALS(0)
          PC = DATA%GRAPH(I)%IPTRS(1)
          RRES(PC) = RRES(PC) + R*DATA%GRAPH(I)%RVALS(1)
        ELSE
          PC = DATA%GRAPH(I)%IPTRS(0)
          RRES(PC) = RRES(PC) + R*DATA%GRAPH(I)%RVALS(0)
        END IF
      END IF
    END DO
!     Collect results
    DF(1:DATA%SIZE_X) = RRES(1:DATA%SIZE_X)
!     Deallocate workspace
    DEALLOCATE (RRES)
  END SUBROUTINE GETDER


! This is where the second derivatives get calculated. This is a new
! subroutine, which doesn't exist in FM.
  SUBROUTINE GETHES(DATA,IF,DF2,LENG,PACKED,G)
    TYPE(AD02_DATA),POINTER :: DATA
    INTEGER, INTENT (IN) :: IF, LENG
    REAL (WP), INTENT (OUT) :: DF2(LENG)
    LOGICAL, INTENT (IN) :: PACKED
    REAL (WP), OPTIONAL, INTENT (OUT) :: G(:)
    INTEGER I, NC, PC, J, PC1, STAT, START_POINTER
    REAL (WP) R, R1, RR ,I1, I2
    REAL (WP), ALLOCATABLE :: RRES(:), RRES2(:), RRES3(:)
    START_POINTER = 0
!     Allocate workspace
    ALLOCATE (RRES(DATA%NUM_NODES),RRES2(DATA%NUM_NODES), &
             RRES3(DATA%NUM_NODES),STAT=STAT)
!     Check for memory allocation error
    IF (STAT/=0) THEN
      CALL ERROR_HANDLER(DATA,ALLOC_ERR)
      RETURN
    END IF
!     Compute first derivatives
!     First, zero the results
    RRES(1:DATA%SIZE_X) = D0       ! These cannot be combined in case
    RRES(DATA%SIZE_X+1:IF-1) = D0  ! DATA%SIZE_X = IF
!     Now we do the computation bit
    RRES(IF) = D1
    DO I = IF, DATA%SIZE_X+1, -1
      R = RRES(I)
      IF (R/=D0) THEN
        IF (DATA%GRAPH(I)%ONUM==2) THEN
          RRES(DATA%GRAPH(I)%IPTRS(0)) = &
              RRES(DATA%GRAPH(I)%IPTRS(0))+R*DATA%GRAPH(I)%RVALS(0)
          RRES(DATA%GRAPH(I)%IPTRS(1)) = &
              RRES(DATA%GRAPH(I)%IPTRS(1))+R*DATA%GRAPH(I)%RVALS(1)
        ELSE
          PC = DATA%GRAPH(I)%IPTRS(0)
          RRES(PC) = RRES(PC) + R*DATA%GRAPH(I)%RVALS(0)
        END IF
      END IF
    END DO
!     If the gradient is required, retrieve the gradient
    IF (PRESENT(G)) THEN
!       Retrieve Gradient G
      G(1:DATA%SIZE_X) = RRES(1:DATA%SIZE_X)
    END IF
    DO J = 1, DATA%SIZE_X
!        Zero results again
      RRES2(1:DATA%SIZE_X) = D0
      RRES3(1:MAX(IF,DATA%SIZE_X)) = D0
      RRES2(J) = D1
!        OK, we've zeroed enough to start work now, and IX(J) has
! been set to one, so we can compute the RRES2 nodes, and the initial
! RRES3 bits
      DO I = DATA%SIZE_X + 1,IF
        RR = D0
        NC = DATA%GRAPH(I)%ONUM
          R = RRES(I)
          IF (NC==2) THEN
            RR = RRES2(DATA%GRAPH(I)%IPTRS(0))*DATA%GRAPH(I)%RVALS(0) + &
              RRES2(DATA%GRAPH(I)%IPTRS(1))*DATA%GRAPH(I)%RVALS(1)
            IF (R/=D0) THEN
              PC1 = DATA%GRAPH(I)%IPTRS(0)
              R1 = RRES3(PC1)
              I1 = RRES2(DATA%GRAPH(I)%IPTRS(0))
              I2 = RRES2(DATA%GRAPH(I)%IPTRS(1))
              R1 = R1 + R*(I1*DATA%DER2(0,I) + I2*DATA%DER2(1,I))
              RRES3(PC1) = R1
              PC1 = DATA%GRAPH(I)%IPTRS(1)
              R1 = RRES3(PC1)
              R1 = R1 + R*(I1*DATA%DER2(1,I) + I2*DATA%DER2(2,I))
              RRES3(PC1) = R1
            END IF
          ELSE
            RR = RRES2(DATA%GRAPH(I)%IPTRS(0))*DATA%GRAPH(I)%RVALS(0)
            IF (R/=D0) THEN
              PC1 = DATA%GRAPH(I)%IPTRS(0)
              R1 = RRES3(PC1)
              R1 = R1 + R*RRES2(DATA%GRAPH(I)%IPTRS(0))*DATA%GRAPH(I)%RVALS(1)
              RRES3(PC1) = R1
            END IF
          END IF
        RRES2(I) = RR
      END DO
!        We're in the final stretch now.  We ripple the RRES3's down
! the graph, just like in stage 2 (first partial evaluation)
      DO I = IF, 1, -1
        R = RRES3(I)
        IF (R/=D0) THEN
          IF (DATA%GRAPH(I)%ONUM==2) THEN
            RRES3(DATA%GRAPH(I)%IPTRS(0)) = RRES3(DATA%GRAPH(I)%IPTRS(0)) + &
                                    R*DATA%GRAPH(I)%RVALS(0)
            RRES3(DATA%GRAPH(I)%IPTRS(1)) = RRES3(DATA%GRAPH(I)%IPTRS(1)) + &
                                    R*DATA%GRAPH(I)%RVALS(1)
          ELSE
            PC = DATA%GRAPH(I)%IPTRS(0)
            RRES3(PC) = RRES3(PC) + R*DATA%GRAPH(I)%RVALS(0)
          END IF
        END IF
      END DO

      IF (PACKED) THEN
!          Read off the results into packed structure for AD02_DERIVS
        DO I = 1, J
          IF (I==J) THEN
            DF2(START_POINTER+I) = RRES3(I)/2.0_WP
          ELSE
            DF2(START_POINTER+I) = RRES3(I)
          END IF
        END DO
        START_POINTER = START_POINTER + J
      ELSE
!          Read off the results into unpacked structure for AD02_HESSIAN
        DO I = 1, J
          DF2(I+((J-1)*DATA%SIZE_X)) = RRES3(I)
          DF2(J+((I-1)*DATA%SIZE_X)) = RRES3(I)
        END DO
      END IF
    END DO
    DEALLOCATE (RRES,RRES2,RRES3,STAT=STAT)

  END SUBROUTINE GETHES

! Gradient (first derivative)
  SUBROUTINE GRAD0(A,GRAD,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: GRAD
    INTEGER, INTENT (OUT) :: ERROR
    REAL (WP) X1(1)
    CALL GRAD1(A,X1,ERROR)
    GRAD = X1(1)
  END SUBROUTINE GRAD0

  SUBROUTINE GRAD1(A,GRAD,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: GRAD(:)
    INTEGER, INTENT (OUT) :: ERROR
    ! 0 Successful
    ! 1 Undefined
    ! 2 Data undefined
    ! 3 Allocate failure
    ! 4 First derivatives not being calculated
    ! 5 Array sizes differ
    TYPE(AD02_DATA), POINTER :: DATA
!       Error checks
    ERROR = 0
    GRAD = 0.0_WP
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    ELSE
      DATA => A%DATA
      IF (DATA%LEVEL==0) THEN
        ERROR = 4
      ELSE IF (DATA%SIZE_X/=SIZE(GRAD)) THEN
        ERROR = 5
      END IF
    END IF
    IF(ERROR>0)RETURN
    CALL GETDER(DATA,A%P,GRAD)
  END SUBROUTINE GRAD1

! Hessian (Second derivative)
  SUBROUTINE HESSIAN0(A,HESSIAN,ERROR,GRAD)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: HESSIAN
    INTEGER, INTENT (OUT) :: ERROR
    REAL (WP), OPTIONAL, INTENT (OUT) :: GRAD
    REAL (WP) :: H1(1,1), G1(1)
    IF (PRESENT(GRAD)) THEN
      CALL HESSIAN1(A,H1,ERROR,G1)
      IF (ERROR>0) RETURN
      HESSIAN = H1(1,1)
      GRAD = G1(1)
    ELSE
      CALL HESSIAN1(A,H1,ERROR)
      IF (ERROR>0) RETURN
      HESSIAN = H1(1,1)
    END IF
  END SUBROUTINE HESSIAN0

  SUBROUTINE HESSIAN1(A,HESSIAN,ERROR,GRAD)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: HESSIAN(:,:)
    INTEGER, INTENT (OUT) :: ERROR
    ! 0 Successful
    ! 1 Undefined
    ! 2 Data undefined
    ! 3 Allocate failure
    ! 4 Second derivatives not being calculated
    ! 5 GRAD has the wrong size
    ! 6 HESSIAN has the wrong shape
    REAL (WP), OPTIONAL, INTENT (OUT) :: GRAD(:)
    TYPE(AD02_DATA), POINTER :: DATA
    HESSIAN = 0.0_WP
    ERROR = 0
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    ELSE
      DATA => A%DATA
      IF (DATA%LEVEL<2) THEN
        ERROR = 4
      ELSE IF (SIZE(HESSIAN,1)/=DATA%SIZE_X .OR. &
             SIZE(HESSIAN,2)/=DATA%SIZE_X) THEN
        ERROR = 6
      ELSE IF (PRESENT(GRAD)) THEN
        IF (DATA%SIZE_X/=SIZE(GRAD)) ERROR = 5
      END IF
    END IF
    IF(ERROR>0)RETURN
    CALL GETHES(DATA,A%P,HESSIAN,DATA%SIZE_X*DATA%SIZE_X,.FALSE.,GRAD)
  END SUBROUTINE HESSIAN1

  SUBROUTINE INITIALIZE_DATA(DATA,ERROR)
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER STAT
    ALLOCATE (DATA,STAT=STAT)
    IF (STAT/=0) THEN
       ERROR = 3
       RETURN
    END IF
    ALLOCATE(DATA%FLAGS(40),STAT=STAT)
    IF (STAT/=0) THEN
       ERROR = 3
       RETURN
    END IF
    DATA%FLAGS = 0
    DATA%MAX_CASE = DATA%MAX_CASE + 1
    DATA%CASE = DATA%MAX_CASE
  END SUBROUTINE INITIALIZE_DATA

! Declare independent variable and give it a value and set order of
! derivatives required
  SUBROUTINE INITIALIZE_11(DEGREE,X,VALUE,DATA,ERROR,FULL_THRESHOLD)
    INTEGER, INTENT (IN) :: DEGREE
    TYPE (AD02_REAL), INTENT (OUT) :: X(:)
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: FULL_THRESHOLD
    REAL (WP), INTENT (IN) :: VALUE(:)
    INTEGER STAT, I

! Check for obvious errors
    ERROR = 0
    IF (SIZE(X)/=SIZE(VALUE)) THEN
       ERROR = 5
       RETURN
    ELSE IF (DEGREE<0 .OR. DEGREE>2) THEN
       ERROR = 4
       RETURN
    END IF

    IF(.NOT.ASSOCIATED(DATA)) THEN
       ALLOCATE (DATA,STAT=STAT)
       IF (STAT/=0) THEN
          ERROR = 3
          RETURN
       END IF
    ELSE IF (DATA%CASE==-1) THEN
       ALLOCATE (DATA,STAT=STAT)
       IF (STAT/=0) THEN
          ERROR = 3
          RETURN
       END IF
    END IF
    IF(.NOT.ASSOCIATED(DATA%FLAGS)) THEN
       ALLOCATE(DATA%FLAGS(40),STAT=STAT)
       IF (STAT/=0) THEN
          ERROR = 3
          RETURN
       END IF
       DATA%FLAGS = 0
    END IF
    DATA%MAX_CASE = DATA%MAX_CASE + 1
    DATA%CASE = DATA%MAX_CASE
    DO I = 1,SIZE(X)
      X(I)%DATA => DATA
      X(I)%CASE = DATA%CASE
    END DO
    DATA%SIZE_X = SIZE(X)
    DATA%LEVEL = DEGREE

    IF (PRESENT(FULL_THRESHOLD)) I = FULL_THRESHOLD

!     Set parameter for LOG10 routine
    LN10 = LOG(10.0_WP)
!   Allocate the arrays DATA%GRAPH (and DATA%DER2 if LEVEL=2)
      IF (DATA%MAX_NODES<=0) THEN
        DATA%MAX_NODES = INIT_MAX_NODES
        ALLOCATE (DATA%GRAPH(DATA%MAX_NODES),STAT=STAT)
        IF (STAT/=0) THEN
          ERROR = 3
          RETURN
        END IF
      END IF
      IF (DEGREE==2) THEN
        IF (DATA%MAX_NODES2/=DATA%MAX_NODES) THEN
          DATA%MAX_NODES2 = DATA%MAX_NODES
          IF (ASSOCIATED(DATA%DER2)) DEALLOCATE (DATA%DER2)
          ALLOCATE (DATA%DER2(0:2,DATA%MAX_NODES),STAT=STAT)
          IF (STAT/=0) THEN
            ERROR = 3
            RETURN
          END IF
        END IF
      END IF
      DATA%NUM_NODES = 1
      DATA%LEVEL = DEGREE
      DO I = 1, DATA%SIZE_X
!       Create new node in computational graph
        X(I)%P = I
!       DATA%GRAPH(DATA%NUM_NODES) = NODE(VALUE(I),(/0.0_WP,0.0_WP/),0,(/1,0/))
        DATA%GRAPH(DATA%NUM_NODES)%RVAL = VALUE(I)
        DATA%GRAPH(DATA%NUM_NODES)%RVALS(0) = 0.0_WP
        DATA%GRAPH(DATA%NUM_NODES)%RVALS(1) = 0.0_WP
        DATA%GRAPH(DATA%NUM_NODES)%ONUM = 0
        DATA%GRAPH(DATA%NUM_NODES)%IPTRS(0) = 1
        DATA%GRAPH(DATA%NUM_NODES)%IPTRS(1) = 0
        IF (DATA%LEVEL==2)  DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
        DATA%NUM_NODES = DATA%NUM_NODES + 1
        IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
      END DO
  END SUBROUTINE INITIALIZE_11

  SUBROUTINE INITIALIZE_10(DEGREE,X,VALUE,DATA,ERROR,FULL_THRESHOLD)
    INTEGER, INTENT (IN) :: DEGREE
    TYPE (AD02_REAL), INTENT (OUT) :: X(:)
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: FULL_THRESHOLD
    REAL (WP), INTENT (IN) :: VALUE
    REAL (WP), DIMENSION (SIZE(X)) :: VAL
    VAL = VALUE
    CALL INITIALIZE_11(DEGREE,X,VAL,DATA,ERROR,FULL_THRESHOLD)
  END SUBROUTINE INITIALIZE_10

  SUBROUTINE INITIALIZE_0(DEGREE,X,VALUE,DATA,ERROR,FULL_THRESHOLD)
    INTEGER, INTENT (IN) :: DEGREE
    TYPE (AD02_REAL), INTENT (OUT) :: X
    REAL (WP), INTENT (IN) :: VALUE
    TYPE (AD02_DATA), POINTER :: DATA
    INTEGER, INTENT (OUT) :: ERROR
    INTEGER, OPTIONAL, INTENT (IN) :: FULL_THRESHOLD
    REAL (WP) VAL(1)
    TYPE (AD02_REAL) :: A1(1)
    VAL(1) = VALUE
    CALL INITIALIZE_11(DEGREE,A1,VAL,DATA,ERROR,FULL_THRESHOLD)
    X = A1(1)
  END SUBROUTINE INITIALIZE_0

! Make variable temporary
  SUBROUTINE MAKE_TEMP(A)
    TYPE (AD02_REAL), INTENT (INOUT) :: A
    A%CASE = -ABS(A%CASE)
  END SUBROUTINE MAKE_TEMP

! Increase the sizes of the arrays storing the the computational graph
  SUBROUTINE REQMEM_NODES(DATA)
    TYPE (AD02_DATA), POINTER :: DATA
    TYPE (NODE), ALLOCATABLE :: TEMP1(:)
    REAL (WP), ALLOCATABLE :: TEMP2(:,:)
    INTEGER STAT
    ALLOCATE (TEMP1(DATA%MAX_NODES),STAT=STAT)
!       Check for failure of allocate statement
    IF (STAT/=0) THEN
      CALL ERROR_HANDLER(DATA,ALLOC_ERR)
      RETURN
    END IF
    TEMP1 = DATA%GRAPH
    DEALLOCATE (DATA%GRAPH)
    ALLOCATE (DATA%GRAPH(DATA%MAX_NODES*2),STAT=STAT)
!       Check for failure of allocate statement
    IF (STAT/=0) THEN
      CALL ERROR_HANDLER(DATA,ALLOC_ERR)
      RETURN
    END IF
    DATA%GRAPH(1:DATA%MAX_NODES) = TEMP1
    DEALLOCATE (TEMP1)
    IF (DATA%LEVEL==2) THEN
      ALLOCATE (TEMP2(0:2,DATA%MAX_NODES),STAT=STAT)
!       Check for failure of allocate statement
      IF (STAT/=0) THEN
        CALL ERROR_HANDLER(DATA,ALLOC_ERR)
        RETURN
      END IF
      TEMP2 = DATA%DER2
      DEALLOCATE (DATA%DER2)
      ALLOCATE (DATA%DER2(0:2,DATA%MAX_NODES*2),STAT=STAT)
      DATA%MAX_NODES2 = DATA%MAX_NODES*2
!       Check for failure of allocate statement
      IF (STAT/=0) THEN
        CALL ERROR_HANDLER(DATA,ALLOC_ERR)
        RETURN
      END IF
      DATA%DER2(:,1:DATA%MAX_NODES) = TEMP2
      DEALLOCATE (TEMP2)
    END IF
    DATA%MAX_NODES = DATA%MAX_NODES*2
  END SUBROUTINE REQMEM_NODES

  SUBROUTINE UNARY_WARNING(FUN,A,PROC)
    TYPE (AD02_REAL), INTENT (OUT) :: FUN
    TYPE (AD02_REAL), INTENT (IN) :: A
    CHARACTER(*), OPTIONAL, INTENT(IN) :: PROC
    CALL ERROR_HANDLER(A%DATA,UNDEF_WARN,PROC)
    FUN%DATA => A%DATA
  END SUBROUTINE UNARY_WARNING

  LOGICAL FUNCTION UNDEFINED(X)
    TYPE (AD02_REAL), INTENT (IN) :: X
    IF(ASSOCIATED(X%DATA))THEN
      UNDEFINED = X%DATA%CASE==-1
    ELSE
      UNDEFINED = .TRUE.
    END IF
  END FUNCTION UNDEFINED

  SUBROUTINE UNDEFINE_REAL0(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    IF(PRESENT(DATA))then
       F%DATA => DATA
       IF(ASSOCIATED(DATA)) F%CASE = DATA%CASE
    ELSE
       NULLIFY(F%DATA)
       F%CASE = 0
    END IF
    F%P = -1
  END SUBROUTINE UNDEFINE_REAL0

  SUBROUTINE UNDEFINE_REAL1(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F)
      CALL AD02_UNDEFINE(F(I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL1

  SUBROUTINE UNDEFINE_REAL2(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,2)
      CALL AD02_UNDEFINE(F(:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL2

  SUBROUTINE UNDEFINE_REAL3(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,3)
      CALL AD02_UNDEFINE(F(:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL3

  SUBROUTINE UNDEFINE_REAL4(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,4)
      CALL AD02_UNDEFINE(F(:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL4

  SUBROUTINE UNDEFINE_REAL5(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,5)
      CALL AD02_UNDEFINE(F(:,:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL5

  SUBROUTINE UNDEFINE_REAL6(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,6)
      CALL AD02_UNDEFINE(F(:,:,:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL6

  SUBROUTINE UNDEFINE_REAL7(F,DATA)
    TYPE (AD02_REAL), INTENT (OUT) :: F(:,:,:,:,:,:,:)
    TYPE (AD02_DATA), POINTER, OPTIONAL :: DATA
    INTEGER I
    DO I = 1,SIZE(F,7)
      CALL AD02_UNDEFINE(F(:,:,:,:,:,:,I),DATA)
    END DO
  END SUBROUTINE UNDEFINE_REAL7


  SUBROUTINE USER(D,X,F,NAME)
!     User defined unary function
    TYPE (AD02_REAL), INTENT (IN) :: X
    TYPE (AD02_REAL), INTENT (OUT) :: F
    REAL (WP), INTENT (IN) :: D(0:)
    CHARACTER (LEN=*), INTENT (IN), OPTIONAL :: NAME
    TYPE(AD02_DATA), POINTER :: DATA
    DATA => X%DATA
    F%DATA => DATA
! Check for undefined variable input and if an error has occured
    IF (X%P==-1) THEN
      IF (PRESENT(NAME)) THEN
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,NAME)
      ELSE
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AD02_USER')
      END IF
      F%P = -1
    ELSE IF (DATA%CASE/=ABS(X%CASE)) THEN
      IF (PRESENT(NAME)) THEN
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,NAME)
      ELSE
        CALL ERROR_HANDLER(DATA,UNDEF_WARN,'AD02_USER')
      END IF
      F%P = -1
    ELSE
      F%CASE = -DATA%CASE
! Set values of AD02_REAL ouput variable
      F%P = DATA%NUM_NODES
! Create new node in computational graph
      IF (DATA%LEVEL==2) THEN
        DATA%GRAPH(DATA%NUM_NODES) = NODE(D(0),(/D(1),D(2)/),1,(/X%P,0/))
        DATA%DER2(:,DATA%NUM_NODES) = 0.0_WP
      ELSE
        DATA%GRAPH(DATA%NUM_NODES) = NODE(D(0),(/D(1),0.0_WP/),1,(/X%P,0/))
      END IF
      DATA%NUM_NODES = DATA%NUM_NODES + 1
      IF (DATA%NUM_NODES>DATA%MAX_NODES) CALL REQMEM_NODES(DATA)
    END IF
  END SUBROUTINE USER


! Returns the value of an AD02_REAL variable
  SUBROUTINE VALUE_SCALAR(A,VALUE,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A
    REAL (WP), INTENT (OUT) :: VALUE
    INTEGER, INTENT (OUT) :: ERROR
    ! 0 Successful
    ! 1 Undefined
    ! 2 Data undefined
    TYPE(AD02_DATA), POINTER :: DATA
    VALUE = 0.0_WP
    ERROR = 0
    IF (AD02_UNDEFINED(A))THEN
      ERROR = 1
    ELSE IF (AD02_DATA_UNDEFINED(A))THEN
      ERROR = 2
    END IF
    IF(ERROR>0)RETURN

    DATA => A%DATA
    VALUE = DATA%GRAPH(A%P)%RVAL
  END SUBROUTINE VALUE_SCALAR

! Returns the values of an one-dimensional array of AD02_REAL variables
  SUBROUTINE VALUE_ARRAY(A,VALUE,ERROR)
    TYPE (AD02_REAL), INTENT (IN) :: A(:)
    REAL (WP), INTENT (OUT) :: VALUE(:)
    INTEGER, INTENT (OUT) :: ERROR
    ! 0 Successful
    ! 1 An element is undefined
    ! 2 An element is data undefined
    INTEGER I,ERR
    ERROR = 0
    IF (SIZE(A)/=SIZE(VALUE)) ERROR = 5
    DO I = 1, MIN(SIZE(VALUE),SIZE(A))
       CALL VALUE_SCALAR(A(I),VALUE(I),ERR)
       IF(ERR>0)ERROR = ERR
    END DO
  END SUBROUTINE VALUE_ARRAY

END MODULE HSL_AD02_BACKWARD_DOUBLE




! COPYRIGHT (c) 1980 AEA Technology
! Original date 1 December 1993
!       Toolpack tool decs employed.
!       Arg dimensions changed to *.
! 1/4/99 Size of MARK increased to 100.
! 13/3/02 Cosmetic changes applied to reduce single/double differences
!
! 12th July 2004 Version 1.0.0. Version numbering added.

      SUBROUTINE KB07AI(COUNT,N,INDEX)
!
!             KB07AI      HANDLES INTEGER VARIABLES
!  THE WORK-SPACE 'MARK' OF LENGTH 100 PERMITS UP TO 2**50 NUMBERS
!  TO BE SORTED.

!     .. Scalar Arguments ..
      INTEGER N
!     ..
!     .. Array Arguments ..
      INTEGER COUNT(*)
      INTEGER INDEX(*)
!     ..
!     .. Local Scalars ..
      INTEGER AV,X
      INTEGER I,IF,IFK,IFKA,INT,INTEST,IP,IS,IS1,IY,J,K,K1,LA,LNGTH,M, &
              MLOOP
!     ..
!     .. Local Arrays ..
      INTEGER MARK(100)
!     ..
!     .. Executable Statements ..
!  SET INDEX ARRAY TO ORIGINAL ORDER .
      DO 10 I = 1,N
        INDEX(I) = I
   10 CONTINUE
!  CHECK THAT A TRIVIAL CASE HAS NOT BEEN ENTERED .
      IF (N.EQ.1) GO TO 200
      IF (N.GE.1) GO TO 30
      WRITE (6,FMT=20)

   20 FORMAT (/,/,/,20X,' ***KB07AI** NO NUMBERS TO BE SORTED ** ', &
       'RETURN TO CALLING PROGRAM')

      GO TO 200
!  'M' IS THE LENGTH OF SEGMENT WHICH IS SHORT ENOUGH TO ENTER
!  THE FINAL SORTING ROUTINE. IT MAY BE EASILY CHANGED.
   30 M = 12
!  SET UP INITIAL VALUES.
      LA = 2
      IS = 1
      IF = N
      DO 190 MLOOP = 1,N
!  IF SEGMENT IS SHORT ENOUGH SORT WITH FINAL SORTING ROUTINE .
        IFKA = IF - IS
        IF ((IFKA+1).GT.M) GO TO 70
!********* FINAL SORTING ***
!  ( A SIMPLE BUBBLE SORT )
        IS1 = IS + 1
        DO 60 J = IS1,IF
          I = J
   40     IF (COUNT(I-1).LT.COUNT(I)) GO TO 60
          IF (COUNT(I-1).GT.COUNT(I)) GO TO 50
          IF (INDEX(I-1).LT.INDEX(I)) GO TO 60
   50     AV = COUNT(I-1)
          COUNT(I-1) = COUNT(I)
          COUNT(I) = AV
          INT = INDEX(I-1)
          INDEX(I-1) = INDEX(I)
          INDEX(I) = INT
          I = I - 1
          IF (I.GT.IS) GO TO 40
   60   CONTINUE
        LA = LA - 2
        GO TO 170
!             *******  QUICKSORT  ********
!  SELECT THE NUMBER IN THE CENTRAL POSITION IN THE SEGMENT AS
!  THE TEST NUMBER.REPLACE IT WITH THE NUMBER FROM THE SEGMENT'S
!  HIGHEST ADDRESS.
   70   IY = (IS+IF)/2
        X = COUNT(IY)
        INTEST = INDEX(IY)
        COUNT(IY) = COUNT(IF)
        INDEX(IY) = INDEX(IF)
!  THE MARKERS 'I' AND 'IFK' ARE USED FOR THE BEGINNING AND END
!  OF THE SECTION NOT SO FAR TESTED AGAINST THE PRESENT VALUE
!  OF X .
        K = 1
        IFK = IF
!  WE ALTERNATE BETWEEN THE OUTER LOOP THAT INCREASES I AND THE
!  INNER LOOP THAT REDUCES IFK, MOVING NUMBERS AND INDICES AS
!  NECESSARY, UNTIL THEY MEET .
        DO 110 I = IS,IF
          IF (X.GT.COUNT(I)) GO TO 110
          IF (X.LT.COUNT(I)) GO TO 80
          IF (INTEST.GT.INDEX(I)) GO TO 110
   80     IF (I.GE.IFK) GO TO 120
          COUNT(IFK) = COUNT(I)
          INDEX(IFK) = INDEX(I)
          K1 = K
          DO 100 K = K1,IFKA
            IFK = IF - K
            IF (COUNT(IFK).GT.X) GO TO 100
            IF (COUNT(IFK).LT.X) GO TO 90
            IF (INTEST.LE.INDEX(IFK)) GO TO 100
   90       IF (I.GE.IFK) GO TO 130
            COUNT(I) = COUNT(IFK)
            INDEX(I) = INDEX(IFK)
            GO TO 110

  100     CONTINUE
          GO TO 120

  110   CONTINUE
!  RETURN THE TEST NUMBER TO THE POSITION MARKED BY THE MARKER
!  WHICH DID NOT MOVE LAST. IT DIVIDES THE INITIAL SEGMENT INTO
!  2 PARTS. ANY ELEMENT IN THE FIRST PART IS LESS THAN OR EQUAL
!  TO ANY ELEMENT IN THE SECOND PART, AND THEY MAY NOW BE SORTED
!  INDEPENDENTLY .
  120   COUNT(IFK) = X
        INDEX(IFK) = INTEST
        IP = IFK
        GO TO 140

  130   COUNT(I) = X
        INDEX(I) = INTEST
        IP = I
!  STORE THE LONGER SUBDIVISION IN WORKSPACE.
  140   IF ((IP-IS).GT. (IF-IP)) GO TO 150
        MARK(LA) = IF
        MARK(LA-1) = IP + 1
        IF = IP - 1
        GO TO 160

  150   MARK(LA) = IP - 1
        MARK(LA-1) = IS
        IS = IP + 1
!  FIND THE LENGTH OF THE SHORTER SUBDIVISION.
  160   LNGTH = IF - IS
        IF (LNGTH.LE.0) GO TO 180
!  IF IT CONTAINS MORE THAN ONE ELEMENT SUPPLY IT WITH WORKSPACE .
        LA = LA + 2
        GO TO 190

  170   IF (LA.LE.0) GO TO 200
!  OBTAIN THE ADDRESS OF THE SHORTEST SEGMENT AWAITING QUICKSORT
  180   IF = MARK(LA)
        IS = MARK(LA-1)
  190 CONTINUE
  200 RETURN

      END SUBROUTINE

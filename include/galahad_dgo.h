//* \file galahad_dgo.h */

/*
 * THIS VERSION: GALAHAD 4.0 - 2022-03-13 AT 16:15 GMT.
 *
 *-*-*-*-*-*-*-*-*-  GALAHAD_DGO C INTERFACE  *-*-*-*-*-*-*-*-*-*-
 *
 *  Copyright reserved, Gould/Orban/Toint, for GALAHAD productions
 *  Principal author: Jaroslav Fowkes & Nick Gould
 *
 *  History -
 *   originally released GALAHAD Version 3.3. August 6th 2021
 *
 *  For full documentation, see
 *   http://galahad.rl.ac.uk/galahad-www/specs.html
 */

/*! \mainpage GALAHAD C package dgo

  \section dgo_intro Introduction

  \subsection dgo_purpose Purpose

  The dgo package uses a <b>deterministic partition-and-bound trust-region
  method to find an approximation to the global minimizer of a differentiable
  objective function \f$f(x)\f$ of \f$n\f$ variables \f$x\f$, subject to a
  finite set of simple bounds \f$x^l \leq x \leq x^u\f$ on the
  variables.</b>
  The method offers the choice of direct
  and iterative solution of the key trust-region subproblems, and
  is suitable for large problems. First derivatives are required,
  and if second derivatives can be calculated, they will be exploited---if
  the product of second derivatives with a vector may be found but
  not the derivatives themselves, that may also be exploited.

  Although there are theoretical guarantees, these may require a large
  number of evaluations as the dimension and nonconvexity increase.
  The alternative GALAHAD package bgo may sometimes be
  preferred.

  \subsection dgo_authors Authors

  J. Fowkes and N. I. M. Gould, STFC-Rutherford Appleton Laboratory, England.

  Julia interface, additionally A. Montoison and D. Orban, Polytechnique Montréal.

  \subsection dgo_date Originally released

  July 2021, C interface August 2021.

  \subsection dgo_terminology Terminology

  The \e gradient \f$\nabla_x f(x)\f$ of \f$f(x)\f$ is the vector whose
  \f$i\f$-th component is \f$\partial f(x)/\partial x_i\f$.
  The \e Hessian \f$\nabla_{xx} f(x)\f$ of \f$f(x)\f$ is the symmetric matrix
  whose \f$i,j\f$-th entry is \f$\partial^2 f(x)/\partial x_i \partial x_j\f$.
  The Hessian is \e sparse if a significant and useful proportion of the
  entries are universally zero.

  \subsection dgo_method Method

  Starting with the initial box \f$x^l \leq x \leq x^u\f$, a sequence of
  boxes is generated by considering the current set, and partitioning
  a promising candidate into three equally-sized sub-boxes by splitting
  along one of the box dimensions. Each partition requires only a pair of
  new function and derivative evaluations, and these values, together with
  estimates of Lipschitz constants, makes it possible to remove other boxes
  from further consideration as soon as they cannot contain a global minimizer.
  Efficient control of the dictionary of vertices of the sub-boxes
  is handled using a suitable hashing procedure provided by the GALAHAD
  package hash; each sub-box is indexed by the concatenated
  coordinates of a pair of opposite vertices. At various
  stages, local minimization in a promising sub-box, using the GALAHAD
  package trb, may be used to improve the best-known upper bound
  on the global minimizer.
  If \f$n=1\f$, the specialised GALAHAD univariate global minimization package
  ugo is called directly.

  We reiterate that although there are theoretical guarantees,
  these may require a large number of evaluations as the dimension
  and nonconvexity increase.
  Thus the method should best be viewed as a heuristic to try to find
  a reasonable approximation of the global minimum.

  \subsection dgo_references References

  The global minimization method employed is an extension of that due to

  Ya. D. Sergeyev and D. E. Kasov (2015),
  ``A deterministic global optimization using smooth diagonal
  auxiliary functions'',
  Communications in Nonlinear Science and Numerical Simulation,
  Vol 21, Nos 1-3, pp. 99-111.

  but adapted to use 2nd derivatives, while in the special case when \f$n=1\f$,
  a simplification based on the ideas in

  D. Lera and Ya. D. Sergeyev (2013),
  ``Acceleration of univariate global optimization algorithms working with
  Lipschitz functions and Lipschitz first derivatives''
  SIAM J. Optimization Vol. 23, No. 1, pp. 508–529

  is used instead. The generic bound-constrained trust-region method used
  for local minimization is described in detail in

  A. R. Conn, N. I. M. Gould and Ph. L. Toint (2000),
  Trust-region methods.
  SIAM/MPS Series on Optimization.

  \section dgo_call_order Call order

  To solve a given problem, functions from the dgo package must be called
  in the following order:

  - \link dgo_initialize \endlink - provide default control parameters and
      set up initial data structures
  - \link dgo_read_specfile \endlink (optional) - override control values
      by reading replacement values from a file
  - \link dgo_import \endlink - set up problem data structures and fixed
      values
  - \link dgo_reset_control \endlink (optional) - possibly change control
      parameters if a sequence of problems are being solved
  - solve the problem by calling one of
     - \link dgo_solve_with_mat \endlink - solve using function calls to
       evaluate function, gradient and Hessian values
     - \link dgo_solve_without_mat \endlink - solve using function calls to
       evaluate function and gradient values and Hessian-vector products
     - \link dgo_solve_reverse_with_mat \endlink - solve returning to the
       calling program to obtain function, gradient and Hessian values, or
     - \link dgo_solve_reverse_without_mat \endlink - solve returning to the
       calling prorgram to obtain function and gradient values and
       Hessian-vector products
  - \link dgo_information \endlink (optional) - recover information about
    the solution and solution process
  - \link dgo_terminate \endlink - deallocate data structures

  \latexonly
  See Section~\ref{examples} for examples of use.
  \endlatexonly
  \htmlonly
  See the <a href="examples.html">examples tab</a> for illustrations of use.
  \endhtmlonly
  \manonly
  See the examples section for illustrations of use.
  \endmanonly

  \section main_symmetric_matrices Symmetric matrix storage formats

  The symmetric \f$n\f$ by \f$n\f$ matrix \f$H = \nabla_{xx}f\f$ may be
  presented and stored in a variety of formats. But crucially symmetry
  is exploited by only storing values from the lower triangular part
  (i.e, those entries that lie on or below the leading diagonal).

  Both C-style (0 based)  and fortran-style (1-based) indexing is allowed.
  Choose \c control.f_indexing as \c false for C style and \c true for
  fortran style; the discussion below presumes C style, but add 1 to
  indices for the corresponding fortran version.

  Wrappers will automatically convert between 0-based (C) and 1-based
  (fortran) array indexing, so may be used transparently from C. This
  conversion involves both time and memory overheads that may be avoided
  by supplying data that is already stored using 1-based indexing.

  \subsection symmetric_matrix_dense Dense storage format

  The matrix \f$H\f$ is stored as a compact  dense matrix by rows, that is,
  the values of the entries of each row in turn are
  stored in order within an appropriate real one-dimensional array.
  Since \f$H\f$ is symmetric, only the lower triangular part (that is the part
  \f$H_{ij}\f$ for \f$0 \leq j \leq i \leq n-1\f$) need be held.
  In this case the lower triangle should be stored by rows, that is
  component \f$i \ast i / 2 + j\f$  of the storage array H_val
  will hold the value \f$H_{ij}\f$ (and, by symmetry, \f$H_{ji}\f$)
  for \f$0 \leq j \leq i \leq n-1\f$.

  \subsection symmetric_matrix_coordinate Sparse co-ordinate storage format

  Only the nonzero entries of the matrices are stored.
  For the \f$l\f$-th entry, \f$0 \leq l \leq ne-1\f$, of \f$H\f$,
  its row index i, column index j
  and value \f$H_{ij}\f$, \f$0 \leq j \leq i \leq n-1\f$,  are stored as
  the \f$l\f$-th components of the integer arrays H_row and
  H_col and real array H_val, respectively, while the number of nonzeros
  is recorded as H_ne = \f$ne\f$.
  Note that only the entries in the lower triangle should be stored.

  \subsection symmetric_matrix_row_wise Sparse row-wise storage format

  Again only the nonzero entries are stored, but this time
  they are ordered so that those in row i appear directly before those
  in row i+1. For the i-th row of \f$H\f$ the i-th component of the
  integer array H_ptr holds the position of the first entry in this row,
  while H_ptr(n) holds the total number of entries.
  The column indices j, \f$0 \leq j \leq i\f$, and values
  \f$H_{ij}\f$ of the  entries in the i-th row are stored in components
  l = H_ptr(i), \f$\ldots\f$, H_ptr(i+1)-1 of the
  integer array H_col, and real array H_val, respectively.
  Note that as before only the entries in the lower triangle should be stored.
  For sparse matrices, this scheme almost always requires less storage than
  its predecessor.
 */

#ifdef __cplusplus
extern "C" {
#else
#include <stdbool.h>
#include <stdint.h>
#endif

// include guard
#ifndef GALAHAD_DGO_H
#define GALAHAD_DGO_H

// precision
#include "galahad_precision.h"
#include "galahad_cfunctions.h"

// required packages
#include "galahad_trb.h"
#include "galahad_ugo.h"
#include "galahad_hash.h"

/*
 * control derived type as a C struct
 */
struct dgo_control_type {

    /// \brief
    /// use C or Fortran sparse matrix indexing
    bool f_indexing;

    /// \brief
    /// error and warning diagnostics occur on stream error
    int error;

    /// \brief
    /// general output occurs on stream out
    int out;

    /// \brief
    /// the level of output required. Possible values are:
    /// \li \f$\leq\f$ 0 no output,
    /// \li 1 a one-line summary for every improvement
    /// \li 2 a summary of each iteration
    /// \li \f$\geq\f$ 3 increasingly verbose (debugging) output
    int print_level;

    /// \brief
    /// any printing will start on this iteration
    int start_print;

    /// \brief
    /// any printing will stop on this iteration
    int stop_print;

    /// \brief
    /// the number of iterations between printing
    int print_gap;

    /// \brief
    /// the maximum number of iterations performed
    int maxit;

    /// \brief
    /// the maximum number of function evaluations made
    int max_evals;

    /// \brief
    /// the size of the initial hash dictionary
    int dictionary_size;

    /// \brief
    /// removal of the file alive_file from unit alive_unit terminates execution
    int alive_unit;
    /// see alive_unit
    char alive_file[31];

    /// \brief
    /// any bound larger than infinity in modulus will be regarded as infinite
    real_wp_ infinity;

    /// \brief
    /// a small positive constant (<= 1e-6) that ensure that the estimted
    /// gradient Lipschitz constant is not too small
    real_wp_ lipschitz_lower_bound;

    /// \brief
    /// the Lipschitz reliability parameter, the Lipschiz constant used will
    /// be a factor lipschitz_reliability times the largest value observed
    real_wp_ lipschitz_reliability;

    /// \brief
    /// the reliablity control parameter, the actual reliability parameter used
    /// will be .lipschitz_reliability
    /// + MAX( 1, n - 1 ) * .lipschitz_control / iteration
    real_wp_ lipschitz_control;

    /// \brief
    /// the iteration will stop if the length, delta, of the diagonal in the box
    /// with the smallest-found objective function is smaller than .stop_length
    /// times that of the original bound box, delta_0
    real_wp_ stop_length;

    /// \brief
    /// the iteration will stop if the gap between the best objective value
    /// found and the smallest lower bound is smaller than .stop_f
    real_wp_ stop_f;

    /// \brief
    /// the smallest value the objective function may take before the problem
    /// is marked as unbounded
    real_wp_ obj_unbounded;

    /// \brief
    /// the maximum CPU time allowed (-ve means infinite)
    real_wp_ cpu_time_limit;

    /// \brief
    /// the maximum elapsed clock time allowed (-ve means infinite)
    real_wp_ clock_time_limit;

    /// \brief
    /// is the Hessian matrix of second derivatives available or is access only
    /// via matrix-vector products?
    bool hessian_available;

    /// \brief
    /// should boxes that cannot contain the global minimizer be pruned (i.e.,
    /// removed from further consideration)?
    bool prune;

    /// \brief
    /// should approximate minimizers be impoved by judicious local
    /// minimization?
    bool perform_local_optimization;

    /// \brief
    /// if .space_critical true, every effort will be made to use as little
    /// space as possible. This may result in longer computation time
    bool space_critical;

    /// \brief
    /// if .deallocate_error_fatal is true, any array/pointer deallocation error
    /// will terminate execution. Otherwise, computation will continue
    bool deallocate_error_fatal;

    /// \brief
    /// all output lines will be prefixed by %prefix(2:LEN(TRIM(%prefix))-1)
    /// where %prefix contains the required string enclosed in
    /// quotes, e.g. "string" or 'string'
    char prefix[31];

    /// \brief
    /// control parameters for HASH
    struct hash_control_type hash_control;

    /// \brief
    /// control parameters for UGO
    struct ugo_control_type ugo_control;

    /// \brief
    /// control parameters for TRB
    struct trb_control_type trb_control;
};

/*
 * time derived type as a C struct
 */
struct dgo_time_type {

    /// \brief
    /// the total CPU time spent in the package
    real_sp_ total;

    /// \brief
    /// the CPU time spent performing univariate global optimization
    real_sp_ univariate_global;

    /// \brief
    /// the CPU time spent performing multivariate local optimization
    real_sp_ multivariate_local;

    /// \brief
    /// the total clock time spent in the package
    real_wp_ clock_total;

    /// \brief
    /// the clock time spent performing univariate global optimization
    real_wp_ clock_univariate_global;

    /// \brief
    /// the clock time spent performing multivariate local optimization
    real_wp_ clock_multivariate_local;
};

/*
 * inform derived type as a C struct
 */
struct dgo_inform_type {

    /// \brief
    /// return status. See DGO_solve for details
    int status;

    /// \brief
    /// the status of the last attempted allocation/deallocation
    int alloc_status;

    /// \brief
    /// the name of the array for which an allocation/deallocation error ocurred
    char bad_alloc[81];

    /// \brief
    /// the total number of iterations performed
    int iter;

    /// \brief
    /// the total number of evaluations of the objective function
    int f_eval;

    /// \brief
    /// the total number of evaluations of the gradient of the objective
    /// function
    int g_eval;

    /// \brief
    /// the total number of evaluations of the Hessian of the objective function
    int h_eval;

    /// \brief
    /// the value of the objective function at the best estimate of the solution
    /// determined by DGO_solve
    real_wp_ obj;

    /// \brief
    /// the norm of the projected gradient of the objective function at the
    /// best estimate of the solution determined by DGO_solve
    real_wp_ norm_pg;

    /// \brief
    /// the ratio of the final to the initial box lengths
    real_wp_ length_ratio;

    /// \brief
    /// the gap between the best objective value found and the lowest bound
    real_wp_ f_gap;

    /// \brief
    /// why did the iteration stop? This wil be 'D' if the box length is small
    /// enough, 'F' if the objective gap is small enough, and ' ' otherwise
    char why_stop[2];

    /// \brief
    /// timings (see above)
    struct dgo_time_type time;

    /// \brief
    /// inform parameters for HASH
    struct hash_inform_type hash_inform;

    /// \brief
    /// inform parameters for UGO
    struct ugo_inform_type ugo_inform;

    /// \brief
    /// inform parameters for TRB
    struct trb_inform_type trb_inform;
};

/*  *-*-*-*-*-*-*-*-*-*-   D G O _ I N I T I A L I Z E    -*-*-*-*-*-*-*-*-*-*
 *
 * Provide default values for DGO controls
 */

void dgo_initialize( void **data,
                     struct dgo_control_type *control,
                     int *status );

/*!<
 Set default control values and initialize private data

 @param[in,out] data  holds private internal data

 @param[out] control is a struct containing control information
              (see dgo_control_type)

 @param[out] status is a scalar variable of type int, that gives
    the exit status from the package. Possible values are (currently):
  \li  0. The import was succesful.
*/

// *-*-*-*-*-*-*-*-*-    D G O  _ R E A D _ S P E C F I L E   -*-*-*-*-*-*-*

void dgo_read_specfile( struct dgo_control_type *control,
                        const char specfile[] );

/*!<
  Read the content of a specification file, and assign values associated
  with given keywords to the corresponding control parameters.
  By default, the spcification file will be named RUNDGO.SPC and
  lie in the current directory.
  Refer to Table 2.1 in the fortran documentation provided in
  $GALAHAD/doc/dgo.pdf for a list of keywords that may be set.

  @param[in,out] control is a struct containing control information
              (see dgo_control_type)
  @param[in]  specfile is a character string containing the name of
              the specification file
*/

//  *-*-*-*-*-*-*-*-*-*-*-*-   D G O _ I M P O R T    -*-*-*-*-*-*-*-*-*-*-*-*

void dgo_import( struct dgo_control_type *control,
                 void **data,
                 int *status,
                 int n,
                 const real_wp_ x_l[],
                 const real_wp_ x_u[],
                 const char H_type[],
                 int ne,
                 const int H_row[],
                 const int H_col[],
                 const int H_ptr[] );

/*!<
 Import problem data into internal storage prior to solution.

 @param[in] control is a struct whose members provide control
  paramters for the remaining prcedures (see dgo_control_type)

 @param[in,out] data holds private internal data

 @param[in,out] status is a scalar variable of type int, that gives
    the exit status from the package. Possible values are:
  \li  1. The import was succesful, and the package is ready for the solve phase
  \li -1. An allocation error occurred. A message indicating the offending
       array is written on unit control.error, and the returned allocation
       status and a string containing the name of the offending array
       are held in inform.alloc_status and inform.bad_alloc respectively.
  \li -2. A deallocation error occurred.  A message indicating the offending
       array is written on unit control.error and the returned allocation
       status and a string containing the name of the offending array
       are held in inform.alloc_status and inform.bad_alloc respectively.
  \li -3. The restriction n > 0 or requirement that type contains
       its relevant string 'dense', 'coordinate', 'sparse_by_rows',
       'diagonal' or 'absent' has been violated.

 @param[in] n is a scalar variable of type int, that holds the number of
    variables.

 @param[in] x_l is a one-dimensional array of size n and type double,
    that holds the values \f$x^l\f$ of the lower bounds on the optimization
    variables \f$x\f$. The j-th component of x_l, \f$j = 0, \ldots, n-1\f$,
    contains \f$x^l_j\f$.

 @param[in] x_u is a one-dimensional array of size n and type double,
    that holds the values \f$x^u\f$ of the upper bounds on the optimization
    variables \f$x\f$. The j-th component of x_u, \f$j = 0, \ldots, n-1\f$,
    contains \f$x^u_j\f$.

 @param[in]  H_type is a one-dimensional array of type char that specifies the
   \link main_symmetric_matrices symmetric storage scheme \endlink
   used for the Hessian. It should be one of 'coordinate', 'sparse_by_rows',
  'dense', 'diagonal' or 'absent', the latter if access to the Hessian is
  via matrix-vector products; lower or upper case variants are allowed.

 @param[in]  ne is a scalar variable of type int, that holds the number of
   entries in the  lower triangular part of H in the sparse co-ordinate
   storage scheme. It need not be set for any of the other three schemes.

 @param[in]  H_row is a one-dimensional array of size ne and type int, that
   holds the row indices of the lower triangular part of H in the sparse
   co-ordinate storage scheme. It need not be set for any of the other
   three schemes, and in this case can be NULL

 @param[in]  H_col is a one-dimensional array of size ne and type int,
   that holds the column indices of the  lower triangular part of H in either
   the sparse co-ordinate, or the sparse row-wise storage scheme. It need not
   be set when the dense or diagonal storage schemes are used, and in this
   case can be NULL

 @param[in]  H_ptr is a one-dimensional array of size n+1 and type int,
   that holds the starting position of  each row of the lower
   triangular part of H, as well as the total number of entries,
   in the sparse row-wise storage scheme. It need not be set when the
   other schemes are used, and in this case can be NULL
 */


//  *-*-*-*-*-*-*-*-*-   D G O _ R E S E T _ C O N T R O L   -*-*-*-*-*-*-*-*

void dgo_reset_control( struct dgo_control_type *control,
                        void **data,
                        int *status );

/*!<
 Reset control parameters after import if required.

 @param[in] control is a struct whose members provide control
  paramters for the remaining prcedures (see dgo_control_type)

 @param[in,out] data holds private internal data

 @param[in,out] status is a scalar variable of type int, that gives
    the exit status from the package. Possible values are:
  \li  1. The import was succesful, and the package is ready for the solve phase
 */

//  *-*-*-*-*-*-*-*-*-   D G O _ S O L V E _ W I T H _ M A T   -*-*-*-*-*-*-*-*

void dgo_solve_with_mat( void **data,
                         void *userdata,
                         int *status,
                         int n,
                         real_wp_ x[],
                         real_wp_ g[],
                         int ne,
                         int (*eval_f)(
                           int, const real_wp_[], real_wp_*, const void * ),
                         int (*eval_g)(
                           int, const real_wp_[], real_wp_[], const void * ),
                         int (*eval_h)(
                           int, int, const real_wp_[], real_wp_[],
                           const void * ),
                         int (*eval_hprod)(
                           int, const real_wp_[], real_wp_[], const real_wp_[],
                           bool, const void * ),
                         int (*eval_prec)(
                           int, const real_wp_[], real_wp_[], const real_wp_[],
                           const void * ) );

/*!<
 Find an approximation to the global minimizer of a given function subject to
 simple bounds on the variables using a partition-and-bound trust-region method.

 This call is for the case where \f$H = \nabla_{xx}f(x)\f$ is
 provided specifically, and all function/derivative information is
 available by function calls.

 @param[in,out] data holds private internal data

 @param[in] userdata is a structure that allows data to be passed into
    the function and derivative evaluation programs.

 @param[in,out] status is a scalar variable of type int, that gives
    the entry and exit status from the package. \n
    On initial entry, status must be set to 1. \n
    Possible exit are:
  \li  0. The run was succesful

  \li -1. An allocation error occurred. A message indicating the offending
       array is written on unit control.error, and the returned allocation
       status and a string containing the name of the offending array
       are held in inform.alloc_status and inform.bad_alloc respectively.
  \li -2. A deallocation error occurred.  A message indicating the offending
       array is written on unit control.error and the returned allocation
       status and a string containing the name of the offending array
       are held in inform.alloc_status and inform.bad_alloc respectively.
  \li -3. The restriction n > 0 or requirement that type contains
       its relevant string 'dense', 'coordinate', 'sparse_by_rows',
       'diagonal' or 'absent' has been violated.
  \li -7. The objective function appears to be unbounded from below
  \li -9. The analysis phase of the factorization failed; the return status
         from the factorization package is given in the component
         inform.factor_status
  \li -10. The factorization failed; the return status from the factorization
         package is given in the component inform.factor_status.
  \li -11. The solution of a set of linear equations using factors from the
         factorization package failed; the return status from the factorization
         package is given in the component inform.factor_status.
  \li -16. The problem is so ill-conditioned that further progress is
           impossible.
  \li -18. Too many iterations have been performed. This may happen if
         control.maxit is too small, but may also be symptomatic of
         a badly scaled problem.
  \li -19. The CPU time limit has been reached. This may happen if
         control.cpu_time_limit is too small, but may also be symptomatic of
         a badly scaled problem.
  \li -82. The user has forced termination of solver by removing the file
         named control.alive_file from unit unit control.alive_unit.
  \li -91. The hash table used to store the dictionary of vertices of the
         sub-boxes is full, and there is no room to increase it further.

 @param[in] n is a scalar variable of type int, that holds the number of
    variables

 @param[in,out] x is a one-dimensional array of size n and type double, that
    holds the values \f$x\f$ of the optimization variables. The j-th component
    of x, j = 0, ... , n-1, contains \f$x_j\f$.

 @param[in,out] g is a one-dimensional array of size n and type double, that
    holds the gradient \f$g = \nabla_xf(x)\f$ of the objective function.
    The j-th component of g, j = 0, ... ,  n-1, contains  \f$g_j \f$.

 @param[in] ne is a scalar variable of type int, that holds the number of
    entries in the lower triangular part of the Hessian matrix \f$H\f$.

 @param eval_f is a user-supplied function that must have the following
   signature:
   \code
        int eval_f( int n, const double x[], double *f, const void *userdata )
   \endcode
   The value of the objective function \f$f(x)\f$ evaluated at x=\f$x\f$ must
   be assigned to f, and the function return value set to 0. If the
   evaluation is impossible at x, return should be set to a nonzero value.
   Data may be passed into \c eval_f via the structure \c userdata.

 @param eval_g is a user-supplied function that must have the following
   signature:
   \code
      int eval_g( int n, const double x[], double g[], const void *userdata )
   \endcode
   The components of the gradient \f$g = \nabla_x f(x\f$) of the objective
   function evaluated at x=\f$x\f$ must be assigned to g, and the function
   return value set to 0. If the evaluation is impossible at x, return
   should be set to a nonzero value.
   Data may be passed into \c eval_g via the structure \c userdata.

 @param eval_h is a user-supplied function that must have the following
   signature:
   \code
        int eval_h( int n, int ne, const double x[], double h[],
                    const void *userdata )
   \endcode
   The nonzeros of the Hessian \f$H = \nabla_{xx}f(x)\f$ of the objective
   function evaluated at x=\f$x\f$ must be assigned to h in the same order
   as presented to dgo_import, and the function return value set to 0.
   If the evaluation is impossible at x, return should be set to a
   nonzero value.
   Data may be passed into \c eval_h via the structure \c userdata.

 @param  eval_prec is an optional user-supplied function that may be NULL.
   If non-NULL, it must have the following signature:
   \code
       int eval_prec( int n, const double x[], double u[], const double v[],
                      const void *userdata )
   \endcode
   The product \f$u = P(x) v\f$ of the user's preconditioner \f$P(x)\f$
   evaluated at \f$x\f$ with the vector v = \f$v\f$, the result \f$u\f$
   must be retured in u, and the function return value set to 0. If the
   evaluation is impossible at x, return should be set to a nonzero value.
   Data may be passed into \c eval_prec via the structure \c userdata.
 */

//  *-*-*-*-*-*-*-*-   D G O _ S O L V E _ W I T H O U T _ M A T   -*-*-*-*-*-*

void dgo_solve_without_mat( void **data,
                            void *userdata,
                            int *status,
                            int n,
                            real_wp_ x[],
                            real_wp_ g[],
                            int (*eval_f)(
                              int, const real_wp_[], real_wp_*, const void * ),
                            int (*eval_g)(
                              int, const real_wp_[], real_wp_[], const void * ),
                            int (*eval_hprod)(
                              int, const real_wp_[], real_wp_[],
                              const real_wp_[], bool, const void * ),
                            int (*eval_shprod)(int, const real_wp_[], int,
                              const int[], const real_wp_[], int*, int[],
                              real_wp_[], bool, const void * ),
                            int (*eval_prec)(
                              int, const real_wp_[], real_wp_[],
                              const real_wp_[], const void * ) );

/*!<
 Find an approximation to the global minimizer of a given function subject to
 simple bounds on the variables using a partition-and-bound trust-region method.

 This call is for the case where access to \f$H = \nabla_{xx}f(x)\f$ is
 provided by Hessian-vector products, and all function/derivative
 information is available by function calls.

 @param[in,out] data holds private internal data

 @param[in] userdata is a structure that allows data to be passed into
    the function and derivative evaluation programs.

 @param[in,out] status is a scalar variable of type int, that gives
    the entry and exit status from the package. \n
    On initial entry, status must be set to 1. \n
    Possible exit are:
  \li  0. The run was succesful

  \li -1. An allocation error occurred. A message indicating the offending
       array is written on unit control.error, and the returned allocation
       status and a string containing the name of the offending array
       are held in inform.alloc_status and inform.bad_alloc respectively.
  \li -2. A deallocation error occurred.  A message indicating the offending
       array is written on unit control.error and the returned allocation
       status and a string containing the name of the offending array
       are held in inform.alloc_status and inform.bad_alloc respectively.
  \li -3. The restriction n > 0 or requirement that type contains
       its relevant string 'dense', 'coordinate', 'sparse_by_rows',
       'diagonal' or 'absent' has been violated.
  \li -7. The objective function appears to be unbounded from below
  \li -9. The analysis phase of the factorization failed; the return status
         from the factorization package is given in the component
         inform.factor_status
  \li -10. The factorization failed; the return status from the factorization
         package is given in the component inform.factor_status.
  \li -11. The solution of a set of linear equations using factors from the
         factorization package failed; the return status from the factorization
         package is given in the component inform.factor_status.
  \li -16. The problem is so ill-conditioned that further progress is
           impossible.
  \li -18. Too many iterations have been performed. This may happen if
         control.maxit is too small, but may also be symptomatic of
         a badly scaled problem.
  \li -19. The CPU time limit has been reached. This may happen if
         control.cpu_time_limit is too small, but may also be symptomatic of
         a badly scaled problem.
  \li -82. The user has forced termination of solver by removing the file
         named control.alive_file from unit unit control.alive_unit.

 @param[in] n is a scalar variable of type int, that holds the number of
    variables

 @param[in,out] x is a one-dimensional array of size n and type double, that
    holds the values \f$x\f$ of the optimization variables. The j-th component
    of x, j = 0, ... , n-1, contains \f$x_j\f$.

 @param[in,out] g is a one-dimensional array of size n and type double, that
    holds the gradient \f$g = \nabla_xf(x)\f$ of the objective function.
    The j-th component of g, j = 0, ... ,  n-1, contains  \f$g_j \f$.

 @param eval_f is a user-supplied function that must have the following
   signature:
   \code
        int eval_f( int n, const double x[], double *f, const void *userdata )
   \endcode
   The value of the objective function \f$f(x)\f$ evaluated at x=\f$x\f$ must
   be assigned to f, and the function return value set to 0. If the
   evaluation is impossible at x, return should be set to a nonzero value.
   Data may be passed into \c eval_f via the structure \c userdata.

 @param eval_g is a user-supplied function that must have the following
   signature:
   \code
      int eval_g( int n, const double x[], double g[], const void *userdata )
   \endcode
   The components of the gradient \f$g = \nabla_x f(x\f$) of the objective
   function evaluated at x=\f$x\f$ must be assigned to g, and the function
   return value set to 0. If the evaluation is impossible at x, return
   should be set to a nonzero value.
   Data may be passed into \c eval_g via the structure \c userdata.

 @param eval_hprod is a user-supplied function that must have the following
   signature:
   \code
        int eval_hprod( int n, const double x[], double u[], const double v[],
                        bool got_h, const void *userdata )
   \endcode
   The sum \f$u + \nabla_{xx}f(x) v\f$ of the product of the Hessian
   \f$\nabla_{xx}f(x)\f$ of the objective function evaluated at x=\f$x\f$
   with the vector v=\f$v\f$ and the vector $\f$u\f$ must be returned in u,
   and the function return value set to 0. If the
   evaluation is impossible at x, return should be set to a nonzero value.
   The Hessian has already been evaluated or used at x if got_h is true.
   Data may be passed into \c eval_hprod via the structure \c userdata.

 @param eval_shprod is a user-supplied function that must have the following
   signature:
   \code
        int eval_shprod( int n, const double x[], int nnz_v,
                         const int index_nz_v[], const double v[],
                         int *nnz_u, int index_nz_u[], double u[],
                         bool got_h, const void *userdata )
   \endcode
   The product \f$u = \nabla_{xx}f(x) v\f$ of the Hessian
   \f$\nabla_{xx}f(x)\f$ of the objective function evaluated at \f$x\f$
   with the sparse vector v=\f$v\f$ must be returned in u, and the function
   return value set to 0. Only the components index_nz_v[0:nnz_v-1] of v
   are nonzero, and the remaining components may not have been be set.
   On exit, the user must indicate the nnz_u indices of u that are nonzero
   in index_nz_u[0:nnz_u-1], and only these components of u need be set.
   If the evaluation is impossible at x, return should be set to a nonzero
   value. The Hessian has already been evaluated or used at x if got_h is true.
   Data may be passed into \c eval_prec via the structure \c userdata.

 @param  eval_prec is an optional user-supplied function that may be NULL.
   If non-NULL, it must have the following signature:
   \code
       int eval_prec( int n, const double x[], double u[], const double v[],
                      const void *userdata )
   \endcode
   The product \f$u = P(x) v\f$ of the user's preconditioner \f$P(x)\f$
   evaluated at \f$x\f$ with the vector v = \f$v\f$, the result \f$u\f$
   must be retured in u, and the function return value set to 0. If the
   evaluation is impossible at x, return should be set to a nonzero value.
   Data may be passed into \c eval_prec via the structure \c userdata.
 */

//  *-*-*-*-*-   D G O _ S O L V E _ R E V E R S E _ W I T H _ M A T   -*-*-*-*

void dgo_solve_reverse_with_mat( void **data,
                                 int *status,
                                 int *eval_status,
                                 int n,
                                 real_wp_ x[],
                                 real_wp_ f,
                                 real_wp_ g[],
                                 int ne,
                                 real_wp_ H_val[],
                                 const real_wp_ u[],
                                 real_wp_ v[] );

/*!<
 Find an approximation to the global minimizer of a given function subject to
 simple bounds on the variables using a partition-and-bound trust-region method.

 This call is for the case where \f$H = \nabla_{xx}f(x)\f$ is
 provided specifically, but function/derivative information is only
 available by returning to the calling procedure

 @param[in,out] data holds private internal data

 @param[in,out] status is a scalar variable of type int, that gives
    the entry and exit status from the package. \n
    On initial entry, status must be set to 1. \n
    Possible exit are:
  \li  0. The run was succesful

  \li -1. An allocation error occurred. A message indicating the offending
       array is written on unit control.error, and the returned allocation
       status and a string containing the name of the offending array
       are held in inform.alloc_status and inform.bad_alloc respectively.
  \li -2. A deallocation error occurred.  A message indicating the offending
       array is written on unit control.error and the returned allocation
       status and a string containing the name of the offending array
       are held in inform.alloc_status and inform.bad_alloc respectively.
  \li -3. The restriction n > 0 or requirement that type contains
       its relevant string 'dense', 'coordinate', 'sparse_by_rows',
       'diagonal' or 'absent' has been violated.
  \li -7. The objective function appears to be unbounded from below
  \li -9. The analysis phase of the factorization failed; the return status
         from the factorization package is given in the component
         inform.factor_status
  \li -10. The factorization failed; the return status from the factorization
         package is given in the component inform.factor_status.
  \li -11. The solution of a set of linear equations using factors from the
         factorization package failed; the return status from the factorization
         package is given in the component inform.factor_status.
  \li -16. The problem is so ill-conditioned that further progress is
           impossible.
  \li -18. Too many iterations have been performed. This may happen if
         control.maxit is too small, but may also be symptomatic of
         a badly scaled problem.
  \li -19. The CPU time limit has been reached. This may happen if
         control.cpu_time_limit is too small, but may also be symptomatic of
         a badly scaled problem.
  \li -82. The user has forced termination of solver by removing the file
         named control.alive_file from unit unit control.alive_unit.

 @param status (continued)
  \li  2. The user should compute the objective function value \f$f(x)\f$ at
         the point \f$x\f$ indicated in x and then re-enter the function.
         The required value should be set in f, and eval_status should be
         set to 0. If the user is unable to evaluate \f$f(x)\f$--- for
         instance, if the function is undefined at \f$x\f$--- the user need
         not set f, but should then set eval_status to a non-zero value.
  \li   3. The user should compute the gradient of the objective function
         \f$\nabla_x f(x)\f$ at the point \f$x\f$ indicated in x and then
         re-enter the function. The value of the i-th component of the g
         radient should be set in g[i], for i = 0, ..., n-1 and eval_status
         should be set to 0. If the user is unable to evaluate a component
         of \f$\nabla_x f(x)\f$ --- for instance if a component of the gradient
         is undefined at \f$x\f$ -the user need not set g, but should then set
         eval_status to a non-zero value.
  \li   4. The user should compute the Hessian of the objective function
         \f$\nabla_{xx}f(x)\f$ at the point x indicated in \f$x\f$ and then
         re-enter the function. The value l-th component of the Hessian stored
         according to the scheme input in the remainder of \f$H\f$ should be
         set in H_val[l], for l = 0, ..., ne-1 and eval_status should be set
         to 0. If the user is unable to evaluate a component of
         \f$\nabla_{xx}f(x)\f$ --- for instance, if a component of the Hessian
         is undefined at \f$x\f$ --- the user need not set H_val, but should
         then set eval_status to a non-zero value.
  \li  5. The user should compute the product \f$\nabla_{xx}f(x)v\f$ of the
        Hessian of the objective function \f$\nabla_{xx}f(x)\f$ at the point
        \f$x\f$ indicated in x with the vector \f$v\f$, add the result to
        the vector \f$u\f$ and then re-enter the function. The vectors
        \f$u\f$ and \f$v\f$ are given in u and v respectively, the resulting
        vector \f$u + \nabla_{xx}f(x)v\f$ should be set
        in u and eval_status should be set to 0. If the user is unable to
        evaluate the product--- for instance, if a component of the Hessian is
        undefined at \f$x\f$ --- the user need not alter u, but should then set
        eval_status to a non-zero value.
  \li   6. The user should compute the product \f$u = P(x)v\f$ of their
         preconditioner \f$P(x)\f$ at the point x indicated in \f$x\f$ with
         the vector \f$v\f$ and then re-enter the function. The vector \f$v\f$
         is given in v, the resulting vector \f$u = P(x)v\f$ should be set in
         u and eval_status should be set to 0. If the user is unable to
         evaluate the product--- for instance, if a component of the
         preconditioner is undefined at \f$x\f$ --- the user need not set u,
         but should then set eval_status to a non-zero value.
  \li 23. The user should follow the instructions for 2 <b>and</b> 3
        above before returning.
  \li 25. The user should follow the instructions for 2 <b>and</b> 5
        above before returning.
  \li 35. The user should follow the instructions for 3 <b>and</b> 5
        above before returning.
  \li 235. The user should follow the instructions for 2, 3 <b>and</b> 5
        above before returning.

 @param[in,out] eval_status is a scalar variable of type int, that is used to
    indicate if  objective function/gradient/Hessian values can be provided
    (see above)

 @param[in] n is a scalar variable of type int, that holds the number of
    variables

 @param[in,out] x is a one-dimensional array of size n and type double, that
    holds the values \f$x\f$ of the optimization variables. The j-th component
    of x, j = 0, ... , n-1, contains \f$x_j\f$.

 @param[in]
   f is a scalar variable pointer of type double, that holds the value of the
    objective function.

 @param[in,out] g is a one-dimensional array of size n and type double, that
    holds the gradient \f$g = \nabla_xf(x)\f$ of the objective function.
    The j-th component of g, j = 0, ... ,  n-1, contains  \f$g_j \f$.

 @param[in] ne is a scalar variable of type int, that holds the number of
    entries in the lower triangular part of the Hessian matrix \f$H\f$.

 @param[in] H_val is a one-dimensional array of size ne and type double,
    that holds the values of the entries of the lower triangular part of the
    Hessian matrix \f$H\f$ in any of the available storage schemes.

 @param[in] u is a one-dimensional array of size n and type double, that is
    used for reverse communication (see above for details)

 @param[in,out] v is a one-dimensional array of size n and type double, that is
    used for reverse communication (see above for details)
*/

//  *-*-*-   D G O _ S O L V E _ R E V E R S E _ W I T H O U T _ M A T   -*-*-*

void dgo_solve_reverse_without_mat( void **data,
                                  int *status,
                                  int *eval_status,
                                  int n,
                                  real_wp_ x[],
                                  real_wp_ f,
                                  real_wp_ g[],
                                  real_wp_ u[],
                                  real_wp_ v[],
                                  int index_nz_v[],
                                  int *nnz_v,
                                  const int index_nz_u[],
                                  int nnz_u );

/*!<
 Find an approximation to the global minimizer of a given function subject to
 simple bounds on the variables using a partition-and-bound trust-region method.

 This call is for the case where access to \f$H = \nabla_{xx}f(x)\f$ is
 provided by Hessian-vector products, but function/derivative information
 is only available by returning to the calling procedure.

 @param[in,out] data holds private internal data

 @param[in,out] status is a scalar variable of type int, that gives
    the entry and exit status from the package. \n
    On initial entry, status must be set to 1. \n
    Possible exit are:
  \li  0. The run was succesful

  \li -1. An allocation error occurred. A message indicating the offending
       array is written on unit control.error, and the returned allocation
       status and a string containing the name of the offending array
       are held in inform.alloc_status and inform.bad_alloc respectively.
  \li -2. A deallocation error occurred.  A message indicating the offending
       array is written on unit control.error and the returned allocation
       status and a string containing the name of the offending array
       are held in inform.alloc_status and inform.bad_alloc respectively.
  \li -3. The restriction n > 0 or requirement that type contains
       its relevant string 'dense', 'coordinate', 'sparse_by_rows',
       'diagonal' or 'absent' has been violated.
  \li -7. The objective function appears to be unbounded from below
  \li -9. The analysis phase of the factorization failed; the return status
         from the factorization package is given in the component
         inform.factor_status
  \li -10. The factorization failed; the return status from the factorization
         package is given in the component inform.factor_status.
  \li -11. The solution of a set of linear equations using factors from the
         factorization package failed; the return status from the factorization
         package is given in the component inform.factor_status.
  \li -16. The problem is so ill-conditioned that further progress is
           impossible.
  \li -18. Too many iterations have been performed. This may happen if
         control.maxit is too small, but may also be symptomatic of
         a badly scaled problem.
  \li -19. The CPU time limit has been reached. This may happen if
         control.cpu_time_limit is too small, but may also be symptomatic of
         a badly scaled problem.
  \li -82. The user has forced termination of solver by removing the file
         named control.alive_file from unit unit control.alive_unit.

 @param status (continued)
  \li  2. The user should compute the objective function value \f$f(x)\f$ at
         the point \f$x\f$ indicated in x and then re-enter the function.
         The required value should be set in f, and eval_status should be
         set to 0. If the user is unable to evaluate \f$f(x)\f$ --- for
         instance, if the function is undefined at \f$x\f$ --- the user need
         not set f, but should then set eval_status to a non-zero value.
  \li  3. The user should compute the gradient of the objective function
        \f$\nabla_x f(x)\f$ at the point \f$x\f$ indicated in x and then
        re-enter the function. The value of the i-th component of the g
        radient should be set in g[i], for i = 0, ..., n-1 and eval_status
        should be set to 0. If the user is unable to evaluate a component
        of \f$\nabla_x f(x)\f$ --- for instance if a component of the gradient
        is undefined at \f$x\f$ -the user need not set g, but should then set
        eval_status to a non-zero value.
  \li  5. The user should compute the product \f$\nabla_{xx}f(x)v\f$ of the
        Hessian of the objective function \f$\nabla_{xx}f(x)\f$ at the point
        \f$x\f$ indicated in x with the vector \f$v\f$, add the result to
        the vector \f$u\f$ and then re-enter the function. The vectors
        \f$u\f$ and \f$v\f$ are given in u and v respectively, the resulting
        vector \f$u + \nabla_{xx}f(x)v\f$ should be set
        in u and eval_status should be set to 0. If the user is unable to
        evaluate the product--- for instance, if a component of the Hessian is
        undefined at \f$x\f$ --- the user need not alter u, but should then set
        eval_status to a non-zero value.
  \li  6. The user should compute the product \f$u = P(x)v\f$ of their
        preconditioner \f$P(x)\f$ at the point x indicated in \f$x\f$ with
        the vector \f$v\f$ and then re-enter the function. The vector \f$v\f$
        is given in v, the resulting vector \f$u = P(x)v\f$ should be set in
        u and eval_status should be set to 0. If the user is unable to
        evaluate the product--- for instance, if a component of the
        preconditioner is undefined at \f$x\f$ --- the user need not set u,
        but should then set eval_status to a non-zero value.
  \li  7. The user should compute the product \f$u = \nabla_{xx}f(x)v\f$
        of the Hessian of the objective function \f$\nabla_{xx}f(x)\f$
        at the point \f$x\f$ indicated in
        x with the \b sparse vector v=\f$v\f$ and then re-enter the function.
        The nonzeros of \f$v\f$ are stored in
          v[index_nz_v[0:nnz_v-1]]
        while the nonzeros of \f$u\f$ should be returned in
          u[index_nz_u[0:nnz_u-1]];
        the user must set nnz_u and index_nz_u accordingly, and set
        eval_status to 0. If the user is unable to evaluate the product--- for
        instance, if a component of the Hessian is undefined at
        \f$x\f$--- the user
        need not alter u, but should then set eval_status to a non-zero value.
  \li 23. The user should follow the instructions for 2 <b>and</b> 3
        above before returning.
  \li 25. The user should follow the instructions for 2 <b>and</b> 5
        above before returning.
  \li 35. The user should follow the instructions for 3 <b>and</b> 5
        above before returning.
  \li 235. The user should follow the instructions for 2, 3 <b>and</b> 5
        above before returning.

 @param[in,out] eval_status is a scalar variable of type int, that is used to
    indicate if  objective function/gradient/Hessian values can be provided
    (see above)

 @param[in] n is a scalar variable of type int, that holds the number of
    variables

 @param[in,out] x is a one-dimensional array of size n and type double, that
    holds the values \f$x\f$ of the optimization variables. The j-th component
    of x, j = 0, ... , n-1, contains \f$x_j\f$.

 @param[in]
   f is a scalar variable pointer of type double, that holds the value of the
    objective function.

 @param[in,out] g is a one-dimensional array of size n and type double, that
    holds the gradient \f$g = \nabla_xf(x)\f$ of the objective function.
    The j-th component of g, j = 0, ... ,  n-1, contains  \f$g_j \f$.

 @param[in,out] u is a one-dimensional array of size n and type double, that is
    used for reverse communication (see status=5,6,7 above for details)

 @param[in,out] v is a one-dimensional array of size n and type double, that is
    used for reverse communication (see status=5,6,7 above for details)

 @param[in,out] index_nz_v is a one-dimensional array of size n and type int,
    that is used for reverse communication (see status=7 above for details)

 @param[in,out] nnz_v is a scalar variable of type int, that is used for
    reverse communication (see status=7 above for details)

 @param[in] index_nz_u s a one-dimensional array of size n and type int,
     that is used for reverse communication (see status=7 above for details)

 @param[in] nnz_u is a scalar variable of type int, that is used for reverse
     communication (see status=7 above for details). On initial (status=1)
     entry, nnz_u should be set to an (arbitrary) nonzero value, and
     nnz_u=0 is recommended
*/

//  *-*-*-*-*-*-*-*-*-*-   D G O _ I N F O R M A T I O N   -*-*-*-*-*-*-*-*

void dgo_information( void **data,
                      struct dgo_inform_type *inform,
                      int *status );

/*!<
  Provides output information

  @param[in,out] data  holds private internal data

  @param[out] inform   is a struct containing output information
    (see dgo_inform_type)

  @param[out] status   is a scalar variable of type int, that gives
    the exit status from the package. Possible values are (currently):
  \li  0. The values were recorded succesfully
*/

//  *-*-*-*-*-*-*-*-*-*-   D G O _ T E R M I N A T E   -*-*-*-*-*-*-*-*-*-*

void dgo_terminate( void **data,
                    struct dgo_control_type *control,
                    struct dgo_inform_type *inform );

/*!<
  Deallocate all internal private storage

  @param[in,out] data  holds private internal data

  @param[out] control  is a struct containing control information
              (see dgo_control_type)

  @param[out] inform   is a struct containing output information
              (see dgo_inform_type)
 */

/** \anchor examples
   \f$\label{examples}\f$
   \example dgot.c
   This is an example of how to use the package to find an approximation
   to the global minimum of a given function within a bounded region.
   A variety of supported Hessian and constraint matrix storage formats are
   shown.

   Notice that C-style indexing is used, and that this is flaggeed by
   setting \c control.f_indexing to \c false.

    \example dgotf.c
   This is the same example, but now fortran-style indexing is used.\n

 */

// end include guard
#endif

#ifdef __cplusplus
} /* extern "C" */
#endif

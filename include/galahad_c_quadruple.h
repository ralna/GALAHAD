// include guard
#ifndef GALAHAD_C_QUADRUPLE_H
#define GALAHAD_C_QUADRUPLE_H

// Callbacks
typedef int32_t galahad_f_q(int32_t n, const __float128 x[], __float128 *f, const void *userdata);
typedef int32_t galahad_g_q(int32_t n, const __float128 x[], __float128 g[], const void *userdata);
typedef int32_t galahad_h_q(int32_t n, int32_t ne, const __float128 x[], __float128 h[], const void *userdata);
typedef int32_t galahad_prec_q(int32_t n, const __float128 x[], __float128 u[], const __float128 v[], const void *userdata);
typedef int32_t galahad_hprod_q(int32_t n, const __float128 x[], __float128 u[], const __float128 v[], bool got_h, const void *userdata);
typedef int32_t galahad_shprod_q(int32_t n, const __float128 x[], int32_t nnz_v, const int32_t index_nz_v[], const __float128 v[], int32_t *nnz_u, int32_t index_nz_u[], __float128 u[], bool got_h, const void *userdata);
typedef int32_t galahad_constant_prec_q(int32_t n, const __float128 v[], __float128 p[], const void *userdata);
typedef int32_t galahad_r_q(int32_t n, int32_t m, const __float128 x[], __float128 r[], const void *userdata);
typedef int32_t galahad_jr_q(int32_t n, int32_t m, int32_t jne, const __float128 x[], __float128 jr[], const void *userdata);
typedef int32_t galahad_hr_q(int32_t n, int32_t m, int32_t hne, const __float128 x[], const __float128 y[], __float128 hr[], const void *userdata);
typedef int32_t galahad_jrprod_q(int32_t n, int32_t m, const __float128 x[], const bool transpose, __float128 u[], const __float128 v[], bool got_j, const void *userdata);
typedef int32_t galahad_hrprod_q(int32_t n, int32_t m, const __float128 x[], const __float128 y[], __float128 u[], const __float128 v[], bool got_h, const void *userdata);
typedef int32_t galahad_shrprod_q(int32_t n, int32_t m, int32_t pne, const __float128 x[], const __float128 v[], __float128 pval[], bool got_h, const void *userdata);
typedef int32_t galahad_fc_q(int32_t n, int32_t m, const __float128 x[], __float128 *f, __float128 c[], const void *userdata);
typedef int32_t galahad_gj_q(int32_t n, int32_t m, int32_t jne, const __float128 x[], __float128 g[], __float128 j[], const void *userdata);
typedef int32_t galahad_hl_q(int32_t n, int32_t m, int32_t hne, const __float128 x[], const __float128 y[], __float128 h[], const void *userdata);
typedef int32_t galahad_fgh_q(__float128 x, __float128 *f, __float128 *g, __float128 *h, const void *userdata);

typedef int64_t galahad_f_q_64(int64_t n, const __float128 x[], __float128 *f, const void *userdata);
typedef int64_t galahad_g_q_64(int64_t n, const __float128 x[], __float128 g[], const void *userdata);
typedef int64_t galahad_h_q_64(int64_t n, int64_t ne, const __float128 x[], __float128 h[], const void *userdata);
typedef int64_t galahad_prec_q_64(int64_t n, const __float128 x[], __float128 u[], const __float128 v[], const void *userdata);
typedef int64_t galahad_hprod_q_64(int64_t n, const __float128 x[], __float128 u[], const __float128 v[], bool got_h, const void *userdata);
typedef int64_t galahad_shprod_q_64(int64_t n, const __float128 x[], int64_t nnz_v, const int64_t index_nz_v[], const __float128 v[], int64_t *nnz_u, int64_t index_nz_u[], __float128 u[], bool got_h, const void *userdata);
typedef int64_t galahad_constant_prec_q_64(int64_t n, const __float128 v[], __float128 p[], const void *userdata);
typedef int64_t galahad_r_q_64(int64_t n, int64_t m, const __float128 x[], __float128 r[], const void *userdata);
typedef int64_t galahad_jr_q_64(int64_t n, int64_t m, int64_t jne, const __float128 x[], __float128 jr[], const void *userdata);
typedef int64_t galahad_hr_q_64(int64_t n, int64_t m, int64_t hne, const __float128 x[], const __float128 y[], __float128 hr[], const void *userdata);
typedef int64_t galahad_jrprod_q_64(int64_t n, int64_t m, const __float128 x[], const bool transpose, __float128 u[], const __float128 v[], bool got_j, const void *userdata);
typedef int64_t galahad_hrprod_q_64(int64_t n, int64_t m, const __float128 x[], const __float128 y[], __float128 u[], const __float128 v[], bool got_h, const void *userdata);
typedef int64_t galahad_shrprod_q_64(int64_t n, int64_t m, int64_t pne, const __float128 x[], const __float128 v[], __float128 pval[], bool got_h, const void *userdata);
typedef int64_t galahad_fc_q_64(int64_t n, int64_t m, const __float128 x[], __float128 *f, __float128 c[], const void *userdata);
typedef int64_t galahad_gj_q_64(int64_t n, int64_t m, int64_t jne, const __float128 x[], __float128 g[], __float128 j[], const void *userdata);
typedef int64_t galahad_hl_q_64(int64_t n, int64_t m, int64_t hne, const __float128 x[], const __float128 y[], __float128 h[], const void *userdata);
typedef int64_t galahad_fgh_q_64(__float128 x, __float128 *f, __float128 *g, __float128 *h, const void *userdata);

// C interface for BSC
struct bsc_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t max_col_a;
    int32_t exceeds_max_col;
    __float128 time;
    __float128 clock_time;
};

struct bsc_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t max_col_a;
    int64_t exceeds_max_col;
    __float128 time;
    __float128 clock_time;
};

void bsc_initialize_q(void **data, struct bsc_control_type *control, int32_t *status);
void bsc_initialize_q_64(void **data, struct bsc_control_type_64 *control, int64_t *status);
void bsc_import_q(struct bsc_control_type *control, void **data, int32_t *status, int32_t m, int32_t n, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr, int32_t *S_ne);
void bsc_import_q_64(struct bsc_control_type_64 *control, void **data, int64_t *status, int64_t m, int64_t n, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr, int64_t *S_ne);
void bsc_reset_control_q(struct bsc_control_type *control, void **data, int32_t *status);
void bsc_reset_control_q_64(struct bsc_control_type_64 *control, void **data, int64_t *status);
void bsc_form_s_q(void **data, int32_t *status, int32_t m, int32_t n, int32_t a_ne, __float128 *A_val, int32_t s_ne, int32_t *S_row, int32_t *S_col, int32_t *S_ptr, __float128 *S_val, __float128 *D);
void bsc_form_s_q_64(void **data, int64_t *status, int64_t m, int64_t n, int64_t a_ne, __float128 *A_val, int64_t s_ne, int64_t *S_row, int64_t *S_col, int64_t *S_ptr, __float128 *S_val, __float128 *D);
void bsc_information_q(void **data, struct bsc_inform_type_q *inform, int32_t *status);
void bsc_information_q_64(void **data, struct bsc_inform_type_q_64 *inform, int64_t *status);
void bsc_terminate_q(void **data, struct bsc_control_type *control, struct bsc_inform_type_q *inform);
void bsc_terminate_q_64(void **data, struct bsc_control_type_64 *control, struct bsc_inform_type_q_64 *inform);

// C interface for CONVERT
struct convert_time_type_q {
    __float128 total;
    __float128 clock_total;
};

struct convert_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    int32_t duplicates;
    char bad_alloc[81];
    struct convert_time_type_q time;
};

struct convert_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t duplicates;
    char bad_alloc[81];
    struct convert_time_type_q time;
};

void convert_initialize_q(void **data, struct convert_control_type *control, int32_t *status);
void convert_initialize_q_64(void **data, struct convert_control_type_64 *control, int64_t *status);
void convert_information_q(void **data, struct convert_inform_type_q *inform, int32_t *status);
void convert_information_q_64(void **data, struct convert_inform_type_q_64 *inform, int64_t *status);
void convert_terminate_q(void **data, struct convert_control_type *control, struct convert_inform_type_q *inform);
void convert_terminate_q_64(void **data, struct convert_control_type_64 *control, struct convert_inform_type_q_64 *inform);

// C interface for FIT
void fit_initialize_q(void **data, struct fit_control_type *control, int32_t *status);
void fit_initialize_q_64(void **data, struct fit_control_type_64 *control, int64_t *status);
void fit_information_q(void **data, struct fit_inform_type *inform, int32_t *status);
void fit_information_q_64(void **data, struct fit_inform_type_64 *inform, int64_t *status);
void fit_terminate_q(void **data, struct fit_control_type *control, struct fit_inform_type *inform);
void fit_terminate_q_64(void **data, struct fit_control_type_64 *control, struct fit_inform_type_64 *inform);

// C interface for GLRT
struct glrt_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t itmax;
    int32_t stopping_rule;
    int32_t freq;
    int32_t extra_vectors;
    int32_t ritz_printout_device;
    __float128 stop_relative;
    __float128 stop_absolute;
    __float128 fraction_opt;
    __float128 rminvr_zero;
    __float128 f_0;
    bool unitm;
    bool impose_descent;
    bool space_critical;
    bool deallocate_error_fatal;
    bool print_ritz_values;
    char ritz_file_name[31];
    char prefix[31];
};

struct glrt_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t itmax;
    int64_t stopping_rule;
    int64_t freq;
    int64_t extra_vectors;
    int64_t ritz_printout_device;
    __float128 stop_relative;
    __float128 stop_absolute;
    __float128 fraction_opt;
    __float128 rminvr_zero;
    __float128 f_0;
    bool unitm;
    bool impose_descent;
    bool space_critical;
    bool deallocate_error_fatal;
    bool print_ritz_values;
    char ritz_file_name[31];
    char prefix[31];
};

struct glrt_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    __float128 obj;
    __float128 obj_regularized;
    __float128 multiplier;
    __float128 xpo_norm;
    __float128 leftmost;
    bool negative_curvature;
    bool hard_case;
};

struct glrt_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    __float128 obj;
    __float128 obj_regularized;
    __float128 multiplier;
    __float128 xpo_norm;
    __float128 leftmost;
    bool negative_curvature;
    bool hard_case;
};

void glrt_initialize_q(void **data, struct glrt_control_type_q *control, int32_t *status);
void glrt_initialize_q_64(void **data, struct glrt_control_type_q_64 *control, int64_t *status);
void glrt_read_specfile_q(struct glrt_control_type_q *control, char *specfile);
void glrt_read_specfile_q_64(struct glrt_control_type_q_64 *control, char *specfile);
void glrt_import_control_q(struct glrt_control_type_q *control, void **data, int32_t *status);
void glrt_import_control_q_64(struct glrt_control_type_q_64 *control, void **data, int64_t *status);
void glrt_solve_problem_q(void **data, int32_t *status, int32_t n, __float128 power, __float128 weight, __float128 *x, __float128 *r, __float128 *vector);
void glrt_solve_problem_q_64(void **data, int64_t *status, int64_t n, __float128 power, __float128 weight, __float128 *x, __float128 *r, __float128 *vector);
void glrt_information_q(void **data, struct glrt_inform_type_q *inform, int32_t *status);
void glrt_information_q_64(void **data, struct glrt_inform_type_q_64 *inform, int64_t *status);
void glrt_terminate_q(void **data, struct glrt_control_type_q *control, struct glrt_inform_type_q *inform);
void glrt_terminate_q_64(void **data, struct glrt_control_type_q_64 *control, struct glrt_inform_type_q_64 *inform);

// C interface for GLS
struct gls_control_type_q {
    bool f_indexing;
    int32_t lp;
    int32_t wp;
    int32_t mp;
    int32_t ldiag;
    int32_t btf;
    int32_t maxit;
    int32_t factor_blocking;
    int32_t solve_blas;
    int32_t la;
    int32_t la_int;
    int32_t maxla;
    int32_t pivoting;
    int32_t fill_in;
    __float128 multiplier;
    __float128 reduce;
    __float128 u;
    __float128 switch_full;
    __float128 drop;
    __float128 tolerance;
    __float128 cgce;
    bool diagonal_pivoting;
    bool struct_abort;
};

struct gls_control_type_q_64 {
    bool f_indexing;
    int64_t lp;
    int64_t wp;
    int64_t mp;
    int64_t ldiag;
    int64_t btf;
    int64_t maxit;
    int64_t factor_blocking;
    int64_t solve_blas;
    int64_t la;
    int64_t la_int;
    int64_t maxla;
    int64_t pivoting;
    int64_t fill_in;
    __float128 multiplier;
    __float128 reduce;
    __float128 u;
    __float128 switch_full;
    __float128 drop;
    __float128 tolerance;
    __float128 cgce;
    bool diagonal_pivoting;
    bool struct_abort;
};

struct gls_ainfo_type_q {
    int32_t flag;
    int32_t more;
    int32_t len_analyse;
    int32_t len_factorize;
    int32_t ncmpa;
    int32_t rank;
    int32_t drop;
    int32_t struc_rank;
    int32_t oor;
    int32_t dup;
    int32_t stat;
    int32_t lblock;
    int32_t sblock;
    int32_t tblock;
    __float128 ops;
};

struct gls_ainfo_type_q_64 {
    int64_t flag;
    int64_t more;
    int64_t len_analyse;
    int64_t len_factorize;
    int64_t ncmpa;
    int64_t rank;
    int64_t drop;
    int64_t struc_rank;
    int64_t oor;
    int64_t dup;
    int64_t stat;
    int64_t lblock;
    int64_t sblock;
    int64_t tblock;
    __float128 ops;
};

struct gls_finfo_type_q {
    int32_t flag;
    int32_t more;
    int32_t size_factor;
    int32_t len_factorize;
    int32_t drop;
    int32_t rank;
    int32_t stat;
    __float128 ops;
};

struct gls_finfo_type_q_64 {
    int64_t flag;
    int64_t more;
    int64_t size_factor;
    int64_t len_factorize;
    int64_t drop;
    int64_t rank;
    int64_t stat;
    __float128 ops;
};

void gls_initialize_q(void **data, struct gls_control_type_q *control);
void gls_initialize_q_64(void **data, struct gls_control_type_q_64 *control);
void gls_read_specfile_q(struct gls_control_type_q *control, char *specfile);
void gls_read_specfile_q_64(struct gls_control_type_q_64 *control, char *specfile);
void gls_import_q(struct gls_control_type_q *control, void **data, int32_t *status);
void gls_import_q_64(struct gls_control_type_q_64 *control, void **data, int64_t *status);
void gls_reset_control_q(struct gls_control_type_q *control, void **data, int32_t *status);
void gls_reset_control_q_64(struct gls_control_type_q_64 *control, void **data, int64_t *status);
void gls_information_q(void **data, struct gls_ainfo_type_q *ainfo, struct gls_finfo_type_q *finfo, struct gls_sinfo_type *sinfo, int32_t *status);
void gls_information_q_64(void **data, struct gls_ainfo_type_q_64 *ainfo, struct gls_finfo_type_q_64 *finfo, struct gls_sinfo_type_64 *sinfo, int64_t *status);
void gls_finalize_q(void **data, struct gls_control_type_q *control, int32_t *status);
void gls_finalize_q_64(void **data, struct gls_control_type_q_64 *control, int64_t *status);

// C interface for GLTR
struct gltr_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t itmax;
    int32_t Lanczos_itmax;
    int32_t extra_vectors;
    int32_t ritz_printout_device;
    __float128 stop_relative;
    __float128 stop_absolute;
    __float128 fraction_opt;
    __float128 f_min;
    __float128 rminvr_zero;
    __float128 f_0;
    bool unitm;
    bool steihaug_toint;
    bool boundary;
    bool equality_problem;
    bool space_critical;
    bool deallocate_error_fatal;
    bool print_ritz_values;
    char ritz_file_name[31];
    char prefix[31];
};

struct gltr_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t itmax;
    int64_t Lanczos_itmax;
    int64_t extra_vectors;
    int64_t ritz_printout_device;
    __float128 stop_relative;
    __float128 stop_absolute;
    __float128 fraction_opt;
    __float128 f_min;
    __float128 rminvr_zero;
    __float128 f_0;
    bool unitm;
    bool steihaug_toint;
    bool boundary;
    bool equality_problem;
    bool space_critical;
    bool deallocate_error_fatal;
    bool print_ritz_values;
    char ritz_file_name[31];
    char prefix[31];
};

struct gltr_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    __float128 obj;
    __float128 multiplier;
    __float128 mnormx;
    __float128 piv;
    __float128 curv;
    __float128 rayleigh;
    __float128 leftmost;
    bool negative_curvature;
    bool hard_case;
};

struct gltr_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    __float128 obj;
    __float128 multiplier;
    __float128 mnormx;
    __float128 piv;
    __float128 curv;
    __float128 rayleigh;
    __float128 leftmost;
    bool negative_curvature;
    bool hard_case;
};

void gltr_initialize_q(void **data, struct gltr_control_type_q *control, int32_t *status);
void gltr_initialize_q_64(void **data, struct gltr_control_type_q_64 *control, int64_t *status);
void gltr_read_specfile_q(struct gltr_control_type_q *control, char *specfile);
void gltr_read_specfile_q_64(struct gltr_control_type_q_64 *control, char *specfile);
void gltr_import_control_q(struct gltr_control_type_q *control, void **data, int32_t *status);
void gltr_import_control_q_64(struct gltr_control_type_q_64 *control, void **data, int64_t *status);
void gltr_solve_problem_q(void **data, int32_t *status, int32_t n, __float128 radius, __float128 *x, __float128 *r, __float128 *vector);
void gltr_solve_problem_q_64(void **data, int64_t *status, int64_t n, __float128 radius, __float128 *x, __float128 *r, __float128 *vector);
void gltr_information_q(void **data, struct gltr_inform_type_q *inform, int32_t *status);
void gltr_information_q_64(void **data, struct gltr_inform_type_q_64 *inform, int64_t *status);
void gltr_terminate_q(void **data, struct gltr_control_type_q *control, struct gltr_inform_type_q *inform);
void gltr_terminate_q_64(void **data, struct gltr_control_type_q_64 *control, struct gltr_inform_type_q_64 *inform);

// C interface for HASH
void hash_initialize_q(int32_t nchar, int32_t length, void **data, struct hash_control_type *control, struct hash_inform_type *inform);
void hash_initialize_q_64(int64_t nchar, int64_t length, void **data, struct hash_control_type_64 *control, struct hash_inform_type_64 *inform);
void hash_information_q(void **data, struct hash_inform_type *inform, int32_t *status);
void hash_information_q_64(void **data, struct hash_inform_type_64 *inform, int64_t *status);
void hash_terminate_q(void **data, struct hash_control_type *control, struct hash_inform_type *inform);
void hash_terminate_q_64(void **data, struct hash_control_type_64 *control, struct hash_inform_type_64 *inform);

// C interface for HSL
struct ma48_control_q {
    int32_t f_arrays;
    __float128 multiplier;
    __float128 u;
    __float128 switch_;
    __float128 drop;
    __float128 tolerance;
    __float128 cgce;
    int32_t lp;
    int32_t wp;
    int32_t mp;
    int32_t ldiag;
    int32_t btf;
    int32_t struct_;
    int32_t maxit;
    int32_t factor_blocking;
    int32_t solve_blas;
    int32_t pivoting;
    int32_t diagonal_pivoting;
    int32_t fill_in;
    int32_t switch_mode;
};

struct ma48_control_q_64 {
    int64_t f_arrays;
    __float128 multiplier;
    __float128 u;
    __float128 switch_;
    __float128 drop;
    __float128 tolerance;
    __float128 cgce;
    int64_t lp;
    int64_t wp;
    int64_t mp;
    int64_t ldiag;
    int64_t btf;
    int64_t struct_;
    int64_t maxit;
    int64_t factor_blocking;
    int64_t solve_blas;
    int64_t pivoting;
    int64_t diagonal_pivoting;
    int64_t fill_in;
    int64_t switch_mode;
};

struct ma48_ainfo_q {
    __float128 ops;
    int32_t flag;
    int32_t more;
    int64_t lena_analyse;
    int64_t lenj_analyse;
    int64_t lena_factorize;
    int64_t leni_factorize;
    int32_t ncmpa;
    int32_t rank;
    int64_t drop;
    int32_t struc_rank;
    int64_t oor;
    int64_t dup;
    int32_t stat;
    int32_t lblock;
    int32_t sblock;
    int64_t tblock;
};

struct ma48_ainfo_q_64 {
    __float128 ops;
    int64_t flag;
    int64_t more;
    int64_t lena_analyse;
    int64_t lenj_analyse;
    int64_t lena_factorize;
    int64_t leni_factorize;
    int64_t ncmpa;
    int64_t rank;
    int64_t drop;
    int64_t struc_rank;
    int64_t oor;
    int64_t dup;
    int64_t stat;
    int64_t lblock;
    int64_t sblock;
    int64_t tblock;
};

struct ma48_finfo_q {
    __float128 ops;
    int32_t flag;
    int32_t more;
    int64_t size_factor;
    int64_t lena_factorize;
    int64_t leni_factorize;
    int64_t drop;
    int32_t rank;
    int32_t stat;
};

struct ma48_finfo_q_64 {
    __float128 ops;
    int64_t flag;
    int64_t more;
    int64_t size_factor;
    int64_t lena_factorize;
    int64_t leni_factorize;
    int64_t drop;
    int64_t rank;
    int64_t stat;
};

struct ma57_control_q {
    int32_t f_arrays;
    __float128 multiplier;
    __float128 reduce;
    __float128 u;
    __float128 static_tolerance;
    __float128 static_level;
    __float128 tolerance;
    __float128 convergence;
    __float128 consist;
    int32_t lp;
    int32_t wp;
    int32_t mp;
    int32_t sp;
    int32_t ldiag;
    int32_t nemin;
    int32_t factorblocking;
    int32_t solveblocking;
    int32_t la;
    int32_t liw;
    int32_t maxla;
    int32_t maxliw;
    int32_t pivoting;
    int32_t thresh;
    int32_t ordering;
    int32_t scaling;
    int32_t rank_deficient;
    int32_t ispare[5];
    __float128 rspare[10];
};

struct ma57_control_q_64 {
    int64_t f_arrays;
    __float128 multiplier;
    __float128 reduce;
    __float128 u;
    __float128 static_tolerance;
    __float128 static_level;
    __float128 tolerance;
    __float128 convergence;
    __float128 consist;
    int64_t lp;
    int64_t wp;
    int64_t mp;
    int64_t sp;
    int64_t ldiag;
    int64_t nemin;
    int64_t factorblocking;
    int64_t solveblocking;
    int64_t la;
    int64_t liw;
    int64_t maxla;
    int64_t maxliw;
    int64_t pivoting;
    int64_t thresh;
    int64_t ordering;
    int64_t scaling;
    int64_t rank_deficient;
    int64_t ispare[5];
    __float128 rspare[10];
};

struct ma57_ainfo_q {
    __float128 opsa;
    __float128 opse;
    int32_t flag;
    int32_t more;
    int32_t nsteps;
    int32_t nrltot;
    int32_t nirtot;
    int32_t nrlnec;
    int32_t nirnec;
    int32_t nrladu;
    int32_t niradu;
    int32_t ncmpa;
    int32_t ordering;
    int32_t oor;
    int32_t dup;
    int32_t maxfrt;
    int32_t stat;
    int32_t ispare[5];
    __float128 rspare[10];
};

struct ma57_ainfo_q_64 {
    __float128 opsa;
    __float128 opse;
    int64_t flag;
    int64_t more;
    int64_t nsteps;
    int64_t nrltot;
    int64_t nirtot;
    int64_t nrlnec;
    int64_t nirnec;
    int64_t nrladu;
    int64_t niradu;
    int64_t ncmpa;
    int64_t ordering;
    int64_t oor;
    int64_t dup;
    int64_t maxfrt;
    int64_t stat;
    int64_t ispare[5];
    __float128 rspare[10];
};

struct ma57_finfo_q {
    __float128 opsa;
    __float128 opse;
    __float128 opsb;
    __float128 maxchange;
    __float128 smin;
    __float128 smax;
    int32_t flag;
    int32_t more;
    int32_t maxfrt;
    int32_t nebdu;
    int32_t nrlbdu;
    int32_t nirbdu;
    int32_t nrltot;
    int32_t nirtot;
    int32_t nrlnec;
    int32_t nirnec;
    int32_t ncmpbr;
    int32_t ncmpbi;
    int32_t ntwo;
    int32_t neig;
    int32_t delay;
    int32_t signc;
    int32_t static_;
    int32_t modstep;
    int32_t rank;
    int32_t stat;
    int32_t ispare[5];
    __float128 rspare[10];
};

struct ma57_finfo_q_64 {
    __float128 opsa;
    __float128 opse;
    __float128 opsb;
    __float128 maxchange;
    __float128 smin;
    __float128 smax;
    int64_t flag;
    int64_t more;
    int64_t maxfrt;
    int64_t nebdu;
    int64_t nrlbdu;
    int64_t nirbdu;
    int64_t nrltot;
    int64_t nirtot;
    int64_t nrlnec;
    int64_t nirnec;
    int64_t ncmpbr;
    int64_t ncmpbi;
    int64_t ntwo;
    int64_t neig;
    int64_t delay;
    int64_t signc;
    int64_t static_;
    int64_t modstep;
    int64_t rank;
    int64_t stat;
    int64_t ispare[5];
    __float128 rspare[10];
};

struct ma57_sinfo_q {
    __float128 cond;
    __float128 cond2;
    __float128 berr;
    __float128 berr2;
    __float128 error;
    int32_t flag;
    int32_t stat;
    int32_t ispare[5];
    __float128 rspare[10];
};

struct ma57_sinfo_q_64 {
    __float128 cond;
    __float128 cond2;
    __float128 berr;
    __float128 berr2;
    __float128 error;
    int64_t flag;
    int64_t stat;
    int64_t ispare[5];
    __float128 rspare[10];
};

struct ma77_control_q {
    int32_t f_arrays;
    int32_t print_level;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int32_t bits;
    int32_t buffer_lpage[2];
    int32_t buffer_npage[2];
    int64_t file_size;
    int64_t maxstore;
    int64_t storage[3];
    int32_t nemin;
    int32_t maxit;
    int32_t infnorm;
    __float128 thresh;
    int32_t nb54;
    int32_t action;
    __float128 multiplier;
    int32_t nb64;
    int32_t nbi;
    __float128 small;
    __float128 static_;
    int64_t storage_indef;
    __float128 u;
    __float128 umin;
    __float128 consist_tol;
    int32_t ispare[5];
    int64_t lspare[5];
    __float128 rspare[5];
};

struct ma77_control_q_64 {
    int64_t f_arrays;
    int64_t print_level;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t bits;
    int64_t buffer_lpage[2];
    int64_t buffer_npage[2];
    int64_t file_size;
    int64_t maxstore;
    int64_t storage[3];
    int64_t nemin;
    int64_t maxit;
    int64_t infnorm;
    __float128 thresh;
    int64_t nb54;
    int64_t action;
    __float128 multiplier;
    int64_t nb64;
    int64_t nbi;
    __float128 small;
    __float128 static_;
    int64_t storage_indef;
    __float128 u;
    __float128 umin;
    __float128 consist_tol;
    int64_t ispare[5];
    int64_t lspare[5];
    __float128 rspare[5];
};

struct ma77_info_q {
    __float128 detlog;
    int32_t detsign;
    int32_t flag;
    int32_t iostat;
    int32_t matrix_dup;
    int32_t matrix_rank;
    int32_t matrix_outrange;
    int32_t maxdepth;
    int32_t maxfront;
    int64_t minstore;
    int32_t ndelay;
    int64_t nfactor;
    int64_t nflops;
    int32_t niter;
    int32_t nsup;
    int32_t num_neg;
    int32_t num_nothresh;
    int32_t num_perturbed;
    int32_t ntwo;
    int32_t stat;
    int32_t index[4];
    int64_t nio_read[2];
    int64_t nio_write[2];
    int64_t nwd_read[2];
    int64_t nwd_write[2];
    int32_t num_file[4];
    int64_t storage[4];
    int32_t tree_nodes;
    int32_t unit_restart;
    int32_t unused;
    __float128 usmall;
    int32_t ispare[5];
    int64_t lspare[5];
    __float128 rspare[5];
};

struct ma77_info_q_64 {
    __float128 detlog;
    int64_t detsign;
    int64_t flag;
    int64_t iostat;
    int64_t matrix_dup;
    int64_t matrix_rank;
    int64_t matrix_outrange;
    int64_t maxdepth;
    int64_t maxfront;
    int64_t minstore;
    int64_t ndelay;
    int64_t nfactor;
    int64_t nflops;
    int64_t niter;
    int64_t nsup;
    int64_t num_neg;
    int64_t num_nothresh;
    int64_t num_perturbed;
    int64_t ntwo;
    int64_t stat;
    int64_t index[4];
    int64_t nio_read[2];
    int64_t nio_write[2];
    int64_t nwd_read[2];
    int64_t nwd_write[2];
    int64_t num_file[4];
    int64_t storage[4];
    int64_t tree_nodes;
    int64_t unit_restart;
    int64_t unused;
    __float128 usmall;
    int64_t ispare[5];
    int64_t lspare[5];
    __float128 rspare[5];
};

struct ma86_control_q {
    int32_t f_arrays;
    int32_t diagnostics_level;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int32_t nemin;
    int32_t nb;
    int32_t action;
    int32_t nbi;
    int32_t pool_size;
    __float128 small_;
    __float128 static_;
    __float128 u;
    __float128 umin;
    int32_t scaling;
};

struct ma86_control_q_64 {
    int64_t f_arrays;
    int64_t diagnostics_level;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t nemin;
    int64_t nb;
    int64_t action;
    int64_t nbi;
    int64_t pool_size;
    __float128 small_;
    __float128 static_;
    __float128 u;
    __float128 umin;
    int64_t scaling;
};

struct ma86_info_q {
    __float128 detlog;
    int32_t detsign;
    int32_t flag;
    int32_t matrix_rank;
    int32_t maxdepth;
    int32_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int32_t num_neg;
    int32_t num_nodes;
    int32_t num_nothresh;
    int32_t num_perturbed;
    int32_t num_two;
    int32_t pool_size;
    int32_t stat;
    __float128 usmall;
};

struct ma86_info_q_64 {
    __float128 detlog;
    int64_t detsign;
    int64_t flag;
    int64_t matrix_rank;
    int64_t maxdepth;
    int64_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int64_t num_neg;
    int64_t num_nodes;
    int64_t num_nothresh;
    int64_t num_perturbed;
    int64_t num_two;
    int64_t pool_size;
    int64_t stat;
    __float128 usmall;
};

struct ma87_control_q {
    int32_t f_arrays;
    int32_t diagnostics_level;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int32_t nemin;
    int32_t nb;
    int32_t pool_size;
    __float128 diag_zero_minus;
    __float128 diag_zero_plus;
    char unused[40];
};

struct ma87_control_q_64 {
    int64_t f_arrays;
    int64_t diagnostics_level;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t nemin;
    int64_t nb;
    int64_t pool_size;
    __float128 diag_zero_minus;
    __float128 diag_zero_plus;
    char unused[40];
};

struct ma87_info_q {
    __float128 detlog;
    int32_t flag;
    int32_t maxdepth;
    int64_t num_factor;
    int64_t num_flops;
    int32_t num_nodes;
    int32_t pool_size;
    int32_t stat;
    int32_t num_zero;
    char unused[40];
};

struct ma87_info_q_64 {
    __float128 detlog;
    int64_t flag;
    int64_t maxdepth;
    int64_t num_factor;
    int64_t num_flops;
    int64_t num_nodes;
    int64_t pool_size;
    int64_t stat;
    int64_t num_zero;
    char unused[40];
};

struct ma97_control_q {
    int32_t f_arrays;
    int32_t action;
    int32_t nemin;
    __float128 multiplier;
    int32_t ordering;
    int32_t print_level;
    int32_t scaling;
    __float128 small;
    __float128 u;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int64_t factor_min;
    int32_t solve_blas3;
    int64_t solve_min;
    int32_t solve_mf;
    __float128 consist_tol;
    int32_t ispare[5];
    __float128 rspare[10];
};

struct ma97_control_q_64 {
    int64_t f_arrays;
    int64_t action;
    int64_t nemin;
    __float128 multiplier;
    int64_t ordering;
    int64_t print_level;
    int64_t scaling;
    __float128 small;
    __float128 u;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t factor_min;
    int64_t solve_blas3;
    int64_t solve_min;
    int64_t solve_mf;
    __float128 consist_tol;
    int64_t ispare[5];
    __float128 rspare[10];
};

struct ma97_info_q {
    int32_t flag;
    int32_t flag68;
    int32_t flag77;
    int32_t matrix_dup;
    int32_t matrix_rank;
    int32_t matrix_outrange;
    int32_t matrix_missing_diag;
    int32_t maxdepth;
    int32_t maxfront;
    int32_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int32_t num_neg;
    int32_t num_sup;
    int32_t num_two;
    int32_t ordering;
    int32_t stat;
    int32_t maxsupernode;
    int32_t ispare[4];
    __float128 rspare[10];
};

struct ma97_info_q_64 {
    int64_t flag;
    int64_t flag68;
    int64_t flag77;
    int64_t matrix_dup;
    int64_t matrix_rank;
    int64_t matrix_outrange;
    int64_t matrix_missing_diag;
    int64_t maxdepth;
    int64_t maxfront;
    int64_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int64_t num_neg;
    int64_t num_sup;
    int64_t num_two;
    int64_t ordering;
    int64_t stat;
    int64_t maxsupernode;
    int64_t ispare[4];
    __float128 rspare[10];
};

struct mi20_control_q {
    int32_t f_arrays;
    int32_t aggressive;
    int32_t c_fail;
    int32_t max_levels;
    int32_t max_points;
    __float128 reduction;
    int32_t st_method;
    __float128 st_parameter;
    int32_t testing;
    __float128 trunc_parameter;
    int32_t coarse_solver;
    int32_t coarse_solver_its;
    __float128 damping;
    __float128 err_tol;
    int32_t levels;
    int32_t pre_smoothing;
    int32_t smoother;
    int32_t post_smoothing;
    int32_t v_iterations;
    int32_t print_level;
    int32_t print;
    int32_t error;
    int32_t one_pass_coarsen;
};

struct mi20_control_q_64 {
    int64_t f_arrays;
    int64_t aggressive;
    int64_t c_fail;
    int64_t max_levels;
    int64_t max_points;
    __float128 reduction;
    int64_t st_method;
    __float128 st_parameter;
    int64_t testing;
    __float128 trunc_parameter;
    int64_t coarse_solver;
    int64_t coarse_solver_its;
    __float128 damping;
    __float128 err_tol;
    int64_t levels;
    int64_t pre_smoothing;
    int64_t smoother;
    int64_t post_smoothing;
    int64_t v_iterations;
    int64_t print_level;
    int64_t print;
    int64_t error;
    int64_t one_pass_coarsen;
};

struct mi20_solve_control_q {
    __float128 abs_tol;
    __float128 breakdown_tol;
    int32_t gmres_restart;
    bool init_guess;
    int32_t krylov_solver;
    int32_t max_its;
    int32_t preconditioner_side;
    __float128 rel_tol;
};

struct mi20_solve_control_q_64 {
    __float128 abs_tol;
    __float128 breakdown_tol;
    int64_t gmres_restart;
    bool init_guess;
    int64_t krylov_solver;
    int64_t max_its;
    int64_t preconditioner_side;
    __float128 rel_tol;
};

struct mi20_info_q {
    int32_t flag;
    int32_t clevels;
    int32_t cpoints;
    int32_t cnnz;
    int32_t stat;
    int32_t getrf_info;
    int32_t iterations;
    __float128 residual;
};

struct mi20_info_q_64 {
    int64_t flag;
    int64_t clevels;
    int64_t cpoints;
    int64_t cnnz;
    int64_t stat;
    int64_t getrf_info;
    int64_t iterations;
    __float128 residual;
};

struct mi28_control_q {
    int32_t f_arrays;
    __float128 alpha;
    bool check;
    int32_t iorder;
    int32_t iscale;
    __float128 lowalpha;
    int32_t maxshift;
    bool rrt;
    __float128 shift_factor;
    __float128 shift_factor2;
    __float128 small;
    __float128 tau1;
    __float128 tau2;
    int32_t unit_error;
    int32_t unit_warning;
};

struct mi28_control_q_64 {
    int64_t f_arrays;
    __float128 alpha;
    bool check;
    int64_t iorder;
    int64_t iscale;
    __float128 lowalpha;
    int64_t maxshift;
    bool rrt;
    __float128 shift_factor;
    __float128 shift_factor2;
    __float128 small;
    __float128 tau1;
    __float128 tau2;
    int64_t unit_error;
    int64_t unit_warning;
};

struct mi28_info_q {
    int32_t band_after;
    int32_t band_before;
    int32_t dup;
    int32_t flag;
    int32_t flag61;
    int32_t flag64;
    int32_t flag68;
    int32_t flag77;
    int32_t nrestart;
    int32_t nshift;
    int32_t oor;
    __float128 profile_before;
    __float128 profile_after;
    int64_t size_r;
    int32_t stat;
    __float128 alpha;
};

struct mi28_info_q_64 {
    int64_t band_after;
    int64_t band_before;
    int64_t dup;
    int64_t flag;
    int64_t flag61;
    int64_t flag64;
    int64_t flag68;
    int64_t flag77;
    int64_t nrestart;
    int64_t nshift;
    int64_t oor;
    __float128 profile_before;
    __float128 profile_after;
    int64_t size_r;
    int64_t stat;
    __float128 alpha;
};

// C interface for IR
struct ir_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t itref_max;
    __float128 acceptable_residual_relative;
    __float128 acceptable_residual_absolute;
    __float128 required_residual_relative;
    bool record_residuals;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct ir_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t itref_max;
    __float128 acceptable_residual_relative;
    __float128 acceptable_residual_absolute;
    __float128 required_residual_relative;
    bool record_residuals;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct ir_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    __float128 norm_initial_residual;
    __float128 norm_final_residual;
};

struct ir_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    __float128 norm_initial_residual;
    __float128 norm_final_residual;
};

void ir_initialize_q(void **data, struct ir_control_type_q *control, int32_t *status);
void ir_initialize_q_64(void **data, struct ir_control_type_q_64 *control, int64_t *status);
void ir_information_q(void **data, struct ir_inform_type_q *inform, int32_t *status);
void ir_information_q_64(void **data, struct ir_inform_type_q_64 *inform, int64_t *status);
void ir_terminate_q(void **data, struct ir_control_type_q *control, struct ir_inform_type_q *inform);
void ir_terminate_q_64(void **data, struct ir_control_type_q_64 *control, struct ir_inform_type_q_64 *inform);

// C interface for L2RT
struct l2rt_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t itmin;
    int32_t itmax;
    int32_t bitmax;
    int32_t extra_vectors;
    int32_t stopping_rule;
    int32_t freq;
    __float128 stop_relative;
    __float128 stop_absolute;
    __float128 fraction_opt;
    __float128 time_limit;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct l2rt_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t itmin;
    int64_t itmax;
    int64_t bitmax;
    int64_t extra_vectors;
    int64_t stopping_rule;
    int64_t freq;
    __float128 stop_relative;
    __float128 stop_absolute;
    __float128 fraction_opt;
    __float128 time_limit;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct l2rt_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    int32_t biters;
    int32_t biter_min;
    int32_t biter_max;
    __float128 obj;
    __float128 multiplier;
    __float128 x_norm;
    __float128 r_norm;
    __float128 Atr_norm;
    __float128 biter_mean;
};

struct l2rt_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    int64_t biters;
    int64_t biter_min;
    int64_t biter_max;
    __float128 obj;
    __float128 multiplier;
    __float128 x_norm;
    __float128 r_norm;
    __float128 Atr_norm;
    __float128 biter_mean;
};

void l2rt_initialize_q(void **data, struct l2rt_control_type_q *control, int32_t *status);
void l2rt_initialize_q_64(void **data, struct l2rt_control_type_q_64 *control, int64_t *status);
void l2rt_read_specfile_q(struct l2rt_control_type_q *control, char *specfile);
void l2rt_read_specfile_q_64(struct l2rt_control_type_q_64 *control, char *specfile);
void l2rt_import_control_q(struct l2rt_control_type_q *control, void **data, int32_t *status);
void l2rt_import_control_q_64(struct l2rt_control_type_q_64 *control, void **data, int64_t *status);
void l2rt_solve_problem_q(void **data, int32_t *status, int32_t m, int32_t n, __float128 power, __float128 weight, __float128 shift, __float128 *x, __float128 *u, __float128 *v);
void l2rt_solve_problem_q_64(void **data, int64_t *status, int64_t m, int64_t n, __float128 power, __float128 weight, __float128 shift, __float128 *x, __float128 *u, __float128 *v);
void l2rt_information_q(void **data, struct l2rt_inform_type_q *inform, int32_t *status);
void l2rt_information_q_64(void **data, struct l2rt_inform_type_q_64 *inform, int64_t *status);
void l2rt_terminate_q(void **data, struct l2rt_control_type_q *control, struct l2rt_inform_type_q *inform);
void l2rt_terminate_q_64(void **data, struct l2rt_control_type_q_64 *control, struct l2rt_inform_type_q_64 *inform);

// C interface for LHS
void lhs_initialize_q(void **data, struct lhs_control_type *control, struct lhs_inform_type *inform);
void lhs_initialize_q_64(void **data, struct lhs_control_type_64 *control, struct lhs_inform_type_64 *inform);
void lhs_read_specfile_q(struct lhs_control_type *control, char *specfile);
void lhs_read_specfile_q_64(struct lhs_control_type_64 *control, char *specfile);
void lhs_ihs_q(int32_t n_dimen, int32_t n_points, int32_t *seed, int32_t *X, struct lhs_control_type *control, struct lhs_inform_type *inform, void **data);
void lhs_ihs_q_64(int64_t n_dimen, int64_t n_points, int64_t *seed, int64_t *X, struct lhs_control_type_64 *control, struct lhs_inform_type_64 *inform, void **data);
void lhs_get_seed_q(int32_t *seed);
void lhs_get_seed_q_64(int64_t *seed);
void lhs_information_q(void **data, struct lhs_inform_type *inform, int32_t *status);
void lhs_information_q_64(void **data, struct lhs_inform_type_64 *inform, int64_t *status);
void lhs_terminate_q(void **data, struct lhs_control_type *control, struct lhs_inform_type *inform);
void lhs_terminate_q_64(void **data, struct lhs_control_type_64 *control, struct lhs_inform_type_64 *inform);

// C interface for LMS
struct lms_time_type_q {
    __float128 total;
    __float128 setup;
    __float128 form;
    __float128 apply;
    __float128 clock_total;
    __float128 clock_setup;
    __float128 clock_form;
    __float128 clock_apply;
};

struct lms_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    int32_t length;
    bool updates_skipped;
    char bad_alloc[81];
    struct lms_time_type_q time;
};

struct lms_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t length;
    bool updates_skipped;
    char bad_alloc[81];
    struct lms_time_type_q time;
};

void lms_initialize_q(void **data, struct lms_control_type *control, int32_t *status);
void lms_initialize_q_64(void **data, struct lms_control_type_64 *control, int64_t *status);
void lms_information_q(void **data, struct lms_inform_type_q *inform, int32_t *status);
void lms_information_q_64(void **data, struct lms_inform_type_q_64 *inform, int64_t *status);
void lms_terminate_q(void **data, struct lms_control_type *control, struct lms_inform_type_q *inform);
void lms_terminate_q_64(void **data, struct lms_control_type_64 *control, struct lms_inform_type_q_64 *inform);

// C interface for LSRT
struct lsrt_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t itmin;
    int32_t itmax;
    int32_t bitmax;
    int32_t extra_vectors;
    int32_t stopping_rule;
    int32_t freq;
    __float128 stop_relative;
    __float128 stop_absolute;
    __float128 fraction_opt;
    __float128 time_limit;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct lsrt_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t itmin;
    int64_t itmax;
    int64_t bitmax;
    int64_t extra_vectors;
    int64_t stopping_rule;
    int64_t freq;
    __float128 stop_relative;
    __float128 stop_absolute;
    __float128 fraction_opt;
    __float128 time_limit;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct lsrt_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    int32_t biters;
    int32_t biter_min;
    int32_t biter_max;
    __float128 obj;
    __float128 multiplier;
    __float128 x_norm;
    __float128 r_norm;
    __float128 Atr_norm;
    __float128 biter_mean;
};

struct lsrt_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    int64_t biters;
    int64_t biter_min;
    int64_t biter_max;
    __float128 obj;
    __float128 multiplier;
    __float128 x_norm;
    __float128 r_norm;
    __float128 Atr_norm;
    __float128 biter_mean;
};

void lsrt_initialize_q(void **data, struct lsrt_control_type_q *control, int32_t *status);
void lsrt_initialize_q_64(void **data, struct lsrt_control_type_q_64 *control, int64_t *status);
void lsrt_read_specfile_q(struct lsrt_control_type_q *control, char *specfile);
void lsrt_read_specfile_q_64(struct lsrt_control_type_q_64 *control, char *specfile);
void lsrt_import_control_q(struct lsrt_control_type_q *control, void **data, int32_t *status);
void lsrt_import_control_q_64(struct lsrt_control_type_q_64 *control, void **data, int64_t *status);
void lsrt_solve_problem_q(void **data, int32_t *status, int32_t m, int32_t n, __float128 power, __float128 weight, __float128 *x, __float128 *u, __float128 *v);
void lsrt_solve_problem_q_64(void **data, int64_t *status, int64_t m, int64_t n, __float128 power, __float128 weight, __float128 *x, __float128 *u, __float128 *v);
void lsrt_information_q(void **data, struct lsrt_inform_type_q *inform, int32_t *status);
void lsrt_information_q_64(void **data, struct lsrt_inform_type_q_64 *inform, int64_t *status);
void lsrt_terminate_q(void **data, struct lsrt_control_type_q *control, struct lsrt_inform_type_q *inform);
void lsrt_terminate_q_64(void **data, struct lsrt_control_type_q_64 *control, struct lsrt_inform_type_q_64 *inform);

// C interface for LSTR
struct lstr_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t itmin;
    int32_t itmax;
    int32_t itmax_on_boundary;
    int32_t bitmax;
    int32_t extra_vectors;
    __float128 stop_relative;
    __float128 stop_absolute;
    __float128 fraction_opt;
    __float128 time_limit;
    bool steihaug_toint;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct lstr_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t itmin;
    int64_t itmax;
    int64_t itmax_on_boundary;
    int64_t bitmax;
    int64_t extra_vectors;
    __float128 stop_relative;
    __float128 stop_absolute;
    __float128 fraction_opt;
    __float128 time_limit;
    bool steihaug_toint;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct lstr_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    int32_t biters;
    int32_t biter_min;
    int32_t biter_max;
    __float128 multiplier;
    __float128 x_norm;
    __float128 r_norm;
    __float128 Atr_norm;
    __float128 biter_mean;
};

struct lstr_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    int64_t biters;
    int64_t biter_min;
    int64_t biter_max;
    __float128 multiplier;
    __float128 x_norm;
    __float128 r_norm;
    __float128 Atr_norm;
    __float128 biter_mean;
};

void lstr_initialize_q(void **data, struct lstr_control_type_q *control, int32_t *status);
void lstr_initialize_q_64(void **data, struct lstr_control_type_q_64 *control, int64_t *status);
void lstr_read_specfile_q(struct lstr_control_type_q *control, char *specfile);
void lstr_read_specfile_q_64(struct lstr_control_type_q_64 *control, char *specfile);
void lstr_import_control_q(struct lstr_control_type_q *control, void **data, int32_t *status);
void lstr_import_control_q_64(struct lstr_control_type_q_64 *control, void **data, int64_t *status);
void lstr_solve_problem_q(void **data, int32_t *status, int32_t m, int32_t n, __float128 radius, __float128 *x, __float128 *u, __float128 *v);
void lstr_solve_problem_q_64(void **data, int64_t *status, int64_t m, int64_t n, __float128 radius, __float128 *x, __float128 *u, __float128 *v);
void lstr_information_q(void **data, struct lstr_inform_type_q *inform, int32_t *status);
void lstr_information_q_64(void **data, struct lstr_inform_type_q_64 *inform, int64_t *status);
void lstr_terminate_q(void **data, struct lstr_control_type_q *control, struct lstr_inform_type_q *inform);
void lstr_terminate_q_64(void **data, struct lstr_control_type_q_64 *control, struct lstr_inform_type_q_64 *inform);

// C interface for NODEND
struct nodend_time_type_q {
    __float128 total;
    __float128 metis;
    __float128 clock_total;
    __float128 clock_metis;
};

struct nodend_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    char version[4];
    struct nodend_time_type_q time;
};

struct nodend_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    char version[4];
    struct nodend_time_type_q time;
};

void nodend_initialize_q(void **data, struct nodend_control_type *control, int32_t *status);
void nodend_initialize_q_64(void **data, struct nodend_control_type_64 *control, int64_t *status);
void nodend_read_specfile_q(struct nodend_control_type *control, char *specfile);
void nodend_read_specfile_q_64(struct nodend_control_type_64 *control, char *specfile);
void nodend_order_q(struct nodend_control_type *control, void **data, int32_t *status, int32_t n, int32_t *perm, char *A_type, int32_t ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void nodend_order_q_64(struct nodend_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t *perm, char *A_type, int64_t ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void nodend_information_q(void **data, struct nodend_inform_type_q *inform, int32_t *status);
void nodend_information_q_64(void **data, struct nodend_inform_type_q_64 *inform, int64_t *status);
void nodend_terminate_q(void **data);
void nodend_terminate_q_64(void **data);

// C interface for PRESOLVE
struct presolve_control_type_q {
    bool f_indexing;
    int32_t termination;
    int32_t max_nbr_transforms;
    int32_t max_nbr_passes;
    __float128 c_accuracy;
    __float128 z_accuracy;
    __float128 infinity;
    int32_t out;
    int32_t errout;
    int32_t print_level;
    bool dual_transformations;
    bool redundant_xc;
    int32_t primal_constraints_freq;
    int32_t dual_constraints_freq;
    int32_t singleton_columns_freq;
    int32_t doubleton_columns_freq;
    int32_t unc_variables_freq;
    int32_t dependent_variables_freq;
    int32_t sparsify_rows_freq;
    int32_t max_fill;
    int32_t transf_file_nbr;
    int32_t transf_buffer_size;
    int32_t transf_file_status;
    char transf_file_name[31];
    int32_t y_sign;
    int32_t inactive_y;
    int32_t z_sign;
    int32_t inactive_z;
    int32_t final_x_bounds;
    int32_t final_z_bounds;
    int32_t final_c_bounds;
    int32_t final_y_bounds;
    int32_t check_primal_feasibility;
    int32_t check_dual_feasibility;
    __float128 pivot_tol;
    __float128 min_rel_improve;
    __float128 max_growth_factor;
};

struct presolve_control_type_q_64 {
    bool f_indexing;
    int64_t termination;
    int64_t max_nbr_transforms;
    int64_t max_nbr_passes;
    __float128 c_accuracy;
    __float128 z_accuracy;
    __float128 infinity;
    int64_t out;
    int64_t errout;
    int64_t print_level;
    bool dual_transformations;
    bool redundant_xc;
    int64_t primal_constraints_freq;
    int64_t dual_constraints_freq;
    int64_t singleton_columns_freq;
    int64_t doubleton_columns_freq;
    int64_t unc_variables_freq;
    int64_t dependent_variables_freq;
    int64_t sparsify_rows_freq;
    int64_t max_fill;
    int64_t transf_file_nbr;
    int64_t transf_buffer_size;
    int64_t transf_file_status;
    char transf_file_name[31];
    int64_t y_sign;
    int64_t inactive_y;
    int64_t z_sign;
    int64_t inactive_z;
    int64_t final_x_bounds;
    int64_t final_z_bounds;
    int64_t final_c_bounds;
    int64_t final_y_bounds;
    int64_t check_primal_feasibility;
    int64_t check_dual_feasibility;
    __float128 pivot_tol;
    __float128 min_rel_improve;
    __float128 max_growth_factor;
};

void presolve_initialize_q(void **data, struct presolve_control_type_q *control, int32_t *status);
void presolve_initialize_q_64(void **data, struct presolve_control_type_q_64 *control, int64_t *status);
void presolve_read_specfile_q(struct presolve_control_type_q *control, char *specfile);
void presolve_read_specfile_q_64(struct presolve_control_type_q_64 *control, char *specfile);
void presolve_import_problem_q(struct presolve_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, __float128 *H_val, __float128 *g, __float128 f, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, int32_t *n_out, int32_t *m_out, int32_t *H_ne_out, int32_t *A_ne_out);
void presolve_import_problem_q_64(struct presolve_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, __float128 *H_val, __float128 *g, __float128 f, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, int64_t *n_out, int64_t *m_out, int64_t *H_ne_out, int64_t *A_ne_out);
void presolve_transform_problem_q(void **data, int32_t *status, int32_t n, int32_t m, int32_t H_ne, int32_t *H_col, int32_t *H_ptr, __float128 *H_val, __float128 *g, __float128 *f, int32_t A_ne, int32_t *A_col, int32_t *A_ptr, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *y_l, __float128 *y_u, __float128 *z_l, __float128 *z_u);
void presolve_transform_problem_q_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t H_ne, int64_t *H_col, int64_t *H_ptr, __float128 *H_val, __float128 *g, __float128 *f, int64_t A_ne, int64_t *A_col, int64_t *A_ptr, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *y_l, __float128 *y_u, __float128 *z_l, __float128 *z_u);
void presolve_restore_solution_q(void **data, int32_t *status, int32_t n_in, int32_t m_in, __float128 *x_in, __float128 *c_in, __float128 *y_in, __float128 *z_in, int32_t n, int32_t m, __float128 *x, __float128 *c, __float128 *y, __float128 *z);
void presolve_restore_solution_q_64(void **data, int64_t *status, int64_t n_in, int64_t m_in, __float128 *x_in, __float128 *c_in, __float128 *y_in, __float128 *z_in, int64_t n, int64_t m, __float128 *x, __float128 *c, __float128 *y, __float128 *z);
void presolve_information_q(void **data, struct presolve_inform_type *inform, int32_t *status);
void presolve_information_q_64(void **data, struct presolve_inform_type_64 *inform, int64_t *status);
void presolve_terminate_q(void **data, struct presolve_control_type_q *control, struct presolve_inform_type *inform);
void presolve_terminate_q_64(void **data, struct presolve_control_type_q_64 *control, struct presolve_inform_type_64 *inform);

// C interface for ROOTS
struct roots_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    __float128 tol;
    __float128 zero_coef;
    __float128 zero_f;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct roots_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    __float128 tol;
    __float128 zero_coef;
    __float128 zero_f;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

void roots_initialize_q(void **data, struct roots_control_type_q *control, int32_t *status);
void roots_initialize_q_64(void **data, struct roots_control_type_q_64 *control, int64_t *status);
void roots_information_q(void **data, struct roots_inform_type *inform, int32_t *status);
void roots_information_q_64(void **data, struct roots_inform_type_64 *inform, int64_t *status);
void roots_terminate_q(void **data, struct roots_control_type_q *control, struct roots_inform_type *inform);
void roots_terminate_q_64(void **data, struct roots_control_type_q_64 *control, struct roots_inform_type_64 *inform);

// C interface for RPD
void rpd_initialize_q(void **data, struct rpd_control_type *control, int32_t *status);
void rpd_initialize_q_64(void **data, struct rpd_control_type_64 *control, int64_t *status);
void rpd_get_stats_q(char *qplib_file, int32_t qplib_file_len, struct rpd_control_type *control, void **data, int32_t *status, char *p_type, int32_t *n, int32_t *m, int32_t *h_ne, int32_t *a_ne, int32_t *h_c_ne);
void rpd_get_stats_q_64(char *qplib_file, int64_t qplib_file_len, struct rpd_control_type_64 *control, void **data, int64_t *status, char *p_type, int64_t *n, int64_t *m, int64_t *h_ne, int64_t *a_ne, int64_t *h_c_ne);
void rpd_get_g_q(void **data, int32_t *status, int32_t n, __float128 *g);
void rpd_get_g_q_64(void **data, int64_t *status, int64_t n, __float128 *g);
void rpd_get_f_q(void **data, int32_t *status, __float128 *f);
void rpd_get_f_q_64(void **data, int64_t *status, __float128 *f);
void rpd_get_xlu_q(void **data, int32_t *status, int32_t n, __float128 *x_l, __float128 *x_u);
void rpd_get_xlu_q_64(void **data, int64_t *status, int64_t n, __float128 *x_l, __float128 *x_u);
void rpd_get_clu_q(void **data, int32_t *status, int32_t m, __float128 *c_l, __float128 *c_u);
void rpd_get_clu_q_64(void **data, int64_t *status, int64_t m, __float128 *c_l, __float128 *c_u);
void rpd_get_h_q(void **data, int32_t *status, int32_t h_ne, int32_t *h_row, int32_t *h_col, __float128 *h_val);
void rpd_get_h_q_64(void **data, int64_t *status, int64_t h_ne, int64_t *h_row, int64_t *h_col, __float128 *h_val);
void rpd_get_a_q(void **data, int32_t *status, int32_t a_ne, int32_t *a_row, int32_t *a_col, __float128 *a_val);
void rpd_get_a_q_64(void **data, int64_t *status, int64_t a_ne, int64_t *a_row, int64_t *a_col, __float128 *a_val);
void rpd_get_h_c_q(void **data, int32_t *status, int32_t h_c_ne, int32_t *h_c_ptr, int32_t *h_c_row, int32_t *h_c_col, __float128 *h_c_val);
void rpd_get_h_c_q_64(void **data, int64_t *status, int64_t h_c_ne, int64_t *h_c_ptr, int64_t *h_c_row, int64_t *h_c_col, __float128 *h_c_val);
void rpd_get_x_type_q(void **data, int32_t *status, int32_t n, int32_t *x_type);
void rpd_get_x_type_q_64(void **data, int64_t *status, int64_t n, int64_t *x_type);
void rpd_get_x_q(void **data, int32_t *status, int32_t n, __float128 *x);
void rpd_get_x_q_64(void **data, int64_t *status, int64_t n, __float128 *x);
void rpd_get_y_q(void **data, int32_t *status, int32_t m, __float128 *y);
void rpd_get_y_q_64(void **data, int64_t *status, int64_t m, __float128 *y);
void rpd_get_z_q(void **data, int32_t *status, int32_t n, __float128 *z);
void rpd_get_z_q_64(void **data, int64_t *status, int64_t n, __float128 *z);
void rpd_information_q(void **data, struct rpd_inform_type *inform, int32_t *status);
void rpd_information_q_64(void **data, struct rpd_inform_type_64 *inform, int64_t *status);
void rpd_terminate_q(void **data, struct rpd_control_type *control, struct rpd_inform_type *inform);
void rpd_terminate_q_64(void **data, struct rpd_control_type_64 *control, struct rpd_inform_type_64 *inform);

// C interface for SCU
void scu_initialize_q(void **data, struct scu_control_type *control, int32_t *status);
void scu_initialize_q_64(void **data, struct scu_control_type *control, int64_t *status);
void scu_information_q(void **data, struct scu_inform_type *inform, int32_t *status);
void scu_information_q_64(void **data, struct scu_inform_type_64 *inform, int64_t *status);
void scu_terminate_q(void **data, struct scu_control_type *control, struct scu_inform_type *inform);
void scu_terminate_q_64(void **data, struct scu_control_type *control, struct scu_inform_type_64 *inform);

// C interface for SEC
struct sec_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    __float128 h_initial;
    __float128 update_skip_tol;
    char prefix[31];
};

struct sec_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    __float128 h_initial;
    __float128 update_skip_tol;
    char prefix[31];
};

void sec_initialize_q(struct sec_control_type_q *control, int32_t *status);
void sec_initialize_q_64(struct sec_control_type_q_64 *control, int64_t *status);
void sec_information_q(void **data, struct sec_inform_type *inform, int32_t *status);
void sec_information_q_64(void **data, struct sec_inform_type_64 *inform, int64_t *status);
void sec_terminate_q(void **data, struct sec_control_type_q *control, struct sec_inform_type *inform);
void sec_terminate_q_64(void **data, struct sec_control_type_q_64 *control, struct sec_inform_type_64 *inform);

// C interface for SHA
struct sha_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    int32_t max_degree;
    int32_t differences_needed;
    int32_t max_reduced_degree;
    int32_t approximation_algorithm_used;
    int32_t bad_row;
    __float128 max_off_diagonal_difference;
    char bad_alloc[81];
};

struct sha_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t max_degree;
    int64_t differences_needed;
    int64_t max_reduced_degree;
    int64_t approximation_algorithm_used;
    int64_t bad_row;
    __float128 max_off_diagonal_difference;
    char bad_alloc[81];
};

void sha_initialize_q(void **data, struct sha_control_type *control, int32_t *status);
void sha_initialize_q_64(void **data, struct sha_control_type_64 *control, int64_t *status);
void sha_reset_control_q(struct sha_control_type *control, void **data, int32_t *status);
void sha_reset_control_q_64(struct sha_control_type_64 *control, void **data, int64_t *status);
void sha_analyse_matrix_q(struct sha_control_type *control, void **data, int32_t *status, int32_t n, int32_t ne, int32_t *row, int32_t *col, int32_t *m);
void sha_analyse_matrix_q_64(struct sha_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t ne, int64_t *row, int64_t *col, int64_t *m);
void sha_recover_matrix_q(void **data, int32_t *status, int32_t ne, int32_t m, int32_t ls1, int32_t ls2, __float128 **strans, int32_t ly1, int32_t ly2, __float128 **ytrans, __float128 *val, int32_t *precedence);
void sha_recover_matrix_q_64(void **data, int64_t *status, int64_t ne, int64_t m, int64_t ls1, int64_t ls2, __float128 **strans, int64_t ly1, int64_t ly2, __float128 **ytrans, __float128 *val, int64_t *precedence);
void sha_information_q(void **data, struct sha_inform_type_q *inform, int32_t *status);
void sha_information_q_64(void **data, struct sha_inform_type_q_64 *inform, int64_t *status);
void sha_terminate_q(void **data, struct sha_control_type *control, struct sha_inform_type_q *inform);
void sha_terminate_q_64(void **data, struct sha_control_type_64 *control, struct sha_inform_type_q_64 *inform);

// C interface for SILS
struct sils_control_type_q {
    bool f_indexing;
    int32_t ICNTL[30];
    int32_t lp;
    int32_t wp;
    int32_t mp;
    int32_t sp;
    int32_t ldiag;
    int32_t la;
    int32_t liw;
    int32_t maxla;
    int32_t maxliw;
    int32_t pivoting;
    int32_t nemin;
    int32_t factorblocking;
    int32_t solveblocking;
    int32_t thresh;
    int32_t ordering;
    int32_t scaling;
    __float128 CNTL[5];
    __float128 multiplier;
    __float128 reduce;
    __float128 u;
    __float128 static_tolerance;
    __float128 static_level;
    __float128 tolerance;
    __float128 convergence;
};

struct sils_control_type_q_64 {
    bool f_indexing;
    int64_t ICNTL[30];
    int64_t lp;
    int64_t wp;
    int64_t mp;
    int64_t sp;
    int64_t ldiag;
    int64_t la;
    int64_t liw;
    int64_t maxla;
    int64_t maxliw;
    int64_t pivoting;
    int64_t nemin;
    int64_t factorblocking;
    int64_t solveblocking;
    int64_t thresh;
    int64_t ordering;
    int64_t scaling;
    __float128 CNTL[5];
    __float128 multiplier;
    __float128 reduce;
    __float128 u;
    __float128 static_tolerance;
    __float128 static_level;
    __float128 tolerance;
    __float128 convergence;
};

struct sils_ainfo_type_q {
    int32_t flag;
    int32_t more;
    int32_t nsteps;
    int32_t nrltot;
    int32_t nirtot;
    int32_t nrlnec;
    int32_t nirnec;
    int32_t nrladu;
    int32_t niradu;
    int32_t ncmpa;
    int32_t oor;
    int32_t dup;
    int32_t maxfrt;
    int32_t stat;
    int32_t faulty;
    __float128 opsa;
    __float128 opse;
};

struct sils_ainfo_type_q_64 {
    int64_t flag;
    int64_t more;
    int64_t nsteps;
    int64_t nrltot;
    int64_t nirtot;
    int64_t nrlnec;
    int64_t nirnec;
    int64_t nrladu;
    int64_t niradu;
    int64_t ncmpa;
    int64_t oor;
    int64_t dup;
    int64_t maxfrt;
    int64_t stat;
    int64_t faulty;
    __float128 opsa;
    __float128 opse;
};

struct sils_finfo_type_q {
    int32_t flag;
    int32_t more;
    int32_t maxfrt;
    int32_t nebdu;
    int32_t nrlbdu;
    int32_t nirbdu;
    int32_t nrltot;
    int32_t nirtot;
    int32_t nrlnec;
    int32_t nirnec;
    int32_t ncmpbr;
    int32_t ncmpbi;
    int32_t ntwo;
    int32_t neig;
    int32_t delay;
    int32_t signc;
    int32_t nstatic;
    int32_t modstep;
    int32_t rank;
    int32_t stat;
    int32_t faulty;
    int32_t step;
    __float128 opsa;
    __float128 opse;
    __float128 opsb;
    __float128 maxchange;
    __float128 smin;
    __float128 smax;
};

struct sils_finfo_type_q_64 {
    int64_t flag;
    int64_t more;
    int64_t maxfrt;
    int64_t nebdu;
    int64_t nrlbdu;
    int64_t nirbdu;
    int64_t nrltot;
    int64_t nirtot;
    int64_t nrlnec;
    int64_t nirnec;
    int64_t ncmpbr;
    int64_t ncmpbi;
    int64_t ntwo;
    int64_t neig;
    int64_t delay;
    int64_t signc;
    int64_t nstatic;
    int64_t modstep;
    int64_t rank;
    int64_t stat;
    int64_t faulty;
    int64_t step;
    __float128 opsa;
    __float128 opse;
    __float128 opsb;
    __float128 maxchange;
    __float128 smin;
    __float128 smax;
};

struct sils_sinfo_type_q {
    int32_t flag;
    int32_t stat;
    __float128 cond;
    __float128 cond2;
    __float128 berr;
    __float128 berr2;
    __float128 error;
};

struct sils_sinfo_type_q_64 {
    int64_t flag;
    int64_t stat;
    __float128 cond;
    __float128 cond2;
    __float128 berr;
    __float128 berr2;
    __float128 error;
};

void sils_initialize_q(void **data, struct sils_control_type_q *control, int32_t *status);
void sils_initialize_q_64(void **data, struct sils_control_type_q_64 *control, int64_t *status);
void sils_read_specfile_q(struct sils_control_type_q *control, char *specfile);
void sils_read_specfile_q_64(struct sils_control_type_q_64 *control, char *specfile);
void sils_import_q(struct sils_control_type_q *control, void **data, int32_t *status);
void sils_import_q_64(struct sils_control_type_q_64 *control, void **data, int64_t *status);
void sils_reset_control_q(struct sils_control_type_q *control, void **data, int32_t *status);
void sils_reset_control_q_64(struct sils_control_type_q_64 *control, void **data, int64_t *status);
void sils_information_q(void **data, struct sils_ainfo_type_q *ainfo, struct sils_finfo_type_q *finfo, struct sils_sinfo_type_q *sinfo, int32_t *status);
void sils_information_q_64(void **data, struct sils_ainfo_type_q_64 *ainfo, struct sils_finfo_type_q_64 *finfo, struct sils_sinfo_type_q_64 *sinfo, int64_t *status);
void sils_finalize_q(void **data, struct sils_control_type_q *control, int32_t *status);
void sils_finalize_q_64(void **data, struct sils_control_type_q_64 *control, int64_t *status);

// C interface for UGO
struct ugo_control_type_q {
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t initial_points;
    int32_t storage_increment;
    int32_t buffer;
    int32_t lipschitz_estimate_used;
    int32_t next_interval_selection;
    int32_t refine_with_newton;
    int32_t alive_unit;
    char alive_file[31];
    __float128 stop_length;
    __float128 small_g_for_newton;
    __float128 small_g;
    __float128 obj_sufficient;
    __float128 global_lipschitz_constant;
    __float128 reliability_parameter;
    __float128 lipschitz_lower_bound;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool second_derivative_available;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct ugo_control_type_q_64 {
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t initial_points;
    int64_t storage_increment;
    int64_t buffer;
    int64_t lipschitz_estimate_used;
    int64_t next_interval_selection;
    int64_t refine_with_newton;
    int64_t alive_unit;
    char alive_file[31];
    __float128 stop_length;
    __float128 small_g_for_newton;
    __float128 small_g;
    __float128 obj_sufficient;
    __float128 global_lipschitz_constant;
    __float128 reliability_parameter;
    __float128 lipschitz_lower_bound;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool second_derivative_available;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct ugo_time_type_q {
    float total;
    __float128 clock_total;
};

struct ugo_inform_type_q {
    int32_t status;
    int32_t eval_status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    struct ugo_time_type_q time;
};

struct ugo_inform_type_q_64 {
    int64_t status;
    int64_t eval_status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    struct ugo_time_type_q time;
};

void ugo_initialize_q(void **data, struct ugo_control_type_q *control, int32_t *status);
void ugo_initialize_q_64(void **data, struct ugo_control_type_q_64 *control, int64_t *status);
void ugo_read_specfile_q(struct ugo_control_type_q *control, char *specfile);
void ugo_read_specfile_q_64(struct ugo_control_type_q_64 *control, char *specfile);
void ugo_import_q(struct ugo_control_type_q *control, void **data, int32_t *status, __float128 *x_l, __float128 *x_u);
void ugo_import_q_64(struct ugo_control_type_q_64 *control, void **data, int64_t *status, __float128 *x_l, __float128 *x_u);
void ugo_reset_control_q(struct ugo_control_type_q *control, void **data, int32_t *status);
void ugo_reset_control_q_64(struct ugo_control_type_q_64 *control, void **data, int64_t *status);
void ugo_solve_direct_q(void **data, void *userdata, int32_t *status, __float128 *x, __float128 *f, __float128 *g, __float128 *h, galahad_fgh_q *eval_fgh);
void ugo_solve_direct_q_64(void **data, void *userdata, int64_t *status, __float128 *x, __float128 *f, __float128 *g, __float128 *h, galahad_fgh_q_64 *eval_fgh);
void ugo_solve_reverse_q(void **data, int32_t *status, int32_t *eval_status, __float128 *x, __float128 *f, __float128 *g, __float128 *h);
void ugo_solve_reverse_q_64(void **data, int64_t *status, int64_t *eval_status, __float128 *x, __float128 *f, __float128 *g, __float128 *h);
void ugo_information_q(void **data, struct ugo_inform_type_q *inform, int32_t *status);
void ugo_information_q_64(void **data, struct ugo_inform_type_q_64 *inform, int64_t *status);
void ugo_terminate_q(void **data, struct ugo_control_type_q *control, struct ugo_inform_type_q *inform);
void ugo_terminate_q_64(void **data, struct ugo_control_type_q_64 *control, struct ugo_inform_type_q_64 *inform);

// C interface for SSIDS
struct ssids_control_type_q {
    int32_t array_base;
    int32_t print_level;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int32_t ordering;
    int32_t nemin;
    bool ignore_numa;
    bool use_gpu;
    bool gpu_only;
    int64_t min_gpu_work;
    float max_load_inbalance;
    float gpu_perf_coeff;
    int32_t scaling;
    int64_t small_subtree_threshold;
    int32_t cpu_block_size;
    bool action;
    int32_t pivot_method;
    __float128 small;
    __float128 u;
    struct nodend_control_type nodend_control;
    int32_t nstream;
    __float128 multiplier;
    float min_loadbalance;
    int32_t failed_pivot_method;
};

struct ssids_control_type_q_64 {
    int64_t array_base;
    int64_t print_level;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t ordering;
    int64_t nemin;
    bool ignore_numa;
    bool use_gpu;
    bool gpu_only;
    int64_t min_gpu_work;
    float max_load_inbalance;
    float gpu_perf_coeff;
    int64_t scaling;
    int64_t small_subtree_threshold;
    int64_t cpu_block_size;
    bool action;
    int64_t pivot_method;
    __float128 small;
    __float128 u;
    struct nodend_control_type_64 nodend_control;
    int64_t nstream;
    __float128 multiplier;
    float min_loadbalance;
    int64_t failed_pivot_method;
};

struct ssids_inform_type_q {
    int32_t flag;
    int32_t matrix_dup;
    int32_t matrix_missing_diag;
    int32_t matrix_outrange;
    int32_t matrix_rank;
    int32_t maxdepth;
    int32_t maxfront;
    int32_t maxsupernode;
    int32_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int32_t num_neg;
    int32_t num_sup;
    int32_t num_two;
    int32_t stat;
    int32_t cuda_error;
    int32_t cublas_error;
    struct nodend_inform_type_q nodend_inform;
    int32_t not_first_pass;
    int32_t not_second_pass;
    int32_t nparts;
    int64_t cpu_flops;
    int64_t gpu_flops;
};

struct ssids_inform_type_q_64 {
    int64_t flag;
    int64_t matrix_dup;
    int64_t matrix_missing_diag;
    int64_t matrix_outrange;
    int64_t matrix_rank;
    int64_t maxdepth;
    int64_t maxfront;
    int64_t maxsupernode;
    int64_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int64_t num_neg;
    int64_t num_sup;
    int64_t num_two;
    int64_t stat;
    int64_t cuda_error;
    int64_t cublas_error;
    struct nodend_inform_type_q_64 nodend_inform;
    int64_t not_first_pass;
    int64_t not_second_pass;
    int64_t nparts;
    int64_t cpu_flops;
    int64_t gpu_flops;
};

void spral_ssids_default_control_q(struct ssids_control_type_q *control);
void spral_ssids_default_control_q_64(struct ssids_control_type_q_64 *control);
void spral_ssids_analyse_q(bool check, int32_t n, int32_t *order, int64_t *ptr, int32_t *row, __float128 *val, void **akeep, struct ssids_control_type_q *control, struct ssids_inform_type_q *inform);
void spral_ssids_analyse_q_64(bool check, int64_t n, int64_t *order, int64_t *ptr, int64_t *row, __float128 *val, void **akeep, struct ssids_control_type_q_64 *control, struct ssids_inform_type_q_64 *inform);
void spral_ssids_analyse_ptr32_q(bool check, int32_t n, int32_t *order, int32_t *ptr, int32_t *row, __float128 *val, void **akeep, struct ssids_control_type_q *control, struct ssids_inform_type_q *inform);
void spral_ssids_analyse_ptr32_q_64(bool check, int64_t n, int64_t *order, int64_t *ptr, int64_t *row, __float128 *val, void **akeep, struct ssids_control_type_q_64 *control, struct ssids_inform_type_q_64 *inform);
void spral_ssids_analyse_coord_q(int32_t n, int32_t *order, int64_t ne, int32_t *row, int32_t *col, __float128 *val, void **akeep, struct ssids_control_type_q *control, struct ssids_inform_type_q *inform);
void spral_ssids_analyse_coord_q_64(int64_t n, int64_t *order, int64_t ne, int64_t *row, int64_t *col, __float128 *val, void **akeep, struct ssids_control_type_q_64 *control, struct ssids_inform_type_q_64 *inform);
void spral_ssids_factor_q(bool posdef, int64_t *ptr, int32_t *row, __float128 *val, __float128 *scale, void *akeep, void **fkeep, struct ssids_control_type_q *control, struct ssids_inform_type_q *inform);
void spral_ssids_factor_q_64(bool posdef, int64_t *ptr, int64_t *row, __float128 *val, __float128 *scale, void *akeep, void **fkeep, struct ssids_control_type_q_64 *control, struct ssids_inform_type_q_64 *inform);
void spral_ssids_factor_ptr32_q(bool posdef, int32_t *ptr, int32_t *row, __float128 *val, __float128 *scale, void *akeep, void **fkeep, struct ssids_control_type_q *control, struct ssids_inform_type_q *inform);
void spral_ssids_factor_ptr32_q_64(bool posdef, int64_t *ptr, int64_t *row, __float128 *val, __float128 *scale, void *akeep, void **fkeep, struct ssids_control_type_q_64 *control, struct ssids_inform_type_q_64 *inform);
void spral_ssids_solve1_q(int32_t job, __float128 *x1, void *akeep, void *fkeep, struct ssids_control_type_q *control, struct ssids_inform_type_q *inform);
void spral_ssids_solve1_q_64(int64_t job, __float128 *x1, void *akeep, void *fkeep, struct ssids_control_type_q_64 *control, struct ssids_inform_type_q_64 *inform);
void spral_ssids_solve_q(int32_t job, int32_t nrhs, __float128 *x, int32_t ldx, void *akeep, void *fkeep, struct ssids_control_type_q *control, struct ssids_inform_type_q *inform);
void spral_ssids_solve_q_64(int64_t job, int64_t nrhs, __float128 *x, int64_t ldx, void *akeep, void *fkeep, struct ssids_control_type_q_64 *control, struct ssids_inform_type_q_64 *inform);
int32_t spral_ssids_free_akeep_q(void **akeep);
int64_t spral_ssids_free_akeep_q_64(void **akeep);
int32_t spral_ssids_free_fkeep_q(void **fkeep);
int64_t spral_ssids_free_fkeep_q_64(void **fkeep);
int32_t spral_ssids_free_q(void **akeep, void **fkeep);
int64_t spral_ssids_free_q_64(void **akeep, void **fkeep);
void spral_ssids_enquire_posdef_q(void *akeep, void *fkeep, struct ssids_control_type_q *control, struct ssids_inform_type_q *inform, __float128 *d);
void spral_ssids_enquire_posdef_q_64(void *akeep, void *fkeep, struct ssids_control_type_q_64 *control, struct ssids_inform_type_q_64 *inform, __float128 *d);
void spral_ssids_enquire_indef_q(void *akeep, void *fkeep, struct ssids_control_type_q *control, struct ssids_inform_type_q *inform, int32_t *piv_order, __float128 *d);
void spral_ssids_enquire_indef_q_64(void *akeep, void *fkeep, struct ssids_control_type_q_64 *control, struct ssids_inform_type_q_64 *inform, int64_t *piv_order, __float128 *d);
void spral_ssids_alter_q(__float128 *d, void *akeep, void *fkeep, struct ssids_control_type_q *control, struct ssids_inform_type_q *inform);
void spral_ssids_alter_q_64(__float128 *d, void *akeep, void *fkeep, struct ssids_control_type_q_64 *control, struct ssids_inform_type_q_64 *inform);

// C interface for SLS
struct sls_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t warning;
    int32_t out;
    int32_t statistics;
    int32_t print_level;
    int32_t print_level_solver;
    int32_t bits;
    int32_t block_size_kernel;
    int32_t block_size_elimination;
    int32_t blas_block_size_factorize;
    int32_t blas_block_size_solve;
    int32_t node_amalgamation;
    int32_t initial_pool_size;
    int32_t min_real_factor_size;
    int32_t min_integer_factor_size;
    int64_t max_real_factor_size;
    int64_t max_integer_factor_size;
    int64_t max_in_core_store;
    __float128 array_increase_factor;
    __float128 array_decrease_factor;
    int32_t pivot_control;
    int32_t ordering;
    int32_t full_row_threshold;
    int32_t row_search_indefinite;
    int32_t scaling;
    int32_t scale_maxit;
    __float128 scale_thresh;
    __float128 relative_pivot_tolerance;
    __float128 minimum_pivot_tolerance;
    __float128 absolute_pivot_tolerance;
    __float128 zero_tolerance;
    __float128 zero_pivot_tolerance;
    __float128 negative_pivot_tolerance;
    __float128 static_pivot_tolerance;
    __float128 static_level_switch;
    __float128 consistency_tolerance;
    int32_t max_iterative_refinements;
    __float128 acceptable_residual_relative;
    __float128 acceptable_residual_absolute;
    bool multiple_rhs;
    bool generate_matrix_file;
    int32_t matrix_file_device;
    char matrix_file_name[31];
    char out_of_core_directory[401];
    char out_of_core_integer_factor_file[401];
    char out_of_core_real_factor_file[401];
    char out_of_core_real_work_file[401];
    char out_of_core_indefinite_file[401];
    char out_of_core_restart_file[501];
    char prefix[31];
    struct nodend_control_type nodend_control;
};

struct sls_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t warning;
    int64_t out;
    int64_t statistics;
    int64_t print_level;
    int64_t print_level_solver;
    int64_t bits;
    int64_t block_size_kernel;
    int64_t block_size_elimination;
    int64_t blas_block_size_factorize;
    int64_t blas_block_size_solve;
    int64_t node_amalgamation;
    int64_t initial_pool_size;
    int64_t min_real_factor_size;
    int64_t min_integer_factor_size;
    int64_t max_real_factor_size;
    int64_t max_integer_factor_size;
    int64_t max_in_core_store;
    __float128 array_increase_factor;
    __float128 array_decrease_factor;
    int64_t pivot_control;
    int64_t ordering;
    int64_t full_row_threshold;
    int64_t row_search_indefinite;
    int64_t scaling;
    int64_t scale_maxit;
    __float128 scale_thresh;
    __float128 relative_pivot_tolerance;
    __float128 minimum_pivot_tolerance;
    __float128 absolute_pivot_tolerance;
    __float128 zero_tolerance;
    __float128 zero_pivot_tolerance;
    __float128 negative_pivot_tolerance;
    __float128 static_pivot_tolerance;
    __float128 static_level_switch;
    __float128 consistency_tolerance;
    int64_t max_iterative_refinements;
    __float128 acceptable_residual_relative;
    __float128 acceptable_residual_absolute;
    bool multiple_rhs;
    bool generate_matrix_file;
    int64_t matrix_file_device;
    char matrix_file_name[31];
    char out_of_core_directory[401];
    char out_of_core_integer_factor_file[401];
    char out_of_core_real_factor_file[401];
    char out_of_core_real_work_file[401];
    char out_of_core_indefinite_file[401];
    char out_of_core_restart_file[501];
    char prefix[31];
    struct nodend_control_type_64 nodend_control;
};

struct sls_time_type_q {
    __float128 total;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 order_external;
    __float128 analyse_external;
    __float128 factorize_external;
    __float128 solve_external;
    __float128 clock_total;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
    __float128 clock_order_external;
    __float128 clock_analyse_external;
    __float128 clock_factorize_external;
    __float128 clock_solve_external;
};

struct sls_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t more_info;
    int32_t entries;
    int32_t out_of_range;
    int32_t duplicates;
    int32_t upper;
    int32_t missing_diagonals;
    int32_t max_depth_assembly_tree;
    int32_t nodes_assembly_tree;
    int64_t real_size_desirable;
    int64_t integer_size_desirable;
    int64_t real_size_necessary;
    int64_t integer_size_necessary;
    int64_t real_size_factors;
    int64_t integer_size_factors;
    int64_t entries_in_factors;
    int32_t max_task_pool_size;
    int32_t max_front_size;
    int32_t compresses_real;
    int32_t compresses_integer;
    int32_t two_by_two_pivots;
    int32_t semi_bandwidth;
    int32_t delayed_pivots;
    int32_t pivot_sign_changes;
    int32_t static_pivots;
    int32_t first_modified_pivot;
    int32_t rank;
    int32_t negative_eigenvalues;
    int32_t num_zero;
    int32_t iterative_refinements;
    int64_t flops_assembly;
    int64_t flops_elimination;
    int64_t flops_blas;
    __float128 largest_modified_pivot;
    __float128 minimum_scaling_factor;
    __float128 maximum_scaling_factor;
    __float128 condition_number_1;
    __float128 condition_number_2;
    __float128 backward_error_1;
    __float128 backward_error_2;
    __float128 forward_error;
    bool alternative;
    char solver[21];
    struct sls_time_type_q time;
    struct sils_ainfo_type_q sils_ainfo;
    struct sils_finfo_type_q sils_finfo;
    struct sils_sinfo_type_q sils_sinfo;
    struct ma57_ainfo_q ma57_ainfo;
    struct ma57_finfo_q ma57_finfo;
    struct ma57_sinfo_q ma57_sinfo;
    struct ma77_info_q ma77_info;
    struct ma86_info_q ma86_info;
    struct ma87_info_q ma87_info;
    struct ma97_info_q ma97_info;
    struct ssids_inform_type_q ssids_inform;
    struct nodend_inform_type_q nodend_inform;
    int32_t mc61_info[10];
    __float128 mc61_rinfo[15];
    struct mc64_info mc64_info;
    struct mc68_info mc68_info;
    int32_t mc77_info[10];
    __float128 mc77_rinfo[10];
    int32_t mumps_error;
    int32_t mumps_info[80];
    __float128 mumps_rinfo[40];
    int32_t pardiso_error;
    int32_t pardiso_IPARM[64];
    __float128 pardiso_DPARM[64];
    int32_t mkl_pardiso_error;
    int32_t mkl_pardiso_IPARM[64];
    int32_t pastix_info;
    int32_t wsmp_error;
    int32_t wsmp_iparm[64];
    __float128 wsmp_dparm[64];
    int32_t mpi_ierr;
    int32_t lapack_error;
};

struct sls_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t more_info;
    int64_t entries;
    int64_t out_of_range;
    int64_t duplicates;
    int64_t upper;
    int64_t missing_diagonals;
    int64_t max_depth_assembly_tree;
    int64_t nodes_assembly_tree;
    int64_t real_size_desirable;
    int64_t integer_size_desirable;
    int64_t real_size_necessary;
    int64_t integer_size_necessary;
    int64_t real_size_factors;
    int64_t integer_size_factors;
    int64_t entries_in_factors;
    int64_t max_task_pool_size;
    int64_t max_front_size;
    int64_t compresses_real;
    int64_t compresses_integer;
    int64_t two_by_two_pivots;
    int64_t semi_bandwidth;
    int64_t delayed_pivots;
    int64_t pivot_sign_changes;
    int64_t static_pivots;
    int64_t first_modified_pivot;
    int64_t rank;
    int64_t negative_eigenvalues;
    int64_t num_zero;
    int64_t iterative_refinements;
    int64_t flops_assembly;
    int64_t flops_elimination;
    int64_t flops_blas;
    __float128 largest_modified_pivot;
    __float128 minimum_scaling_factor;
    __float128 maximum_scaling_factor;
    __float128 condition_number_1;
    __float128 condition_number_2;
    __float128 backward_error_1;
    __float128 backward_error_2;
    __float128 forward_error;
    bool alternative;
    char solver[21];
    struct sls_time_type_q time;
    struct sils_ainfo_type_q_64 sils_ainfo;
    struct sils_finfo_type_q_64 sils_finfo;
    struct sils_sinfo_type_q_64 sils_sinfo;
    struct ma57_ainfo_q_64 ma57_ainfo;
    struct ma57_finfo_q_64 ma57_finfo;
    struct ma57_sinfo_q_64 ma57_sinfo;
    struct ma77_info_q_64 ma77_info;
    struct ma86_info_q_64 ma86_info;
    struct ma87_info_q_64 ma87_info;
    struct ma97_info_q_64 ma97_info;
    struct ssids_inform_type_q_64 ssids_inform;
    struct nodend_inform_type_q_64 nodend_inform;
    int64_t mc61_info[10];
    __float128 mc61_rinfo[15];
    struct mc64_info_64 mc64_info;
    struct mc68_info_64 mc68_info;
    int64_t mc77_info[10];
    __float128 mc77_rinfo[10];
    int64_t mumps_error;
    int64_t mumps_info[80];
    __float128 mumps_rinfo[40];
    int64_t pardiso_error;
    int64_t pardiso_IPARM[64];
    __float128 pardiso_DPARM[64];
    int64_t mkl_pardiso_error;
    int64_t mkl_pardiso_IPARM[64];
    int64_t pastix_info;
    int64_t wsmp_error;
    int64_t wsmp_iparm[64];
    __float128 wsmp_dparm[64];
    int64_t mpi_ierr;
    int64_t lapack_error;
};

void sls_initialize_q(char *solver, void **data, struct sls_control_type_q *control, int32_t *status);
void sls_initialize_q_64(char *solver, void **data, struct sls_control_type_q_64 *control, int64_t *status);
void sls_read_specfile_q(struct sls_control_type_q *control, char *specfile);
void sls_read_specfile_q_64(struct sls_control_type_q_64 *control, char *specfile);
void sls_analyse_matrix_q(struct sls_control_type_q *control, void **data, int32_t *status, int32_t n, char *type, int32_t ne, int32_t *row, int32_t *col, int32_t *ptr);
void sls_analyse_matrix_q_64(struct sls_control_type_q_64 *control, void **data, int64_t *status, int64_t n, char *type, int64_t ne, int64_t *row, int64_t *col, int64_t *ptr);
void sls_reset_control_q(struct sls_control_type_q *control, void **data, int32_t *status);
void sls_reset_control_q_64(struct sls_control_type_q_64 *control, void **data, int64_t *status);
void sls_factorize_matrix_q(void **data, int32_t *status, int32_t ne, __float128 *val);
void sls_factorize_matrix_q_64(void **data, int64_t *status, int64_t ne, __float128 *val);
void sls_solve_system_q(void **data, int32_t *status, int32_t n, __float128 *sol);
void sls_solve_system_q_64(void **data, int64_t *status, int64_t n, __float128 *sol);
void sls_partial_solve_system_q(char *part, void **data, int32_t *status, int32_t n, __float128 *sol);
void sls_partial_solve_system_q_64(char *part, void **data, int64_t *status, int64_t n, __float128 *sol);
void sls_information_q(void **data, struct sls_inform_type_q *inform, int32_t *status);
void sls_information_q_64(void **data, struct sls_inform_type_q_64 *inform, int64_t *status);
void sls_terminate_q(void **data, struct sls_control_type_q *control, struct sls_inform_type_q *inform);
void sls_terminate_q_64(void **data, struct sls_control_type_q_64 *control, struct sls_inform_type_q_64 *inform);

// C interface for RQS
struct rqs_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t problem;
    int32_t print_level;
    int32_t dense_factorization;
    int32_t new_h;
    int32_t new_m;
    int32_t new_a;
    int32_t max_factorizations;
    int32_t inverse_itmax;
    int32_t taylor_max_degree;
    __float128 initial_multiplier;
    __float128 lower;
    __float128 upper;
    __float128 stop_normal;
    __float128 stop_hard;
    __float128 start_invit_tol;
    __float128 start_invitmax_tol;
    bool use_initial_multiplier;
    bool initialize_approx_eigenvector;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q sls_control;
    struct ir_control_type_q ir_control;
};

struct rqs_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t problem;
    int64_t print_level;
    int64_t dense_factorization;
    int64_t new_h;
    int64_t new_m;
    int64_t new_a;
    int64_t max_factorizations;
    int64_t inverse_itmax;
    int64_t taylor_max_degree;
    __float128 initial_multiplier;
    __float128 lower;
    __float128 upper;
    __float128 stop_normal;
    __float128 stop_hard;
    __float128 start_invit_tol;
    __float128 start_invitmax_tol;
    bool use_initial_multiplier;
    bool initialize_approx_eigenvector;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q_64 sls_control;
    struct ir_control_type_q_64 ir_control;
};

struct rqs_time_type_q {
    __float128 total;
    __float128 assemble;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_assemble;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct rqs_history_type_q {
    __float128 lambda;
    __float128 x_norm;
};

struct rqs_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    int32_t factorizations;
    int64_t max_entries_factors;
    int32_t len_history;
    __float128 obj;
    __float128 obj_regularized;
    __float128 x_norm;
    __float128 multiplier;
    __float128 pole;
    bool dense_factorization;
    bool hard_case;
    char bad_alloc[81];
    struct rqs_time_type_q time;
    struct rqs_history_type_q history[100];
    struct sls_inform_type_q sls_inform;
    struct ir_inform_type_q ir_inform;
};

struct rqs_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorizations;
    int64_t max_entries_factors;
    int64_t len_history;
    __float128 obj;
    __float128 obj_regularized;
    __float128 x_norm;
    __float128 multiplier;
    __float128 pole;
    bool dense_factorization;
    bool hard_case;
    char bad_alloc[81];
    struct rqs_time_type_q time;
    struct rqs_history_type_q history[100];
    struct sls_inform_type_q_64 sls_inform;
    struct ir_inform_type_q_64 ir_inform;
};

void rqs_initialize_q(void **data, struct rqs_control_type_q *control, int32_t *status);
void rqs_initialize_q_64(void **data, struct rqs_control_type_q_64 *control, int64_t *status);
void rqs_read_specfile_q(struct rqs_control_type_q *control, char *specfile);
void rqs_read_specfile_q_64(struct rqs_control_type_q_64 *control, char *specfile);
void rqs_import_q(struct rqs_control_type_q *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void rqs_import_q_64(struct rqs_control_type_q_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void rqs_import_m_q(void **data, int32_t *status, int32_t n, char *M_type, int32_t M_ne, int32_t *M_row, int32_t *M_col, int32_t *M_ptr);
void rqs_import_m_q_64(void **data, int64_t *status, int64_t n, char *M_type, int64_t M_ne, int64_t *M_row, int64_t *M_col, int64_t *M_ptr);
void rqs_import_a_q(void **data, int32_t *status, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void rqs_import_a_q_64(void **data, int64_t *status, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void rqs_reset_control_q(struct rqs_control_type_q *control, void **data, int32_t *status);
void rqs_reset_control_q_64(struct rqs_control_type_q_64 *control, void **data, int64_t *status);
void rqs_solve_problem_q(void **data, int32_t *status, int32_t n, __float128 power, __float128 weight, __float128 f, __float128 *c, int32_t H_ne, __float128 *H_val, __float128 *x, int32_t M_ne, __float128 *M_val, int32_t m, int32_t A_ne, __float128 *A_val, __float128 *y);
void rqs_solve_problem_q_64(void **data, int64_t *status, int64_t n, __float128 power, __float128 weight, __float128 f, __float128 *c, int64_t H_ne, __float128 *H_val, __float128 *x, int64_t M_ne, __float128 *M_val, int64_t m, int64_t A_ne, __float128 *A_val, __float128 *y);
void rqs_information_q(void **data, struct rqs_inform_type_q *inform, int32_t *status);
void rqs_information_q_64(void **data, struct rqs_inform_type_q_64 *inform, int64_t *status);
void rqs_terminate_q(void **data, struct rqs_control_type_q *control, struct rqs_inform_type_q *inform);
void rqs_terminate_q_64(void **data, struct rqs_control_type_q_64 *control, struct rqs_inform_type_q_64 *inform);

// C interface for DPS
struct dps_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t problem;
    int32_t print_level;
    int32_t new_h;
    int32_t taylor_max_degree;
    __float128 eigen_min;
    __float128 lower;
    __float128 upper;
    __float128 stop_normal;
    __float128 stop_absolute_normal;
    bool goldfarb;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q sls_control;
};

struct dps_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t problem;
    int64_t print_level;
    int64_t new_h;
    int64_t taylor_max_degree;
    __float128 eigen_min;
    __float128 lower;
    __float128 upper;
    __float128 stop_normal;
    __float128 stop_absolute_normal;
    bool goldfarb;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q_64 sls_control;
};

struct dps_time_type_q {
    __float128 total;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct dps_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    int32_t mod_1by1;
    int32_t mod_2by2;
    __float128 obj;
    __float128 obj_regularized;
    __float128 x_norm;
    __float128 multiplier;
    __float128 pole;
    bool hard_case;
    char bad_alloc[81];
    struct dps_time_type_q time;
    struct sls_inform_type_q sls_inform;
};

struct dps_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t mod_1by1;
    int64_t mod_2by2;
    __float128 obj;
    __float128 obj_regularized;
    __float128 x_norm;
    __float128 multiplier;
    __float128 pole;
    bool hard_case;
    char bad_alloc[81];
    struct dps_time_type_q time;
    struct sls_inform_type_q_64 sls_inform;
};

void dps_initialize_q(void **data, struct dps_control_type_q *control, int32_t *status);
void dps_initialize_q_64(void **data, struct dps_control_type_q_64 *control, int64_t *status);
void dps_read_specfile_q(struct dps_control_type_q *control, char *specfile);
void dps_read_specfile_q_64(struct dps_control_type_q_64 *control, char *specfile);
void dps_import_q(struct dps_control_type_q *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void dps_import_q_64(struct dps_control_type_q_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void dps_reset_control_q(struct dps_control_type_q *control, void **data, int32_t *status);
void dps_reset_control_q_64(struct dps_control_type_q_64 *control, void **data, int64_t *status);
void dps_solve_tr_problem_q(void **data, int32_t *status, int32_t n, int32_t ne, __float128 *H_val, __float128 *c, __float128 f, __float128 radius, __float128 *x);
void dps_solve_tr_problem_q_64(void **data, int64_t *status, int64_t n, int64_t ne, __float128 *H_val, __float128 *c, __float128 f, __float128 radius, __float128 *x);
void dps_solve_rq_problem_q(void **data, int32_t *status, int32_t n, int32_t ne, __float128 *H_val, __float128 *c, __float128 f, __float128 power, __float128 weight, __float128 *x);
void dps_solve_rq_problem_q_64(void **data, int64_t *status, int64_t n, int64_t ne, __float128 *H_val, __float128 *c, __float128 f, __float128 power, __float128 weight, __float128 *x);
void dps_resolve_tr_problem_q(void **data, int32_t *status, int32_t n, __float128 *c, __float128 f, __float128 radius, __float128 *x);
void dps_resolve_tr_problem_q_64(void **data, int64_t *status, int64_t n, __float128 *c, __float128 f, __float128 radius, __float128 *x);
void dps_resolve_rq_problem_q(void **data, int32_t *status, int32_t n, __float128 *c, __float128 f, __float128 power, __float128 weight, __float128 *x);
void dps_resolve_rq_problem_q_64(void **data, int64_t *status, int64_t n, __float128 *c, __float128 f, __float128 power, __float128 weight, __float128 *x);
void dps_information_q(void **data, struct dps_inform_type_q *inform, int32_t *status);
void dps_information_q_64(void **data, struct dps_inform_type_q_64 *inform, int64_t *status);
void dps_terminate_q(void **data, struct dps_control_type_q *control, struct dps_inform_type_q *inform);
void dps_terminate_q_64(void **data, struct dps_control_type_q_64 *control, struct dps_inform_type_q_64 *inform);

// C interface for PSLS
struct psls_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t preconditioner;
    int32_t semi_bandwidth;
    int32_t scaling;
    int32_t ordering;
    int32_t max_col;
    int32_t icfs_vectors;
    int32_t mi28_lsize;
    int32_t mi28_rsize;
    __float128 min_diagonal;
    bool new_structure;
    bool get_semi_bandwidth;
    bool get_norm_residual;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q sls_control;
    struct mi28_control_q mi28_control;
};

struct psls_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t preconditioner;
    int64_t semi_bandwidth;
    int64_t scaling;
    int64_t ordering;
    int64_t max_col;
    int64_t icfs_vectors;
    int64_t mi28_lsize;
    int64_t mi28_rsize;
    __float128 min_diagonal;
    bool new_structure;
    bool get_semi_bandwidth;
    bool get_norm_residual;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q_64 sls_control;
    struct mi28_control_q_64 mi28_control;
};

struct psls_time_type_q {
    float total;
    float assemble;
    float analyse;
    float factorize;
    float solve;
    float update;
    __float128 clock_total;
    __float128 clock_assemble;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
    __float128 clock_update;
};

struct psls_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    int32_t analyse_status;
    int32_t factorize_status;
    int32_t solve_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t preconditioner;
    int32_t semi_bandwidth;
    int32_t reordered_semi_bandwidth;
    int32_t out_of_range;
    int32_t duplicates;
    int32_t upper;
    int32_t missing_diagonals;
    int32_t semi_bandwidth_used;
    int32_t neg1;
    int32_t neg2;
    bool perturbed;
    __float128 fill_in_ratio;
    __float128 norm_residual;
    char bad_alloc[81];
    int32_t mc61_info[10];
    __float128 mc61_rinfo[15];
    struct psls_time_type_q time;
    struct sls_inform_type_q sls_inform;
    struct mi28_info_q mi28_info;
};

struct psls_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t analyse_status;
    int64_t factorize_status;
    int64_t solve_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t preconditioner;
    int64_t semi_bandwidth;
    int64_t reordered_semi_bandwidth;
    int64_t out_of_range;
    int64_t duplicates;
    int64_t upper;
    int64_t missing_diagonals;
    int64_t semi_bandwidth_used;
    int64_t neg1;
    int64_t neg2;
    bool perturbed;
    __float128 fill_in_ratio;
    __float128 norm_residual;
    char bad_alloc[81];
    int64_t mc61_info[10];
    __float128 mc61_rinfo[15];
    struct psls_time_type_q time;
    struct sls_inform_type_q_64 sls_inform;
    struct mi28_info_q_64 mi28_info;
};

void psls_initialize_q(void **data, struct psls_control_type_q *control, int32_t *status);
void psls_initialize_q_64(void **data, struct psls_control_type_q_64 *control, int64_t *status);
void psls_read_specfile_q(struct psls_control_type_q *control, char *specfile);
void psls_read_specfile_q_64(struct psls_control_type_q_64 *control, char *specfile);
void psls_import_q(struct psls_control_type_q *control, void **data, int32_t *status, int32_t n, char *type, int32_t ne, int32_t *row, int32_t *col, int32_t *ptr);
void psls_import_q_64(struct psls_control_type_q_64 *control, void **data, int64_t *status, int64_t n, char *type, int64_t ne, int64_t *row, int64_t *col, int64_t *ptr);
void psls_reset_control_q(struct psls_control_type_q *control, void **data, int32_t *status);
void psls_reset_control_q_64(struct psls_control_type_q_64 *control, void **data, int64_t *status);
void psls_form_preconditioner_q(void **data, int32_t *status, int32_t ne, __float128 *val);
void psls_form_preconditioner_q_64(void **data, int64_t *status, int64_t ne, __float128 *val);
void psls_form_subset_preconditioner_q(void **data, int32_t *status, int32_t ne, __float128 *val, int32_t n_sub, int32_t *sub);
void psls_form_subset_preconditioner_q_64(void **data, int64_t *status, int64_t ne, __float128 *val, int64_t n_sub, int64_t *sub);
void psls_update_preconditioner_q(void **data, int32_t *status, int32_t ne, __float128 *val, int32_t n_del, int32_t *del);
void psls_update_preconditioner_q_64(void **data, int64_t *status, int64_t ne, __float128 *val, int64_t n_del, int64_t *del);
void psls_apply_preconditioner_q(void **data, int32_t *status, int32_t n, __float128 *sol);
void psls_apply_preconditioner_q_64(void **data, int64_t *status, int64_t n, __float128 *sol);
void psls_information_q(void **data, struct psls_inform_type_q *inform, int32_t *status);
void psls_information_q_64(void **data, struct psls_inform_type_q_64 *inform, int64_t *status);
void psls_terminate_q(void **data, struct psls_control_type_q *control, struct psls_inform_type_q *inform);
void psls_terminate_q_64(void **data, struct psls_control_type_q_64 *control, struct psls_inform_type_q_64 *inform);

// C interface for ARC
struct arc_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t non_monotone;
    int32_t model;
    int32_t norm;
    int32_t semi_bandwidth;
    int32_t lbfgs_vectors;
    int32_t max_dxg;
    int32_t icfs_vectors;
    int32_t mi28_lsize;
    int32_t mi28_rsize;
    int32_t advanced_start;
    __float128 stop_g_absolute;
    __float128 stop_g_relative;
    __float128 stop_s;
    __float128 initial_weight;
    __float128 minimum_weight;
    __float128 reduce_gap;
    __float128 tiny_gap;
    __float128 large_root;
    __float128 eta_successful;
    __float128 eta_very_successful;
    __float128 eta_too_successful;
    __float128 weight_decrease_min;
    __float128 weight_decrease;
    __float128 weight_increase;
    __float128 weight_increase_max;
    __float128 obj_unbounded;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool renormalize_weight;
    bool quadratic_ratio_test;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_q rqs_control;
    struct glrt_control_type_q glrt_control;
    struct dps_control_type_q dps_control;
    struct psls_control_type_q psls_control;
    struct lms_control_type lms_control;
    struct lms_control_type lms_control_prec;
    struct sha_control_type sha_control;
};

struct arc_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t non_monotone;
    int64_t model;
    int64_t norm;
    int64_t semi_bandwidth;
    int64_t lbfgs_vectors;
    int64_t max_dxg;
    int64_t icfs_vectors;
    int64_t mi28_lsize;
    int64_t mi28_rsize;
    int64_t advanced_start;
    __float128 stop_g_absolute;
    __float128 stop_g_relative;
    __float128 stop_s;
    __float128 initial_weight;
    __float128 minimum_weight;
    __float128 reduce_gap;
    __float128 tiny_gap;
    __float128 large_root;
    __float128 eta_successful;
    __float128 eta_very_successful;
    __float128 eta_too_successful;
    __float128 weight_decrease_min;
    __float128 weight_decrease;
    __float128 weight_increase;
    __float128 weight_increase_max;
    __float128 obj_unbounded;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool renormalize_weight;
    bool quadratic_ratio_test;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_q_64 rqs_control;
    struct glrt_control_type_q_64 glrt_control;
    struct dps_control_type_q_64 dps_control;
    struct psls_control_type_q_64 psls_control;
    struct lms_control_type_64 lms_control;
    struct lms_control_type_64 lms_control_prec;
    struct sha_control_type_64 sha_control;
};

struct arc_time_type_q {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct arc_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    int32_t factorization_max;
    int32_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    __float128 factorization_average;
    __float128 obj;
    __float128 norm_g;
    __float128 weight;
    struct arc_time_type_q time;
    struct rqs_inform_type_q rqs_inform;
    struct glrt_inform_type_q glrt_inform;
    struct dps_inform_type_q dps_inform;
    struct psls_inform_type_q psls_inform;
    struct lms_inform_type_q lms_inform;
    struct lms_inform_type_q lms_inform_prec;
    struct sha_inform_type_q sha_inform;
};

struct arc_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    int64_t factorization_max;
    int64_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    __float128 factorization_average;
    __float128 obj;
    __float128 norm_g;
    __float128 weight;
    struct arc_time_type_q time;
    struct rqs_inform_type_q_64 rqs_inform;
    struct glrt_inform_type_q_64 glrt_inform;
    struct dps_inform_type_q_64 dps_inform;
    struct psls_inform_type_q_64 psls_inform;
    struct lms_inform_type_q_64 lms_inform;
    struct lms_inform_type_q_64 lms_inform_prec;
    struct sha_inform_type_q_64 sha_inform;
};

void arc_initialize_q(void **data, struct arc_control_type_q *control, int32_t *status);
void arc_initialize_q_64(void **data, struct arc_control_type_q_64 *control, int64_t *status);
void arc_read_specfile_q(struct arc_control_type_q *control, char *specfile);
void arc_read_specfile_q_64(struct arc_control_type_q_64 *control, char *specfile);
void arc_import_q(struct arc_control_type_q *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void arc_import_q_64(struct arc_control_type_q_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void arc_reset_control_q(struct arc_control_type_q *control, void **data, int32_t *status);
void arc_reset_control_q_64(struct arc_control_type_q_64 *control, void **data, int64_t *status);
void arc_solve_with_mat_q(void **data, void *userdata, int32_t *status, int32_t n, __float128 *x, __float128 *g, int32_t ne, galahad_f_q *eval_f, galahad_g_q *eval_g, galahad_h_q *eval_h, galahad_prec_q *eval_prec);
void arc_solve_with_mat_q_64(void **data, void *userdata, int64_t *status, int64_t n, __float128 *x, __float128 *g, int64_t ne, galahad_f_q_64 *eval_f, galahad_g_q_64 *eval_g, galahad_h_q_64 *eval_h, galahad_prec_q_64 *eval_prec);
void arc_solve_without_mat_q(void **data, void *userdata, int32_t *status, int32_t n, __float128 *x, __float128 *g, galahad_f_q *eval_f, galahad_g_q *eval_g, galahad_hprod_q *eval_hprod, galahad_prec_q *eval_prec);
void arc_solve_without_mat_q_64(void **data, void *userdata, int64_t *status, int64_t n, __float128 *x, __float128 *g, galahad_f_q_64 *eval_f, galahad_g_q_64 *eval_g, galahad_hprod_q_64 *eval_hprod, galahad_prec_q_64 *eval_prec);
void arc_solve_reverse_with_mat_q(void **data, int32_t *status, int32_t *eval_status, int32_t n, __float128 *x, __float128 f, __float128 *g, int32_t ne, __float128 *H_val, __float128 *u, __float128 *v);
void arc_solve_reverse_with_mat_q_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, __float128 *x, __float128 f, __float128 *g, int64_t ne, __float128 *H_val, __float128 *u, __float128 *v);
void arc_solve_reverse_without_mat_q(void **data, int32_t *status, int32_t *eval_status, int32_t n, __float128 *x, __float128 f, __float128 *g, __float128 *u, __float128 *v);
void arc_solve_reverse_without_mat_q_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, __float128 *x, __float128 f, __float128 *g, __float128 *u, __float128 *v);
void arc_information_q(void **data, struct arc_inform_type_q *inform, int32_t *status);
void arc_information_q_64(void **data, struct arc_inform_type_q_64 *inform, int64_t *status);
void arc_terminate_q(void **data, struct arc_control_type_q *control, struct arc_inform_type_q *inform);
void arc_terminate_q_64(void **data, struct arc_control_type_q_64 *control, struct arc_inform_type_q_64 *inform);

// C interface for TRS
struct trs_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t problem;
    int32_t print_level;
    int32_t dense_factorization;
    int32_t new_h;
    int32_t new_m;
    int32_t new_a;
    int32_t max_factorizations;
    int32_t inverse_itmax;
    int32_t taylor_max_degree;
    __float128 initial_multiplier;
    __float128 lower;
    __float128 upper;
    __float128 stop_normal;
    __float128 stop_absolute_normal;
    __float128 stop_hard;
    __float128 start_invit_tol;
    __float128 start_invitmax_tol;
    bool equality_problem;
    bool use_initial_multiplier;
    bool initialize_approx_eigenvector;
    bool force_Newton;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q sls_control;
    struct ir_control_type_q ir_control;
};

struct trs_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t problem;
    int64_t print_level;
    int64_t dense_factorization;
    int64_t new_h;
    int64_t new_m;
    int64_t new_a;
    int64_t max_factorizations;
    int64_t inverse_itmax;
    int64_t taylor_max_degree;
    __float128 initial_multiplier;
    __float128 lower;
    __float128 upper;
    __float128 stop_normal;
    __float128 stop_absolute_normal;
    __float128 stop_hard;
    __float128 start_invit_tol;
    __float128 start_invitmax_tol;
    bool equality_problem;
    bool use_initial_multiplier;
    bool initialize_approx_eigenvector;
    bool force_Newton;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q_64 sls_control;
    struct ir_control_type_q_64 ir_control;
};

struct trs_time_type_q {
    __float128 total;
    __float128 assemble;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_assemble;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct trs_history_type_q {
    __float128 lambda;
    __float128 x_norm;
};

struct trs_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    int32_t factorizations;
    int64_t max_entries_factors;
    int32_t len_history;
    __float128 obj;
    __float128 x_norm;
    __float128 multiplier;
    __float128 pole;
    bool dense_factorization;
    bool hard_case;
    char bad_alloc[81];
    struct trs_time_type_q time;
    struct trs_history_type_q history[100];
    struct sls_inform_type_q sls_inform;
    struct ir_inform_type_q ir_inform;
};

struct trs_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorizations;
    int64_t max_entries_factors;
    int64_t len_history;
    __float128 obj;
    __float128 x_norm;
    __float128 multiplier;
    __float128 pole;
    bool dense_factorization;
    bool hard_case;
    char bad_alloc[81];
    struct trs_time_type_q time;
    struct trs_history_type_q history[100];
    struct sls_inform_type_q_64 sls_inform;
    struct ir_inform_type_q_64 ir_inform;
};

void trs_initialize_q(void **data, struct trs_control_type_q *control, int32_t *status);
void trs_initialize_q_64(void **data, struct trs_control_type_q_64 *control, int64_t *status);
void trs_read_specfile_q(struct trs_control_type_q *control, char *specfile);
void trs_read_specfile_q_64(struct trs_control_type_q_64 *control, char *specfile);
void trs_import_q(struct trs_control_type_q *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void trs_import_q_64(struct trs_control_type_q_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void trs_import_m_q(void **data, int32_t *status, int32_t n, char *M_type, int32_t M_ne, int32_t *M_row, int32_t *M_col, int32_t *M_ptr);
void trs_import_m_q_64(void **data, int64_t *status, int64_t n, char *M_type, int64_t M_ne, int64_t *M_row, int64_t *M_col, int64_t *M_ptr);
void trs_import_a_q(void **data, int32_t *status, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void trs_import_a_q_64(void **data, int64_t *status, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void trs_reset_control_q(struct trs_control_type_q *control, void **data, int32_t *status);
void trs_reset_control_q_64(struct trs_control_type_q_64 *control, void **data, int64_t *status);
void trs_solve_problem_q(void **data, int32_t *status, int32_t n, __float128 radius, __float128 f, __float128 *c, int32_t H_ne, __float128 *H_val, __float128 *x, int32_t M_ne, __float128 *M_val, int32_t m, int32_t A_ne, __float128 *A_val, __float128 *y);
void trs_solve_problem_q_64(void **data, int64_t *status, int64_t n, __float128 radius, __float128 f, __float128 *c, int64_t H_ne, __float128 *H_val, __float128 *x, int64_t M_ne, __float128 *M_val, int64_t m, int64_t A_ne, __float128 *A_val, __float128 *y);
void trs_information_q(void **data, struct trs_inform_type_q *inform, int32_t *status);
void trs_information_q_64(void **data, struct trs_inform_type_q_64 *inform, int64_t *status);
void trs_terminate_q(void **data, struct trs_control_type_q *control, struct trs_inform_type_q *inform);
void trs_terminate_q_64(void **data, struct trs_control_type_q_64 *control, struct trs_inform_type_q_64 *inform);

// C interface for TRB
struct trb_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t more_toraldo;
    int32_t non_monotone;
    int32_t model;
    int32_t norm;
    int32_t semi_bandwidth;
    int32_t lbfgs_vectors;
    int32_t max_dxg;
    int32_t icfs_vectors;
    int32_t mi28_lsize;
    int32_t mi28_rsize;
    int32_t advanced_start;
    __float128 infinity;
    __float128 stop_pg_absolute;
    __float128 stop_pg_relative;
    __float128 stop_s;
    __float128 initial_radius;
    __float128 maximum_radius;
    __float128 stop_rel_cg;
    __float128 eta_successful;
    __float128 eta_very_successful;
    __float128 eta_too_successful;
    __float128 radius_increase;
    __float128 radius_reduce;
    __float128 radius_reduce_max;
    __float128 obj_unbounded;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool retrospective_trust_region;
    bool renormalize_radius;
    bool two_norm_tr;
    bool exact_gcp;
    bool accurate_bqp;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct trs_control_type_q trs_control;
    struct gltr_control_type_q gltr_control;
    struct psls_control_type_q psls_control;
    struct lms_control_type lms_control;
    struct lms_control_type lms_control_prec;
    struct sha_control_type sha_control;
};

struct trb_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t more_toraldo;
    int64_t non_monotone;
    int64_t model;
    int64_t norm;
    int64_t semi_bandwidth;
    int64_t lbfgs_vectors;
    int64_t max_dxg;
    int64_t icfs_vectors;
    int64_t mi28_lsize;
    int64_t mi28_rsize;
    int64_t advanced_start;
    __float128 infinity;
    __float128 stop_pg_absolute;
    __float128 stop_pg_relative;
    __float128 stop_s;
    __float128 initial_radius;
    __float128 maximum_radius;
    __float128 stop_rel_cg;
    __float128 eta_successful;
    __float128 eta_very_successful;
    __float128 eta_too_successful;
    __float128 radius_increase;
    __float128 radius_reduce;
    __float128 radius_reduce_max;
    __float128 obj_unbounded;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool retrospective_trust_region;
    bool renormalize_radius;
    bool two_norm_tr;
    bool exact_gcp;
    bool accurate_bqp;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct trs_control_type_q_64 trs_control;
    struct gltr_control_type_q_64 gltr_control;
    struct psls_control_type_q_64 psls_control;
    struct lms_control_type_64 lms_control;
    struct lms_control_type_64 lms_control_prec;
    struct sha_control_type_64 sha_control;
};

struct trb_time_type_q {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct trb_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t cg_maxit;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    int32_t n_free;
    int32_t factorization_status;
    int32_t factorization_max;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    __float128 obj;
    __float128 norm_pg;
    __float128 radius;
    struct trb_time_type_q time;
    struct trs_inform_type_q trs_inform;
    struct gltr_inform_type_q gltr_inform;
    struct psls_inform_type_q psls_inform;
    struct lms_inform_type_q lms_inform;
    struct lms_inform_type_q lms_inform_prec;
    struct sha_inform_type_q sha_inform;
};

struct trb_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t cg_maxit;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    int64_t n_free;
    int64_t factorization_status;
    int64_t factorization_max;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    __float128 obj;
    __float128 norm_pg;
    __float128 radius;
    struct trb_time_type_q time;
    struct trs_inform_type_q_64 trs_inform;
    struct gltr_inform_type_q_64 gltr_inform;
    struct psls_inform_type_q_64 psls_inform;
    struct lms_inform_type_q_64 lms_inform;
    struct lms_inform_type_q_64 lms_inform_prec;
    struct sha_inform_type_q_64 sha_inform;
};

void trb_initialize_q(void **data, struct trb_control_type_q *control, int32_t *status);
void trb_initialize_q_64(void **data, struct trb_control_type_q_64 *control, int64_t *status);
void trb_read_specfile_q(struct trb_control_type_q *control, char *specfile);
void trb_read_specfile_q_64(struct trb_control_type_q_64 *control, char *specfile);
void trb_import_q(struct trb_control_type_q *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void trb_import_q_64(struct trb_control_type_q_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void trb_reset_control_q(struct trb_control_type_q *control, void **data, int32_t *status);
void trb_reset_control_q_64(struct trb_control_type_q_64 *control, void **data, int64_t *status);
void trb_solve_with_mat_q(void **data, void *userdata, int32_t *status, int32_t n, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *g, int32_t ne, galahad_f_q *eval_f, galahad_g_q *eval_g, galahad_h_q *eval_h, galahad_prec_q *eval_prec);
void trb_solve_with_mat_q_64(void **data, void *userdata, int64_t *status, int64_t n, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *g, int64_t ne, galahad_f_q_64 *eval_f, galahad_g_q_64 *eval_g, galahad_h_q_64 *eval_h, galahad_prec_q_64 *eval_prec);
void trb_solve_without_mat_q(void **data, void *userdata, int32_t *status, int32_t n, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *g, galahad_f_q *eval_f, galahad_g_q *eval_g, galahad_hprod_q *eval_hprod, galahad_shprod_q *eval_shprod, galahad_prec_q *eval_prec);
void trb_solve_without_mat_q_64(void **data, void *userdata, int64_t *status, int64_t n, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *g, galahad_f_q_64 *eval_f, galahad_g_q_64 *eval_g, galahad_hprod_q_64 *eval_hprod, galahad_shprod_q_64 *eval_shprod, galahad_prec_q_64 *eval_prec);
void trb_solve_reverse_with_mat_q(void **data, int32_t *status, int32_t *eval_status, int32_t n, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 f, __float128 *g, int32_t ne, __float128 *H_val, __float128 *u, __float128 *v);
void trb_solve_reverse_with_mat_q_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 f, __float128 *g, int64_t ne, __float128 *H_val, __float128 *u, __float128 *v);
void trb_solve_reverse_without_mat_q(void **data, int32_t *status, int32_t *eval_status, int32_t n, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 f, __float128 *g, __float128 *u, __float128 *v, int32_t *index_nz_v, int32_t *nnz_v, int32_t *index_nz_u, int32_t nnz_u);
void trb_solve_reverse_without_mat_q_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 f, __float128 *g, __float128 *u, __float128 *v, int64_t *index_nz_v, int64_t *nnz_v, int64_t *index_nz_u, int64_t nnz_u);
void trb_information_q(void **data, struct trb_inform_type_q *inform, int32_t *status);
void trb_information_q_64(void **data, struct trb_inform_type_q_64 *inform, int64_t *status);
void trb_terminate_q(void **data, struct trb_control_type_q *control, struct trb_inform_type_q *inform);
void trb_terminate_q_64(void **data, struct trb_control_type_q_64 *control, struct trb_inform_type_q_64 *inform);

// C interface for BGO
struct bgo_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t attempts_max;
    int32_t max_evals;
    int32_t sampling_strategy;
    int32_t hypercube_discretization;
    int32_t alive_unit;
    char alive_file[31];
    __float128 infinity;
    __float128 obj_unbounded;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool random_multistart;
    bool hessian_available;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct ugo_control_type_q ugo_control;
    struct lhs_control_type lhs_control;
    struct trb_control_type_q trb_control;
};

struct bgo_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t attempts_max;
    int64_t max_evals;
    int64_t sampling_strategy;
    int64_t hypercube_discretization;
    int64_t alive_unit;
    char alive_file[31];
    __float128 infinity;
    __float128 obj_unbounded;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool random_multistart;
    bool hessian_available;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct ugo_control_type_q_64 ugo_control;
    struct lhs_control_type_64 lhs_control;
    struct trb_control_type_q_64 trb_control;
};

struct bgo_time_type_q {
    float total;
    float univariate_global;
    float multivariate_local;
    __float128 clock_total;
    __float128 clock_univariate_global;
    __float128 clock_multivariate_local;
};

struct bgo_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    __float128 obj;
    __float128 norm_pg;
    struct bgo_time_type_q time;
    struct ugo_inform_type_q ugo_inform;
    struct lhs_inform_type lhs_inform;
    struct trb_inform_type_q trb_inform;
};

struct bgo_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    __float128 obj;
    __float128 norm_pg;
    struct bgo_time_type_q time;
    struct ugo_inform_type_q_64 ugo_inform;
    struct lhs_inform_type_64 lhs_inform;
    struct trb_inform_type_q_64 trb_inform;
};

void bgo_initialize_q(void **data, struct bgo_control_type_q *control, int32_t *status);
void bgo_initialize_q_64(void **data, struct bgo_control_type_q_64 *control, int64_t *status);
void bgo_read_specfile_q(struct bgo_control_type_q *control, char *specfile);
void bgo_read_specfile_q_64(struct bgo_control_type_q_64 *control, char *specfile);
void bgo_import_q(struct bgo_control_type_q *control, void **data, int32_t *status, int32_t n, __float128 *x_l, __float128 *x_u, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void bgo_import_q_64(struct bgo_control_type_q_64 *control, void **data, int64_t *status, int64_t n, __float128 *x_l, __float128 *x_u, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void bgo_reset_control_q(struct bgo_control_type_q *control, void **data, int32_t *status);
void bgo_reset_control_q_64(struct bgo_control_type_q_64 *control, void **data, int64_t *status);
void bgo_solve_with_mat_q(void **data, void *userdata, int32_t *status, int32_t n, __float128 *x, __float128 *g, int32_t ne, galahad_f_q *eval_f, galahad_g_q *eval_g, galahad_h_q *eval_h, galahad_hprod_q *eval_hprod, galahad_prec_q *eval_prec);
void bgo_solve_with_mat_q_64(void **data, void *userdata, int64_t *status, int64_t n, __float128 *x, __float128 *g, int64_t ne, galahad_f_q_64 *eval_f, galahad_g_q_64 *eval_g, galahad_h_q_64 *eval_h, galahad_hprod_q_64 *eval_hprod, galahad_prec_q_64 *eval_prec);
void bgo_solve_without_mat_q(void **data, void *userdata, int32_t *status, int32_t n, __float128 *x, __float128 *g, galahad_f_q *eval_f, galahad_g_q *eval_g, galahad_hprod_q *eval_hprod, galahad_shprod_q *eval_shprod, galahad_prec_q *eval_prec);
void bgo_solve_without_mat_q_64(void **data, void *userdata, int64_t *status, int64_t n, __float128 *x, __float128 *g, galahad_f_q_64 *eval_f, galahad_g_q_64 *eval_g, galahad_hprod_q_64 *eval_hprod, galahad_shprod_q_64 *eval_shprod, galahad_prec_q_64 *eval_prec);
void bgo_solve_reverse_with_mat_q(void **data, int32_t *status, int32_t *eval_status, int32_t n, __float128 *x, __float128 f, __float128 *g, int32_t ne, __float128 *H_val, __float128 *u, __float128 *v);
void bgo_solve_reverse_with_mat_q_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, __float128 *x, __float128 f, __float128 *g, int64_t ne, __float128 *H_val, __float128 *u, __float128 *v);
void bgo_solve_reverse_without_mat_q(void **data, int32_t *status, int32_t *eval_status, int32_t n, __float128 *x, __float128 f, __float128 *g, __float128 *u, __float128 *v, int32_t *index_nz_v, int32_t *nnz_v, int32_t *index_nz_u, int32_t nnz_u);
void bgo_solve_reverse_without_mat_q_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, __float128 *x, __float128 f, __float128 *g, __float128 *u, __float128 *v, int64_t *index_nz_v, int64_t *nnz_v, int64_t *index_nz_u, int64_t nnz_u);
void bgo_information_q(void **data, struct bgo_inform_type_q *inform, int32_t *status);
void bgo_information_q_64(void **data, struct bgo_inform_type_q_64 *inform, int64_t *status);
void bgo_terminate_q(void **data, struct bgo_control_type_q *control, struct bgo_inform_type_q *inform);
void bgo_terminate_q_64(void **data, struct bgo_control_type_q_64 *control, struct bgo_inform_type_q_64 *inform);

// C interface for ULS
struct uls_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t warning;
    int32_t out;
    int32_t print_level;
    int32_t print_level_solver;
    int32_t initial_fill_in_factor;
    int32_t min_real_factor_size;
    int32_t min_integer_factor_size;
    int64_t max_factor_size;
    int32_t blas_block_size_factorize;
    int32_t blas_block_size_solve;
    int32_t pivot_control;
    int32_t pivot_search_limit;
    int32_t minimum_size_for_btf;
    int32_t max_iterative_refinements;
    bool stop_if_singular;
    __float128 array_increase_factor;
    __float128 switch_to_full_code_density;
    __float128 array_decrease_factor;
    __float128 relative_pivot_tolerance;
    __float128 absolute_pivot_tolerance;
    __float128 zero_tolerance;
    __float128 acceptable_residual_relative;
    __float128 acceptable_residual_absolute;
    char prefix[31];
};

struct uls_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t warning;
    int64_t out;
    int64_t print_level;
    int64_t print_level_solver;
    int64_t initial_fill_in_factor;
    int64_t min_real_factor_size;
    int64_t min_integer_factor_size;
    int64_t max_factor_size;
    int64_t blas_block_size_factorize;
    int64_t blas_block_size_solve;
    int64_t pivot_control;
    int64_t pivot_search_limit;
    int64_t minimum_size_for_btf;
    int64_t max_iterative_refinements;
    bool stop_if_singular;
    __float128 array_increase_factor;
    __float128 switch_to_full_code_density;
    __float128 array_decrease_factor;
    __float128 relative_pivot_tolerance;
    __float128 absolute_pivot_tolerance;
    __float128 zero_tolerance;
    __float128 acceptable_residual_relative;
    __float128 acceptable_residual_absolute;
    char prefix[31];
};

struct uls_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t more_info;
    int64_t out_of_range;
    int64_t duplicates;
    int64_t entries_dropped;
    int64_t workspace_factors;
    int32_t compresses;
    int64_t entries_in_factors;
    int32_t rank;
    int32_t structural_rank;
    int32_t pivot_control;
    int32_t iterative_refinements;
    bool alternative;
    char solver[21];
    struct gls_ainfo_type_q gls_ainfo;
    struct gls_finfo_type_q gls_finfo;
    struct gls_sinfo_type gls_sinfo;
    struct ma48_ainfo_q ma48_ainfo;
    struct ma48_finfo_q ma48_finfo;
    struct ma48_sinfo ma48_sinfo;
    int32_t lapack_error;
};

struct uls_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t more_info;
    int64_t out_of_range;
    int64_t duplicates;
    int64_t entries_dropped;
    int64_t workspace_factors;
    int64_t compresses;
    int64_t entries_in_factors;
    int64_t rank;
    int64_t structural_rank;
    int64_t pivot_control;
    int64_t iterative_refinements;
    bool alternative;
    char solver[21];
    struct gls_ainfo_type_q_64 gls_ainfo;
    struct gls_finfo_type_q_64 gls_finfo;
    struct gls_sinfo_type_64 gls_sinfo;
    struct ma48_ainfo_q_64 ma48_ainfo;
    struct ma48_finfo_q_64 ma48_finfo;
    struct ma48_sinfo_64 ma48_sinfo;
    int64_t lapack_error;
};

void uls_initialize_q(char *solver, void **data, struct uls_control_type_q *control, int32_t *status);
void uls_initialize_q_64(char *solver, void **data, struct uls_control_type_q_64 *control, int64_t *status);
void uls_read_specfile_q(struct uls_control_type_q *control, char *specfile);
void uls_read_specfile_q_64(struct uls_control_type_q_64 *control, char *specfile);
void uls_factorize_matrix_q(struct uls_control_type_q *control, void **data, int32_t *status, int32_t m, int32_t n, char *type, int32_t ne, __float128 *val, int32_t *row, int32_t *col, int32_t *ptr);
void uls_factorize_matrix_q_64(struct uls_control_type_q_64 *control, void **data, int64_t *status, int64_t m, int64_t n, char *type, int64_t ne, __float128 *val, int64_t *row, int64_t *col, int64_t *ptr);
void uls_reset_control_q(struct uls_control_type_q *control, void **data, int32_t *status);
void uls_reset_control_q_64(struct uls_control_type_q_64 *control, void **data, int64_t *status);
void uls_solve_system_q(void **data, int32_t *status, int32_t m, int32_t n, __float128 *sol, bool trans);
void uls_solve_system_q_64(void **data, int64_t *status, int64_t m, int64_t n, __float128 *sol, bool trans);
void uls_information_q(void **data, struct uls_inform_type_q *inform, int32_t *status);
void uls_information_q_64(void **data, struct uls_inform_type_q_64 *inform, int64_t *status);
void uls_terminate_q(void **data, struct uls_control_type_q *control, struct uls_inform_type_q *inform);
void uls_terminate_q_64(void **data, struct uls_control_type_q_64 *control, struct uls_inform_type_q_64 *inform);

// C interface for SBLS
struct sbls_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t indmin;
    int32_t valmin;
    int32_t len_ulsmin;
    int32_t itref_max;
    int32_t maxit_pcg;
    int32_t new_a;
    int32_t new_h;
    int32_t new_c;
    int32_t preconditioner;
    int32_t semi_bandwidth;
    int32_t factorization;
    int32_t max_col;
    int32_t scaling;
    int32_t ordering;
    __float128 pivot_tol;
    __float128 pivot_tol_for_basis;
    __float128 zero_pivot;
    __float128 static_tolerance;
    __float128 static_level;
    __float128 min_diagonal;
    __float128 stop_absolute;
    __float128 stop_relative;
    bool remove_dependencies;
    bool find_basis_by_transpose;
    bool affine;
    bool allow_singular;
    bool perturb_to_make_definite;
    bool get_norm_residual;
    bool check_basis;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q sls_control;
    struct uls_control_type_q uls_control;
};

struct sbls_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t indmin;
    int64_t valmin;
    int64_t len_ulsmin;
    int64_t itref_max;
    int64_t maxit_pcg;
    int64_t new_a;
    int64_t new_h;
    int64_t new_c;
    int64_t preconditioner;
    int64_t semi_bandwidth;
    int64_t factorization;
    int64_t max_col;
    int64_t scaling;
    int64_t ordering;
    __float128 pivot_tol;
    __float128 pivot_tol_for_basis;
    __float128 zero_pivot;
    __float128 static_tolerance;
    __float128 static_level;
    __float128 min_diagonal;
    __float128 stop_absolute;
    __float128 stop_relative;
    bool remove_dependencies;
    bool find_basis_by_transpose;
    bool affine;
    bool allow_singular;
    bool perturb_to_make_definite;
    bool get_norm_residual;
    bool check_basis;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q_64 sls_control;
    struct uls_control_type_q_64 uls_control;
};

struct sbls_time_type_q {
    __float128 total;
    __float128 form;
    __float128 factorize;
    __float128 apply;
    __float128 clock_total;
    __float128 clock_form;
    __float128 clock_factorize;
    __float128 clock_apply;
};

struct sbls_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t sort_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t preconditioner;
    int32_t factorization;
    int32_t d_plus;
    int32_t rank;
    bool rank_def;
    bool perturbed;
    int32_t iter_pcg;
    __float128 norm_residual;
    bool alternative;
    struct sbls_time_type_q time;
    struct sls_inform_type_q sls_inform;
    struct uls_inform_type_q uls_inform;
};

struct sbls_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t sort_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t preconditioner;
    int64_t factorization;
    int64_t d_plus;
    int64_t rank;
    bool rank_def;
    bool perturbed;
    int64_t iter_pcg;
    __float128 norm_residual;
    bool alternative;
    struct sbls_time_type_q time;
    struct sls_inform_type_q_64 sls_inform;
    struct uls_inform_type_q_64 uls_inform;
};

void sbls_initialize_q(void **data, struct sbls_control_type_q *control, int32_t *status);
void sbls_initialize_q_64(void **data, struct sbls_control_type_q_64 *control, int64_t *status);
void sbls_read_specfile_q(struct sbls_control_type_q *control, char *specfile);
void sbls_read_specfile_q_64(struct sbls_control_type_q_64 *control, char *specfile);
void sbls_import_q(struct sbls_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr, char *C_type, int32_t C_ne, int32_t *C_row, int32_t *C_col, int32_t *C_ptr);
void sbls_import_q_64(struct sbls_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr, char *C_type, int64_t C_ne, int64_t *C_row, int64_t *C_col, int64_t *C_ptr);
void sbls_reset_control_q(struct sbls_control_type_q *control, void **data, int32_t *status);
void sbls_reset_control_q_64(struct sbls_control_type_q_64 *control, void **data, int64_t *status);
void sbls_factorize_matrix_q(void **data, int32_t *status, int32_t n, int32_t h_ne, __float128 *H_val, int32_t a_ne, __float128 *A_val, int32_t c_ne, __float128 *C_val, __float128 *D);
void sbls_factorize_matrix_q_64(void **data, int64_t *status, int64_t n, int64_t h_ne, __float128 *H_val, int64_t a_ne, __float128 *A_val, int64_t c_ne, __float128 *C_val, __float128 *D);
void sbls_solve_system_q(void **data, int32_t *status, int32_t n, int32_t m, __float128 *sol);
void sbls_solve_system_q_64(void **data, int64_t *status, int64_t n, int64_t m, __float128 *sol);
void sbls_information_q(void **data, struct sbls_inform_type_q *inform, int32_t *status);
void sbls_information_q_64(void **data, struct sbls_inform_type_q_64 *inform, int64_t *status);
void sbls_terminate_q(void **data, struct sbls_control_type_q *control, struct sbls_inform_type_q *inform);
void sbls_terminate_q_64(void **data, struct sbls_control_type_q_64 *control, struct sbls_inform_type_q_64 *inform);

// C interface for BLLS
struct blls_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t cold_start;
    int32_t preconditioner;
    int32_t ratio_cg_vs_sd;
    int32_t change_max;
    int32_t cg_maxit;
    int32_t arcsearch_max_steps;
    int32_t sif_file_device;
    __float128 weight;
    __float128 infinity;
    __float128 stop_d;
    __float128 identical_bounds_tol;
    __float128 stop_cg_relative;
    __float128 stop_cg_absolute;
    __float128 alpha_max;
    __float128 alpha_initial;
    __float128 alpha_reduction;
    __float128 arcsearch_acceptance_tol;
    __float128 stabilisation_weight;
    __float128 cpu_time_limit;
    bool direct_subproblem_solve;
    bool exact_arc_search;
    bool advance;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_q sbls_control;
    struct convert_control_type convert_control;
};

struct blls_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t cold_start;
    int64_t preconditioner;
    int64_t ratio_cg_vs_sd;
    int64_t change_max;
    int64_t cg_maxit;
    int64_t arcsearch_max_steps;
    int64_t sif_file_device;
    __float128 weight;
    __float128 infinity;
    __float128 stop_d;
    __float128 identical_bounds_tol;
    __float128 stop_cg_relative;
    __float128 stop_cg_absolute;
    __float128 alpha_max;
    __float128 alpha_initial;
    __float128 alpha_reduction;
    __float128 arcsearch_acceptance_tol;
    __float128 stabilisation_weight;
    __float128 cpu_time_limit;
    bool direct_subproblem_solve;
    bool exact_arc_search;
    bool advance;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_q_64 sbls_control;
    struct convert_control_type_64 convert_control;
};

struct blls_time_type_q {
    __float128 total;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct blls_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    int32_t factorization_status;
    int32_t iter;
    int32_t cg_iter;
    __float128 obj;
    __float128 norm_pg;
    char bad_alloc[81];
    struct blls_time_type_q time;
    struct sbls_inform_type_q sbls_inform;
    struct convert_inform_type_q convert_inform;
};

struct blls_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorization_status;
    int64_t iter;
    int64_t cg_iter;
    __float128 obj;
    __float128 norm_pg;
    char bad_alloc[81];
    struct blls_time_type_q time;
    struct sbls_inform_type_q_64 sbls_inform;
    struct convert_inform_type_q_64 convert_inform;
};

void blls_initialize_q(void **data, struct blls_control_type_q *control, int32_t *status);
void blls_initialize_q_64(void **data, struct blls_control_type_q_64 *control, int64_t *status);
void blls_read_specfile_q(struct blls_control_type_q *control, char *specfile);
void blls_read_specfile_q_64(struct blls_control_type_q_64 *control, char *specfile);
void blls_import_q(struct blls_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t o, char *Ao_type, int32_t Ao_ne, int32_t *Ao_row, int32_t *Ao_col, int32_t Ao_ptr_ne, int32_t *Ao_ptr);
void blls_import_q_64(struct blls_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t o, char *Ao_type, int64_t Ao_ne, int64_t *Ao_row, int64_t *Ao_col, int64_t Ao_ptr_ne, int64_t *Ao_ptr);
void blls_import_without_a_q(struct blls_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t o);
void blls_import_without_a_q_64(struct blls_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t o);
void blls_reset_control_q(struct blls_control_type_q *control, void **data, int32_t *status);
void blls_reset_control_q_64(struct blls_control_type_q_64 *control, void **data, int64_t *status);
void blls_solve_given_a_q(void **data, void *userdata, int32_t *status, int32_t n, int32_t o, int32_t Ao_ne, __float128 *Ao_val, __float128 *b, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *z, __float128 *r, __float128 *g, int32_t *x_stat, __float128 *w, galahad_constant_prec_q *eval_prec);
void blls_solve_given_a_q_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t o, int64_t Ao_ne, __float128 *Ao_val, __float128 *b, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *z, __float128 *r, __float128 *g, int64_t *x_stat, __float128 *w, galahad_constant_prec_q_64 *eval_prec);
void blls_solve_reverse_a_prod_q(void **data, int32_t *status, int32_t *eval_status, int32_t n, int32_t o, __float128 *b, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *z, __float128 *r, __float128 *g, int32_t *x_stat, __float128 *v, __float128 *p, int32_t *nz_v, int32_t *nz_v_start, int32_t *nz_v_end, int32_t *nz_p, int32_t nz_p_end, __float128 *w);
void blls_solve_reverse_a_prod_q_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, int64_t o, __float128 *b, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *z, __float128 *r, __float128 *g, int64_t *x_stat, __float128 *v, __float128 *p, int64_t *nz_v, int64_t *nz_v_start, int64_t *nz_v_end, int64_t *nz_p, int64_t nz_p_end, __float128 *w);
void blls_information_q(void **data, struct blls_inform_type_q *inform, int32_t *status);
void blls_information_q_64(void **data, struct blls_inform_type_q_64 *inform, int64_t *status);
void blls_terminate_q(void **data, struct blls_control_type_q *control, struct blls_inform_type_q *inform);
void blls_terminate_q_64(void **data, struct blls_control_type_q_64 *control, struct blls_inform_type_q_64 *inform);

// C interface for BQP
struct bqp_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t cold_start;
    int32_t ratio_cg_vs_sd;
    int32_t change_max;
    int32_t cg_maxit;
    int32_t sif_file_device;
    __float128 infinity;
    __float128 stop_p;
    __float128 stop_d;
    __float128 stop_c;
    __float128 identical_bounds_tol;
    __float128 stop_cg_relative;
    __float128 stop_cg_absolute;
    __float128 zero_curvature;
    __float128 cpu_time_limit;
    bool exact_arcsearch;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_q sbls_control;
};

struct bqp_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t cold_start;
    int64_t ratio_cg_vs_sd;
    int64_t change_max;
    int64_t cg_maxit;
    int64_t sif_file_device;
    __float128 infinity;
    __float128 stop_p;
    __float128 stop_d;
    __float128 stop_c;
    __float128 identical_bounds_tol;
    __float128 stop_cg_relative;
    __float128 stop_cg_absolute;
    __float128 zero_curvature;
    __float128 cpu_time_limit;
    bool exact_arcsearch;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_q_64 sbls_control;
};

struct bqp_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    int32_t factorization_status;
    int32_t iter;
    int32_t cg_iter;
    __float128 obj;
    __float128 norm_pg;
    char bad_alloc[81];
    struct bqp_time_type time;
    struct sbls_inform_type_q sbls_inform;
};

struct bqp_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorization_status;
    int64_t iter;
    int64_t cg_iter;
    __float128 obj;
    __float128 norm_pg;
    char bad_alloc[81];
    struct bqp_time_type time;
    struct sbls_inform_type_q_64 sbls_inform;
};

void bqp_initialize_q(void **data, struct bqp_control_type_q *control, int32_t *status);
void bqp_initialize_q_64(void **data, struct bqp_control_type_q_64 *control, int64_t *status);
void bqp_read_specfile_q(struct bqp_control_type_q *control, char *specfile);
void bqp_read_specfile_q_64(struct bqp_control_type_q_64 *control, char *specfile);
void bqp_import_q(struct bqp_control_type_q *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void bqp_import_q_64(struct bqp_control_type_q_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void bqp_import_without_h_q(struct bqp_control_type_q *control, void **data, int32_t *status, int32_t n);
void bqp_import_without_h_q_64(struct bqp_control_type_q_64 *control, void **data, int64_t *status, int64_t n);
void bqp_reset_control_q(struct bqp_control_type_q *control, void **data, int32_t *status);
void bqp_reset_control_q_64(struct bqp_control_type_q_64 *control, void **data, int64_t *status);
void bqp_solve_given_h_q(void **data, int32_t *status, int32_t n, int32_t h_ne, __float128 *H_val, __float128 *g, __float128 f, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *z, int32_t *x_stat);
void bqp_solve_given_h_q_64(void **data, int64_t *status, int64_t n, int64_t h_ne, __float128 *H_val, __float128 *g, __float128 f, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *z, int64_t *x_stat);
void bqp_solve_reverse_h_prod_q(void **data, int32_t *status, int32_t n, __float128 *g, __float128 f, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *z, int32_t *x_stat, __float128 *v, __float128 *prod, int32_t *nz_v, int32_t *nz_v_start, int32_t *nz_v_end, int32_t *nz_prod, int32_t nz_prod_end);
void bqp_solve_reverse_h_prod_q_64(void **data, int64_t *status, int64_t n, __float128 *g, __float128 f, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *z, int64_t *x_stat, __float128 *v, __float128 *prod, int64_t *nz_v, int64_t *nz_v_start, int64_t *nz_v_end, int64_t *nz_prod, int64_t nz_prod_end);
void bqp_information_q(void **data, struct bqp_inform_type_q *inform, int32_t *status);
void bqp_information_q_64(void **data, struct bqp_inform_type_q_64 *inform, int64_t *status);
void bqp_terminate_q(void **data, struct bqp_control_type_q *control, struct bqp_inform_type_q *inform);
void bqp_terminate_q_64(void **data, struct bqp_control_type_q_64 *control, struct bqp_inform_type_q_64 *inform);

// C interface for FDC
struct fdc_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t indmin;
    int32_t valmin;
    __float128 pivot_tol;
    __float128 zero_pivot;
    __float128 max_infeas;
    bool use_sls;
    bool scale;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q sls_control;
    struct uls_control_type_q uls_control;
};

struct fdc_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t indmin;
    int64_t valmin;
    __float128 pivot_tol;
    __float128 zero_pivot;
    __float128 max_infeas;
    bool use_sls;
    bool scale;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q_64 sls_control;
    struct uls_control_type_q_64 uls_control;
};

struct fdc_time_type_q {
    __float128 total;
    __float128 analyse;
    __float128 factorize;
    __float128 clock_total;
    __float128 clock_analyse;
    __float128 clock_factorize;
};

struct fdc_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    __float128 non_negligible_pivot;
    struct fdc_time_type_q time;
    struct sls_inform_type_q sls_inform;
    struct uls_inform_type_q uls_inform;
};

struct fdc_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    __float128 non_negligible_pivot;
    struct fdc_time_type_q time;
    struct sls_inform_type_q_64 sls_inform;
    struct uls_inform_type_q_64 uls_inform;
};

void fdc_initialize_q(void **data, struct fdc_control_type_q *control, int32_t *status);
void fdc_initialize_q_64(void **data, struct fdc_control_type_q_64 *control, int64_t *status);
void fdc_read_specfile_q(struct fdc_control_type_q *control, char *specfile);
void fdc_read_specfile_q_64(struct fdc_control_type_q_64 *control, char *specfile);
void fdc_find_dependent_rows_q(struct fdc_control_type_q *control, void **data, struct fdc_inform_type_q *inform, int32_t *status, int32_t m, int32_t n, int32_t A_ne, int32_t *A_col, int32_t *A_ptr, __float128 *A_val, __float128 *b, int32_t *n_depen, int32_t *depen);
void fdc_find_dependent_rows_q_64(struct fdc_control_type_q_64 *control, void **data, struct fdc_inform_type_q_64 *inform, int64_t *status, int64_t m, int64_t n, int64_t A_ne, int64_t *A_col, int64_t *A_ptr, __float128 *A_val, __float128 *b, int64_t *n_depen, int64_t *depen);
void fdc_terminate_q(void **data, struct fdc_control_type_q *control, struct fdc_inform_type_q *inform);
void fdc_terminate_q_64(void **data, struct fdc_control_type_q_64 *control, struct fdc_inform_type_q_64 *inform);

// C interface for CRO
struct cro_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t max_schur_complement;
    __float128 infinity;
    __float128 feasibility_tolerance;
    bool check_io;
    bool refine_solution;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q sls_control;
    struct sbls_control_type_q sbls_control;
    struct uls_control_type_q uls_control;
    struct ir_control_type_q ir_control;
};

struct cro_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t max_schur_complement;
    __float128 infinity;
    __float128 feasibility_tolerance;
    bool check_io;
    bool refine_solution;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q_64 sls_control;
    struct sbls_control_type_q_64 sbls_control;
    struct uls_control_type_q_64 uls_control;
    struct ir_control_type_q_64 ir_control;
};

struct cro_time_type_q {
    float total;
    float analyse;
    float factorize;
    float solve;
    __float128 clock_total;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct cro_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t dependent;
    struct cro_time_type_q time;
    struct sls_inform_type_q sls_inform;
    struct sbls_inform_type_q sbls_inform;
    struct uls_inform_type_q uls_inform;
    int32_t scu_status;
    struct scu_inform_type scu_inform;
    struct ir_inform_type_q ir_inform;
};

struct cro_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t dependent;
    struct cro_time_type_q time;
    struct sls_inform_type_q_64 sls_inform;
    struct sbls_inform_type_q_64 sbls_inform;
    struct uls_inform_type_q_64 uls_inform;
    int64_t scu_status;
    struct scu_inform_type_64 scu_inform;
    struct ir_inform_type_q_64 ir_inform;
};

void cro_initialize_q(void **data, struct cro_control_type_q *control, int32_t *status);
void cro_initialize_q_64(void **data, struct cro_control_type_q_64 *control, int64_t *status);
void cro_read_specfile_q(struct cro_control_type_q *control, char *specfile);
void cro_read_specfile_q_64(struct cro_control_type_q_64 *control, char *specfile);
void cro_crossover_solution_q(void **data, struct cro_control_type_q *control, struct cro_inform_type_q *inform, int32_t n, int32_t m, int32_t m_equal, int32_t h_ne, __float128 *H_val, int32_t *H_col, int32_t *H_ptr, int32_t a_ne, __float128 *A_val, int32_t *A_col, int32_t *A_ptr, __float128 *g, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat);
void cro_crossover_solution_q_64(void **data, struct cro_control_type_q_64 *control, struct cro_inform_type_q_64 *inform, int64_t n, int64_t m, int64_t m_equal, int64_t h_ne, __float128 *H_val, int64_t *H_col, int64_t *H_ptr, int64_t a_ne, __float128 *A_val, int64_t *A_col, int64_t *A_ptr, __float128 *g, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat);
void cro_terminate_q(void **data, struct cro_control_type_q *control, struct cro_inform_type_q *inform);
void cro_terminate_q_64(void **data, struct cro_control_type_q_64 *control, struct cro_inform_type_q_64 *inform);

// C interface for BQPB
struct bqpb_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 perturb_h;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 tau;
    __float128 gamma_c;
    __float128 gamma_f;
    __float128 reduce_infeas;
    __float128 obj_unbounded;
    __float128 potential_unbounded;
    __float128 identical_bounds_tol;
    __float128 mu_pounce;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_q fdc_control;
    struct sbls_control_type_q sbls_control;
    struct fit_control_type fit_control;
    struct roots_control_type_q roots_control;
    struct cro_control_type_q cro_control;
};

struct bqpb_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 perturb_h;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 tau;
    __float128 gamma_c;
    __float128 gamma_f;
    __float128 reduce_infeas;
    __float128 obj_unbounded;
    __float128 potential_unbounded;
    __float128 identical_bounds_tol;
    __float128 mu_pounce;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_q_64 fdc_control;
    struct sbls_control_type_q_64 sbls_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_q_64 roots_control;
    struct cro_control_type_q_64 cro_control;
};

struct bqpb_time_type_q {
    __float128 total;
    __float128 preprocess;
    __float128 find_dependent;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_find_dependent;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct bqpb_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    __float128 init_primal_infeasibility;
    __float128 init_dual_infeasibility;
    __float128 init_complementary_slackness;
    __float128 potential;
    __float128 non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    __float128 checkpointsTime[16];
    struct bqpb_time_type_q time;
    struct fdc_inform_type_q fdc_inform;
    struct sbls_inform_type_q sbls_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type_q cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct bqpb_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    __float128 init_primal_infeasibility;
    __float128 init_dual_infeasibility;
    __float128 init_complementary_slackness;
    __float128 potential;
    __float128 non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    __float128 checkpointsTime[16];
    struct bqpb_time_type_q time;
    struct fdc_inform_type_q_64 fdc_inform;
    struct sbls_inform_type_q_64 sbls_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_q_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void bqpb_initialize_q(void **data, struct bqpb_control_type_q *control, int32_t *status);
void bqpb_initialize_q_64(void **data, struct bqpb_control_type_q_64 *control, int64_t *status);
void bqpb_read_specfile_q(struct bqpb_control_type_q *control, char *specfile);
void bqpb_read_specfile_q_64(struct bqpb_control_type_q_64 *control, char *specfile);
void bqpb_import_q(struct bqpb_control_type_q *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void bqpb_import_q_64(struct bqpb_control_type_q_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void bqpb_reset_control_q(struct bqpb_control_type_q *control, void **data, int32_t *status);
void bqpb_reset_control_q_64(struct bqpb_control_type_q_64 *control, void **data, int64_t *status);
void bqpb_solve_qp_q(void **data, int32_t *status, int32_t n, int32_t h_ne, __float128 *H_val, __float128 *g, __float128 f, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *z, int32_t *x_stat);
void bqpb_solve_qp_q_64(void **data, int64_t *status, int64_t n, int64_t h_ne, __float128 *H_val, __float128 *g, __float128 f, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *z, int64_t *x_stat);
void bqpb_solve_sldqp_q(void **data, int32_t *status, int32_t n, __float128 *w, __float128 *x0, __float128 *g, __float128 f, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *z, int32_t *x_stat);
void bqpb_solve_sldqp_q_64(void **data, int64_t *status, int64_t n, __float128 *w, __float128 *x0, __float128 *g, __float128 f, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *z, int64_t *x_stat);
void bqpb_information_q(void **data, struct bqpb_inform_type_q *inform, int32_t *status);
void bqpb_information_q_64(void **data, struct bqpb_inform_type_q_64 *inform, int64_t *status);
void bqpb_terminate_q(void **data, struct bqpb_control_type_q *control, struct bqpb_inform_type_q *inform);
void bqpb_terminate_q_64(void **data, struct bqpb_control_type_q_64 *control, struct bqpb_inform_type_q_64 *inform);

// C interface for CCQP
struct ccqp_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 perturb_h;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 tau;
    __float128 gamma_c;
    __float128 gamma_f;
    __float128 reduce_infeas;
    __float128 obj_unbounded;
    __float128 potential_unbounded;
    __float128 identical_bounds_tol;
    __float128 mu_pounce;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_q fdc_control;
    struct sbls_control_type_q sbls_control;
    struct sbls_control_type_q sbls_pounce_control;
    struct fit_control_type fit_control;
    struct roots_control_type_q roots_control;
    struct cro_control_type_q cro_control;
};

struct ccqp_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 perturb_h;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 tau;
    __float128 gamma_c;
    __float128 gamma_f;
    __float128 reduce_infeas;
    __float128 obj_unbounded;
    __float128 potential_unbounded;
    __float128 identical_bounds_tol;
    __float128 mu_pounce;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_q_64 fdc_control;
    struct sbls_control_type_q_64 sbls_control;
    struct sbls_control_type_q_64 sbls_pounce_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_q_64 roots_control;
    struct cro_control_type_q_64 cro_control;
};

struct ccqp_time_type_q {
    __float128 total;
    __float128 preprocess;
    __float128 find_dependent;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_find_dependent;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct ccqp_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    __float128 init_primal_infeasibility;
    __float128 init_dual_infeasibility;
    __float128 init_complementary_slackness;
    __float128 potential;
    __float128 non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    __float128 checkpointsTime[16];
    struct ccqp_time_type_q time;
    struct fdc_inform_type_q fdc_inform;
    struct sbls_inform_type_q sbls_inform;
    struct sbls_inform_type_q sbls_pounce_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type_q cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct ccqp_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    __float128 init_primal_infeasibility;
    __float128 init_dual_infeasibility;
    __float128 init_complementary_slackness;
    __float128 potential;
    __float128 non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    __float128 checkpointsTime[16];
    struct ccqp_time_type_q time;
    struct fdc_inform_type_q_64 fdc_inform;
    struct sbls_inform_type_q_64 sbls_inform;
    struct sbls_inform_type_q_64 sbls_pounce_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_q_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void ccqp_initialize_q(void **data, struct ccqp_control_type_q *control, int32_t *status);
void ccqp_initialize_q_64(void **data, struct ccqp_control_type_q_64 *control, int64_t *status);
void ccqp_read_specfile_q(struct ccqp_control_type_q *control, char *specfile);
void ccqp_read_specfile_q_64(struct ccqp_control_type_q_64 *control, char *specfile);
void ccqp_import_q(struct ccqp_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void ccqp_import_q_64(struct ccqp_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void ccqp_reset_control_q(struct ccqp_control_type_q *control, void **data, int32_t *status);
void ccqp_reset_control_q_64(struct ccqp_control_type_q_64 *control, void **data, int64_t *status);
void ccqp_solve_qp_q(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, __float128 *H_val, __float128 *g, __float128 f, int32_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat);
void ccqp_solve_qp_q_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, __float128 *H_val, __float128 *g, __float128 f, int64_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat);
void ccqp_solve_sldqp_q(void **data, int32_t *status, int32_t n, int32_t m, __float128 *w, __float128 *x0, __float128 *g, __float128 f, int32_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat);
void ccqp_solve_sldqp_q_64(void **data, int64_t *status, int64_t n, int64_t m, __float128 *w, __float128 *x0, __float128 *g, __float128 f, int64_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat);
void ccqp_information_q(void **data, struct ccqp_inform_type_q *inform, int32_t *status);
void ccqp_information_q_64(void **data, struct ccqp_inform_type_q_64 *inform, int64_t *status);
void ccqp_terminate_q(void **data, struct ccqp_control_type_q *control, struct ccqp_inform_type_q *inform);
void ccqp_terminate_q_64(void **data, struct ccqp_control_type_q_64 *control, struct ccqp_inform_type_q_64 *inform);

// C interface for CQP
struct cqp_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 perturb_h;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 tau;
    __float128 gamma_c;
    __float128 gamma_f;
    __float128 reduce_infeas;
    __float128 obj_unbounded;
    __float128 potential_unbounded;
    __float128 identical_bounds_tol;
    __float128 mu_pounce;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_q fdc_control;
    struct sbls_control_type_q sbls_control;
    struct fit_control_type fit_control;
    struct roots_control_type_q roots_control;
    struct cro_control_type_q cro_control;
};

struct cqp_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 perturb_h;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 tau;
    __float128 gamma_c;
    __float128 gamma_f;
    __float128 reduce_infeas;
    __float128 obj_unbounded;
    __float128 potential_unbounded;
    __float128 identical_bounds_tol;
    __float128 mu_pounce;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_q_64 fdc_control;
    struct sbls_control_type_q_64 sbls_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_q_64 roots_control;
    struct cro_control_type_q_64 cro_control;
};

struct cqp_time_type_q {
    __float128 total;
    __float128 preprocess;
    __float128 find_dependent;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_find_dependent;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct cqp_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    __float128 init_primal_infeasibility;
    __float128 init_dual_infeasibility;
    __float128 init_complementary_slackness;
    __float128 potential;
    __float128 non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    __float128 checkpointsTime[16];
    struct cqp_time_type_q time;
    struct fdc_inform_type_q fdc_inform;
    struct sbls_inform_type_q sbls_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type_q cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct cqp_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    __float128 init_primal_infeasibility;
    __float128 init_dual_infeasibility;
    __float128 init_complementary_slackness;
    __float128 potential;
    __float128 non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    __float128 checkpointsTime[16];
    struct cqp_time_type_q time;
    struct fdc_inform_type_q_64 fdc_inform;
    struct sbls_inform_type_q_64 sbls_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_q_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void cqp_initialize_q(void **data, struct cqp_control_type_q *control, int32_t *status);
void cqp_initialize_q_64(void **data, struct cqp_control_type_q_64 *control, int64_t *status);
void cqp_read_specfile_q(struct cqp_control_type_q *control, char *specfile);
void cqp_read_specfile_q_64(struct cqp_control_type_q_64 *control, char *specfile);
void cqp_import_q(struct cqp_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void cqp_import_q_64(struct cqp_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void cqp_reset_control_q(struct cqp_control_type_q *control, void **data, int32_t *status);
void cqp_reset_control_q_64(struct cqp_control_type_q_64 *control, void **data, int64_t *status);
void cqp_solve_qp_q(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, __float128 *H_val, __float128 *g, __float128 f, int32_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat);
void cqp_solve_qp_q_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, __float128 *H_val, __float128 *g, __float128 f, int64_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat);
void cqp_solve_sldqp_q(void **data, int32_t *status, int32_t n, int32_t m, __float128 *w, __float128 *x0, __float128 *g, __float128 f, int32_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat);
void cqp_solve_sldqp_q_64(void **data, int64_t *status, int64_t n, int64_t m, __float128 *w, __float128 *x0, __float128 *g, __float128 f, int64_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat);
void cqp_information_q(void **data, struct cqp_inform_type_q *inform, int32_t *status);
void cqp_information_q_64(void **data, struct cqp_inform_type_q_64 *inform, int64_t *status);
void cqp_terminate_q(void **data, struct cqp_control_type_q *control, struct cqp_inform_type_q *inform);
void cqp_terminate_q_64(void **data, struct cqp_control_type_q_64 *control, struct cqp_inform_type_q_64 *inform);

// C interface for CLLS
struct clls_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 tau;
    __float128 gamma_c;
    __float128 gamma_f;
    __float128 reduce_infeas;
    __float128 identical_bounds_tol;
    __float128 mu_pounce;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_q fdc_control;
    struct sls_control_type_q sls_control;
    struct sls_control_type_q sls_pounce_control;
    struct fit_control_type fit_control;
    struct roots_control_type_q roots_control;
    struct cro_control_type_q cro_control;
};

struct clls_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 tau;
    __float128 gamma_c;
    __float128 gamma_f;
    __float128 reduce_infeas;
    __float128 identical_bounds_tol;
    __float128 mu_pounce;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_q_64 fdc_control;
    struct sls_control_type_q_64 sls_control;
    struct sls_control_type_q_64 sls_pounce_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_q_64 roots_control;
    struct cro_control_type_q_64 cro_control;
};

struct clls_time_type_q {
    __float128 total;
    __float128 preprocess;
    __float128 find_dependent;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_find_dependent;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct clls_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    __float128 non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    __float128 checkpointsTime[16];
    struct clls_time_type_q time;
    struct fdc_inform_type_q fdc_inform;
    struct sls_inform_type_q sls_inform;
    struct sls_inform_type_q sls_pounce_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type_q cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct clls_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    __float128 non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    __float128 checkpointsTime[16];
    struct clls_time_type_q time;
    struct fdc_inform_type_q_64 fdc_inform;
    struct sls_inform_type_q_64 sls_inform;
    struct sls_inform_type_q_64 sls_pounce_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_q_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void clls_initialize_q(void **data, struct clls_control_type_q *control, int32_t *status);
void clls_initialize_q_64(void **data, struct clls_control_type_q_64 *control, int64_t *status);
void clls_read_specfile_q(struct clls_control_type_q *control, char *specfile);
void clls_read_specfile_q_64(struct clls_control_type_q_64 *control, char *specfile);
void clls_import_q(struct clls_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t o, int32_t m, char *Ao_type, int32_t Ao_ne, int32_t *Ao_row, int32_t *Ao_col, int32_t Ao_ptr_ne, int32_t *Ao_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t A_ptr_ne, int32_t *A_ptr);
void clls_import_q_64(struct clls_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t o, int64_t m, char *Ao_type, int64_t Ao_ne, int64_t *Ao_row, int64_t *Ao_col, int64_t Ao_ptr_ne, int64_t *Ao_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t A_ptr_ne, int64_t *A_ptr);
void clls_reset_control_q(struct clls_control_type_q *control, void **data, int32_t *status);
void clls_reset_control_q_64(struct clls_control_type_q_64 *control, void **data, int64_t *status);
void clls_solve_clls_q(void **data, int32_t *status, int32_t n, int32_t o, int32_t m, int32_t Ao_ne, __float128 *Ao_val, __float128 *b, __float128 regularization_weight, int32_t A_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *r, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat, __float128 *w);
void clls_solve_clls_q_64(void **data, int64_t *status, int64_t n, int64_t o, int64_t m, int64_t Ao_ne, __float128 *Ao_val, __float128 *b, __float128 regularization_weight, int64_t A_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *r, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat, __float128 *w);
void clls_information_q(void **data, struct clls_inform_type_q *inform, int32_t *status);
void clls_information_q_64(void **data, struct clls_inform_type_q_64 *inform, int64_t *status);
void clls_terminate_q(void **data, struct clls_control_type_q *control, struct clls_inform_type_q *inform);
void clls_terminate_q_64(void **data, struct clls_control_type_q_64 *control, struct clls_inform_type_q_64 *inform);

// C interface for DGO
struct dgo_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t max_evals;
    int32_t dictionary_size;
    int32_t alive_unit;
    char alive_file[31];
    __float128 infinity;
    __float128 lipschitz_lower_bound;
    __float128 lipschitz_reliability;
    __float128 lipschitz_control;
    __float128 stop_length;
    __float128 stop_f;
    __float128 obj_unbounded;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool hessian_available;
    bool prune;
    bool perform_local_optimization;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct hash_control_type hash_control;
    struct ugo_control_type_q ugo_control;
    struct trb_control_type_q trb_control;
};

struct dgo_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t max_evals;
    int64_t dictionary_size;
    int64_t alive_unit;
    char alive_file[31];
    __float128 infinity;
    __float128 lipschitz_lower_bound;
    __float128 lipschitz_reliability;
    __float128 lipschitz_control;
    __float128 stop_length;
    __float128 stop_f;
    __float128 obj_unbounded;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool hessian_available;
    bool prune;
    bool perform_local_optimization;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct hash_control_type_64 hash_control;
    struct ugo_control_type_q_64 ugo_control;
    struct trb_control_type_q_64 trb_control;
};

struct dgo_time_type_q {
    float total;
    float univariate_global;
    float multivariate_local;
    __float128 clock_total;
    __float128 clock_univariate_global;
    __float128 clock_multivariate_local;
};

struct dgo_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    __float128 obj;
    __float128 norm_pg;
    __float128 length_ratio;
    __float128 f_gap;
    char why_stop[2];
    struct dgo_time_type_q time;
    struct hash_inform_type hash_inform;
    struct ugo_inform_type_q ugo_inform;
    struct trb_inform_type_q trb_inform;
};

struct dgo_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    __float128 obj;
    __float128 norm_pg;
    __float128 length_ratio;
    __float128 f_gap;
    char why_stop[2];
    struct dgo_time_type_q time;
    struct hash_inform_type_64 hash_inform;
    struct ugo_inform_type_q_64 ugo_inform;
    struct trb_inform_type_q_64 trb_inform;
};

void dgo_initialize_q(void **data, struct dgo_control_type_q *control, int32_t *status);
void dgo_initialize_q_64(void **data, struct dgo_control_type_q_64 *control, int64_t *status);
void dgo_read_specfile_q(struct dgo_control_type_q *control, char *specfile);
void dgo_read_specfile_q_64(struct dgo_control_type_q_64 *control, char *specfile);
void dgo_import_q(struct dgo_control_type_q *control, void **data, int32_t *status, int32_t n, __float128 *x_l, __float128 *x_u, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void dgo_import_q_64(struct dgo_control_type_q_64 *control, void **data, int64_t *status, int64_t n, __float128 *x_l, __float128 *x_u, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void dgo_reset_control_q(struct dgo_control_type_q *control, void **data, int32_t *status);
void dgo_reset_control_q_64(struct dgo_control_type_q_64 *control, void **data, int64_t *status);
void dgo_solve_with_mat_q(void **data, void *userdata, int32_t *status, int32_t n, __float128 *x, __float128 *g, int32_t ne, galahad_f_q *eval_f, galahad_g_q *eval_g, galahad_h_q *eval_h, galahad_hprod_q *eval_hprod, galahad_prec_q *eval_prec);
void dgo_solve_with_mat_q_64(void **data, void *userdata, int64_t *status, int64_t n, __float128 *x, __float128 *g, int64_t ne, galahad_f_q_64 *eval_f, galahad_g_q_64 *eval_g, galahad_h_q_64 *eval_h, galahad_hprod_q_64 *eval_hprod, galahad_prec_q_64 *eval_prec);
void dgo_solve_without_mat_q(void **data, void *userdata, int32_t *status, int32_t n, __float128 *x, __float128 *g, galahad_f_q *eval_f, galahad_g_q *eval_g, galahad_hprod_q *eval_hprod, galahad_shprod_q *eval_shprod, galahad_prec_q *eval_prec);
void dgo_solve_without_mat_q_64(void **data, void *userdata, int64_t *status, int64_t n, __float128 *x, __float128 *g, galahad_f_q_64 *eval_f, galahad_g_q_64 *eval_g, galahad_hprod_q_64 *eval_hprod, galahad_shprod_q_64 *eval_shprod, galahad_prec_q_64 *eval_prec);
void dgo_solve_reverse_with_mat_q(void **data, int32_t *status, int32_t *eval_status, int32_t n, __float128 *x, __float128 f, __float128 *g, int32_t ne, __float128 *H_val, __float128 *u, __float128 *v);
void dgo_solve_reverse_with_mat_q_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, __float128 *x, __float128 f, __float128 *g, int64_t ne, __float128 *H_val, __float128 *u, __float128 *v);
void dgo_solve_reverse_without_mat_q(void **data, int32_t *status, int32_t *eval_status, int32_t n, __float128 *x, __float128 f, __float128 *g, __float128 *u, __float128 *v, int32_t *index_nz_v, int32_t *nnz_v, int32_t *index_nz_u, int32_t nnz_u);
void dgo_solve_reverse_without_mat_q_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, __float128 *x, __float128 f, __float128 *g, __float128 *u, __float128 *v, int64_t *index_nz_v, int64_t *nnz_v, int64_t *index_nz_u, int64_t nnz_u);
void dgo_information_q(void **data, struct dgo_inform_type_q *inform, int32_t *status);
void dgo_information_q_64(void **data, struct dgo_inform_type_q_64 *inform, int64_t *status);
void dgo_terminate_q(void **data, struct dgo_control_type_q *control, struct dgo_inform_type_q *inform);
void dgo_terminate_q_64(void **data, struct dgo_control_type_q_64 *control, struct dgo_inform_type_q_64 *inform);

// C interface for DQP
struct dqp_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t dual_starting_point;
    int32_t maxit;
    int32_t max_sc;
    int32_t cauchy_only;
    int32_t arc_search_maxit;
    int32_t cg_maxit;
    int32_t explore_optimal_subspace;
    int32_t restore_problem;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    __float128 rho;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 stop_cg_relative;
    __float128 stop_cg_absolute;
    __float128 cg_zero_curvature;
    __float128 max_growth;
    __float128 identical_bounds_tol;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    __float128 initial_perturbation;
    __float128 perturbation_reduction;
    __float128 final_perturbation;
    bool factor_optimal_matrix;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool exact_arc_search;
    bool subspace_direct;
    bool subspace_alternate;
    bool subspace_arc_search;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_q fdc_control;
    struct sls_control_type_q sls_control;
    struct sbls_control_type_q sbls_control;
    struct gltr_control_type_q gltr_control;
};

struct dqp_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t dual_starting_point;
    int64_t maxit;
    int64_t max_sc;
    int64_t cauchy_only;
    int64_t arc_search_maxit;
    int64_t cg_maxit;
    int64_t explore_optimal_subspace;
    int64_t restore_problem;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    __float128 rho;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 stop_cg_relative;
    __float128 stop_cg_absolute;
    __float128 cg_zero_curvature;
    __float128 max_growth;
    __float128 identical_bounds_tol;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    __float128 initial_perturbation;
    __float128 perturbation_reduction;
    __float128 final_perturbation;
    bool factor_optimal_matrix;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool exact_arc_search;
    bool subspace_direct;
    bool subspace_alternate;
    bool subspace_arc_search;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_q_64 fdc_control;
    struct sls_control_type_q_64 sls_control;
    struct sbls_control_type_q_64 sbls_control;
    struct gltr_control_type_q_64 gltr_control;
};

struct dqp_time_type_q {
    __float128 total;
    __float128 preprocess;
    __float128 find_dependent;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 search;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_find_dependent;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
    __float128 clock_search;
};

struct dqp_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t threads;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    __float128 non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    __float128 checkpointsTime[16];
    struct dqp_time_type_q time;
    struct fdc_inform_type_q fdc_inform;
    struct sls_inform_type_q sls_inform;
    struct sbls_inform_type_q sbls_inform;
    struct gltr_inform_type_q gltr_inform;
    int32_t scu_status;
    struct scu_inform_type scu_inform;
    struct rpd_inform_type rpd_inform;
};

struct dqp_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t threads;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    __float128 non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    __float128 checkpointsTime[16];
    struct dqp_time_type_q time;
    struct fdc_inform_type_q_64 fdc_inform;
    struct sls_inform_type_q_64 sls_inform;
    struct sbls_inform_type_q_64 sbls_inform;
    struct gltr_inform_type_q_64 gltr_inform;
    int64_t scu_status;
    struct scu_inform_type_64 scu_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void dqp_initialize_q(void **data, struct dqp_control_type_q *control, int32_t *status);
void dqp_initialize_q_64(void **data, struct dqp_control_type_q_64 *control, int64_t *status);
void dqp_read_specfile_q(struct dqp_control_type_q *control, char *specfile);
void dqp_read_specfile_q_64(struct dqp_control_type_q_64 *control, char *specfile);
void dqp_import_q(struct dqp_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void dqp_import_q_64(struct dqp_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void dqp_reset_control_q(struct dqp_control_type_q *control, void **data, int32_t *status);
void dqp_reset_control_q_64(struct dqp_control_type_q_64 *control, void **data, int64_t *status);
void dqp_solve_qp_q(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, __float128 *H_val, __float128 *g, __float128 f, int32_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat);
void dqp_solve_qp_q_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, __float128 *H_val, __float128 *g, __float128 f, int64_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat);
void dqp_solve_sldqp_q(void **data, int32_t *status, int32_t n, int32_t m, __float128 *w, __float128 *x0, __float128 *g, __float128 f, int32_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat);
void dqp_solve_sldqp_q_64(void **data, int64_t *status, int64_t n, int64_t m, __float128 *w, __float128 *x0, __float128 *g, __float128 f, int64_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat);
void dqp_information_q(void **data, struct dqp_inform_type_q *inform, int32_t *status);
void dqp_information_q_64(void **data, struct dqp_inform_type_q_64 *inform, int64_t *status);
void dqp_terminate_q(void **data, struct dqp_control_type_q *control, struct dqp_inform_type_q *inform);
void dqp_terminate_q_64(void **data, struct dqp_control_type_q_64 *control, struct dqp_inform_type_q_64 *inform);

// C interface for EQP
struct eqp_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t factorization;
    int32_t max_col;
    int32_t indmin;
    int32_t valmin;
    int32_t len_ulsmin;
    int32_t itref_max;
    int32_t cg_maxit;
    int32_t preconditioner;
    int32_t semi_bandwidth;
    int32_t new_a;
    int32_t new_h;
    int32_t sif_file_device;
    __float128 pivot_tol;
    __float128 pivot_tol_for_basis;
    __float128 zero_pivot;
    __float128 inner_fraction_opt;
    __float128 radius;
    __float128 min_diagonal;
    __float128 max_infeasibility_relative;
    __float128 max_infeasibility_absolute;
    __float128 inner_stop_relative;
    __float128 inner_stop_absolute;
    __float128 inner_stop_inter;
    bool find_basis_by_transpose;
    bool remove_dependencies;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct fdc_control_type_q fdc_control;
    struct sbls_control_type_q sbls_control;
    struct gltr_control_type_q gltr_control;
};

struct eqp_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t factorization;
    int64_t max_col;
    int64_t indmin;
    int64_t valmin;
    int64_t len_ulsmin;
    int64_t itref_max;
    int64_t cg_maxit;
    int64_t preconditioner;
    int64_t semi_bandwidth;
    int64_t new_a;
    int64_t new_h;
    int64_t sif_file_device;
    __float128 pivot_tol;
    __float128 pivot_tol_for_basis;
    __float128 zero_pivot;
    __float128 inner_fraction_opt;
    __float128 radius;
    __float128 min_diagonal;
    __float128 max_infeasibility_relative;
    __float128 max_infeasibility_absolute;
    __float128 inner_stop_relative;
    __float128 inner_stop_absolute;
    __float128 inner_stop_inter;
    bool find_basis_by_transpose;
    bool remove_dependencies;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct fdc_control_type_q_64 fdc_control;
    struct sbls_control_type_q_64 sbls_control;
    struct gltr_control_type_q_64 gltr_control;
};

struct eqp_time_type_q {
    __float128 total;
    __float128 find_dependent;
    __float128 factorize;
    __float128 solve;
    __float128 solve_inter;
    __float128 clock_total;
    __float128 clock_find_dependent;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct eqp_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t cg_iter;
    int32_t cg_iter_inter;
    int64_t factorization_integer;
    int64_t factorization_real;
    __float128 obj;
    struct eqp_time_type_q time;
    struct fdc_inform_type_q fdc_inform;
    struct sbls_inform_type_q sbls_inform;
    struct gltr_inform_type_q gltr_inform;
};

struct eqp_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t cg_iter;
    int64_t cg_iter_inter;
    int64_t factorization_integer;
    int64_t factorization_real;
    __float128 obj;
    struct eqp_time_type_q time;
    struct fdc_inform_type_q_64 fdc_inform;
    struct sbls_inform_type_q_64 sbls_inform;
    struct gltr_inform_type_q_64 gltr_inform;
};

void eqp_initialize_q(void **data, struct eqp_control_type_q *control, int32_t *status);
void eqp_initialize_q_64(void **data, struct eqp_control_type_q_64 *control, int64_t *status);
void eqp_read_specfile_q(struct eqp_control_type_q *control, char *specfile);
void eqp_read_specfile_q_64(struct eqp_control_type_q_64 *control, char *specfile);
void eqp_import_q(struct eqp_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void eqp_import_q_64(struct eqp_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void eqp_reset_control_q(struct eqp_control_type_q *control, void **data, int32_t *status);
void eqp_reset_control_q_64(struct eqp_control_type_q_64 *control, void **data, int64_t *status);
void eqp_solve_qp_q(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, __float128 *H_val, __float128 *g, __float128 f, int32_t a_ne, __float128 *A_val, __float128 *c, __float128 *x, __float128 *y);
void eqp_solve_qp_q_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, __float128 *H_val, __float128 *g, __float128 f, int64_t a_ne, __float128 *A_val, __float128 *c, __float128 *x, __float128 *y);
void eqp_solve_sldqp_q(void **data, int32_t *status, int32_t n, int32_t m, __float128 *w, __float128 *x0, __float128 *g, __float128 f, int32_t a_ne, __float128 *A_val, __float128 *c, __float128 *x, __float128 *y);
void eqp_solve_sldqp_q_64(void **data, int64_t *status, int64_t n, int64_t m, __float128 *w, __float128 *x0, __float128 *g, __float128 f, int64_t a_ne, __float128 *A_val, __float128 *c, __float128 *x, __float128 *y);
void eqp_resolve_qp_q(void **data, int32_t *status, int32_t n, int32_t m, __float128 *g, __float128 f, __float128 *c, __float128 *x, __float128 *y);
void eqp_resolve_qp_q_64(void **data, int64_t *status, int64_t n, int64_t m, __float128 *g, __float128 f, __float128 *c, __float128 *x, __float128 *y);
void eqp_information_q(void **data, struct eqp_inform_type_q *inform, int32_t *status);
void eqp_information_q_64(void **data, struct eqp_inform_type_q_64 *inform, int64_t *status);
void eqp_terminate_q(void **data, struct eqp_control_type_q *control, struct eqp_inform_type_q *inform);
void eqp_terminate_q_64(void **data, struct eqp_control_type_q_64 *control, struct eqp_inform_type_q_64 *inform);

// C interface for LPA
struct lpa_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t max_iterative_refinements;
    int32_t min_real_factor_size;
    int32_t min_integer_factor_size;
    int32_t random_number_seed;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    __float128 infinity;
    __float128 tol_data;
    __float128 feas_tol;
    __float128 relative_pivot_tolerance;
    __float128 growth_limit;
    __float128 zero_tolerance;
    __float128 change_tolerance;
    __float128 identical_bounds_tol;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool scale;
    bool dual;
    bool warm_start;
    bool steepest_edge;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
};

struct lpa_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t max_iterative_refinements;
    int64_t min_real_factor_size;
    int64_t min_integer_factor_size;
    int64_t random_number_seed;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    __float128 infinity;
    __float128 tol_data;
    __float128 feas_tol;
    __float128 relative_pivot_tolerance;
    __float128 growth_limit;
    __float128 zero_tolerance;
    __float128 change_tolerance;
    __float128 identical_bounds_tol;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool scale;
    bool dual;
    bool warm_start;
    bool steepest_edge;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
};

struct lpa_time_type_q {
    __float128 total;
    __float128 preprocess;
    __float128 clock_total;
    __float128 clock_preprocess;
};

struct lpa_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t la04_job;
    int32_t la04_job_info;
    __float128 obj;
    __float128 primal_infeasibility;
    bool feasible;
    __float128 RINFO[40];
    struct lpa_time_type_q time;
    struct rpd_inform_type rpd_inform;
};

struct lpa_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t la04_job;
    int64_t la04_job_info;
    __float128 obj;
    __float128 primal_infeasibility;
    bool feasible;
    __float128 RINFO[40];
    struct lpa_time_type_q time;
    struct rpd_inform_type_64 rpd_inform;
};

void lpa_initialize_q(void **data, struct lpa_control_type_q *control, int32_t *status);
void lpa_initialize_q_64(void **data, struct lpa_control_type_q_64 *control, int64_t *status);
void lpa_read_specfile_q(struct lpa_control_type_q *control, char *specfile);
void lpa_read_specfile_q_64(struct lpa_control_type_q_64 *control, char *specfile);
void lpa_import_q(struct lpa_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void lpa_import_q_64(struct lpa_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void lpa_reset_control_q(struct lpa_control_type_q *control, void **data, int32_t *status);
void lpa_reset_control_q_64(struct lpa_control_type_q_64 *control, void **data, int64_t *status);
void lpa_solve_lp_q(void **data, int32_t *status, int32_t n, int32_t m, __float128 *g, __float128 f, int32_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat);
void lpa_solve_lp_q_64(void **data, int64_t *status, int64_t n, int64_t m, __float128 *g, __float128 f, int64_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat);
void lpa_information_q(void **data, struct lpa_inform_type_q *inform, int32_t *status);
void lpa_information_q_64(void **data, struct lpa_inform_type_q_64 *inform, int64_t *status);
void lpa_terminate_q(void **data, struct lpa_control_type_q *control, struct lpa_inform_type_q *inform);
void lpa_terminate_q_64(void **data, struct lpa_control_type_q_64 *control, struct lpa_inform_type_q_64 *inform);

// C interface for LPB
struct lpb_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 tau;
    __float128 gamma_c;
    __float128 gamma_f;
    __float128 reduce_infeas;
    __float128 obj_unbounded;
    __float128 potential_unbounded;
    __float128 identical_bounds_tol;
    __float128 mu_pounce;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_q fdc_control;
    struct sbls_control_type_q sbls_control;
    struct fit_control_type fit_control;
    struct roots_control_type_q roots_control;
    struct cro_control_type_q cro_control;
};

struct lpb_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 tau;
    __float128 gamma_c;
    __float128 gamma_f;
    __float128 reduce_infeas;
    __float128 obj_unbounded;
    __float128 potential_unbounded;
    __float128 identical_bounds_tol;
    __float128 mu_pounce;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_q_64 fdc_control;
    struct sbls_control_type_q_64 sbls_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_q_64 roots_control;
    struct cro_control_type_q_64 cro_control;
};

struct lpb_time_type_q {
    __float128 total;
    __float128 preprocess;
    __float128 find_dependent;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_find_dependent;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct lpb_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    __float128 init_primal_infeasibility;
    __float128 init_dual_infeasibility;
    __float128 init_complementary_slackness;
    __float128 potential;
    __float128 non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    __float128 checkpointsTime[16];
    struct lpb_time_type_q time;
    struct fdc_inform_type_q fdc_inform;
    struct sbls_inform_type_q sbls_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type_q cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct lpb_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    __float128 init_primal_infeasibility;
    __float128 init_dual_infeasibility;
    __float128 init_complementary_slackness;
    __float128 potential;
    __float128 non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    __float128 checkpointsTime[16];
    struct lpb_time_type_q time;
    struct fdc_inform_type_q_64 fdc_inform;
    struct sbls_inform_type_q_64 sbls_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_q_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void lpb_initialize_q(void **data, struct lpb_control_type_q *control, int32_t *status);
void lpb_initialize_q_64(void **data, struct lpb_control_type_q_64 *control, int64_t *status);
void lpb_read_specfile_q(struct lpb_control_type_q *control, char *specfile);
void lpb_read_specfile_q_64(struct lpb_control_type_q_64 *control, char *specfile);
void lpb_import_q(struct lpb_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void lpb_import_q_64(struct lpb_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void lpb_reset_control_q(struct lpb_control_type_q *control, void **data, int32_t *status);
void lpb_reset_control_q_64(struct lpb_control_type_q_64 *control, void **data, int64_t *status);
void lpb_solve_lp_q(void **data, int32_t *status, int32_t n, int32_t m, __float128 *g, __float128 f, int32_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat);
void lpb_solve_lp_q_64(void **data, int64_t *status, int64_t n, int64_t m, __float128 *g, __float128 f, int64_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat);
void lpb_information_q(void **data, struct lpb_inform_type_q *inform, int32_t *status);
void lpb_information_q_64(void **data, struct lpb_inform_type_q_64 *inform, int64_t *status);
void lpb_terminate_q(void **data, struct lpb_control_type_q *control, struct lpb_inform_type_q *inform);
void lpb_terminate_q_64(void **data, struct lpb_control_type_q_64 *control, struct lpb_inform_type_q_64 *inform);

// C interface for LSQP
struct lsqp_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t factor;
    int32_t max_col;
    int32_t indmin;
    int32_t valmin;
    int32_t itref_max;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t extrapolate;
    int32_t path_history;
    int32_t path_derivatives;
    int32_t fit_order;
    int32_t sif_file_device;
    __float128 infinity;
    __float128 stop_p;
    __float128 stop_d;
    __float128 stop_c;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 reduce_infeas;
    __float128 potential_unbounded;
    __float128 pivot_tol;
    __float128 pivot_tol_for_dependencies;
    __float128 zero_pivot;
    __float128 identical_bounds_tol;
    __float128 mu_min;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool feasol;
    bool balance_initial_complentarity;
    bool use_corrector;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct fdc_control_type_q fdc_control;
    struct sbls_control_type_q sbls_control;
};

struct lsqp_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t factor;
    int64_t max_col;
    int64_t indmin;
    int64_t valmin;
    int64_t itref_max;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t extrapolate;
    int64_t path_history;
    int64_t path_derivatives;
    int64_t fit_order;
    int64_t sif_file_device;
    __float128 infinity;
    __float128 stop_p;
    __float128 stop_d;
    __float128 stop_c;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 reduce_infeas;
    __float128 potential_unbounded;
    __float128 pivot_tol;
    __float128 pivot_tol_for_dependencies;
    __float128 zero_pivot;
    __float128 identical_bounds_tol;
    __float128 mu_min;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool feasol;
    bool balance_initial_complentarity;
    bool use_corrector;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct fdc_control_type_q_64 fdc_control;
    struct sbls_control_type_q_64 sbls_control;
};

struct lsqp_time_type_q {
    __float128 total;
    __float128 preprocess;
    __float128 find_dependent;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_find_dependent;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct lsqp_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    __float128 obj;
    __float128 potential;
    __float128 non_negligible_pivot;
    bool feasible;
    struct lsqp_time_type_q time;
    struct fdc_inform_type_q fdc_inform;
    struct sbls_inform_type_q sbls_inform;
};

struct lsqp_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    __float128 obj;
    __float128 potential;
    __float128 non_negligible_pivot;
    bool feasible;
    struct lsqp_time_type_q time;
    struct fdc_inform_type_q_64 fdc_inform;
    struct sbls_inform_type_q_64 sbls_inform;
};

void lsqp_initialize_q(void **data, struct lsqp_control_type_q *control, int32_t *status);
void lsqp_initialize_q_64(void **data, struct lsqp_control_type_q_64 *control, int64_t *status);
void lsqp_read_specfile_q(struct lsqp_control_type_q *control, char *specfile);
void lsqp_read_specfile_q_64(struct lsqp_control_type_q_64 *control, char *specfile);
void lsqp_import_q(struct lsqp_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void lsqp_import_q_64(struct lsqp_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void lsqp_reset_control_q(struct lsqp_control_type_q *control, void **data, int32_t *status);
void lsqp_reset_control_q_64(struct lsqp_control_type_q_64 *control, void **data, int64_t *status);
void lsqp_solve_qp_q(void **data, int32_t *status, int32_t n, int32_t m, __float128 *w, __float128 *x0, __float128 *g, __float128 f, int32_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat);
void lsqp_solve_qp_q_64(void **data, int64_t *status, int64_t n, int64_t m, __float128 *w, __float128 *x0, __float128 *g, __float128 f, int64_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat);
void lsqp_information_q(void **data, struct lsqp_inform_type_q *inform, int32_t *status);
void lsqp_information_q_64(void **data, struct lsqp_inform_type_q_64 *inform, int64_t *status);
void lsqp_terminate_q(void **data, struct lsqp_control_type_q *control, struct lsqp_inform_type_q *inform);
void lsqp_terminate_q_64(void **data, struct lsqp_control_type_q_64 *control, struct lsqp_inform_type_q_64 *inform);

// C interface for NLS
struct nls_subproblem_control_type_q {
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t jacobian_available;
    int32_t hessian_available;
    int32_t model;
    int32_t norm;
    int32_t non_monotone;
    int32_t weight_update_strategy;
    __float128 stop_c_absolute;
    __float128 stop_c_relative;
    __float128 stop_g_absolute;
    __float128 stop_g_relative;
    __float128 stop_s;
    __float128 power;
    __float128 initial_weight;
    __float128 minimum_weight;
    __float128 initial_inner_weight;
    __float128 eta_successful;
    __float128 eta_very_successful;
    __float128 eta_too_successful;
    __float128 weight_decrease_min;
    __float128 weight_decrease;
    __float128 weight_increase;
    __float128 weight_increase_max;
    __float128 reduce_gap;
    __float128 tiny_gap;
    __float128 large_root;
    __float128 switch_to_newton;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool subproblem_direct;
    bool renormalize_weight;
    bool magic_step;
    bool print_obj;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_q rqs_control;
    struct glrt_control_type_q glrt_control;
    struct psls_control_type_q psls_control;
    struct bsc_control_type bsc_control;
    struct roots_control_type_q roots_control;
};

struct nls_subproblem_control_type_q_64 {
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t jacobian_available;
    int64_t hessian_available;
    int64_t model;
    int64_t norm;
    int64_t non_monotone;
    int64_t weight_update_strategy;
    __float128 stop_c_absolute;
    __float128 stop_c_relative;
    __float128 stop_g_absolute;
    __float128 stop_g_relative;
    __float128 stop_s;
    __float128 power;
    __float128 initial_weight;
    __float128 minimum_weight;
    __float128 initial_inner_weight;
    __float128 eta_successful;
    __float128 eta_very_successful;
    __float128 eta_too_successful;
    __float128 weight_decrease_min;
    __float128 weight_decrease;
    __float128 weight_increase;
    __float128 weight_increase_max;
    __float128 reduce_gap;
    __float128 tiny_gap;
    __float128 large_root;
    __float128 switch_to_newton;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool subproblem_direct;
    bool renormalize_weight;
    bool magic_step;
    bool print_obj;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_q_64 rqs_control;
    struct glrt_control_type_q_64 glrt_control;
    struct psls_control_type_q_64 psls_control;
    struct bsc_control_type_64 bsc_control;
    struct roots_control_type_q_64 roots_control;
};

struct nls_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t jacobian_available;
    int32_t hessian_available;
    int32_t model;
    int32_t norm;
    int32_t non_monotone;
    int32_t weight_update_strategy;
    __float128 stop_c_absolute;
    __float128 stop_c_relative;
    __float128 stop_g_absolute;
    __float128 stop_g_relative;
    __float128 stop_s;
    __float128 power;
    __float128 initial_weight;
    __float128 minimum_weight;
    __float128 initial_inner_weight;
    __float128 eta_successful;
    __float128 eta_very_successful;
    __float128 eta_too_successful;
    __float128 weight_decrease_min;
    __float128 weight_decrease;
    __float128 weight_increase;
    __float128 weight_increase_max;
    __float128 reduce_gap;
    __float128 tiny_gap;
    __float128 large_root;
    __float128 switch_to_newton;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool subproblem_direct;
    bool renormalize_weight;
    bool magic_step;
    bool print_obj;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_q rqs_control;
    struct glrt_control_type_q glrt_control;
    struct psls_control_type_q psls_control;
    struct bsc_control_type bsc_control;
    struct roots_control_type_q roots_control;
    struct nls_subproblem_control_type_q subproblem_control;
};

struct nls_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t jacobian_available;
    int64_t hessian_available;
    int64_t model;
    int64_t norm;
    int64_t non_monotone;
    int64_t weight_update_strategy;
    __float128 stop_c_absolute;
    __float128 stop_c_relative;
    __float128 stop_g_absolute;
    __float128 stop_g_relative;
    __float128 stop_s;
    __float128 power;
    __float128 initial_weight;
    __float128 minimum_weight;
    __float128 initial_inner_weight;
    __float128 eta_successful;
    __float128 eta_very_successful;
    __float128 eta_too_successful;
    __float128 weight_decrease_min;
    __float128 weight_decrease;
    __float128 weight_increase;
    __float128 weight_increase_max;
    __float128 reduce_gap;
    __float128 tiny_gap;
    __float128 large_root;
    __float128 switch_to_newton;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool subproblem_direct;
    bool renormalize_weight;
    bool magic_step;
    bool print_obj;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_q_64 rqs_control;
    struct glrt_control_type_q_64 glrt_control;
    struct psls_control_type_q_64 psls_control;
    struct bsc_control_type_64 bsc_control;
    struct roots_control_type_q_64 roots_control;
    struct nls_subproblem_control_type_q_64 subproblem_control;
};

struct nls_time_type_q {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct nls_subproblem_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int32_t iter;
    int32_t cg_iter;
    int32_t c_eval;
    int32_t j_eval;
    int32_t h_eval;
    int32_t factorization_max;
    int32_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    __float128 factorization_average;
    __float128 obj;
    __float128 norm_c;
    __float128 norm_g;
    __float128 weight;
    struct nls_time_type_q time;
    struct rqs_inform_type_q rqs_inform;
    struct glrt_inform_type_q glrt_inform;
    struct psls_inform_type_q psls_inform;
    struct bsc_inform_type_q bsc_inform;
    struct roots_inform_type roots_inform;
};

struct nls_subproblem_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int64_t iter;
    int64_t cg_iter;
    int64_t c_eval;
    int64_t j_eval;
    int64_t h_eval;
    int64_t factorization_max;
    int64_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    __float128 factorization_average;
    __float128 obj;
    __float128 norm_c;
    __float128 norm_g;
    __float128 weight;
    struct nls_time_type_q time;
    struct rqs_inform_type_q_64 rqs_inform;
    struct glrt_inform_type_q_64 glrt_inform;
    struct psls_inform_type_q_64 psls_inform;
    struct bsc_inform_type_q_64 bsc_inform;
    struct roots_inform_type_64 roots_inform;
};

struct nls_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int32_t iter;
    int32_t cg_iter;
    int32_t c_eval;
    int32_t j_eval;
    int32_t h_eval;
    int32_t factorization_max;
    int32_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    __float128 factorization_average;
    __float128 obj;
    __float128 norm_c;
    __float128 norm_g;
    __float128 weight;
    struct nls_time_type_q time;
    struct rqs_inform_type_q rqs_inform;
    struct glrt_inform_type_q glrt_inform;
    struct psls_inform_type_q psls_inform;
    struct bsc_inform_type_q bsc_inform;
    struct roots_inform_type roots_inform;
    struct nls_subproblem_inform_type_q subproblem_inform;
};

struct nls_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int64_t iter;
    int64_t cg_iter;
    int64_t c_eval;
    int64_t j_eval;
    int64_t h_eval;
    int64_t factorization_max;
    int64_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    __float128 factorization_average;
    __float128 obj;
    __float128 norm_c;
    __float128 norm_g;
    __float128 weight;
    struct nls_time_type_q time;
    struct rqs_inform_type_q_64 rqs_inform;
    struct glrt_inform_type_q_64 glrt_inform;
    struct psls_inform_type_q_64 psls_inform;
    struct bsc_inform_type_q_64 bsc_inform;
    struct roots_inform_type_64 roots_inform;
    struct nls_subproblem_inform_type_q_64 subproblem_inform;
};

void nls_initialize_q(void **data, struct nls_control_type_q *control, struct nls_inform_type_q *inform);
void nls_initialize_q_64(void **data, struct nls_control_type_q_64 *control, struct nls_inform_type_q_64 *inform);
void nls_read_specfile_q(struct nls_control_type_q *control, char *specfile);
void nls_read_specfile_q_64(struct nls_control_type_q_64 *control, char *specfile);
void nls_import_q(struct nls_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *J_type, int32_t J_ne, int32_t *J_row, int32_t *J_col, int32_t *J_ptr, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *P_type, int32_t P_ne, int32_t *P_row, int32_t *P_col, int32_t *P_ptr, __float128 *w);
void nls_import_q_64(struct nls_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *J_type, int64_t J_ne, int64_t *J_row, int64_t *J_col, int64_t *J_ptr, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *P_type, int64_t P_ne, int64_t *P_row, int64_t *P_col, int64_t *P_ptr, __float128 *w);
void nls_reset_control_q(struct nls_control_type_q *control, void **data, int32_t *status);
void nls_reset_control_q_64(struct nls_control_type_q_64 *control, void **data, int64_t *status);
void nls_solve_with_mat_q(void **data, void *userdata, int32_t *status, int32_t n, int32_t m, __float128 *x, __float128 *c, __float128 *g, galahad_r_q *eval_r, int32_t j_ne, galahad_jr_q *eval_jr, int32_t h_ne, galahad_hr_q *eval_hr, int32_t p_ne, galahad_shrprod_q *eval_shrprod);
void nls_solve_with_mat_q_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t m, __float128 *x, __float128 *c, __float128 *g, galahad_r_q_64 *eval_r, int64_t j_ne, galahad_jr_q_64 *eval_jr, int64_t h_ne, galahad_hr_q_64 *eval_hr, int64_t p_ne, galahad_shrprod_q_64 *eval_shrprod);
void nls_solve_without_mat_q(void **data, void *userdata, int32_t *status, int32_t n, int32_t m, __float128 *x, __float128 *c, __float128 *g, galahad_r_q *eval_r, galahad_jrprod_q *eval_jrprod, galahad_hrprod_q *eval_hrprod, int32_t p_ne, galahad_shrprod_q *eval_shrprod);
void nls_solve_without_mat_q_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t m, __float128 *x, __float128 *c, __float128 *g, galahad_r_q_64 *eval_r, galahad_jrprod_q_64 *eval_jrprod, galahad_hrprod_q_64 *eval_hrprod, int64_t p_ne, galahad_shrprod_q_64 *eval_shrprod);
void nls_solve_reverse_with_mat_q(void **data, int32_t *status, int32_t *eval_status, int32_t n, int32_t m, __float128 *x, __float128 *c, __float128 *g, int32_t j_ne, __float128 *J_val, __float128 *y, int32_t h_ne, __float128 *H_val, __float128 *v, int32_t p_ne, __float128 *P_val);
void nls_solve_reverse_with_mat_q_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, int64_t m, __float128 *x, __float128 *c, __float128 *g, int64_t j_ne, __float128 *J_val, __float128 *y, int64_t h_ne, __float128 *H_val, __float128 *v, int64_t p_ne, __float128 *P_val);
void nls_solve_reverse_without_mat_q(void **data, int32_t *status, int32_t *eval_status, int32_t n, int32_t m, __float128 *x, __float128 *c, __float128 *g, bool *transpose, __float128 *u, __float128 *v, __float128 *y, int32_t p_ne, __float128 *P_val);
void nls_solve_reverse_without_mat_q_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, int64_t m, __float128 *x, __float128 *c, __float128 *g, bool *transpose, __float128 *u, __float128 *v, __float128 *y, int64_t p_ne, __float128 *P_val);
void nls_information_q(void **data, struct nls_inform_type_q *inform, int32_t *status);
void nls_information_q_64(void **data, struct nls_inform_type_q_64 *inform, int64_t *status);
void nls_terminate_q(void **data, struct nls_control_type_q *control, struct nls_inform_type_q *inform);
void nls_terminate_q_64(void **data, struct nls_control_type_q_64 *control, struct nls_inform_type_q_64 *inform);

// C interface for QPA
struct qpa_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t factor;
    int32_t max_col;
    int32_t max_sc;
    int32_t indmin;
    int32_t valmin;
    int32_t itref_max;
    int32_t infeas_check_interval;
    int32_t cg_maxit;
    int32_t precon;
    int32_t nsemib;
    int32_t full_max_fill;
    int32_t deletion_strategy;
    int32_t restore_problem;
    int32_t monitor_residuals;
    int32_t cold_start;
    int32_t sif_file_device;
    __float128 infinity;
    __float128 feas_tol;
    __float128 obj_unbounded;
    __float128 increase_rho_g_factor;
    __float128 infeas_g_improved_by_factor;
    __float128 increase_rho_b_factor;
    __float128 infeas_b_improved_by_factor;
    __float128 pivot_tol;
    __float128 pivot_tol_for_dependencies;
    __float128 zero_pivot;
    __float128 inner_stop_relative;
    __float128 inner_stop_absolute;
    __float128 multiplier_tol;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool treat_zero_bounds_as_general;
    bool solve_qp;
    bool solve_within_bounds;
    bool randomize;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char prefix[31];
    bool each_interval;
    struct sls_control_type_q sls_control;
};

struct qpa_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t factor;
    int64_t max_col;
    int64_t max_sc;
    int64_t indmin;
    int64_t valmin;
    int64_t itref_max;
    int64_t infeas_check_interval;
    int64_t cg_maxit;
    int64_t precon;
    int64_t nsemib;
    int64_t full_max_fill;
    int64_t deletion_strategy;
    int64_t restore_problem;
    int64_t monitor_residuals;
    int64_t cold_start;
    int64_t sif_file_device;
    __float128 infinity;
    __float128 feas_tol;
    __float128 obj_unbounded;
    __float128 increase_rho_g_factor;
    __float128 infeas_g_improved_by_factor;
    __float128 increase_rho_b_factor;
    __float128 infeas_b_improved_by_factor;
    __float128 pivot_tol;
    __float128 pivot_tol_for_dependencies;
    __float128 zero_pivot;
    __float128 inner_stop_relative;
    __float128 inner_stop_absolute;
    __float128 multiplier_tol;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool treat_zero_bounds_as_general;
    bool solve_qp;
    bool solve_within_bounds;
    bool randomize;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char prefix[31];
    bool each_interval;
    struct sls_control_type_q_64 sls_control;
};

struct qpa_time_type_q {
    __float128 total;
    __float128 preprocess;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct qpa_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t major_iter;
    int32_t iter;
    int32_t cg_iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nmods;
    int32_t num_g_infeas;
    int32_t num_b_infeas;
    __float128 obj;
    __float128 infeas_g;
    __float128 infeas_b;
    __float128 merit;
    struct qpa_time_type_q time;
    struct sls_inform_type_q sls_inform;
};

struct qpa_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t major_iter;
    int64_t iter;
    int64_t cg_iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nmods;
    int64_t num_g_infeas;
    int64_t num_b_infeas;
    __float128 obj;
    __float128 infeas_g;
    __float128 infeas_b;
    __float128 merit;
    struct qpa_time_type_q time;
    struct sls_inform_type_q_64 sls_inform;
};

void qpa_initialize_q(void **data, struct qpa_control_type_q *control, int32_t *status);
void qpa_initialize_q_64(void **data, struct qpa_control_type_q_64 *control, int64_t *status);
void qpa_read_specfile_q(struct qpa_control_type_q *control, char *specfile);
void qpa_read_specfile_q_64(struct qpa_control_type_q_64 *control, char *specfile);
void qpa_import_q(struct qpa_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void qpa_import_q_64(struct qpa_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void qpa_reset_control_q(struct qpa_control_type_q *control, void **data, int32_t *status);
void qpa_reset_control_q_64(struct qpa_control_type_q_64 *control, void **data, int64_t *status);
void qpa_solve_qp_q(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, __float128 *H_val, __float128 *g, __float128 f, int32_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat);
void qpa_solve_qp_q_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, __float128 *H_val, __float128 *g, __float128 f, int64_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat);
void qpa_solve_l1qp_q(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, __float128 *H_val, __float128 *g, __float128 f, __float128 rho_g, __float128 rho_b, int32_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat);
void qpa_solve_l1qp_q_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, __float128 *H_val, __float128 *g, __float128 f, __float128 rho_g, __float128 rho_b, int64_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat);
void qpa_solve_bcl1qp_q(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, __float128 *H_val, __float128 *g, __float128 f, __float128 rho_g, int32_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat);
void qpa_solve_bcl1qp_q_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, __float128 *H_val, __float128 *g, __float128 f, __float128 rho_g, int64_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat);
void qpa_information_q(void **data, struct qpa_inform_type_q *inform, int32_t *status);
void qpa_information_q_64(void **data, struct qpa_inform_type_q_64 *inform, int64_t *status);
void qpa_terminate_q(void **data, struct qpa_control_type_q *control, struct qpa_inform_type_q *inform);
void qpa_terminate_q_64(void **data, struct qpa_control_type_q_64 *control, struct qpa_inform_type_q_64 *inform);

// C interface for QPB
struct qpb_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t itref_max;
    int32_t cg_maxit;
    int32_t indicator_type;
    int32_t restore_problem;
    int32_t extrapolate;
    int32_t path_history;
    int32_t factor;
    int32_t max_col;
    int32_t indmin;
    int32_t valmin;
    int32_t infeas_max;
    int32_t precon;
    int32_t nsemib;
    int32_t path_derivatives;
    int32_t fit_order;
    int32_t sif_file_device;
    __float128 infinity;
    __float128 stop_p;
    __float128 stop_d;
    __float128 stop_c;
    __float128 theta_d;
    __float128 theta_c;
    __float128 beta;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 reduce_infeas;
    __float128 obj_unbounded;
    __float128 pivot_tol;
    __float128 pivot_tol_for_dependencies;
    __float128 zero_pivot;
    __float128 identical_bounds_tol;
    __float128 inner_stop_relative;
    __float128 inner_stop_absolute;
    __float128 initial_radius;
    __float128 mu_min;
    __float128 inner_fraction_opt;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool center;
    bool primal;
    bool puiseux;
    bool feasol;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct lsqp_control_type_q lsqp_control;
    struct fdc_control_type_q fdc_control;
    struct sbls_control_type_q sbls_control;
    struct gltr_control_type_q gltr_control;
    struct fit_control_type fit_control;
};

struct qpb_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t itref_max;
    int64_t cg_maxit;
    int64_t indicator_type;
    int64_t restore_problem;
    int64_t extrapolate;
    int64_t path_history;
    int64_t factor;
    int64_t max_col;
    int64_t indmin;
    int64_t valmin;
    int64_t infeas_max;
    int64_t precon;
    int64_t nsemib;
    int64_t path_derivatives;
    int64_t fit_order;
    int64_t sif_file_device;
    __float128 infinity;
    __float128 stop_p;
    __float128 stop_d;
    __float128 stop_c;
    __float128 theta_d;
    __float128 theta_c;
    __float128 beta;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 reduce_infeas;
    __float128 obj_unbounded;
    __float128 pivot_tol;
    __float128 pivot_tol_for_dependencies;
    __float128 zero_pivot;
    __float128 identical_bounds_tol;
    __float128 inner_stop_relative;
    __float128 inner_stop_absolute;
    __float128 initial_radius;
    __float128 mu_min;
    __float128 inner_fraction_opt;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool center;
    bool primal;
    bool puiseux;
    bool feasol;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct lsqp_control_type_q_64 lsqp_control;
    struct fdc_control_type_q_64 fdc_control;
    struct sbls_control_type_q_64 sbls_control;
    struct gltr_control_type_q_64 gltr_control;
    struct fit_control_type_64 fit_control;
};

struct qpb_time_type_q {
    __float128 total;
    __float128 preprocess;
    __float128 find_dependent;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 phase1_total;
    __float128 phase1_analyse;
    __float128 phase1_factorize;
    __float128 phase1_solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_find_dependent;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
    __float128 clock_phase1_total;
    __float128 clock_phase1_analyse;
    __float128 clock_phase1_factorize;
    __float128 clock_phase1_solve;
};

struct qpb_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t nmods;
    __float128 obj;
    __float128 non_negligible_pivot;
    bool feasible;
    struct qpb_time_type_q time;
    struct lsqp_inform_type_q lsqp_inform;
    struct fdc_inform_type_q fdc_inform;
    struct sbls_inform_type_q sbls_inform;
    struct gltr_inform_type_q gltr_inform;
    struct fit_inform_type fit_inform;
};

struct qpb_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t nmods;
    __float128 obj;
    __float128 non_negligible_pivot;
    bool feasible;
    struct qpb_time_type_q time;
    struct lsqp_inform_type_q_64 lsqp_inform;
    struct fdc_inform_type_q_64 fdc_inform;
    struct sbls_inform_type_q_64 sbls_inform;
    struct gltr_inform_type_q_64 gltr_inform;
    struct fit_inform_type_64 fit_inform;
};

void qpb_initialize_q(void **data, struct qpb_control_type_q *control, int32_t *status);
void qpb_initialize_q_64(void **data, struct qpb_control_type_q_64 *control, int64_t *status);
void qpb_read_specfile_q(struct qpb_control_type_q *control, char *specfile);
void qpb_read_specfile_q_64(struct qpb_control_type_q_64 *control, char *specfile);
void qpb_import_q(struct qpb_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void qpb_import_q_64(struct qpb_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void qpb_reset_control_q(struct qpb_control_type_q *control, void **data, int32_t *status);
void qpb_reset_control_q_64(struct qpb_control_type_q_64 *control, void **data, int64_t *status);
void qpb_solve_qp_q(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, __float128 *H_val, __float128 *g, __float128 f, int32_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int32_t *x_stat, int32_t *c_stat);
void qpb_solve_qp_q_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, __float128 *H_val, __float128 *g, __float128 f, int64_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y, __float128 *z, int64_t *x_stat, int64_t *c_stat);
void qpb_information_q(void **data, struct qpb_inform_type_q *inform, int32_t *status);
void qpb_information_q_64(void **data, struct qpb_inform_type_q_64 *inform, int64_t *status);
void qpb_terminate_q(void **data, struct qpb_control_type_q *control, struct qpb_inform_type_q *inform);
void qpb_terminate_q_64(void **data, struct qpb_control_type_q_64 *control, struct qpb_inform_type_q_64 *inform);

// C interface for SLLS
struct slls_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t cold_start;
    int32_t preconditioner;
    int32_t ratio_cg_vs_sd;
    int32_t change_max;
    int32_t cg_maxit;
    int32_t arcsearch_max_steps;
    int32_t sif_file_device;
    __float128 weight;
    __float128 stop_d;
    __float128 stop_cg_relative;
    __float128 stop_cg_absolute;
    __float128 alpha_max;
    __float128 alpha_initial;
    __float128 alpha_reduction;
    __float128 arcsearch_acceptance_tol;
    __float128 stabilisation_weight;
    __float128 cpu_time_limit;
    bool direct_subproblem_solve;
    bool exact_arc_search;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_q sbls_control;
    struct convert_control_type convert_control;
};

struct slls_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t cold_start;
    int64_t preconditioner;
    int64_t ratio_cg_vs_sd;
    int64_t change_max;
    int64_t cg_maxit;
    int64_t arcsearch_max_steps;
    int64_t sif_file_device;
    __float128 weight;
    __float128 stop_d;
    __float128 stop_cg_relative;
    __float128 stop_cg_absolute;
    __float128 alpha_max;
    __float128 alpha_initial;
    __float128 alpha_reduction;
    __float128 arcsearch_acceptance_tol;
    __float128 stabilisation_weight;
    __float128 cpu_time_limit;
    bool direct_subproblem_solve;
    bool exact_arc_search;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_q_64 sbls_control;
    struct convert_control_type_64 convert_control;
};

struct slls_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    int32_t factorization_status;
    int32_t iter;
    int32_t cg_iter;
    __float128 obj;
    __float128 norm_pg;
    char bad_alloc[81];
    struct slls_time_type time;
    struct sbls_inform_type_q sbls_inform;
    struct convert_inform_type_q convert_inform;
};

struct slls_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorization_status;
    int64_t iter;
    int64_t cg_iter;
    __float128 obj;
    __float128 norm_pg;
    char bad_alloc[81];
    struct slls_time_type time;
    struct sbls_inform_type_q_64 sbls_inform;
    struct convert_inform_type_q_64 convert_inform;
};

void slls_initialize_q(void **data, struct slls_control_type_q *control, int32_t *status);
void slls_initialize_q_64(void **data, struct slls_control_type_q_64 *control, int64_t *status);
void slls_read_specfile_q(struct slls_control_type_q *control, char *specfile);
void slls_read_specfile_q_64(struct slls_control_type_q_64 *control, char *specfile);
void slls_import_q(struct slls_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *Ao_type, int32_t Ao_ne, int32_t *Ao_row, int32_t *Ao_col, int32_t Ao_ptr_ne, int32_t *Ao_ptr);
void slls_import_q_64(struct slls_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *Ao_type, int64_t Ao_ne, int64_t *Ao_row, int64_t *Ao_col, int64_t Ao_ptr_ne, int64_t *Ao_ptr);
void slls_import_without_a_q(struct slls_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t o);
void slls_import_without_a_q_64(struct slls_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t o);
void slls_reset_control_q(struct slls_control_type_q *control, void **data, int32_t *status);
void slls_reset_control_q_64(struct slls_control_type_q_64 *control, void **data, int64_t *status);
void slls_solve_given_a_q(void **data, void *userdata, int32_t *status, int32_t n, int32_t o, int32_t Ao_ne, __float128 *Ao_val, __float128 *b, __float128 *x, __float128 *z, __float128 *r, __float128 *g, int32_t *x_stat, galahad_constant_prec_q *eval_prec);
void slls_solve_given_a_q_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t o, int64_t Ao_ne, __float128 *Ao_val, __float128 *b, __float128 *x, __float128 *z, __float128 *r, __float128 *g, int64_t *x_stat, galahad_constant_prec_q_64 *eval_prec);
void slls_solve_reverse_a_prod_q(void **data, int32_t *status, int32_t *eval_status, int32_t n, int32_t o, __float128 *b, __float128 *x, __float128 *z, __float128 *r, __float128 *g, int32_t *x_stat, __float128 *v, __float128 *p, int32_t *nz_v, int32_t *nz_v_start, int32_t *nz_v_end, int32_t *nz_p, int32_t nz_p_end);
void slls_solve_reverse_a_prod_q_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, int64_t o, __float128 *b, __float128 *x, __float128 *z, __float128 *r, __float128 *g, int64_t *x_stat, __float128 *v, __float128 *p, int64_t *nz_v, int64_t *nz_v_start, int64_t *nz_v_end, int64_t *nz_p, int64_t nz_p_end);
void slls_information_q(void **data, struct slls_inform_type_q *inform, int32_t *status);
void slls_information_q_64(void **data, struct slls_inform_type_q_64 *inform, int64_t *status);
void slls_terminate_q(void **data, struct slls_control_type_q *control, struct slls_inform_type_q *inform);
void slls_terminate_q_64(void **data, struct slls_control_type_q_64 *control, struct slls_inform_type_q_64 *inform);

// C interface for TRU
struct tru_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t non_monotone;
    int32_t model;
    int32_t norm;
    int32_t semi_bandwidth;
    int32_t lbfgs_vectors;
    int32_t max_dxg;
    int32_t icfs_vectors;
    int32_t mi28_lsize;
    int32_t mi28_rsize;
    int32_t advanced_start;
    __float128 stop_g_absolute;
    __float128 stop_g_relative;
    __float128 stop_s;
    __float128 initial_radius;
    __float128 maximum_radius;
    __float128 eta_successful;
    __float128 eta_very_successful;
    __float128 eta_too_successful;
    __float128 radius_increase;
    __float128 radius_reduce;
    __float128 radius_reduce_max;
    __float128 obj_unbounded;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool retrospective_trust_region;
    bool renormalize_radius;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct trs_control_type_q trs_control;
    struct gltr_control_type_q gltr_control;
    struct dps_control_type_q dps_control;
    struct psls_control_type_q psls_control;
    struct lms_control_type lms_control;
    struct lms_control_type lms_control_prec;
    struct sec_control_type_q sec_control;
    struct sha_control_type sha_control;
};

struct tru_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t non_monotone;
    int64_t model;
    int64_t norm;
    int64_t semi_bandwidth;
    int64_t lbfgs_vectors;
    int64_t max_dxg;
    int64_t icfs_vectors;
    int64_t mi28_lsize;
    int64_t mi28_rsize;
    int64_t advanced_start;
    __float128 stop_g_absolute;
    __float128 stop_g_relative;
    __float128 stop_s;
    __float128 initial_radius;
    __float128 maximum_radius;
    __float128 eta_successful;
    __float128 eta_very_successful;
    __float128 eta_too_successful;
    __float128 radius_increase;
    __float128 radius_reduce;
    __float128 radius_reduce_max;
    __float128 obj_unbounded;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool retrospective_trust_region;
    bool renormalize_radius;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct trs_control_type_q_64 trs_control;
    struct gltr_control_type_q_64 gltr_control;
    struct dps_control_type_q_64 dps_control;
    struct psls_control_type_q_64 psls_control;
    struct lms_control_type_64 lms_control;
    struct lms_control_type_64 lms_control_prec;
    struct sec_control_type_q_64 sec_control;
    struct sha_control_type_64 sha_control;
};

struct tru_time_type_q {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct tru_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    int32_t factorization_max;
    int32_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    __float128 factorization_average;
    __float128 obj;
    __float128 norm_g;
    __float128 radius;
    struct tru_time_type_q time;
    struct trs_inform_type_q trs_inform;
    struct gltr_inform_type_q gltr_inform;
    struct dps_inform_type_q dps_inform;
    struct psls_inform_type_q psls_inform;
    struct lms_inform_type_q lms_inform;
    struct lms_inform_type_q lms_inform_prec;
    struct sec_inform_type sec_inform;
    struct sha_inform_type_q sha_inform;
};

struct tru_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    int64_t factorization_max;
    int64_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    __float128 factorization_average;
    __float128 obj;
    __float128 norm_g;
    __float128 radius;
    struct tru_time_type_q time;
    struct trs_inform_type_q_64 trs_inform;
    struct gltr_inform_type_q_64 gltr_inform;
    struct dps_inform_type_q_64 dps_inform;
    struct psls_inform_type_q_64 psls_inform;
    struct lms_inform_type_q_64 lms_inform;
    struct lms_inform_type_q_64 lms_inform_prec;
    struct sec_inform_type_64 sec_inform;
    struct sha_inform_type_q_64 sha_inform;
};

void tru_initialize_q(void **data, struct tru_control_type_q *control, int32_t *status);
void tru_initialize_q_64(void **data, struct tru_control_type_q_64 *control, int64_t *status);
void tru_read_specfile_q(struct tru_control_type_q *control, char *specfile);
void tru_read_specfile_q_64(struct tru_control_type_q_64 *control, char *specfile);
void tru_import_q(struct tru_control_type_q *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void tru_import_q_64(struct tru_control_type_q_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void tru_reset_control_q(struct tru_control_type_q *control, void **data, int32_t *status);
void tru_reset_control_q_64(struct tru_control_type_q_64 *control, void **data, int64_t *status);
void tru_solve_with_mat_q(void **data, void *userdata, int32_t *status, int32_t n, __float128 *x, __float128 *g, int32_t ne, galahad_f_q *eval_f, galahad_g_q *eval_g, galahad_h_q *eval_h, galahad_prec_q *eval_prec);
void tru_solve_with_mat_q_64(void **data, void *userdata, int64_t *status, int64_t n, __float128 *x, __float128 *g, int64_t ne, galahad_f_q_64 *eval_f, galahad_g_q_64 *eval_g, galahad_h_q_64 *eval_h, galahad_prec_q_64 *eval_prec);
void tru_solve_without_mat_q(void **data, void *userdata, int32_t *status, int32_t n, __float128 *x, __float128 *g, galahad_f_q *eval_f, galahad_g_q *eval_g, galahad_hprod_q *eval_hprod, galahad_prec_q *eval_prec);
void tru_solve_without_mat_q_64(void **data, void *userdata, int64_t *status, int64_t n, __float128 *x, __float128 *g, galahad_f_q_64 *eval_f, galahad_g_q_64 *eval_g, galahad_hprod_q_64 *eval_hprod, galahad_prec_q_64 *eval_prec);
void tru_solve_reverse_with_mat_q(void **data, int32_t *status, int32_t *eval_status, int32_t n, __float128 *x, __float128 f, __float128 *g, int32_t ne, __float128 *H_val, __float128 *u, __float128 *v);
void tru_solve_reverse_with_mat_q_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, __float128 *x, __float128 f, __float128 *g, int64_t ne, __float128 *H_val, __float128 *u, __float128 *v);
void tru_solve_reverse_without_mat_q(void **data, int32_t *status, int32_t *eval_status, int32_t n, __float128 *x, __float128 f, __float128 *g, __float128 *u, __float128 *v);
void tru_solve_reverse_without_mat_q_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, __float128 *x, __float128 f, __float128 *g, __float128 *u, __float128 *v);
void tru_information_q(void **data, struct tru_inform_type_q *inform, int32_t *status);
void tru_information_q_64(void **data, struct tru_inform_type_q_64 *inform, int64_t *status);
void tru_terminate_q(void **data, struct tru_control_type_q *control, struct tru_inform_type_q *inform);
void tru_terminate_q_64(void **data, struct tru_control_type_q_64 *control, struct tru_inform_type_q_64 *inform);

// C interface for WCP
struct wcp_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t initial_point;
    int32_t factor;
    int32_t max_col;
    int32_t indmin;
    int32_t valmin;
    int32_t itref_max;
    int32_t infeas_max;
    int32_t perturbation_strategy;
    int32_t restore_problem;
    __float128 infinity;
    __float128 stop_p;
    __float128 stop_d;
    __float128 stop_c;
    __float128 prfeas;
    __float128 dufeas;
    __float128 mu_target;
    __float128 mu_accept_fraction;
    __float128 mu_increase_factor;
    __float128 required_infeas_reduction;
    __float128 implicit_tol;
    __float128 pivot_tol;
    __float128 pivot_tol_for_dependencies;
    __float128 zero_pivot;
    __float128 perturb_start;
    __float128 alpha_scale;
    __float128 identical_bounds_tol;
    __float128 reduce_perturb_factor;
    __float128 reduce_perturb_multiplier;
    __float128 insufficiently_feasible;
    __float128 perturbation_small;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool balance_initial_complementarity;
    bool use_corrector;
    bool space_critical;
    bool deallocate_error_fatal;
    bool record_x_status;
    bool record_c_status;
    char prefix[31];
    struct fdc_control_type_q fdc_control;
    struct sbls_control_type_q sbls_control;
};

struct wcp_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t initial_point;
    int64_t factor;
    int64_t max_col;
    int64_t indmin;
    int64_t valmin;
    int64_t itref_max;
    int64_t infeas_max;
    int64_t perturbation_strategy;
    int64_t restore_problem;
    __float128 infinity;
    __float128 stop_p;
    __float128 stop_d;
    __float128 stop_c;
    __float128 prfeas;
    __float128 dufeas;
    __float128 mu_target;
    __float128 mu_accept_fraction;
    __float128 mu_increase_factor;
    __float128 required_infeas_reduction;
    __float128 implicit_tol;
    __float128 pivot_tol;
    __float128 pivot_tol_for_dependencies;
    __float128 zero_pivot;
    __float128 perturb_start;
    __float128 alpha_scale;
    __float128 identical_bounds_tol;
    __float128 reduce_perturb_factor;
    __float128 reduce_perturb_multiplier;
    __float128 insufficiently_feasible;
    __float128 perturbation_small;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool balance_initial_complementarity;
    bool use_corrector;
    bool space_critical;
    bool deallocate_error_fatal;
    bool record_x_status;
    bool record_c_status;
    char prefix[31];
    struct fdc_control_type_q_64 fdc_control;
    struct sbls_control_type_q_64 sbls_control;
};

struct wcp_time_type_q {
    __float128 total;
    __float128 preprocess;
    __float128 find_dependent;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_find_dependent;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct wcp_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t c_implicit;
    int32_t x_implicit;
    int32_t y_implicit;
    int32_t z_implicit;
    __float128 obj;
    __float128 mu_final_target_max;
    __float128 non_negligible_pivot;
    bool feasible;
    struct wcp_time_type_q time;
    struct fdc_inform_type_q fdc_inform;
    struct sbls_inform_type_q sbls_inform;
};

struct wcp_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t c_implicit;
    int64_t x_implicit;
    int64_t y_implicit;
    int64_t z_implicit;
    __float128 obj;
    __float128 mu_final_target_max;
    __float128 non_negligible_pivot;
    bool feasible;
    struct wcp_time_type_q time;
    struct fdc_inform_type_q_64 fdc_inform;
    struct sbls_inform_type_q_64 sbls_inform;
};

void wcp_initialize_q(void **data, struct wcp_control_type_q *control, int32_t *status);
void wcp_initialize_q_64(void **data, struct wcp_control_type_q_64 *control, int64_t *status);
void wcp_read_specfile_q(struct wcp_control_type_q *control, char *specfile);
void wcp_read_specfile_q_64(struct wcp_control_type_q_64 *control, char *specfile);
void wcp_import_q(struct wcp_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void wcp_import_q_64(struct wcp_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void wcp_reset_control_q(struct wcp_control_type_q *control, void **data, int32_t *status);
void wcp_reset_control_q_64(struct wcp_control_type_q_64 *control, void **data, int64_t *status);
void wcp_find_wcp_q(void **data, int32_t *status, int32_t n, int32_t m, __float128 *g, int32_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y_l, __float128 *y_u, __float128 *z_l, __float128 *z_u, int32_t *x_stat, int32_t *c_stat);
void wcp_find_wcp_q_64(void **data, int64_t *status, int64_t n, int64_t m, __float128 *g, int64_t a_ne, __float128 *A_val, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *c, __float128 *y_l, __float128 *y_u, __float128 *z_l, __float128 *z_u, int64_t *x_stat, int64_t *c_stat);
void wcp_information_q(void **data, struct wcp_inform_type_q *inform, int32_t *status);
void wcp_information_q_64(void **data, struct wcp_inform_type_q_64 *inform, int64_t *status);
void wcp_terminate_q(void **data, struct wcp_control_type_q *control, struct wcp_inform_type_q *inform);
void wcp_terminate_q_64(void **data, struct wcp_control_type_q_64 *control, struct wcp_inform_type_q_64 *inform);

// C interface for LLSR
struct llsr_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t new_a;
    int32_t new_s;
    int32_t max_factorizations;
    int32_t taylor_max_degree;
    __float128 initial_multiplier;
    __float128 lower;
    __float128 upper;
    __float128 stop_normal;
    bool use_initial_multiplier;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sbls_control_type_q sbls_control;
    struct sls_control_type_q sls_control;
    struct ir_control_type_q ir_control;
};

struct llsr_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t new_a;
    int64_t new_s;
    int64_t max_factorizations;
    int64_t taylor_max_degree;
    __float128 initial_multiplier;
    __float128 lower;
    __float128 upper;
    __float128 stop_normal;
    bool use_initial_multiplier;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sbls_control_type_q_64 sbls_control;
    struct sls_control_type_q_64 sls_control;
    struct ir_control_type_q_64 ir_control;
};

struct llsr_time_type_q {
    __float128 total;
    __float128 assemble;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_assemble;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct llsr_history_type_q {
    __float128 lambda;
    __float128 x_norm;
    __float128 r_norm;
};

struct llsr_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    int32_t factorizations;
    int32_t len_history;
    __float128 r_norm;
    __float128 x_norm;
    __float128 multiplier;
    char bad_alloc[81];
    struct llsr_time_type_q time;
    struct llsr_history_type_q history[100];
    struct sbls_inform_type_q sbls_inform;
    struct sls_inform_type_q sls_inform;
    struct ir_inform_type_q ir_inform;
};

struct llsr_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorizations;
    int64_t len_history;
    __float128 r_norm;
    __float128 x_norm;
    __float128 multiplier;
    char bad_alloc[81];
    struct llsr_time_type_q time;
    struct llsr_history_type_q history[100];
    struct sbls_inform_type_q_64 sbls_inform;
    struct sls_inform_type_q_64 sls_inform;
    struct ir_inform_type_q_64 ir_inform;
};

void llsr_initialize_q(void **data, struct llsr_control_type_q *control, int32_t *status);
void llsr_initialize_q_64(void **data, struct llsr_control_type_q_64 *control, int64_t *status);
void llsr_read_specfile_q(struct llsr_control_type_q *control, char *specfile);
void llsr_read_specfile_q_64(struct llsr_control_type_q_64 *control, char *specfile);
void llsr_import_q(struct llsr_control_type_q *control, void **data, int32_t *status, int32_t m, int32_t n, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void llsr_import_q_64(struct llsr_control_type_q_64 *control, void **data, int64_t *status, int64_t m, int64_t n, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void llsr_import_scaling_q(struct llsr_control_type_q *control, void **data, int32_t *status, int32_t n, char *S_type, int32_t S_ne, int32_t *S_row, int32_t *S_col, int32_t *S_ptr);
void llsr_import_scaling_q_64(struct llsr_control_type_q_64 *control, void **data, int64_t *status, int64_t n, char *S_type, int64_t S_ne, int64_t *S_row, int64_t *S_col, int64_t *S_ptr);
void llsr_reset_control_q(struct llsr_control_type_q *control, void **data, int32_t *status);
void llsr_reset_control_q_64(struct llsr_control_type_q_64 *control, void **data, int64_t *status);
void llsr_solve_problem_q(void **data, int32_t *status, int32_t m, int32_t n, __float128 power, __float128 weight, int32_t A_ne, __float128 *A_val, __float128 *b, __float128 *x, int32_t S_ne, __float128 *S_val);
void llsr_solve_problem_q_64(void **data, int64_t *status, int64_t m, int64_t n, __float128 power, __float128 weight, int64_t A_ne, __float128 *A_val, __float128 *b, __float128 *x, int64_t S_ne, __float128 *S_val);
void llsr_information_q(void **data, struct llsr_inform_type_q *inform, int32_t *status);
void llsr_information_q_64(void **data, struct llsr_inform_type_q_64 *inform, int64_t *status);
void llsr_terminate_q(void **data, struct llsr_control_type_q *control, struct llsr_inform_type_q *inform);
void llsr_terminate_q_64(void **data, struct llsr_control_type_q_64 *control, struct llsr_inform_type_q_64 *inform);

// C interface for LLST
struct llst_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t new_a;
    int32_t new_s;
    int32_t max_factorizations;
    int32_t taylor_max_degree;
    __float128 initial_multiplier;
    __float128 lower;
    __float128 upper;
    __float128 stop_normal;
    bool equality_problem;
    bool use_initial_multiplier;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sbls_control_type_q sbls_control;
    struct sls_control_type_q sls_control;
    struct ir_control_type_q ir_control;
};

struct llst_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t new_a;
    int64_t new_s;
    int64_t max_factorizations;
    int64_t taylor_max_degree;
    __float128 initial_multiplier;
    __float128 lower;
    __float128 upper;
    __float128 stop_normal;
    bool equality_problem;
    bool use_initial_multiplier;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sbls_control_type_q_64 sbls_control;
    struct sls_control_type_q_64 sls_control;
    struct ir_control_type_q_64 ir_control;
};

struct llst_time_type_q {
    __float128 total;
    __float128 assemble;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_assemble;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct llst_history_type_q {
    __float128 lambda;
    __float128 x_norm;
    __float128 r_norm;
};

struct llst_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    int32_t factorizations;
    int32_t len_history;
    __float128 r_norm;
    __float128 x_norm;
    __float128 multiplier;
    char bad_alloc[81];
    struct llst_time_type_q time;
    struct llst_history_type_q history[100];
    struct sbls_inform_type_q sbls_inform;
    struct sls_inform_type_q sls_inform;
    struct ir_inform_type_q ir_inform;
};

struct llst_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorizations;
    int64_t len_history;
    __float128 r_norm;
    __float128 x_norm;
    __float128 multiplier;
    char bad_alloc[81];
    struct llst_time_type_q time;
    struct llst_history_type_q history[100];
    struct sbls_inform_type_q_64 sbls_inform;
    struct sls_inform_type_q_64 sls_inform;
    struct ir_inform_type_q_64 ir_inform;
};

void llst_initialize_q(void **data, struct llst_control_type_q *control, int32_t *status);
void llst_initialize_q_64(void **data, struct llst_control_type_q_64 *control, int64_t *status);
void llst_read_specfile_q(struct llst_control_type_q *control, char *specfile);
void llst_read_specfile_q_64(struct llst_control_type_q_64 *control, char *specfile);
void llst_import_q(struct llst_control_type_q *control, void **data, int32_t *status, int32_t m, int32_t n, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void llst_import_q_64(struct llst_control_type_q_64 *control, void **data, int64_t *status, int64_t m, int64_t n, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void llst_import_scaling_q(struct llst_control_type_q *control, void **data, int32_t *status, int32_t n, char *S_type, int32_t S_ne, int32_t *S_row, int32_t *S_col, int32_t *S_ptr);
void llst_import_scaling_q_64(struct llst_control_type_q_64 *control, void **data, int64_t *status, int64_t n, char *S_type, int64_t S_ne, int64_t *S_row, int64_t *S_col, int64_t *S_ptr);
void llst_reset_control_q(struct llst_control_type_q *control, void **data, int32_t *status);
void llst_reset_control_q_64(struct llst_control_type_q_64 *control, void **data, int64_t *status);
void llst_solve_problem_q(void **data, int32_t *status, int32_t m, int32_t n, __float128 radius, int32_t A_ne, __float128 *A_val, __float128 *b, __float128 *x, int32_t S_ne, __float128 *S_val);
void llst_solve_problem_q_64(void **data, int64_t *status, int64_t m, int64_t n, __float128 radius, int64_t A_ne, __float128 *A_val, __float128 *b, __float128 *x, int64_t S_ne, __float128 *S_val);
void llst_information_q(void **data, struct llst_inform_type_q *inform, int32_t *status);
void llst_information_q_64(void **data, struct llst_inform_type_q_64 *inform, int64_t *status);
void llst_terminate_q(void **data, struct llst_control_type_q *control, struct llst_inform_type_q *inform);
void llst_terminate_q_64(void **data, struct llst_control_type_q_64 *control, struct llst_inform_type_q_64 *inform);

// C interface for BLLSB
struct bllsb_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 tau;
    __float128 gamma_c;
    __float128 gamma_f;
    __float128 reduce_infeas;
    __float128 identical_bounds_tol;
    __float128 mu_pounce;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_q fdc_control;
    struct sls_control_type_q sls_control;
    struct sls_control_type_q sls_pounce_control;
    struct fit_control_type fit_control;
    struct roots_control_type_q roots_control;
    struct cro_control_type_q cro_control;
};

struct bllsb_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 prfeas;
    __float128 dufeas;
    __float128 muzero;
    __float128 tau;
    __float128 gamma_c;
    __float128 gamma_f;
    __float128 reduce_infeas;
    __float128 identical_bounds_tol;
    __float128 mu_pounce;
    __float128 indicator_tol_p;
    __float128 indicator_tol_pd;
    __float128 indicator_tol_tapia;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_q_64 fdc_control;
    struct sls_control_type_q_64 sls_control;
    struct sls_control_type_q_64 sls_pounce_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_q_64 roots_control;
    struct cro_control_type_q_64 cro_control;
};

struct bllsb_time_type_q {
    __float128 total;
    __float128 preprocess;
    __float128 find_dependent;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_find_dependent;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct bllsb_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    __float128 non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    __float128 checkpointsTime[16];
    struct bllsb_time_type_q time;
    struct fdc_inform_type_q fdc_inform;
    struct sls_inform_type_q sls_inform;
    struct sls_inform_type_q sls_pounce_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type_q cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct bllsb_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    __float128 non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    __float128 checkpointsTime[16];
    struct bllsb_time_type_q time;
    struct fdc_inform_type_q_64 fdc_inform;
    struct sls_inform_type_q_64 sls_inform;
    struct sls_inform_type_q_64 sls_pounce_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_q_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void bllsb_initialize_q(void **data, struct bllsb_control_type_q *control, int32_t *status);
void bllsb_initialize_q_64(void **data, struct bllsb_control_type_q_64 *control, int64_t *status);
void bllsb_read_specfile_q(struct bllsb_control_type_q *control, char *specfile);
void bllsb_read_specfile_q_64(struct bllsb_control_type_q_64 *control, char *specfile);
void bllsb_import_q(struct bllsb_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t o, char *Ao_type, int32_t Ao_ne, int32_t *Ao_row, int32_t *Ao_col, int32_t Ao_ptr_ne, int32_t *Ao_ptr);
void bllsb_import_q_64(struct bllsb_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t o, char *Ao_type, int64_t Ao_ne, int64_t *Ao_row, int64_t *Ao_col, int64_t Ao_ptr_ne, int64_t *Ao_ptr);
void bllsb_reset_control_q(struct bllsb_control_type_q *control, void **data, int32_t *status);
void bllsb_reset_control_q_64(struct bllsb_control_type_q_64 *control, void **data, int64_t *status);
void bllsb_solve_blls_q(void **data, int32_t *status, int32_t n, int32_t o, int32_t Ao_ne, __float128 *Ao_val, __float128 *b, __float128 regularization_weight, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *r, __float128 *z, int32_t *x_stat, __float128 *w);
void bllsb_solve_blls_q_64(void **data, int64_t *status, int64_t n, int64_t o, int64_t Ao_ne, __float128 *Ao_val, __float128 *b, __float128 regularization_weight, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *r, __float128 *z, int64_t *x_stat, __float128 *w);
void bllsb_information_q(void **data, struct bllsb_inform_type_q *inform, int32_t *status);
void bllsb_information_q_64(void **data, struct bllsb_inform_type_q_64 *inform, int64_t *status);
void bllsb_terminate_q(void **data, struct bllsb_control_type_q *control, struct bllsb_inform_type_q *inform);
void bllsb_terminate_q_64(void **data, struct bllsb_control_type_q_64 *control, struct bllsb_inform_type_q_64 *inform);

// C interface for SSLS
struct ssls_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q sls_control;
};

struct ssls_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_q_64 sls_control;
};

struct ssls_time_type_q {
    __float128 total;
    __float128 analyse;
    __float128 factorize;
    __float128 solve;
    __float128 clock_total;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct ssls_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t rank;
    bool rank_def;
    struct ssls_time_type_q time;
    struct sls_inform_type_q sls_inform;
};

struct ssls_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t rank;
    bool rank_def;
    struct ssls_time_type_q time;
    struct sls_inform_type_q_64 sls_inform;
};

void ssls_initialize_q(void **data, struct ssls_control_type_q *control, int32_t *status);
void ssls_initialize_q_64(void **data, struct ssls_control_type_q_64 *control, int64_t *status);
void ssls_read_specfile_q(struct ssls_control_type_q *control, char *specfile);
void ssls_read_specfile_q_64(struct ssls_control_type_q_64 *control, char *specfile);
void ssls_import_q(struct ssls_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr, char *C_type, int32_t C_ne, int32_t *C_row, int32_t *C_col, int32_t *C_ptr);
void ssls_import_q_64(struct ssls_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr, char *C_type, int64_t C_ne, int64_t *C_row, int64_t *C_col, int64_t *C_ptr);
void ssls_reset_control_q(struct ssls_control_type_q *control, void **data, int32_t *status);
void ssls_reset_control_q_64(struct ssls_control_type_q_64 *control, void **data, int64_t *status);
void ssls_factorize_matrix_q(void **data, int32_t *status, int32_t h_ne, __float128 *H_val, int32_t a_ne, __float128 *A_val, int32_t c_ne, __float128 *C_val);
void ssls_factorize_matrix_q_64(void **data, int64_t *status, int64_t h_ne, __float128 *H_val, int64_t a_ne, __float128 *A_val, int64_t c_ne, __float128 *C_val);
void ssls_solve_system_q(void **data, int32_t *status, int32_t n, int32_t m, __float128 *sol);
void ssls_solve_system_q_64(void **data, int64_t *status, int64_t n, int64_t m, __float128 *sol);
void ssls_information_q(void **data, struct ssls_inform_type_q *inform, int32_t *status);
void ssls_information_q_64(void **data, struct ssls_inform_type_q_64 *inform, int64_t *status);
void ssls_terminate_q(void **data, struct ssls_control_type_q *control, struct ssls_inform_type_q *inform);
void ssls_terminate_q_64(void **data, struct ssls_control_type_q_64 *control, struct ssls_inform_type_q_64 *inform);

// C interface for EXPO
struct expo_control_type_q {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t max_it;
    int32_t max_eval;
    int32_t alive_unit;
    char alive_file[31];
    int32_t update_multipliers_itmin;
    __float128 update_multipliers_tol;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 stop_s;
    __float128 stop_subproblem_rel;
    __float128 initial_mu;
    __float128 mu_reduce;
    __float128 obj_unbounded;
    __float128 try_advanced_start;
    __float128 try_sqp_start;
    __float128 stop_advanced_start;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct bsc_control_type bsc_control;
    struct tru_control_type_q tru_control;
    struct ssls_control_type_q ssls_control;
};

struct expo_control_type_q_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t max_it;
    int64_t max_eval;
    int64_t alive_unit;
    char alive_file[31];
    int64_t update_multipliers_itmin;
    __float128 update_multipliers_tol;
    __float128 infinity;
    __float128 stop_abs_p;
    __float128 stop_rel_p;
    __float128 stop_abs_d;
    __float128 stop_rel_d;
    __float128 stop_abs_c;
    __float128 stop_rel_c;
    __float128 stop_s;
    __float128 stop_subproblem_rel;
    __float128 initial_mu;
    __float128 mu_reduce;
    __float128 obj_unbounded;
    __float128 try_advanced_start;
    __float128 try_sqp_start;
    __float128 stop_advanced_start;
    __float128 cpu_time_limit;
    __float128 clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct bsc_control_type_64 bsc_control;
    struct tru_control_type_q_64 tru_control;
    struct ssls_control_type_q_64 ssls_control;
};

struct expo_time_type_q {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    __float128 clock_total;
    __float128 clock_preprocess;
    __float128 clock_analyse;
    __float128 clock_factorize;
    __float128 clock_solve;
};

struct expo_inform_type_q {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int32_t iter;
    int32_t fc_eval;
    int32_t gj_eval;
    int32_t hl_eval;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    struct expo_time_type_q time;
    struct bsc_inform_type_q bsc_inform;
    struct tru_inform_type_q tru_inform;
    struct ssls_inform_type_q ssls_inform;
};

struct expo_inform_type_q_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int64_t iter;
    int64_t fc_eval;
    int64_t gj_eval;
    int64_t hl_eval;
    __float128 obj;
    __float128 primal_infeasibility;
    __float128 dual_infeasibility;
    __float128 complementary_slackness;
    struct expo_time_type_q time;
    struct bsc_inform_type_q_64 bsc_inform;
    struct tru_inform_type_q_64 tru_inform;
    struct ssls_inform_type_q_64 ssls_inform;
};

void expo_initialize_q(void **data, struct expo_control_type_q *control, struct expo_inform_type_q *inform);
void expo_initialize_q_64(void **data, struct expo_control_type_q_64 *control, struct expo_inform_type_q_64 *inform);
void expo_read_specfile_q(struct expo_control_type_q *control, char *specfile);
void expo_read_specfile_q_64(struct expo_control_type_q_64 *control, char *specfile);
void expo_import_q(struct expo_control_type_q *control, void **data, int32_t *status, int32_t n, int32_t m, char *J_type, int32_t J_ne, int32_t *J_row, int32_t *J_col, int32_t *J_ptr, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void expo_import_q_64(struct expo_control_type_q_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *J_type, int64_t J_ne, int64_t *J_row, int64_t *J_col, int64_t *J_ptr, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void expo_reset_control_q(struct expo_control_type_q *control, void **data, int32_t *status);
void expo_reset_control_q_64(struct expo_control_type_q_64 *control, void **data, int64_t *status);
void expo_solve_hessian_direct_q(void **data, void *userdata, int32_t *status, int32_t n, int32_t m, int32_t J_ne, int32_t H_ne, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *y, __float128 *z, __float128 *c, __float128 *gl, galahad_fc_q *eval_fc, galahad_gj_q *eval_gj, galahad_hl_q *eval_hl);
void expo_solve_hessian_direct_q_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t m, int64_t J_ne, int64_t H_ne, __float128 *c_l, __float128 *c_u, __float128 *x_l, __float128 *x_u, __float128 *x, __float128 *y, __float128 *z, __float128 *c, __float128 *gl, galahad_fc_q_64 *eval_fc, galahad_gj_q_64 *eval_gj, galahad_hl_q_64 *eval_hl);
void expo_information_q(void **data, struct expo_inform_type_q *inform, int32_t *status);
void expo_information_q_64(void **data, struct expo_inform_type_q_64 *inform, int64_t *status);
void expo_terminate_q(void **data, struct expo_control_type_q *control, struct expo_inform_type_q *inform);
void expo_terminate_q_64(void **data, struct expo_control_type_q_64 *control, struct expo_inform_type_q_64 *inform);

// end include guard
#endif

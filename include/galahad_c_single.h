// include guard
#ifndef GALAHAD_C_SINGLE_H
#define GALAHAD_C_SINGLE_H

// Callbacks
typedef int32_t galahad_f_s(int32_t n, const float x[], float *f, const void *userdata);
typedef int32_t galahad_g_s(int32_t n, const float x[], float g[], const void *userdata);
typedef int32_t galahad_h_s(int32_t n, int32_t ne, const float x[], float h[], const void *userdata);
typedef int32_t galahad_prec_s(int32_t n, const float x[], float u[], const float v[], const void *userdata);
typedef int32_t galahad_hprod_s(int32_t n, const float x[], float u[], const float v[], bool got_h, const void *userdata);
typedef int32_t galahad_shprod_s(int32_t n, const float x[], int32_t nnz_v, const int32_t index_nz_v[], const float v[], int32_t *nnz_u, int32_t index_nz_u[], float u[], bool got_h, const void *userdata);
typedef int32_t galahad_constant_prec_s(int32_t n, const float v[], float p[], const void *userdata);
typedef int32_t galahad_r_s(int32_t n, int32_t m, const float x[], float r[], const void *userdata);
typedef int32_t galahad_jr_s(int32_t n, int32_t m, int32_t jne, const float x[], float jr[], const void *userdata);
typedef int32_t galahad_hr_s(int32_t n, int32_t m, int32_t hne, const float x[], const float y[], float hr[], const void *userdata);
typedef int32_t galahad_jrprod_s(int32_t n, int32_t m, const float x[], const bool transpose, float u[], const float v[], bool got_j, const void *userdata);
typedef int32_t galahad_hrprod_s(int32_t n, int32_t m, const float x[], const float y[], float u[], const float v[], bool got_h, const void *userdata);
typedef int32_t galahad_shrprod_s(int32_t n, int32_t m, int32_t pne, const float x[], const float v[], float pval[], bool got_h, const void *userdata);
typedef int32_t galahad_fc_s(int32_t n, int32_t m, const float x[], float *f, float c[], const void *userdata);
typedef int32_t galahad_gj_s(int32_t n, int32_t m, int32_t jne, const float x[], float g[], float j[], const void *userdata);
typedef int32_t galahad_hl_s(int32_t n, int32_t m, int32_t hne, const float x[], const float y[], float h[], const void *userdata);
typedef int32_t galahad_fgh_s(float x, float *f, float *g, float *h, const void *userdata);

typedef int64_t galahad_f_s_64(int64_t n, const float x[], float *f, const void *userdata);
typedef int64_t galahad_g_s_64(int64_t n, const float x[], float g[], const void *userdata);
typedef int64_t galahad_h_s_64(int64_t n, int64_t ne, const float x[], float h[], const void *userdata);
typedef int64_t galahad_prec_s_64(int64_t n, const float x[], float u[], const float v[], const void *userdata);
typedef int64_t galahad_hprod_s_64(int64_t n, const float x[], float u[], const float v[], bool got_h, const void *userdata);
typedef int64_t galahad_shprod_s_64(int64_t n, const float x[], int64_t nnz_v, const int64_t index_nz_v[], const float v[], int64_t *nnz_u, int64_t index_nz_u[], float u[], bool got_h, const void *userdata);
typedef int64_t galahad_constant_prec_s_64(int64_t n, const float v[], float p[], const void *userdata);
typedef int64_t galahad_r_s_64(int64_t n, int64_t m, const float x[], float r[], const void *userdata);
typedef int64_t galahad_jr_s_64(int64_t n, int64_t m, int64_t jne, const float x[], float jr[], const void *userdata);
typedef int64_t galahad_hr_s_64(int64_t n, int64_t m, int64_t hne, const float x[], const float y[], float hr[], const void *userdata);
typedef int64_t galahad_jrprod_s_64(int64_t n, int64_t m, const float x[], const bool transpose, float u[], const float v[], bool got_j, const void *userdata);
typedef int64_t galahad_hrprod_s_64(int64_t n, int64_t m, const float x[], const float y[], float u[], const float v[], bool got_h, const void *userdata);
typedef int64_t galahad_shrprod_s_64(int64_t n, int64_t m, int64_t pne, const float x[], const float v[], float pval[], bool got_h, const void *userdata);
typedef int64_t galahad_fc_s_64(int64_t n, int64_t m, const float x[], float *f, float c[], const void *userdata);
typedef int64_t galahad_gj_s_64(int64_t n, int64_t m, int64_t jne, const float x[], float g[], float j[], const void *userdata);
typedef int64_t galahad_hl_s_64(int64_t n, int64_t m, int64_t hne, const float x[], const float y[], float h[], const void *userdata);
typedef int64_t galahad_fgh_s_64(float x, float *f, float *g, float *h, const void *userdata);

// C interface for BSC
struct bsc_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t max_col_a;
    int32_t exceeds_max_col;
    float time;
    float clock_time;
};

struct bsc_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t max_col_a;
    int64_t exceeds_max_col;
    float time;
    float clock_time;
};

void bsc_initialize_s(void **data, struct bsc_control_type *control, int32_t *status);
void bsc_initialize_s_64(void **data, struct bsc_control_type_64 *control, int64_t *status);
void bsc_import_s(struct bsc_control_type *control, void **data, int32_t *status, int32_t m, int32_t n, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr, int32_t *S_ne);
void bsc_import_s_64(struct bsc_control_type_64 *control, void **data, int64_t *status, int64_t m, int64_t n, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr, int64_t *S_ne);
void bsc_reset_control_s(struct bsc_control_type *control, void **data, int32_t *status);
void bsc_reset_control_s_64(struct bsc_control_type_64 *control, void **data, int64_t *status);
void bsc_form_s_s(void **data, int32_t *status, int32_t m, int32_t n, int32_t a_ne, float *A_val, int32_t s_ne, int32_t *S_row, int32_t *S_col, int32_t *S_ptr, float *S_val, float *D);
void bsc_form_s_s_64(void **data, int64_t *status, int64_t m, int64_t n, int64_t a_ne, float *A_val, int64_t s_ne, int64_t *S_row, int64_t *S_col, int64_t *S_ptr, float *S_val, float *D);
void bsc_information_s(void **data, struct bsc_inform_type_s *inform, int32_t *status);
void bsc_information_s_64(void **data, struct bsc_inform_type_s_64 *inform, int64_t *status);
void bsc_terminate_s(void **data, struct bsc_control_type *control, struct bsc_inform_type_s *inform);
void bsc_terminate_s_64(void **data, struct bsc_control_type_64 *control, struct bsc_inform_type_s_64 *inform);

// C interface for CONVERT
struct convert_time_type_s {
    float total;
    float clock_total;
};

struct convert_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    int32_t duplicates;
    char bad_alloc[81];
    struct convert_time_type_s time;
};

struct convert_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t duplicates;
    char bad_alloc[81];
    struct convert_time_type_s time;
};

void convert_initialize_s(void **data, struct convert_control_type *control, int32_t *status);
void convert_initialize_s_64(void **data, struct convert_control_type_64 *control, int64_t *status);
void convert_information_s(void **data, struct convert_inform_type_s *inform, int32_t *status);
void convert_information_s_64(void **data, struct convert_inform_type_s_64 *inform, int64_t *status);
void convert_terminate_s(void **data, struct convert_control_type *control, struct convert_inform_type_s *inform);
void convert_terminate_s_64(void **data, struct convert_control_type_64 *control, struct convert_inform_type_s_64 *inform);

// C interface for FIT
void fit_initialize_s(void **data, struct fit_control_type *control, int32_t *status);
void fit_initialize_s_64(void **data, struct fit_control_type_64 *control, int64_t *status);
void fit_information_s(void **data, struct fit_inform_type *inform, int32_t *status);
void fit_information_s_64(void **data, struct fit_inform_type_64 *inform, int64_t *status);
void fit_terminate_s(void **data, struct fit_control_type *control, struct fit_inform_type *inform);
void fit_terminate_s_64(void **data, struct fit_control_type_64 *control, struct fit_inform_type_64 *inform);

// C interface for GLRT
struct glrt_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t itmax;
    int32_t stopping_rule;
    int32_t freq;
    int32_t extra_vectors;
    int32_t ritz_printout_device;
    float stop_relative;
    float stop_absolute;
    float fraction_opt;
    float rminvr_zero;
    float f_0;
    bool unitm;
    bool impose_descent;
    bool space_critical;
    bool deallocate_error_fatal;
    bool print_ritz_values;
    char ritz_file_name[31];
    char prefix[31];
};

struct glrt_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t itmax;
    int64_t stopping_rule;
    int64_t freq;
    int64_t extra_vectors;
    int64_t ritz_printout_device;
    float stop_relative;
    float stop_absolute;
    float fraction_opt;
    float rminvr_zero;
    float f_0;
    bool unitm;
    bool impose_descent;
    bool space_critical;
    bool deallocate_error_fatal;
    bool print_ritz_values;
    char ritz_file_name[31];
    char prefix[31];
};

struct glrt_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    float obj;
    float obj_regularized;
    float multiplier;
    float xpo_norm;
    float leftmost;
    bool negative_curvature;
    bool hard_case;
};

struct glrt_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    float obj;
    float obj_regularized;
    float multiplier;
    float xpo_norm;
    float leftmost;
    bool negative_curvature;
    bool hard_case;
};

void glrt_initialize_s(void **data, struct glrt_control_type_s *control, int32_t *status);
void glrt_initialize_s_64(void **data, struct glrt_control_type_s_64 *control, int64_t *status);
void glrt_read_specfile_s(struct glrt_control_type_s *control, char *specfile);
void glrt_read_specfile_s_64(struct glrt_control_type_s_64 *control, char *specfile);
void glrt_import_control_s(struct glrt_control_type_s *control, void **data, int32_t *status);
void glrt_import_control_s_64(struct glrt_control_type_s_64 *control, void **data, int64_t *status);
void glrt_solve_problem_s(void **data, int32_t *status, int32_t n, float power, float weight, float *x, float *r, float *vector);
void glrt_solve_problem_s_64(void **data, int64_t *status, int64_t n, float power, float weight, float *x, float *r, float *vector);
void glrt_information_s(void **data, struct glrt_inform_type_s *inform, int32_t *status);
void glrt_information_s_64(void **data, struct glrt_inform_type_s_64 *inform, int64_t *status);
void glrt_terminate_s(void **data, struct glrt_control_type_s *control, struct glrt_inform_type_s *inform);
void glrt_terminate_s_64(void **data, struct glrt_control_type_s_64 *control, struct glrt_inform_type_s_64 *inform);

// C interface for GLS
struct gls_control_type_s {
    bool f_indexing;
    int32_t lp;
    int32_t wp;
    int32_t mp;
    int32_t ldiag;
    int32_t btf;
    int32_t maxit;
    int32_t factor_blocking;
    int32_t solve_blas;
    int32_t la;
    int32_t la_int;
    int32_t maxla;
    int32_t pivoting;
    int32_t fill_in;
    float multiplier;
    float reduce;
    float u;
    float switch_full;
    float drop;
    float tolerance;
    float cgce;
    bool diagonal_pivoting;
    bool struct_abort;
};

struct gls_control_type_s_64 {
    bool f_indexing;
    int64_t lp;
    int64_t wp;
    int64_t mp;
    int64_t ldiag;
    int64_t btf;
    int64_t maxit;
    int64_t factor_blocking;
    int64_t solve_blas;
    int64_t la;
    int64_t la_int;
    int64_t maxla;
    int64_t pivoting;
    int64_t fill_in;
    float multiplier;
    float reduce;
    float u;
    float switch_full;
    float drop;
    float tolerance;
    float cgce;
    bool diagonal_pivoting;
    bool struct_abort;
};

struct gls_ainfo_type_s {
    int32_t flag;
    int32_t more;
    int32_t len_analyse;
    int32_t len_factorize;
    int32_t ncmpa;
    int32_t rank;
    int32_t drop;
    int32_t struc_rank;
    int32_t oor;
    int32_t dup;
    int32_t stat;
    int32_t lblock;
    int32_t sblock;
    int32_t tblock;
    float ops;
};

struct gls_ainfo_type_s_64 {
    int64_t flag;
    int64_t more;
    int64_t len_analyse;
    int64_t len_factorize;
    int64_t ncmpa;
    int64_t rank;
    int64_t drop;
    int64_t struc_rank;
    int64_t oor;
    int64_t dup;
    int64_t stat;
    int64_t lblock;
    int64_t sblock;
    int64_t tblock;
    float ops;
};

struct gls_finfo_type_s {
    int32_t flag;
    int32_t more;
    int32_t size_factor;
    int32_t len_factorize;
    int32_t drop;
    int32_t rank;
    int32_t stat;
    float ops;
};

struct gls_finfo_type_s_64 {
    int64_t flag;
    int64_t more;
    int64_t size_factor;
    int64_t len_factorize;
    int64_t drop;
    int64_t rank;
    int64_t stat;
    float ops;
};

void gls_initialize_s(void **data, struct gls_control_type_s *control);
void gls_initialize_s_64(void **data, struct gls_control_type_s_64 *control);
void gls_read_specfile_s(struct gls_control_type_s *control, char *specfile);
void gls_read_specfile_s_64(struct gls_control_type_s_64 *control, char *specfile);
void gls_import_s(struct gls_control_type_s *control, void **data, int32_t *status);
void gls_import_s_64(struct gls_control_type_s_64 *control, void **data, int64_t *status);
void gls_reset_control_s(struct gls_control_type_s *control, void **data, int32_t *status);
void gls_reset_control_s_64(struct gls_control_type_s_64 *control, void **data, int64_t *status);
void gls_information_s(void **data, struct gls_ainfo_type_s *ainfo, struct gls_finfo_type_s *finfo, struct gls_sinfo_type *sinfo, int32_t *status);
void gls_information_s_64(void **data, struct gls_ainfo_type_s_64 *ainfo, struct gls_finfo_type_s_64 *finfo, struct gls_sinfo_type_64 *sinfo, int64_t *status);
void gls_finalize_s(void **data, struct gls_control_type_s *control, int32_t *status);
void gls_finalize_s_64(void **data, struct gls_control_type_s_64 *control, int64_t *status);

// C interface for GLTR
struct gltr_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t itmax;
    int32_t Lanczos_itmax;
    int32_t extra_vectors;
    int32_t ritz_printout_device;
    float stop_relative;
    float stop_absolute;
    float fraction_opt;
    float f_min;
    float rminvr_zero;
    float f_0;
    bool unitm;
    bool steihaug_toint;
    bool boundary;
    bool equality_problem;
    bool space_critical;
    bool deallocate_error_fatal;
    bool print_ritz_values;
    char ritz_file_name[31];
    char prefix[31];
};

struct gltr_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t itmax;
    int64_t Lanczos_itmax;
    int64_t extra_vectors;
    int64_t ritz_printout_device;
    float stop_relative;
    float stop_absolute;
    float fraction_opt;
    float f_min;
    float rminvr_zero;
    float f_0;
    bool unitm;
    bool steihaug_toint;
    bool boundary;
    bool equality_problem;
    bool space_critical;
    bool deallocate_error_fatal;
    bool print_ritz_values;
    char ritz_file_name[31];
    char prefix[31];
};

struct gltr_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    float obj;
    float multiplier;
    float mnormx;
    float piv;
    float curv;
    float rayleigh;
    float leftmost;
    bool negative_curvature;
    bool hard_case;
};

struct gltr_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    float obj;
    float multiplier;
    float mnormx;
    float piv;
    float curv;
    float rayleigh;
    float leftmost;
    bool negative_curvature;
    bool hard_case;
};

void gltr_initialize_s(void **data, struct gltr_control_type_s *control, int32_t *status);
void gltr_initialize_s_64(void **data, struct gltr_control_type_s_64 *control, int64_t *status);
void gltr_read_specfile_s(struct gltr_control_type_s *control, char *specfile);
void gltr_read_specfile_s_64(struct gltr_control_type_s_64 *control, char *specfile);
void gltr_import_control_s(struct gltr_control_type_s *control, void **data, int32_t *status);
void gltr_import_control_s_64(struct gltr_control_type_s_64 *control, void **data, int64_t *status);
void gltr_solve_problem_s(void **data, int32_t *status, int32_t n, float radius, float *x, float *r, float *vector);
void gltr_solve_problem_s_64(void **data, int64_t *status, int64_t n, float radius, float *x, float *r, float *vector);
void gltr_information_s(void **data, struct gltr_inform_type_s *inform, int32_t *status);
void gltr_information_s_64(void **data, struct gltr_inform_type_s_64 *inform, int64_t *status);
void gltr_terminate_s(void **data, struct gltr_control_type_s *control, struct gltr_inform_type_s *inform);
void gltr_terminate_s_64(void **data, struct gltr_control_type_s_64 *control, struct gltr_inform_type_s_64 *inform);

// C interface for HASH
void hash_initialize_s(int32_t nchar, int32_t length, void **data, struct hash_control_type *control, struct hash_inform_type *inform);
void hash_initialize_s_64(int64_t nchar, int64_t length, void **data, struct hash_control_type_64 *control, struct hash_inform_type_64 *inform);
void hash_information_s(void **data, struct hash_inform_type *inform, int32_t *status);
void hash_information_s_64(void **data, struct hash_inform_type_64 *inform, int64_t *status);
void hash_terminate_s(void **data, struct hash_control_type *control, struct hash_inform_type *inform);
void hash_terminate_s_64(void **data, struct hash_control_type_64 *control, struct hash_inform_type_64 *inform);

// C interface for HSL
struct ma48_control_s {
    int32_t f_arrays;
    float multiplier;
    float u;
    float switch_;
    float drop;
    float tolerance;
    float cgce;
    int32_t lp;
    int32_t wp;
    int32_t mp;
    int32_t ldiag;
    int32_t btf;
    int32_t struct_;
    int32_t maxit;
    int32_t factor_blocking;
    int32_t solve_blas;
    int32_t pivoting;
    int32_t diagonal_pivoting;
    int32_t fill_in;
    int32_t switch_mode;
};

struct ma48_control_s_64 {
    int64_t f_arrays;
    float multiplier;
    float u;
    float switch_;
    float drop;
    float tolerance;
    float cgce;
    int64_t lp;
    int64_t wp;
    int64_t mp;
    int64_t ldiag;
    int64_t btf;
    int64_t struct_;
    int64_t maxit;
    int64_t factor_blocking;
    int64_t solve_blas;
    int64_t pivoting;
    int64_t diagonal_pivoting;
    int64_t fill_in;
    int64_t switch_mode;
};

struct ma48_ainfo_s {
    float ops;
    int32_t flag;
    int32_t more;
    int64_t lena_analyse;
    int64_t lenj_analyse;
    int64_t lena_factorize;
    int64_t leni_factorize;
    int32_t ncmpa;
    int32_t rank;
    int64_t drop;
    int32_t struc_rank;
    int64_t oor;
    int64_t dup;
    int32_t stat;
    int32_t lblock;
    int32_t sblock;
    int64_t tblock;
};

struct ma48_ainfo_s_64 {
    float ops;
    int64_t flag;
    int64_t more;
    int64_t lena_analyse;
    int64_t lenj_analyse;
    int64_t lena_factorize;
    int64_t leni_factorize;
    int64_t ncmpa;
    int64_t rank;
    int64_t drop;
    int64_t struc_rank;
    int64_t oor;
    int64_t dup;
    int64_t stat;
    int64_t lblock;
    int64_t sblock;
    int64_t tblock;
};

struct ma48_finfo_s {
    float ops;
    int32_t flag;
    int32_t more;
    int64_t size_factor;
    int64_t lena_factorize;
    int64_t leni_factorize;
    int64_t drop;
    int32_t rank;
    int32_t stat;
};

struct ma48_finfo_s_64 {
    float ops;
    int64_t flag;
    int64_t more;
    int64_t size_factor;
    int64_t lena_factorize;
    int64_t leni_factorize;
    int64_t drop;
    int64_t rank;
    int64_t stat;
};

struct ma57_control_s {
    int32_t f_arrays;
    float multiplier;
    float reduce;
    float u;
    float static_tolerance;
    float static_level;
    float tolerance;
    float convergence;
    float consist;
    int32_t lp;
    int32_t wp;
    int32_t mp;
    int32_t sp;
    int32_t ldiag;
    int32_t nemin;
    int32_t factorblocking;
    int32_t solveblocking;
    int32_t la;
    int32_t liw;
    int32_t maxla;
    int32_t maxliw;
    int32_t pivoting;
    int32_t thresh;
    int32_t ordering;
    int32_t scaling;
    int32_t rank_deficient;
    int32_t ispare[5];
    float rspare[10];
};

struct ma57_control_s_64 {
    int64_t f_arrays;
    float multiplier;
    float reduce;
    float u;
    float static_tolerance;
    float static_level;
    float tolerance;
    float convergence;
    float consist;
    int64_t lp;
    int64_t wp;
    int64_t mp;
    int64_t sp;
    int64_t ldiag;
    int64_t nemin;
    int64_t factorblocking;
    int64_t solveblocking;
    int64_t la;
    int64_t liw;
    int64_t maxla;
    int64_t maxliw;
    int64_t pivoting;
    int64_t thresh;
    int64_t ordering;
    int64_t scaling;
    int64_t rank_deficient;
    int64_t ispare[5];
    float rspare[10];
};

struct ma57_ainfo_s {
    float opsa;
    float opse;
    int32_t flag;
    int32_t more;
    int32_t nsteps;
    int32_t nrltot;
    int32_t nirtot;
    int32_t nrlnec;
    int32_t nirnec;
    int32_t nrladu;
    int32_t niradu;
    int32_t ncmpa;
    int32_t ordering;
    int32_t oor;
    int32_t dup;
    int32_t maxfrt;
    int32_t stat;
    int32_t ispare[5];
    float rspare[10];
};

struct ma57_ainfo_s_64 {
    float opsa;
    float opse;
    int64_t flag;
    int64_t more;
    int64_t nsteps;
    int64_t nrltot;
    int64_t nirtot;
    int64_t nrlnec;
    int64_t nirnec;
    int64_t nrladu;
    int64_t niradu;
    int64_t ncmpa;
    int64_t ordering;
    int64_t oor;
    int64_t dup;
    int64_t maxfrt;
    int64_t stat;
    int64_t ispare[5];
    float rspare[10];
};

struct ma57_finfo_s {
    float opsa;
    float opse;
    float opsb;
    float maxchange;
    float smin;
    float smax;
    int32_t flag;
    int32_t more;
    int32_t maxfrt;
    int32_t nebdu;
    int32_t nrlbdu;
    int32_t nirbdu;
    int32_t nrltot;
    int32_t nirtot;
    int32_t nrlnec;
    int32_t nirnec;
    int32_t ncmpbr;
    int32_t ncmpbi;
    int32_t ntwo;
    int32_t neig;
    int32_t delay;
    int32_t signc;
    int32_t static_;
    int32_t modstep;
    int32_t rank;
    int32_t stat;
    int32_t ispare[5];
    float rspare[10];
};

struct ma57_finfo_s_64 {
    float opsa;
    float opse;
    float opsb;
    float maxchange;
    float smin;
    float smax;
    int64_t flag;
    int64_t more;
    int64_t maxfrt;
    int64_t nebdu;
    int64_t nrlbdu;
    int64_t nirbdu;
    int64_t nrltot;
    int64_t nirtot;
    int64_t nrlnec;
    int64_t nirnec;
    int64_t ncmpbr;
    int64_t ncmpbi;
    int64_t ntwo;
    int64_t neig;
    int64_t delay;
    int64_t signc;
    int64_t static_;
    int64_t modstep;
    int64_t rank;
    int64_t stat;
    int64_t ispare[5];
    float rspare[10];
};

struct ma57_sinfo_s {
    float cond;
    float cond2;
    float berr;
    float berr2;
    float error;
    int32_t flag;
    int32_t stat;
    int32_t ispare[5];
    float rspare[10];
};

struct ma57_sinfo_s_64 {
    float cond;
    float cond2;
    float berr;
    float berr2;
    float error;
    int64_t flag;
    int64_t stat;
    int64_t ispare[5];
    float rspare[10];
};

struct ma77_control_s {
    int32_t f_arrays;
    int32_t print_level;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int32_t bits;
    int32_t buffer_lpage[2];
    int32_t buffer_npage[2];
    int64_t file_size;
    int64_t maxstore;
    int64_t storage[3];
    int32_t nemin;
    int32_t maxit;
    int32_t infnorm;
    float thresh;
    int32_t nb54;
    int32_t action;
    float multiplier;
    int32_t nb64;
    int32_t nbi;
    float small;
    float static_;
    int64_t storage_indef;
    float u;
    float umin;
    float consist_tol;
    int32_t ispare[5];
    int64_t lspare[5];
    float rspare[5];
};

struct ma77_control_s_64 {
    int64_t f_arrays;
    int64_t print_level;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t bits;
    int64_t buffer_lpage[2];
    int64_t buffer_npage[2];
    int64_t file_size;
    int64_t maxstore;
    int64_t storage[3];
    int64_t nemin;
    int64_t maxit;
    int64_t infnorm;
    float thresh;
    int64_t nb54;
    int64_t action;
    float multiplier;
    int64_t nb64;
    int64_t nbi;
    float small;
    float static_;
    int64_t storage_indef;
    float u;
    float umin;
    float consist_tol;
    int64_t ispare[5];
    int64_t lspare[5];
    float rspare[5];
};

struct ma77_info_s {
    float detlog;
    int32_t detsign;
    int32_t flag;
    int32_t iostat;
    int32_t matrix_dup;
    int32_t matrix_rank;
    int32_t matrix_outrange;
    int32_t maxdepth;
    int32_t maxfront;
    int64_t minstore;
    int32_t ndelay;
    int64_t nfactor;
    int64_t nflops;
    int32_t niter;
    int32_t nsup;
    int32_t num_neg;
    int32_t num_nothresh;
    int32_t num_perturbed;
    int32_t ntwo;
    int32_t stat;
    int32_t index[4];
    int64_t nio_read[2];
    int64_t nio_write[2];
    int64_t nwd_read[2];
    int64_t nwd_write[2];
    int32_t num_file[4];
    int64_t storage[4];
    int32_t tree_nodes;
    int32_t unit_restart;
    int32_t unused;
    float usmall;
    int32_t ispare[5];
    int64_t lspare[5];
    float rspare[5];
};

struct ma77_info_s_64 {
    float detlog;
    int64_t detsign;
    int64_t flag;
    int64_t iostat;
    int64_t matrix_dup;
    int64_t matrix_rank;
    int64_t matrix_outrange;
    int64_t maxdepth;
    int64_t maxfront;
    int64_t minstore;
    int64_t ndelay;
    int64_t nfactor;
    int64_t nflops;
    int64_t niter;
    int64_t nsup;
    int64_t num_neg;
    int64_t num_nothresh;
    int64_t num_perturbed;
    int64_t ntwo;
    int64_t stat;
    int64_t index[4];
    int64_t nio_read[2];
    int64_t nio_write[2];
    int64_t nwd_read[2];
    int64_t nwd_write[2];
    int64_t num_file[4];
    int64_t storage[4];
    int64_t tree_nodes;
    int64_t unit_restart;
    int64_t unused;
    float usmall;
    int64_t ispare[5];
    int64_t lspare[5];
    float rspare[5];
};

struct ma86_control_s {
    int32_t f_arrays;
    int32_t diagnostics_level;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int32_t nemin;
    int32_t nb;
    int32_t action;
    int32_t nbi;
    int32_t pool_size;
    float small_;
    float static_;
    float u;
    float umin;
    int32_t scaling;
};

struct ma86_control_s_64 {
    int64_t f_arrays;
    int64_t diagnostics_level;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t nemin;
    int64_t nb;
    int64_t action;
    int64_t nbi;
    int64_t pool_size;
    float small_;
    float static_;
    float u;
    float umin;
    int64_t scaling;
};

struct ma86_info_s {
    float detlog;
    int32_t detsign;
    int32_t flag;
    int32_t matrix_rank;
    int32_t maxdepth;
    int32_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int32_t num_neg;
    int32_t num_nodes;
    int32_t num_nothresh;
    int32_t num_perturbed;
    int32_t num_two;
    int32_t pool_size;
    int32_t stat;
    float usmall;
};

struct ma86_info_s_64 {
    float detlog;
    int64_t detsign;
    int64_t flag;
    int64_t matrix_rank;
    int64_t maxdepth;
    int64_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int64_t num_neg;
    int64_t num_nodes;
    int64_t num_nothresh;
    int64_t num_perturbed;
    int64_t num_two;
    int64_t pool_size;
    int64_t stat;
    float usmall;
};

struct ma87_control_s {
    int32_t f_arrays;
    int32_t diagnostics_level;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int32_t nemin;
    int32_t nb;
    int32_t pool_size;
    float diag_zero_minus;
    float diag_zero_plus;
    char unused[40];
};

struct ma87_control_s_64 {
    int64_t f_arrays;
    int64_t diagnostics_level;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t nemin;
    int64_t nb;
    int64_t pool_size;
    float diag_zero_minus;
    float diag_zero_plus;
    char unused[40];
};

struct ma87_info_s {
    float detlog;
    int32_t flag;
    int32_t maxdepth;
    int64_t num_factor;
    int64_t num_flops;
    int32_t num_nodes;
    int32_t pool_size;
    int32_t stat;
    int32_t num_zero;
    char unused[40];
};

struct ma87_info_s_64 {
    float detlog;
    int64_t flag;
    int64_t maxdepth;
    int64_t num_factor;
    int64_t num_flops;
    int64_t num_nodes;
    int64_t pool_size;
    int64_t stat;
    int64_t num_zero;
    char unused[40];
};

struct ma97_control_s {
    int32_t f_arrays;
    int32_t action;
    int32_t nemin;
    float multiplier;
    int32_t ordering;
    int32_t print_level;
    int32_t scaling;
    float small;
    float u;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int64_t factor_min;
    int32_t solve_blas3;
    int64_t solve_min;
    int32_t solve_mf;
    float consist_tol;
    int32_t ispare[5];
    float rspare[10];
};

struct ma97_control_s_64 {
    int64_t f_arrays;
    int64_t action;
    int64_t nemin;
    float multiplier;
    int64_t ordering;
    int64_t print_level;
    int64_t scaling;
    float small;
    float u;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t factor_min;
    int64_t solve_blas3;
    int64_t solve_min;
    int64_t solve_mf;
    float consist_tol;
    int64_t ispare[5];
    float rspare[10];
};

struct ma97_info_s {
    int32_t flag;
    int32_t flag68;
    int32_t flag77;
    int32_t matrix_dup;
    int32_t matrix_rank;
    int32_t matrix_outrange;
    int32_t matrix_missing_diag;
    int32_t maxdepth;
    int32_t maxfront;
    int32_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int32_t num_neg;
    int32_t num_sup;
    int32_t num_two;
    int32_t ordering;
    int32_t stat;
    int32_t maxsupernode;
    int32_t ispare[4];
    float rspare[10];
};

struct ma97_info_s_64 {
    int64_t flag;
    int64_t flag68;
    int64_t flag77;
    int64_t matrix_dup;
    int64_t matrix_rank;
    int64_t matrix_outrange;
    int64_t matrix_missing_diag;
    int64_t maxdepth;
    int64_t maxfront;
    int64_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int64_t num_neg;
    int64_t num_sup;
    int64_t num_two;
    int64_t ordering;
    int64_t stat;
    int64_t maxsupernode;
    int64_t ispare[4];
    float rspare[10];
};

struct mi20_control_s {
    int32_t f_arrays;
    int32_t aggressive;
    int32_t c_fail;
    int32_t max_levels;
    int32_t max_points;
    float reduction;
    int32_t st_method;
    float st_parameter;
    int32_t testing;
    float trunc_parameter;
    int32_t coarse_solver;
    int32_t coarse_solver_its;
    float damping;
    float err_tol;
    int32_t levels;
    int32_t pre_smoothing;
    int32_t smoother;
    int32_t post_smoothing;
    int32_t v_iterations;
    int32_t print_level;
    int32_t print;
    int32_t error;
    int32_t one_pass_coarsen;
};

struct mi20_control_s_64 {
    int64_t f_arrays;
    int64_t aggressive;
    int64_t c_fail;
    int64_t max_levels;
    int64_t max_points;
    float reduction;
    int64_t st_method;
    float st_parameter;
    int64_t testing;
    float trunc_parameter;
    int64_t coarse_solver;
    int64_t coarse_solver_its;
    float damping;
    float err_tol;
    int64_t levels;
    int64_t pre_smoothing;
    int64_t smoother;
    int64_t post_smoothing;
    int64_t v_iterations;
    int64_t print_level;
    int64_t print;
    int64_t error;
    int64_t one_pass_coarsen;
};

struct mi20_solve_control_s {
    float abs_tol;
    float breakdown_tol;
    int32_t gmres_restart;
    bool init_guess;
    int32_t krylov_solver;
    int32_t max_its;
    int32_t preconditioner_side;
    float rel_tol;
};

struct mi20_solve_control_s_64 {
    float abs_tol;
    float breakdown_tol;
    int64_t gmres_restart;
    bool init_guess;
    int64_t krylov_solver;
    int64_t max_its;
    int64_t preconditioner_side;
    float rel_tol;
};

struct mi20_info_s {
    int32_t flag;
    int32_t clevels;
    int32_t cpoints;
    int32_t cnnz;
    int32_t stat;
    int32_t getrf_info;
    int32_t iterations;
    float residual;
};

struct mi20_info_s_64 {
    int64_t flag;
    int64_t clevels;
    int64_t cpoints;
    int64_t cnnz;
    int64_t stat;
    int64_t getrf_info;
    int64_t iterations;
    float residual;
};

struct mi28_control_s {
    int32_t f_arrays;
    float alpha;
    bool check;
    int32_t iorder;
    int32_t iscale;
    float lowalpha;
    int32_t maxshift;
    bool rrt;
    float shift_factor;
    float shift_factor2;
    float small;
    float tau1;
    float tau2;
    int32_t unit_error;
    int32_t unit_warning;
};

struct mi28_control_s_64 {
    int64_t f_arrays;
    float alpha;
    bool check;
    int64_t iorder;
    int64_t iscale;
    float lowalpha;
    int64_t maxshift;
    bool rrt;
    float shift_factor;
    float shift_factor2;
    float small;
    float tau1;
    float tau2;
    int64_t unit_error;
    int64_t unit_warning;
};

struct mi28_info_s {
    int32_t band_after;
    int32_t band_before;
    int32_t dup;
    int32_t flag;
    int32_t flag61;
    int32_t flag64;
    int32_t flag68;
    int32_t flag77;
    int32_t nrestart;
    int32_t nshift;
    int32_t oor;
    float profile_before;
    float profile_after;
    int64_t size_r;
    int32_t stat;
    float alpha;
};

struct mi28_info_s_64 {
    int64_t band_after;
    int64_t band_before;
    int64_t dup;
    int64_t flag;
    int64_t flag61;
    int64_t flag64;
    int64_t flag68;
    int64_t flag77;
    int64_t nrestart;
    int64_t nshift;
    int64_t oor;
    float profile_before;
    float profile_after;
    int64_t size_r;
    int64_t stat;
    float alpha;
};

// C interface for IR
struct ir_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t itref_max;
    float acceptable_residual_relative;
    float acceptable_residual_absolute;
    float required_residual_relative;
    bool record_residuals;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct ir_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t itref_max;
    float acceptable_residual_relative;
    float acceptable_residual_absolute;
    float required_residual_relative;
    bool record_residuals;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct ir_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    float norm_initial_residual;
    float norm_final_residual;
};

struct ir_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    float norm_initial_residual;
    float norm_final_residual;
};

void ir_initialize_s(void **data, struct ir_control_type_s *control, int32_t *status);
void ir_initialize_s_64(void **data, struct ir_control_type_s_64 *control, int64_t *status);
void ir_information_s(void **data, struct ir_inform_type_s *inform, int32_t *status);
void ir_information_s_64(void **data, struct ir_inform_type_s_64 *inform, int64_t *status);
void ir_terminate_s(void **data, struct ir_control_type_s *control, struct ir_inform_type_s *inform);
void ir_terminate_s_64(void **data, struct ir_control_type_s_64 *control, struct ir_inform_type_s_64 *inform);

// C interface for L2RT
struct l2rt_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t itmin;
    int32_t itmax;
    int32_t bitmax;
    int32_t extra_vectors;
    int32_t stopping_rule;
    int32_t freq;
    float stop_relative;
    float stop_absolute;
    float fraction_opt;
    float time_limit;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct l2rt_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t itmin;
    int64_t itmax;
    int64_t bitmax;
    int64_t extra_vectors;
    int64_t stopping_rule;
    int64_t freq;
    float stop_relative;
    float stop_absolute;
    float fraction_opt;
    float time_limit;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct l2rt_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    int32_t biters;
    int32_t biter_min;
    int32_t biter_max;
    float obj;
    float multiplier;
    float x_norm;
    float r_norm;
    float Atr_norm;
    float biter_mean;
};

struct l2rt_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    int64_t biters;
    int64_t biter_min;
    int64_t biter_max;
    float obj;
    float multiplier;
    float x_norm;
    float r_norm;
    float Atr_norm;
    float biter_mean;
};

void l2rt_initialize_s(void **data, struct l2rt_control_type_s *control, int32_t *status);
void l2rt_initialize_s_64(void **data, struct l2rt_control_type_s_64 *control, int64_t *status);
void l2rt_read_specfile_s(struct l2rt_control_type_s *control, char *specfile);
void l2rt_read_specfile_s_64(struct l2rt_control_type_s_64 *control, char *specfile);
void l2rt_import_control_s(struct l2rt_control_type_s *control, void **data, int32_t *status);
void l2rt_import_control_s_64(struct l2rt_control_type_s_64 *control, void **data, int64_t *status);
void l2rt_solve_problem_s(void **data, int32_t *status, int32_t m, int32_t n, float power, float weight, float shift, float *x, float *u, float *v);
void l2rt_solve_problem_s_64(void **data, int64_t *status, int64_t m, int64_t n, float power, float weight, float shift, float *x, float *u, float *v);
void l2rt_information_s(void **data, struct l2rt_inform_type_s *inform, int32_t *status);
void l2rt_information_s_64(void **data, struct l2rt_inform_type_s_64 *inform, int64_t *status);
void l2rt_terminate_s(void **data, struct l2rt_control_type_s *control, struct l2rt_inform_type_s *inform);
void l2rt_terminate_s_64(void **data, struct l2rt_control_type_s_64 *control, struct l2rt_inform_type_s_64 *inform);

// C interface for LHS
void lhs_initialize_s(void **data, struct lhs_control_type *control, struct lhs_inform_type *inform);
void lhs_initialize_s_64(void **data, struct lhs_control_type_64 *control, struct lhs_inform_type_64 *inform);
void lhs_read_specfile_s(struct lhs_control_type *control, char *specfile);
void lhs_read_specfile_s_64(struct lhs_control_type_64 *control, char *specfile);
void lhs_ihs_s(int32_t n_dimen, int32_t n_points, int32_t *seed, int32_t *X, struct lhs_control_type *control, struct lhs_inform_type *inform, void **data);
void lhs_ihs_s_64(int64_t n_dimen, int64_t n_points, int64_t *seed, int64_t *X, struct lhs_control_type_64 *control, struct lhs_inform_type_64 *inform, void **data);
void lhs_get_seed_s(int32_t *seed);
void lhs_get_seed_s_64(int64_t *seed);
void lhs_information_s(void **data, struct lhs_inform_type *inform, int32_t *status);
void lhs_information_s_64(void **data, struct lhs_inform_type_64 *inform, int64_t *status);
void lhs_terminate_s(void **data, struct lhs_control_type *control, struct lhs_inform_type *inform);
void lhs_terminate_s_64(void **data, struct lhs_control_type_64 *control, struct lhs_inform_type_64 *inform);

// C interface for LMS
struct lms_time_type_s {
    float total;
    float setup;
    float form;
    float apply;
    float clock_total;
    float clock_setup;
    float clock_form;
    float clock_apply;
};

struct lms_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    int32_t length;
    bool updates_skipped;
    char bad_alloc[81];
    struct lms_time_type_s time;
};

struct lms_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t length;
    bool updates_skipped;
    char bad_alloc[81];
    struct lms_time_type_s time;
};

void lms_initialize_s(void **data, struct lms_control_type *control, int32_t *status);
void lms_initialize_s_64(void **data, struct lms_control_type_64 *control, int64_t *status);
void lms_information_s(void **data, struct lms_inform_type_s *inform, int32_t *status);
void lms_information_s_64(void **data, struct lms_inform_type_s_64 *inform, int64_t *status);
void lms_terminate_s(void **data, struct lms_control_type *control, struct lms_inform_type_s *inform);
void lms_terminate_s_64(void **data, struct lms_control_type_64 *control, struct lms_inform_type_s_64 *inform);

// C interface for LSRT
struct lsrt_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t itmin;
    int32_t itmax;
    int32_t bitmax;
    int32_t extra_vectors;
    int32_t stopping_rule;
    int32_t freq;
    float stop_relative;
    float stop_absolute;
    float fraction_opt;
    float time_limit;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct lsrt_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t itmin;
    int64_t itmax;
    int64_t bitmax;
    int64_t extra_vectors;
    int64_t stopping_rule;
    int64_t freq;
    float stop_relative;
    float stop_absolute;
    float fraction_opt;
    float time_limit;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct lsrt_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    int32_t biters;
    int32_t biter_min;
    int32_t biter_max;
    float obj;
    float multiplier;
    float x_norm;
    float r_norm;
    float Atr_norm;
    float biter_mean;
};

struct lsrt_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    int64_t biters;
    int64_t biter_min;
    int64_t biter_max;
    float obj;
    float multiplier;
    float x_norm;
    float r_norm;
    float Atr_norm;
    float biter_mean;
};

void lsrt_initialize_s(void **data, struct lsrt_control_type_s *control, int32_t *status);
void lsrt_initialize_s_64(void **data, struct lsrt_control_type_s_64 *control, int64_t *status);
void lsrt_read_specfile_s(struct lsrt_control_type_s *control, char *specfile);
void lsrt_read_specfile_s_64(struct lsrt_control_type_s_64 *control, char *specfile);
void lsrt_import_control_s(struct lsrt_control_type_s *control, void **data, int32_t *status);
void lsrt_import_control_s_64(struct lsrt_control_type_s_64 *control, void **data, int64_t *status);
void lsrt_solve_problem_s(void **data, int32_t *status, int32_t m, int32_t n, float power, float weight, float *x, float *u, float *v);
void lsrt_solve_problem_s_64(void **data, int64_t *status, int64_t m, int64_t n, float power, float weight, float *x, float *u, float *v);
void lsrt_information_s(void **data, struct lsrt_inform_type_s *inform, int32_t *status);
void lsrt_information_s_64(void **data, struct lsrt_inform_type_s_64 *inform, int64_t *status);
void lsrt_terminate_s(void **data, struct lsrt_control_type_s *control, struct lsrt_inform_type_s *inform);
void lsrt_terminate_s_64(void **data, struct lsrt_control_type_s_64 *control, struct lsrt_inform_type_s_64 *inform);

// C interface for LSTR
struct lstr_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t itmin;
    int32_t itmax;
    int32_t itmax_on_boundary;
    int32_t bitmax;
    int32_t extra_vectors;
    float stop_relative;
    float stop_absolute;
    float fraction_opt;
    float time_limit;
    bool steihaug_toint;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct lstr_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t itmin;
    int64_t itmax;
    int64_t itmax_on_boundary;
    int64_t bitmax;
    int64_t extra_vectors;
    float stop_relative;
    float stop_absolute;
    float fraction_opt;
    float time_limit;
    bool steihaug_toint;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct lstr_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    int32_t biters;
    int32_t biter_min;
    int32_t biter_max;
    float multiplier;
    float x_norm;
    float r_norm;
    float Atr_norm;
    float biter_mean;
};

struct lstr_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    int64_t biters;
    int64_t biter_min;
    int64_t biter_max;
    float multiplier;
    float x_norm;
    float r_norm;
    float Atr_norm;
    float biter_mean;
};

void lstr_initialize_s(void **data, struct lstr_control_type_s *control, int32_t *status);
void lstr_initialize_s_64(void **data, struct lstr_control_type_s_64 *control, int64_t *status);
void lstr_read_specfile_s(struct lstr_control_type_s *control, char *specfile);
void lstr_read_specfile_s_64(struct lstr_control_type_s_64 *control, char *specfile);
void lstr_import_control_s(struct lstr_control_type_s *control, void **data, int32_t *status);
void lstr_import_control_s_64(struct lstr_control_type_s_64 *control, void **data, int64_t *status);
void lstr_solve_problem_s(void **data, int32_t *status, int32_t m, int32_t n, float radius, float *x, float *u, float *v);
void lstr_solve_problem_s_64(void **data, int64_t *status, int64_t m, int64_t n, float radius, float *x, float *u, float *v);
void lstr_information_s(void **data, struct lstr_inform_type_s *inform, int32_t *status);
void lstr_information_s_64(void **data, struct lstr_inform_type_s_64 *inform, int64_t *status);
void lstr_terminate_s(void **data, struct lstr_control_type_s *control, struct lstr_inform_type_s *inform);
void lstr_terminate_s_64(void **data, struct lstr_control_type_s_64 *control, struct lstr_inform_type_s_64 *inform);

// C interface for NODEND
struct nodend_time_type_s {
    float total;
    float metis;
    float clock_total;
    float clock_metis;
};

struct nodend_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    char version[4];
    struct nodend_time_type_s time;
};

struct nodend_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    char version[4];
    struct nodend_time_type_s time;
};

void nodend_initialize_s(void **data, struct nodend_control_type *control, int32_t *status);
void nodend_initialize_s_64(void **data, struct nodend_control_type_64 *control, int64_t *status);
void nodend_read_specfile_s(struct nodend_control_type *control, char *specfile);
void nodend_read_specfile_s_64(struct nodend_control_type_64 *control, char *specfile);
void nodend_order_s(struct nodend_control_type *control, void **data, int32_t *status, int32_t n, int32_t *perm, char *A_type, int32_t ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void nodend_order_s_64(struct nodend_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t *perm, char *A_type, int64_t ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void nodend_information_s(void **data, struct nodend_inform_type_s *inform, int32_t *status);
void nodend_information_s_64(void **data, struct nodend_inform_type_s_64 *inform, int64_t *status);
void nodend_terminate_s(void **data);
void nodend_terminate_s_64(void **data);

// C interface for PRESOLVE
struct presolve_control_type_s {
    bool f_indexing;
    int32_t termination;
    int32_t max_nbr_transforms;
    int32_t max_nbr_passes;
    float c_accuracy;
    float z_accuracy;
    float infinity;
    int32_t out;
    int32_t errout;
    int32_t print_level;
    bool dual_transformations;
    bool redundant_xc;
    int32_t primal_constraints_freq;
    int32_t dual_constraints_freq;
    int32_t singleton_columns_freq;
    int32_t doubleton_columns_freq;
    int32_t unc_variables_freq;
    int32_t dependent_variables_freq;
    int32_t sparsify_rows_freq;
    int32_t max_fill;
    int32_t transf_file_nbr;
    int32_t transf_buffer_size;
    int32_t transf_file_status;
    char transf_file_name[31];
    int32_t y_sign;
    int32_t inactive_y;
    int32_t z_sign;
    int32_t inactive_z;
    int32_t final_x_bounds;
    int32_t final_z_bounds;
    int32_t final_c_bounds;
    int32_t final_y_bounds;
    int32_t check_primal_feasibility;
    int32_t check_dual_feasibility;
    float pivot_tol;
    float min_rel_improve;
    float max_growth_factor;
};

struct presolve_control_type_s_64 {
    bool f_indexing;
    int64_t termination;
    int64_t max_nbr_transforms;
    int64_t max_nbr_passes;
    float c_accuracy;
    float z_accuracy;
    float infinity;
    int64_t out;
    int64_t errout;
    int64_t print_level;
    bool dual_transformations;
    bool redundant_xc;
    int64_t primal_constraints_freq;
    int64_t dual_constraints_freq;
    int64_t singleton_columns_freq;
    int64_t doubleton_columns_freq;
    int64_t unc_variables_freq;
    int64_t dependent_variables_freq;
    int64_t sparsify_rows_freq;
    int64_t max_fill;
    int64_t transf_file_nbr;
    int64_t transf_buffer_size;
    int64_t transf_file_status;
    char transf_file_name[31];
    int64_t y_sign;
    int64_t inactive_y;
    int64_t z_sign;
    int64_t inactive_z;
    int64_t final_x_bounds;
    int64_t final_z_bounds;
    int64_t final_c_bounds;
    int64_t final_y_bounds;
    int64_t check_primal_feasibility;
    int64_t check_dual_feasibility;
    float pivot_tol;
    float min_rel_improve;
    float max_growth_factor;
};

void presolve_initialize_s(void **data, struct presolve_control_type_s *control, int32_t *status);
void presolve_initialize_s_64(void **data, struct presolve_control_type_s_64 *control, int64_t *status);
void presolve_read_specfile_s(struct presolve_control_type_s *control, char *specfile);
void presolve_read_specfile_s_64(struct presolve_control_type_s_64 *control, char *specfile);
void presolve_import_problem_s(struct presolve_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, float *H_val, float *g, float f, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, int32_t *n_out, int32_t *m_out, int32_t *H_ne_out, int32_t *A_ne_out);
void presolve_import_problem_s_64(struct presolve_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, float *H_val, float *g, float f, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, int64_t *n_out, int64_t *m_out, int64_t *H_ne_out, int64_t *A_ne_out);
void presolve_transform_problem_s(void **data, int32_t *status, int32_t n, int32_t m, int32_t H_ne, int32_t *H_col, int32_t *H_ptr, float *H_val, float *g, float *f, int32_t A_ne, int32_t *A_col, int32_t *A_ptr, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *y_l, float *y_u, float *z_l, float *z_u);
void presolve_transform_problem_s_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t H_ne, int64_t *H_col, int64_t *H_ptr, float *H_val, float *g, float *f, int64_t A_ne, int64_t *A_col, int64_t *A_ptr, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *y_l, float *y_u, float *z_l, float *z_u);
void presolve_restore_solution_s(void **data, int32_t *status, int32_t n_in, int32_t m_in, float *x_in, float *c_in, float *y_in, float *z_in, int32_t n, int32_t m, float *x, float *c, float *y, float *z);
void presolve_restore_solution_s_64(void **data, int64_t *status, int64_t n_in, int64_t m_in, float *x_in, float *c_in, float *y_in, float *z_in, int64_t n, int64_t m, float *x, float *c, float *y, float *z);
void presolve_information_s(void **data, struct presolve_inform_type *inform, int32_t *status);
void presolve_information_s_64(void **data, struct presolve_inform_type_64 *inform, int64_t *status);
void presolve_terminate_s(void **data, struct presolve_control_type_s *control, struct presolve_inform_type *inform);
void presolve_terminate_s_64(void **data, struct presolve_control_type_s_64 *control, struct presolve_inform_type_64 *inform);

// C interface for ROOTS
struct roots_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    float tol;
    float zero_coef;
    float zero_f;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct roots_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    float tol;
    float zero_coef;
    float zero_f;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

void roots_initialize_s(void **data, struct roots_control_type_s *control, int32_t *status);
void roots_initialize_s_64(void **data, struct roots_control_type_s_64 *control, int64_t *status);
void roots_information_s(void **data, struct roots_inform_type *inform, int32_t *status);
void roots_information_s_64(void **data, struct roots_inform_type_64 *inform, int64_t *status);
void roots_terminate_s(void **data, struct roots_control_type_s *control, struct roots_inform_type *inform);
void roots_terminate_s_64(void **data, struct roots_control_type_s_64 *control, struct roots_inform_type_64 *inform);

// C interface for RPD
void rpd_initialize_s(void **data, struct rpd_control_type *control, int32_t *status);
void rpd_initialize_s_64(void **data, struct rpd_control_type_64 *control, int64_t *status);
void rpd_get_stats_s(char *qplib_file, int32_t qplib_file_len, struct rpd_control_type *control, void **data, int32_t *status, char *p_type, int32_t *n, int32_t *m, int32_t *h_ne, int32_t *a_ne, int32_t *h_c_ne);
void rpd_get_stats_s_64(char *qplib_file, int64_t qplib_file_len, struct rpd_control_type_64 *control, void **data, int64_t *status, char *p_type, int64_t *n, int64_t *m, int64_t *h_ne, int64_t *a_ne, int64_t *h_c_ne);
void rpd_get_g_s(void **data, int32_t *status, int32_t n, float *g);
void rpd_get_g_s_64(void **data, int64_t *status, int64_t n, float *g);
void rpd_get_f_s(void **data, int32_t *status, float *f);
void rpd_get_f_s_64(void **data, int64_t *status, float *f);
void rpd_get_xlu_s(void **data, int32_t *status, int32_t n, float *x_l, float *x_u);
void rpd_get_xlu_s_64(void **data, int64_t *status, int64_t n, float *x_l, float *x_u);
void rpd_get_clu_s(void **data, int32_t *status, int32_t m, float *c_l, float *c_u);
void rpd_get_clu_s_64(void **data, int64_t *status, int64_t m, float *c_l, float *c_u);
void rpd_get_h_s(void **data, int32_t *status, int32_t h_ne, int32_t *h_row, int32_t *h_col, float *h_val);
void rpd_get_h_s_64(void **data, int64_t *status, int64_t h_ne, int64_t *h_row, int64_t *h_col, float *h_val);
void rpd_get_a_s(void **data, int32_t *status, int32_t a_ne, int32_t *a_row, int32_t *a_col, float *a_val);
void rpd_get_a_s_64(void **data, int64_t *status, int64_t a_ne, int64_t *a_row, int64_t *a_col, float *a_val);
void rpd_get_h_c_s(void **data, int32_t *status, int32_t h_c_ne, int32_t *h_c_ptr, int32_t *h_c_row, int32_t *h_c_col, float *h_c_val);
void rpd_get_h_c_s_64(void **data, int64_t *status, int64_t h_c_ne, int64_t *h_c_ptr, int64_t *h_c_row, int64_t *h_c_col, float *h_c_val);
void rpd_get_x_type_s(void **data, int32_t *status, int32_t n, int32_t *x_type);
void rpd_get_x_type_s_64(void **data, int64_t *status, int64_t n, int64_t *x_type);
void rpd_get_x_s(void **data, int32_t *status, int32_t n, float *x);
void rpd_get_x_s_64(void **data, int64_t *status, int64_t n, float *x);
void rpd_get_y_s(void **data, int32_t *status, int32_t m, float *y);
void rpd_get_y_s_64(void **data, int64_t *status, int64_t m, float *y);
void rpd_get_z_s(void **data, int32_t *status, int32_t n, float *z);
void rpd_get_z_s_64(void **data, int64_t *status, int64_t n, float *z);
void rpd_information_s(void **data, struct rpd_inform_type *inform, int32_t *status);
void rpd_information_s_64(void **data, struct rpd_inform_type_64 *inform, int64_t *status);
void rpd_terminate_s(void **data, struct rpd_control_type *control, struct rpd_inform_type *inform);
void rpd_terminate_s_64(void **data, struct rpd_control_type_64 *control, struct rpd_inform_type_64 *inform);

// C interface for SCU
void scu_initialize_s(void **data, struct scu_control_type *control, int32_t *status);
void scu_initialize_s_64(void **data, struct scu_control_type *control, int64_t *status);
void scu_information_s(void **data, struct scu_inform_type *inform, int32_t *status);
void scu_information_s_64(void **data, struct scu_inform_type_64 *inform, int64_t *status);
void scu_terminate_s(void **data, struct scu_control_type *control, struct scu_inform_type *inform);
void scu_terminate_s_64(void **data, struct scu_control_type *control, struct scu_inform_type_64 *inform);

// C interface for SEC
struct sec_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    float h_initial;
    float update_skip_tol;
    char prefix[31];
};

struct sec_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    float h_initial;
    float update_skip_tol;
    char prefix[31];
};

void sec_initialize_s(struct sec_control_type_s *control, int32_t *status);
void sec_initialize_s_64(struct sec_control_type_s_64 *control, int64_t *status);
void sec_information_s(void **data, struct sec_inform_type *inform, int32_t *status);
void sec_information_s_64(void **data, struct sec_inform_type_64 *inform, int64_t *status);
void sec_terminate_s(void **data, struct sec_control_type_s *control, struct sec_inform_type *inform);
void sec_terminate_s_64(void **data, struct sec_control_type_s_64 *control, struct sec_inform_type_64 *inform);

// C interface for SHA
struct sha_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    int32_t max_degree;
    int32_t differences_needed;
    int32_t max_reduced_degree;
    int32_t approximation_algorithm_used;
    int32_t bad_row;
    float max_off_diagonal_difference;
    char bad_alloc[81];
};

struct sha_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t max_degree;
    int64_t differences_needed;
    int64_t max_reduced_degree;
    int64_t approximation_algorithm_used;
    int64_t bad_row;
    float max_off_diagonal_difference;
    char bad_alloc[81];
};

void sha_initialize_s(void **data, struct sha_control_type *control, int32_t *status);
void sha_initialize_s_64(void **data, struct sha_control_type_64 *control, int64_t *status);
void sha_reset_control_s(struct sha_control_type *control, void **data, int32_t *status);
void sha_reset_control_s_64(struct sha_control_type_64 *control, void **data, int64_t *status);
void sha_analyse_matrix_s(struct sha_control_type *control, void **data, int32_t *status, int32_t n, int32_t ne, int32_t *row, int32_t *col, int32_t *m);
void sha_analyse_matrix_s_64(struct sha_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t ne, int64_t *row, int64_t *col, int64_t *m);
void sha_recover_matrix_s(void **data, int32_t *status, int32_t ne, int32_t m, int32_t ls1, int32_t ls2, float **strans, int32_t ly1, int32_t ly2, float **ytrans, float *val, int32_t *precedence);
void sha_recover_matrix_s_64(void **data, int64_t *status, int64_t ne, int64_t m, int64_t ls1, int64_t ls2, float **strans, int64_t ly1, int64_t ly2, float **ytrans, float *val, int64_t *precedence);
void sha_information_s(void **data, struct sha_inform_type_s *inform, int32_t *status);
void sha_information_s_64(void **data, struct sha_inform_type_s_64 *inform, int64_t *status);
void sha_terminate_s(void **data, struct sha_control_type *control, struct sha_inform_type_s *inform);
void sha_terminate_s_64(void **data, struct sha_control_type_64 *control, struct sha_inform_type_s_64 *inform);

// C interface for SILS
struct sils_control_type_s {
    bool f_indexing;
    int32_t ICNTL[30];
    int32_t lp;
    int32_t wp;
    int32_t mp;
    int32_t sp;
    int32_t ldiag;
    int32_t la;
    int32_t liw;
    int32_t maxla;
    int32_t maxliw;
    int32_t pivoting;
    int32_t nemin;
    int32_t factorblocking;
    int32_t solveblocking;
    int32_t thresh;
    int32_t ordering;
    int32_t scaling;
    float CNTL[5];
    float multiplier;
    float reduce;
    float u;
    float static_tolerance;
    float static_level;
    float tolerance;
    float convergence;
};

struct sils_control_type_s_64 {
    bool f_indexing;
    int64_t ICNTL[30];
    int64_t lp;
    int64_t wp;
    int64_t mp;
    int64_t sp;
    int64_t ldiag;
    int64_t la;
    int64_t liw;
    int64_t maxla;
    int64_t maxliw;
    int64_t pivoting;
    int64_t nemin;
    int64_t factorblocking;
    int64_t solveblocking;
    int64_t thresh;
    int64_t ordering;
    int64_t scaling;
    float CNTL[5];
    float multiplier;
    float reduce;
    float u;
    float static_tolerance;
    float static_level;
    float tolerance;
    float convergence;
};

struct sils_ainfo_type_s {
    int32_t flag;
    int32_t more;
    int32_t nsteps;
    int32_t nrltot;
    int32_t nirtot;
    int32_t nrlnec;
    int32_t nirnec;
    int32_t nrladu;
    int32_t niradu;
    int32_t ncmpa;
    int32_t oor;
    int32_t dup;
    int32_t maxfrt;
    int32_t stat;
    int32_t faulty;
    float opsa;
    float opse;
};

struct sils_ainfo_type_s_64 {
    int64_t flag;
    int64_t more;
    int64_t nsteps;
    int64_t nrltot;
    int64_t nirtot;
    int64_t nrlnec;
    int64_t nirnec;
    int64_t nrladu;
    int64_t niradu;
    int64_t ncmpa;
    int64_t oor;
    int64_t dup;
    int64_t maxfrt;
    int64_t stat;
    int64_t faulty;
    float opsa;
    float opse;
};

struct sils_finfo_type_s {
    int32_t flag;
    int32_t more;
    int32_t maxfrt;
    int32_t nebdu;
    int32_t nrlbdu;
    int32_t nirbdu;
    int32_t nrltot;
    int32_t nirtot;
    int32_t nrlnec;
    int32_t nirnec;
    int32_t ncmpbr;
    int32_t ncmpbi;
    int32_t ntwo;
    int32_t neig;
    int32_t delay;
    int32_t signc;
    int32_t nstatic;
    int32_t modstep;
    int32_t rank;
    int32_t stat;
    int32_t faulty;
    int32_t step;
    float opsa;
    float opse;
    float opsb;
    float maxchange;
    float smin;
    float smax;
};

struct sils_finfo_type_s_64 {
    int64_t flag;
    int64_t more;
    int64_t maxfrt;
    int64_t nebdu;
    int64_t nrlbdu;
    int64_t nirbdu;
    int64_t nrltot;
    int64_t nirtot;
    int64_t nrlnec;
    int64_t nirnec;
    int64_t ncmpbr;
    int64_t ncmpbi;
    int64_t ntwo;
    int64_t neig;
    int64_t delay;
    int64_t signc;
    int64_t nstatic;
    int64_t modstep;
    int64_t rank;
    int64_t stat;
    int64_t faulty;
    int64_t step;
    float opsa;
    float opse;
    float opsb;
    float maxchange;
    float smin;
    float smax;
};

struct sils_sinfo_type_s {
    int32_t flag;
    int32_t stat;
    float cond;
    float cond2;
    float berr;
    float berr2;
    float error;
};

struct sils_sinfo_type_s_64 {
    int64_t flag;
    int64_t stat;
    float cond;
    float cond2;
    float berr;
    float berr2;
    float error;
};

void sils_initialize_s(void **data, struct sils_control_type_s *control, int32_t *status);
void sils_initialize_s_64(void **data, struct sils_control_type_s_64 *control, int64_t *status);
void sils_read_specfile_s(struct sils_control_type_s *control, char *specfile);
void sils_read_specfile_s_64(struct sils_control_type_s_64 *control, char *specfile);
void sils_import_s(struct sils_control_type_s *control, void **data, int32_t *status);
void sils_import_s_64(struct sils_control_type_s_64 *control, void **data, int64_t *status);
void sils_reset_control_s(struct sils_control_type_s *control, void **data, int32_t *status);
void sils_reset_control_s_64(struct sils_control_type_s_64 *control, void **data, int64_t *status);
void sils_information_s(void **data, struct sils_ainfo_type_s *ainfo, struct sils_finfo_type_s *finfo, struct sils_sinfo_type_s *sinfo, int32_t *status);
void sils_information_s_64(void **data, struct sils_ainfo_type_s_64 *ainfo, struct sils_finfo_type_s_64 *finfo, struct sils_sinfo_type_s_64 *sinfo, int64_t *status);
void sils_finalize_s(void **data, struct sils_control_type_s *control, int32_t *status);
void sils_finalize_s_64(void **data, struct sils_control_type_s_64 *control, int64_t *status);

// C interface for UGO
struct ugo_control_type_s {
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t initial_points;
    int32_t storage_increment;
    int32_t buffer;
    int32_t lipschitz_estimate_used;
    int32_t next_interval_selection;
    int32_t refine_with_newton;
    int32_t alive_unit;
    char alive_file[31];
    float stop_length;
    float small_g_for_newton;
    float small_g;
    float obj_sufficient;
    float global_lipschitz_constant;
    float reliability_parameter;
    float lipschitz_lower_bound;
    float cpu_time_limit;
    float clock_time_limit;
    bool second_derivative_available;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct ugo_control_type_s_64 {
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t initial_points;
    int64_t storage_increment;
    int64_t buffer;
    int64_t lipschitz_estimate_used;
    int64_t next_interval_selection;
    int64_t refine_with_newton;
    int64_t alive_unit;
    char alive_file[31];
    float stop_length;
    float small_g_for_newton;
    float small_g;
    float obj_sufficient;
    float global_lipschitz_constant;
    float reliability_parameter;
    float lipschitz_lower_bound;
    float cpu_time_limit;
    float clock_time_limit;
    bool second_derivative_available;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct ugo_time_type_s {
    float total;
    float clock_total;
};

struct ugo_inform_type_s {
    int32_t status;
    int32_t eval_status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    struct ugo_time_type_s time;
};

struct ugo_inform_type_s_64 {
    int64_t status;
    int64_t eval_status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    struct ugo_time_type_s time;
};

void ugo_initialize_s(void **data, struct ugo_control_type_s *control, int32_t *status);
void ugo_initialize_s_64(void **data, struct ugo_control_type_s_64 *control, int64_t *status);
void ugo_read_specfile_s(struct ugo_control_type_s *control, char *specfile);
void ugo_read_specfile_s_64(struct ugo_control_type_s_64 *control, char *specfile);
void ugo_import_s(struct ugo_control_type_s *control, void **data, int32_t *status, float *x_l, float *x_u);
void ugo_import_s_64(struct ugo_control_type_s_64 *control, void **data, int64_t *status, float *x_l, float *x_u);
void ugo_reset_control_s(struct ugo_control_type_s *control, void **data, int32_t *status);
void ugo_reset_control_s_64(struct ugo_control_type_s_64 *control, void **data, int64_t *status);
void ugo_solve_direct_s(void **data, void *userdata, int32_t *status, float *x, float *f, float *g, float *h, galahad_fgh_s *eval_fgh);
void ugo_solve_direct_s_64(void **data, void *userdata, int64_t *status, float *x, float *f, float *g, float *h, galahad_fgh_s_64 *eval_fgh);
void ugo_solve_reverse_s(void **data, int32_t *status, int32_t *eval_status, float *x, float *f, float *g, float *h);
void ugo_solve_reverse_s_64(void **data, int64_t *status, int64_t *eval_status, float *x, float *f, float *g, float *h);
void ugo_information_s(void **data, struct ugo_inform_type_s *inform, int32_t *status);
void ugo_information_s_64(void **data, struct ugo_inform_type_s_64 *inform, int64_t *status);
void ugo_terminate_s(void **data, struct ugo_control_type_s *control, struct ugo_inform_type_s *inform);
void ugo_terminate_s_64(void **data, struct ugo_control_type_s_64 *control, struct ugo_inform_type_s_64 *inform);

// C interface for SSIDS
struct spral_ssids_options_s {
    int32_t array_base;
    int32_t print_level;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int32_t ordering;
    int32_t nemin;
    bool ignore_numa;
    bool use_gpu;
    bool gpu_only;
    int64_t min_gpu_work;
    float max_load_inbalance;
    float gpu_perf_coeff;
    int32_t scaling;
    int64_t small_subtree_threshold;
    int32_t cpu_block_size;
    bool action;
    int32_t pivot_method;
    float small;
    float u;
    struct nodend_control_type nodend_options;
    int32_t nstream;
    float multiplier;
    float min_loadbalance;
    int32_t failed_pivot_method;
};

struct spral_ssids_options_s_64 {
    int64_t array_base;
    int64_t print_level;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t ordering;
    int64_t nemin;
    bool ignore_numa;
    bool use_gpu;
    bool gpu_only;
    int64_t min_gpu_work;
    float max_load_inbalance;
    float gpu_perf_coeff;
    int64_t scaling;
    int64_t small_subtree_threshold;
    int64_t cpu_block_size;
    bool action;
    int64_t pivot_method;
    float small;
    float u;
    struct nodend_control_type_64 nodend_options;
    int64_t nstream;
    float multiplier;
    float min_loadbalance;
    int64_t failed_pivot_method;
};

struct spral_ssids_inform_s {
    int32_t flag;
    int32_t matrix_dup;
    int32_t matrix_missing_diag;
    int32_t matrix_outrange;
    int32_t matrix_rank;
    int32_t maxdepth;
    int32_t maxfront;
    int32_t maxsupernode;
    int32_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int32_t num_neg;
    int32_t num_sup;
    int32_t num_two;
    int32_t stat;
    int32_t cuda_error;
    int32_t cublas_error;
    struct nodend_inform_type_s nodend_inform;
    int32_t not_first_pass;
    int32_t not_second_pass;
    int32_t nparts;
    int64_t cpu_flops;
    int64_t gpu_flops;
};

struct spral_ssids_inform_s_64 {
    int64_t flag;
    int64_t matrix_dup;
    int64_t matrix_missing_diag;
    int64_t matrix_outrange;
    int64_t matrix_rank;
    int64_t maxdepth;
    int64_t maxfront;
    int64_t maxsupernode;
    int64_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int64_t num_neg;
    int64_t num_sup;
    int64_t num_two;
    int64_t stat;
    int64_t cuda_error;
    int64_t cublas_error;
    struct nodend_inform_type_s_64 nodend_inform;
    int64_t not_first_pass;
    int64_t not_second_pass;
    int64_t nparts;
    int64_t cpu_flops;
    int64_t gpu_flops;
};

// C interface for SLS
struct sls_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t warning;
    int32_t out;
    int32_t statistics;
    int32_t print_level;
    int32_t print_level_solver;
    int32_t bits;
    int32_t block_size_kernel;
    int32_t block_size_elimination;
    int32_t blas_block_size_factorize;
    int32_t blas_block_size_solve;
    int32_t node_amalgamation;
    int32_t initial_pool_size;
    int32_t min_real_factor_size;
    int32_t min_integer_factor_size;
    int64_t max_real_factor_size;
    int64_t max_integer_factor_size;
    int64_t max_in_core_store;
    float array_increase_factor;
    float array_decrease_factor;
    int32_t pivot_control;
    int32_t ordering;
    int32_t full_row_threshold;
    int32_t row_search_indefinite;
    int32_t scaling;
    int32_t scale_maxit;
    float scale_thresh;
    float relative_pivot_tolerance;
    float minimum_pivot_tolerance;
    float absolute_pivot_tolerance;
    float zero_tolerance;
    float zero_pivot_tolerance;
    float negative_pivot_tolerance;
    float static_pivot_tolerance;
    float static_level_switch;
    float consistency_tolerance;
    int32_t max_iterative_refinements;
    float acceptable_residual_relative;
    float acceptable_residual_absolute;
    bool multiple_rhs;
    bool generate_matrix_file;
    int32_t matrix_file_device;
    char matrix_file_name[31];
    char out_of_core_directory[401];
    char out_of_core_integer_factor_file[401];
    char out_of_core_real_factor_file[401];
    char out_of_core_real_work_file[401];
    char out_of_core_indefinite_file[401];
    char out_of_core_restart_file[501];
    char prefix[31];
    struct nodend_control_type nodend_control;
};

struct sls_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t warning;
    int64_t out;
    int64_t statistics;
    int64_t print_level;
    int64_t print_level_solver;
    int64_t bits;
    int64_t block_size_kernel;
    int64_t block_size_elimination;
    int64_t blas_block_size_factorize;
    int64_t blas_block_size_solve;
    int64_t node_amalgamation;
    int64_t initial_pool_size;
    int64_t min_real_factor_size;
    int64_t min_integer_factor_size;
    int64_t max_real_factor_size;
    int64_t max_integer_factor_size;
    int64_t max_in_core_store;
    float array_increase_factor;
    float array_decrease_factor;
    int64_t pivot_control;
    int64_t ordering;
    int64_t full_row_threshold;
    int64_t row_search_indefinite;
    int64_t scaling;
    int64_t scale_maxit;
    float scale_thresh;
    float relative_pivot_tolerance;
    float minimum_pivot_tolerance;
    float absolute_pivot_tolerance;
    float zero_tolerance;
    float zero_pivot_tolerance;
    float negative_pivot_tolerance;
    float static_pivot_tolerance;
    float static_level_switch;
    float consistency_tolerance;
    int64_t max_iterative_refinements;
    float acceptable_residual_relative;
    float acceptable_residual_absolute;
    bool multiple_rhs;
    bool generate_matrix_file;
    int64_t matrix_file_device;
    char matrix_file_name[31];
    char out_of_core_directory[401];
    char out_of_core_integer_factor_file[401];
    char out_of_core_real_factor_file[401];
    char out_of_core_real_work_file[401];
    char out_of_core_indefinite_file[401];
    char out_of_core_restart_file[501];
    char prefix[31];
    struct nodend_control_type_64 nodend_control;
};

struct sls_time_type_s {
    float total;
    float analyse;
    float factorize;
    float solve;
    float order_external;
    float analyse_external;
    float factorize_external;
    float solve_external;
    float clock_total;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
    float clock_order_external;
    float clock_analyse_external;
    float clock_factorize_external;
    float clock_solve_external;
};

struct sls_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t more_info;
    int32_t entries;
    int32_t out_of_range;
    int32_t duplicates;
    int32_t upper;
    int32_t missing_diagonals;
    int32_t max_depth_assembly_tree;
    int32_t nodes_assembly_tree;
    int64_t real_size_desirable;
    int64_t integer_size_desirable;
    int64_t real_size_necessary;
    int64_t integer_size_necessary;
    int64_t real_size_factors;
    int64_t integer_size_factors;
    int64_t entries_in_factors;
    int32_t max_task_pool_size;
    int32_t max_front_size;
    int32_t compresses_real;
    int32_t compresses_integer;
    int32_t two_by_two_pivots;
    int32_t semi_bandwidth;
    int32_t delayed_pivots;
    int32_t pivot_sign_changes;
    int32_t static_pivots;
    int32_t first_modified_pivot;
    int32_t rank;
    int32_t negative_eigenvalues;
    int32_t num_zero;
    int32_t iterative_refinements;
    int64_t flops_assembly;
    int64_t flops_elimination;
    int64_t flops_blas;
    float largest_modified_pivot;
    float minimum_scaling_factor;
    float maximum_scaling_factor;
    float condition_number_1;
    float condition_number_2;
    float backward_error_1;
    float backward_error_2;
    float forward_error;
    bool alternative;
    char solver[21];
    struct sls_time_type_s time;
    struct sils_ainfo_type_s sils_ainfo;
    struct sils_finfo_type_s sils_finfo;
    struct sils_sinfo_type_s sils_sinfo;
    struct ma57_ainfo_s ma57_ainfo;
    struct ma57_finfo_s ma57_finfo;
    struct ma57_sinfo_s ma57_sinfo;
    struct ma77_info_s ma77_info;
    struct ma86_info_s ma86_info;
    struct ma87_info_s ma87_info;
    struct ma97_info_s ma97_info;
    struct spral_ssids_inform_s ssids_inform;
    struct nodend_inform_type_s nodend_inform;
    int32_t mc61_info[10];
    float mc61_rinfo[15];
    struct mc64_info mc64_info;
    struct mc68_info mc68_info;
    int32_t mc77_info[10];
    float mc77_rinfo[10];
    int32_t mumps_error;
    int32_t mumps_info[80];
    float mumps_rinfo[40];
    int32_t pardiso_error;
    int32_t pardiso_IPARM[64];
    float pardiso_DPARM[64];
    int32_t mkl_pardiso_error;
    int32_t mkl_pardiso_IPARM[64];
    int32_t pastix_info;
    int32_t wsmp_error;
    int32_t wsmp_iparm[64];
    float wsmp_dparm[64];
    int32_t mpi_ierr;
    int32_t lapack_error;
};

struct sls_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t more_info;
    int64_t entries;
    int64_t out_of_range;
    int64_t duplicates;
    int64_t upper;
    int64_t missing_diagonals;
    int64_t max_depth_assembly_tree;
    int64_t nodes_assembly_tree;
    int64_t real_size_desirable;
    int64_t integer_size_desirable;
    int64_t real_size_necessary;
    int64_t integer_size_necessary;
    int64_t real_size_factors;
    int64_t integer_size_factors;
    int64_t entries_in_factors;
    int64_t max_task_pool_size;
    int64_t max_front_size;
    int64_t compresses_real;
    int64_t compresses_integer;
    int64_t two_by_two_pivots;
    int64_t semi_bandwidth;
    int64_t delayed_pivots;
    int64_t pivot_sign_changes;
    int64_t static_pivots;
    int64_t first_modified_pivot;
    int64_t rank;
    int64_t negative_eigenvalues;
    int64_t num_zero;
    int64_t iterative_refinements;
    int64_t flops_assembly;
    int64_t flops_elimination;
    int64_t flops_blas;
    float largest_modified_pivot;
    float minimum_scaling_factor;
    float maximum_scaling_factor;
    float condition_number_1;
    float condition_number_2;
    float backward_error_1;
    float backward_error_2;
    float forward_error;
    bool alternative;
    char solver[21];
    struct sls_time_type_s time;
    struct sils_ainfo_type_s_64 sils_ainfo;
    struct sils_finfo_type_s_64 sils_finfo;
    struct sils_sinfo_type_s_64 sils_sinfo;
    struct ma57_ainfo_s_64 ma57_ainfo;
    struct ma57_finfo_s_64 ma57_finfo;
    struct ma57_sinfo_s_64 ma57_sinfo;
    struct ma77_info_s_64 ma77_info;
    struct ma86_info_s_64 ma86_info;
    struct ma87_info_s_64 ma87_info;
    struct ma97_info_s_64 ma97_info;
    struct spral_ssids_inform_s_64 ssids_inform;
    struct nodend_inform_type_s_64 nodend_inform;
    int64_t mc61_info[10];
    float mc61_rinfo[15];
    struct mc64_info_64 mc64_info;
    struct mc68_info_64 mc68_info;
    int64_t mc77_info[10];
    float mc77_rinfo[10];
    int64_t mumps_error;
    int64_t mumps_info[80];
    float mumps_rinfo[40];
    int64_t pardiso_error;
    int64_t pardiso_IPARM[64];
    float pardiso_DPARM[64];
    int64_t mkl_pardiso_error;
    int64_t mkl_pardiso_IPARM[64];
    int64_t pastix_info;
    int64_t wsmp_error;
    int64_t wsmp_iparm[64];
    float wsmp_dparm[64];
    int64_t mpi_ierr;
    int64_t lapack_error;
};

void sls_initialize_s(char *solver, void **data, struct sls_control_type_s *control, int32_t *status);
void sls_initialize_s_64(char *solver, void **data, struct sls_control_type_s_64 *control, int64_t *status);
void sls_read_specfile_s(struct sls_control_type_s *control, char *specfile);
void sls_read_specfile_s_64(struct sls_control_type_s_64 *control, char *specfile);
void sls_analyse_matrix_s(struct sls_control_type_s *control, void **data, int32_t *status, int32_t n, char *type, int32_t ne, int32_t *row, int32_t *col, int32_t *ptr);
void sls_analyse_matrix_s_64(struct sls_control_type_s_64 *control, void **data, int64_t *status, int64_t n, char *type, int64_t ne, int64_t *row, int64_t *col, int64_t *ptr);
void sls_reset_control_s(struct sls_control_type_s *control, void **data, int32_t *status);
void sls_reset_control_s_64(struct sls_control_type_s_64 *control, void **data, int64_t *status);
void sls_factorize_matrix_s(void **data, int32_t *status, int32_t ne, float *val);
void sls_factorize_matrix_s_64(void **data, int64_t *status, int64_t ne, float *val);
void sls_solve_system_s(void **data, int32_t *status, int32_t n, float *sol);
void sls_solve_system_s_64(void **data, int64_t *status, int64_t n, float *sol);
void sls_partial_solve_system_s(char *part, void **data, int32_t *status, int32_t n, float *sol);
void sls_partial_solve_system_s_64(char *part, void **data, int64_t *status, int64_t n, float *sol);
void sls_information_s(void **data, struct sls_inform_type_s *inform, int32_t *status);
void sls_information_s_64(void **data, struct sls_inform_type_s_64 *inform, int64_t *status);
void sls_terminate_s(void **data, struct sls_control_type_s *control, struct sls_inform_type_s *inform);
void sls_terminate_s_64(void **data, struct sls_control_type_s_64 *control, struct sls_inform_type_s_64 *inform);

// C interface for RQS
struct rqs_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t problem;
    int32_t print_level;
    int32_t dense_factorization;
    int32_t new_h;
    int32_t new_m;
    int32_t new_a;
    int32_t max_factorizations;
    int32_t inverse_itmax;
    int32_t taylor_max_degree;
    float initial_multiplier;
    float lower;
    float upper;
    float stop_normal;
    float stop_hard;
    float start_invit_tol;
    float start_invitmax_tol;
    bool use_initial_multiplier;
    bool initialize_approx_eigenvector;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s sls_control;
    struct ir_control_type_s ir_control;
};

struct rqs_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t problem;
    int64_t print_level;
    int64_t dense_factorization;
    int64_t new_h;
    int64_t new_m;
    int64_t new_a;
    int64_t max_factorizations;
    int64_t inverse_itmax;
    int64_t taylor_max_degree;
    float initial_multiplier;
    float lower;
    float upper;
    float stop_normal;
    float stop_hard;
    float start_invit_tol;
    float start_invitmax_tol;
    bool use_initial_multiplier;
    bool initialize_approx_eigenvector;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s_64 sls_control;
    struct ir_control_type_s_64 ir_control;
};

struct rqs_time_type_s {
    float total;
    float assemble;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_assemble;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct rqs_history_type_s {
    float lambda;
    float x_norm;
};

struct rqs_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    int32_t factorizations;
    int64_t max_entries_factors;
    int32_t len_history;
    float obj;
    float obj_regularized;
    float x_norm;
    float multiplier;
    float pole;
    bool dense_factorization;
    bool hard_case;
    char bad_alloc[81];
    struct rqs_time_type_s time;
    struct rqs_history_type_s history[100];
    struct sls_inform_type_s sls_inform;
    struct ir_inform_type_s ir_inform;
};

struct rqs_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorizations;
    int64_t max_entries_factors;
    int64_t len_history;
    float obj;
    float obj_regularized;
    float x_norm;
    float multiplier;
    float pole;
    bool dense_factorization;
    bool hard_case;
    char bad_alloc[81];
    struct rqs_time_type_s time;
    struct rqs_history_type_s history[100];
    struct sls_inform_type_s_64 sls_inform;
    struct ir_inform_type_s_64 ir_inform;
};

void rqs_initialize_s(void **data, struct rqs_control_type_s *control, int32_t *status);
void rqs_initialize_s_64(void **data, struct rqs_control_type_s_64 *control, int64_t *status);
void rqs_read_specfile_s(struct rqs_control_type_s *control, char *specfile);
void rqs_read_specfile_s_64(struct rqs_control_type_s_64 *control, char *specfile);
void rqs_import_s(struct rqs_control_type_s *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void rqs_import_s_64(struct rqs_control_type_s_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void rqs_import_m_s(void **data, int32_t *status, int32_t n, char *M_type, int32_t M_ne, int32_t *M_row, int32_t *M_col, int32_t *M_ptr);
void rqs_import_m_s_64(void **data, int64_t *status, int64_t n, char *M_type, int64_t M_ne, int64_t *M_row, int64_t *M_col, int64_t *M_ptr);
void rqs_import_a_s(void **data, int32_t *status, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void rqs_import_a_s_64(void **data, int64_t *status, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void rqs_reset_control_s(struct rqs_control_type_s *control, void **data, int32_t *status);
void rqs_reset_control_s_64(struct rqs_control_type_s_64 *control, void **data, int64_t *status);
void rqs_solve_problem_s(void **data, int32_t *status, int32_t n, float power, float weight, float f, float *c, int32_t H_ne, float *H_val, float *x, int32_t M_ne, float *M_val, int32_t m, int32_t A_ne, float *A_val, float *y);
void rqs_solve_problem_s_64(void **data, int64_t *status, int64_t n, float power, float weight, float f, float *c, int64_t H_ne, float *H_val, float *x, int64_t M_ne, float *M_val, int64_t m, int64_t A_ne, float *A_val, float *y);
void rqs_information_s(void **data, struct rqs_inform_type_s *inform, int32_t *status);
void rqs_information_s_64(void **data, struct rqs_inform_type_s_64 *inform, int64_t *status);
void rqs_terminate_s(void **data, struct rqs_control_type_s *control, struct rqs_inform_type_s *inform);
void rqs_terminate_s_64(void **data, struct rqs_control_type_s_64 *control, struct rqs_inform_type_s_64 *inform);

// C interface for DPS
struct dps_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t problem;
    int32_t print_level;
    int32_t new_h;
    int32_t taylor_max_degree;
    float eigen_min;
    float lower;
    float upper;
    float stop_normal;
    float stop_absolute_normal;
    bool goldfarb;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s sls_control;
};

struct dps_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t problem;
    int64_t print_level;
    int64_t new_h;
    int64_t taylor_max_degree;
    float eigen_min;
    float lower;
    float upper;
    float stop_normal;
    float stop_absolute_normal;
    bool goldfarb;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s_64 sls_control;
};

struct dps_time_type_s {
    float total;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct dps_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    int32_t mod_1by1;
    int32_t mod_2by2;
    float obj;
    float obj_regularized;
    float x_norm;
    float multiplier;
    float pole;
    bool hard_case;
    char bad_alloc[81];
    struct dps_time_type_s time;
    struct sls_inform_type_s sls_inform;
};

struct dps_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t mod_1by1;
    int64_t mod_2by2;
    float obj;
    float obj_regularized;
    float x_norm;
    float multiplier;
    float pole;
    bool hard_case;
    char bad_alloc[81];
    struct dps_time_type_s time;
    struct sls_inform_type_s_64 sls_inform;
};

void dps_initialize_s(void **data, struct dps_control_type_s *control, int32_t *status);
void dps_initialize_s_64(void **data, struct dps_control_type_s_64 *control, int64_t *status);
void dps_read_specfile_s(struct dps_control_type_s *control, char *specfile);
void dps_read_specfile_s_64(struct dps_control_type_s_64 *control, char *specfile);
void dps_import_s(struct dps_control_type_s *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void dps_import_s_64(struct dps_control_type_s_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void dps_reset_control_s(struct dps_control_type_s *control, void **data, int32_t *status);
void dps_reset_control_s_64(struct dps_control_type_s_64 *control, void **data, int64_t *status);
void dps_solve_tr_problem_s(void **data, int32_t *status, int32_t n, int32_t ne, float *H_val, float *c, float f, float radius, float *x);
void dps_solve_tr_problem_s_64(void **data, int64_t *status, int64_t n, int64_t ne, float *H_val, float *c, float f, float radius, float *x);
void dps_solve_rq_problem_s(void **data, int32_t *status, int32_t n, int32_t ne, float *H_val, float *c, float f, float power, float weight, float *x);
void dps_solve_rq_problem_s_64(void **data, int64_t *status, int64_t n, int64_t ne, float *H_val, float *c, float f, float power, float weight, float *x);
void dps_resolve_tr_problem_s(void **data, int32_t *status, int32_t n, float *c, float f, float radius, float *x);
void dps_resolve_tr_problem_s_64(void **data, int64_t *status, int64_t n, float *c, float f, float radius, float *x);
void dps_resolve_rq_problem_s(void **data, int32_t *status, int32_t n, float *c, float f, float power, float weight, float *x);
void dps_resolve_rq_problem_s_64(void **data, int64_t *status, int64_t n, float *c, float f, float power, float weight, float *x);
void dps_information_s(void **data, struct dps_inform_type_s *inform, int32_t *status);
void dps_information_s_64(void **data, struct dps_inform_type_s_64 *inform, int64_t *status);
void dps_terminate_s(void **data, struct dps_control_type_s *control, struct dps_inform_type_s *inform);
void dps_terminate_s_64(void **data, struct dps_control_type_s_64 *control, struct dps_inform_type_s_64 *inform);

// C interface for PSLS
struct psls_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t preconditioner;
    int32_t semi_bandwidth;
    int32_t scaling;
    int32_t ordering;
    int32_t max_col;
    int32_t icfs_vectors;
    int32_t mi28_lsize;
    int32_t mi28_rsize;
    float min_diagonal;
    bool new_structure;
    bool get_semi_bandwidth;
    bool get_norm_residual;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s sls_control;
    struct mi28_control_s mi28_control;
};

struct psls_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t preconditioner;
    int64_t semi_bandwidth;
    int64_t scaling;
    int64_t ordering;
    int64_t max_col;
    int64_t icfs_vectors;
    int64_t mi28_lsize;
    int64_t mi28_rsize;
    float min_diagonal;
    bool new_structure;
    bool get_semi_bandwidth;
    bool get_norm_residual;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s_64 sls_control;
    struct mi28_control_s_64 mi28_control;
};

struct psls_time_type_s {
    float total;
    float assemble;
    float analyse;
    float factorize;
    float solve;
    float update;
    float clock_total;
    float clock_assemble;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
    float clock_update;
};

struct psls_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    int32_t analyse_status;
    int32_t factorize_status;
    int32_t solve_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t preconditioner;
    int32_t semi_bandwidth;
    int32_t reordered_semi_bandwidth;
    int32_t out_of_range;
    int32_t duplicates;
    int32_t upper;
    int32_t missing_diagonals;
    int32_t semi_bandwidth_used;
    int32_t neg1;
    int32_t neg2;
    bool perturbed;
    float fill_in_ratio;
    float norm_residual;
    char bad_alloc[81];
    int32_t mc61_info[10];
    float mc61_rinfo[15];
    struct psls_time_type_s time;
    struct sls_inform_type_s sls_inform;
    struct mi28_info_s mi28_info;
};

struct psls_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t analyse_status;
    int64_t factorize_status;
    int64_t solve_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t preconditioner;
    int64_t semi_bandwidth;
    int64_t reordered_semi_bandwidth;
    int64_t out_of_range;
    int64_t duplicates;
    int64_t upper;
    int64_t missing_diagonals;
    int64_t semi_bandwidth_used;
    int64_t neg1;
    int64_t neg2;
    bool perturbed;
    float fill_in_ratio;
    float norm_residual;
    char bad_alloc[81];
    int64_t mc61_info[10];
    float mc61_rinfo[15];
    struct psls_time_type_s time;
    struct sls_inform_type_s_64 sls_inform;
    struct mi28_info_s_64 mi28_info;
};

void psls_initialize_s(void **data, struct psls_control_type_s *control, int32_t *status);
void psls_initialize_s_64(void **data, struct psls_control_type_s_64 *control, int64_t *status);
void psls_read_specfile_s(struct psls_control_type_s *control, char *specfile);
void psls_read_specfile_s_64(struct psls_control_type_s_64 *control, char *specfile);
void psls_import_s(struct psls_control_type_s *control, void **data, int32_t *status, int32_t n, char *type, int32_t ne, int32_t *row, int32_t *col, int32_t *ptr);
void psls_import_s_64(struct psls_control_type_s_64 *control, void **data, int64_t *status, int64_t n, char *type, int64_t ne, int64_t *row, int64_t *col, int64_t *ptr);
void psls_reset_control_s(struct psls_control_type_s *control, void **data, int32_t *status);
void psls_reset_control_s_64(struct psls_control_type_s_64 *control, void **data, int64_t *status);
void psls_form_preconditioner_s(void **data, int32_t *status, int32_t ne, float *val);
void psls_form_preconditioner_s_64(void **data, int64_t *status, int64_t ne, float *val);
void psls_form_subset_preconditioner_s(void **data, int32_t *status, int32_t ne, float *val, int32_t n_sub, int32_t *sub);
void psls_form_subset_preconditioner_s_64(void **data, int64_t *status, int64_t ne, float *val, int64_t n_sub, int64_t *sub);
void psls_update_preconditioner_s(void **data, int32_t *status, int32_t ne, float *val, int32_t n_del, int32_t *del);
void psls_update_preconditioner_s_64(void **data, int64_t *status, int64_t ne, float *val, int64_t n_del, int64_t *del);
void psls_apply_preconditioner_s(void **data, int32_t *status, int32_t n, float *sol);
void psls_apply_preconditioner_s_64(void **data, int64_t *status, int64_t n, float *sol);
void psls_information_s(void **data, struct psls_inform_type_s *inform, int32_t *status);
void psls_information_s_64(void **data, struct psls_inform_type_s_64 *inform, int64_t *status);
void psls_terminate_s(void **data, struct psls_control_type_s *control, struct psls_inform_type_s *inform);
void psls_terminate_s_64(void **data, struct psls_control_type_s_64 *control, struct psls_inform_type_s_64 *inform);

// C interface for ARC
struct arc_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t non_monotone;
    int32_t model;
    int32_t norm;
    int32_t semi_bandwidth;
    int32_t lbfgs_vectors;
    int32_t max_dxg;
    int32_t icfs_vectors;
    int32_t mi28_lsize;
    int32_t mi28_rsize;
    int32_t advanced_start;
    float stop_g_absolute;
    float stop_g_relative;
    float stop_s;
    float initial_weight;
    float minimum_weight;
    float reduce_gap;
    float tiny_gap;
    float large_root;
    float eta_successful;
    float eta_very_successful;
    float eta_too_successful;
    float weight_decrease_min;
    float weight_decrease;
    float weight_increase;
    float weight_increase_max;
    float obj_unbounded;
    float cpu_time_limit;
    float clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool renormalize_weight;
    bool quadratic_ratio_test;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_s rqs_control;
    struct glrt_control_type_s glrt_control;
    struct dps_control_type_s dps_control;
    struct psls_control_type_s psls_control;
    struct lms_control_type lms_control;
    struct lms_control_type lms_control_prec;
    struct sha_control_type sha_control;
};

struct arc_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t non_monotone;
    int64_t model;
    int64_t norm;
    int64_t semi_bandwidth;
    int64_t lbfgs_vectors;
    int64_t max_dxg;
    int64_t icfs_vectors;
    int64_t mi28_lsize;
    int64_t mi28_rsize;
    int64_t advanced_start;
    float stop_g_absolute;
    float stop_g_relative;
    float stop_s;
    float initial_weight;
    float minimum_weight;
    float reduce_gap;
    float tiny_gap;
    float large_root;
    float eta_successful;
    float eta_very_successful;
    float eta_too_successful;
    float weight_decrease_min;
    float weight_decrease;
    float weight_increase;
    float weight_increase_max;
    float obj_unbounded;
    float cpu_time_limit;
    float clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool renormalize_weight;
    bool quadratic_ratio_test;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_s_64 rqs_control;
    struct glrt_control_type_s_64 glrt_control;
    struct dps_control_type_s_64 dps_control;
    struct psls_control_type_s_64 psls_control;
    struct lms_control_type_64 lms_control;
    struct lms_control_type_64 lms_control_prec;
    struct sha_control_type_64 sha_control;
};

struct arc_time_type_s {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_preprocess;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct arc_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    int32_t factorization_max;
    int32_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    float factorization_average;
    float obj;
    float norm_g;
    float weight;
    struct arc_time_type_s time;
    struct rqs_inform_type_s rqs_inform;
    struct glrt_inform_type_s glrt_inform;
    struct dps_inform_type_s dps_inform;
    struct psls_inform_type_s psls_inform;
    struct lms_inform_type_s lms_inform;
    struct lms_inform_type_s lms_inform_prec;
    struct sha_inform_type_s sha_inform;
};

struct arc_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    int64_t factorization_max;
    int64_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    float factorization_average;
    float obj;
    float norm_g;
    float weight;
    struct arc_time_type_s time;
    struct rqs_inform_type_s_64 rqs_inform;
    struct glrt_inform_type_s_64 glrt_inform;
    struct dps_inform_type_s_64 dps_inform;
    struct psls_inform_type_s_64 psls_inform;
    struct lms_inform_type_s_64 lms_inform;
    struct lms_inform_type_s_64 lms_inform_prec;
    struct sha_inform_type_s_64 sha_inform;
};

void arc_initialize_s(void **data, struct arc_control_type_s *control, int32_t *status);
void arc_initialize_s_64(void **data, struct arc_control_type_s_64 *control, int64_t *status);
void arc_read_specfile_s(struct arc_control_type_s *control, char *specfile);
void arc_read_specfile_s_64(struct arc_control_type_s_64 *control, char *specfile);
void arc_import_s(struct arc_control_type_s *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void arc_import_s_64(struct arc_control_type_s_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void arc_reset_control_s(struct arc_control_type_s *control, void **data, int32_t *status);
void arc_reset_control_s_64(struct arc_control_type_s_64 *control, void **data, int64_t *status);
void arc_solve_with_mat_s(void **data, void *userdata, int32_t *status, int32_t n, float *x, float *g, int32_t ne, galahad_f_s *eval_f, galahad_g_s *eval_g, galahad_h_s *eval_h, galahad_prec_s *eval_prec);
void arc_solve_with_mat_s_64(void **data, void *userdata, int64_t *status, int64_t n, float *x, float *g, int64_t ne, galahad_f_s_64 *eval_f, galahad_g_s_64 *eval_g, galahad_h_s_64 *eval_h, galahad_prec_s_64 *eval_prec);
void arc_solve_without_mat_s(void **data, void *userdata, int32_t *status, int32_t n, float *x, float *g, galahad_f_s *eval_f, galahad_g_s *eval_g, galahad_hprod_s *eval_hprod, galahad_prec_s *eval_prec);
void arc_solve_without_mat_s_64(void **data, void *userdata, int64_t *status, int64_t n, float *x, float *g, galahad_f_s_64 *eval_f, galahad_g_s_64 *eval_g, galahad_hprod_s_64 *eval_hprod, galahad_prec_s_64 *eval_prec);
void arc_solve_reverse_with_mat_s(void **data, int32_t *status, int32_t *eval_status, int32_t n, float *x, float f, float *g, int32_t ne, float *H_val, float *u, float *v);
void arc_solve_reverse_with_mat_s_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, float *x, float f, float *g, int64_t ne, float *H_val, float *u, float *v);
void arc_solve_reverse_without_mat_s(void **data, int32_t *status, int32_t *eval_status, int32_t n, float *x, float f, float *g, float *u, float *v);
void arc_solve_reverse_without_mat_s_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, float *x, float f, float *g, float *u, float *v);
void arc_information_s(void **data, struct arc_inform_type_s *inform, int32_t *status);
void arc_information_s_64(void **data, struct arc_inform_type_s_64 *inform, int64_t *status);
void arc_terminate_s(void **data, struct arc_control_type_s *control, struct arc_inform_type_s *inform);
void arc_terminate_s_64(void **data, struct arc_control_type_s_64 *control, struct arc_inform_type_s_64 *inform);

// C interface for TRS
struct trs_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t problem;
    int32_t print_level;
    int32_t dense_factorization;
    int32_t new_h;
    int32_t new_m;
    int32_t new_a;
    int32_t max_factorizations;
    int32_t inverse_itmax;
    int32_t taylor_max_degree;
    float initial_multiplier;
    float lower;
    float upper;
    float stop_normal;
    float stop_absolute_normal;
    float stop_hard;
    float start_invit_tol;
    float start_invitmax_tol;
    bool equality_problem;
    bool use_initial_multiplier;
    bool initialize_approx_eigenvector;
    bool force_Newton;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s sls_control;
    struct ir_control_type_s ir_control;
};

struct trs_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t problem;
    int64_t print_level;
    int64_t dense_factorization;
    int64_t new_h;
    int64_t new_m;
    int64_t new_a;
    int64_t max_factorizations;
    int64_t inverse_itmax;
    int64_t taylor_max_degree;
    float initial_multiplier;
    float lower;
    float upper;
    float stop_normal;
    float stop_absolute_normal;
    float stop_hard;
    float start_invit_tol;
    float start_invitmax_tol;
    bool equality_problem;
    bool use_initial_multiplier;
    bool initialize_approx_eigenvector;
    bool force_Newton;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s_64 sls_control;
    struct ir_control_type_s_64 ir_control;
};

struct trs_time_type_s {
    float total;
    float assemble;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_assemble;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct trs_history_type_s {
    float lambda;
    float x_norm;
};

struct trs_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    int32_t factorizations;
    int64_t max_entries_factors;
    int32_t len_history;
    float obj;
    float x_norm;
    float multiplier;
    float pole;
    bool dense_factorization;
    bool hard_case;
    char bad_alloc[81];
    struct trs_time_type_s time;
    struct trs_history_type_s history[100];
    struct sls_inform_type_s sls_inform;
    struct ir_inform_type_s ir_inform;
};

struct trs_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorizations;
    int64_t max_entries_factors;
    int64_t len_history;
    float obj;
    float x_norm;
    float multiplier;
    float pole;
    bool dense_factorization;
    bool hard_case;
    char bad_alloc[81];
    struct trs_time_type_s time;
    struct trs_history_type_s history[100];
    struct sls_inform_type_s_64 sls_inform;
    struct ir_inform_type_s_64 ir_inform;
};

void trs_initialize_s(void **data, struct trs_control_type_s *control, int32_t *status);
void trs_initialize_s_64(void **data, struct trs_control_type_s_64 *control, int64_t *status);
void trs_read_specfile_s(struct trs_control_type_s *control, char *specfile);
void trs_read_specfile_s_64(struct trs_control_type_s_64 *control, char *specfile);
void trs_import_s(struct trs_control_type_s *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void trs_import_s_64(struct trs_control_type_s_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void trs_import_m_s(void **data, int32_t *status, int32_t n, char *M_type, int32_t M_ne, int32_t *M_row, int32_t *M_col, int32_t *M_ptr);
void trs_import_m_s_64(void **data, int64_t *status, int64_t n, char *M_type, int64_t M_ne, int64_t *M_row, int64_t *M_col, int64_t *M_ptr);
void trs_import_a_s(void **data, int32_t *status, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void trs_import_a_s_64(void **data, int64_t *status, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void trs_reset_control_s(struct trs_control_type_s *control, void **data, int32_t *status);
void trs_reset_control_s_64(struct trs_control_type_s_64 *control, void **data, int64_t *status);
void trs_solve_problem_s(void **data, int32_t *status, int32_t n, float radius, float f, float *c, int32_t H_ne, float *H_val, float *x, int32_t M_ne, float *M_val, int32_t m, int32_t A_ne, float *A_val, float *y);
void trs_solve_problem_s_64(void **data, int64_t *status, int64_t n, float radius, float f, float *c, int64_t H_ne, float *H_val, float *x, int64_t M_ne, float *M_val, int64_t m, int64_t A_ne, float *A_val, float *y);
void trs_information_s(void **data, struct trs_inform_type_s *inform, int32_t *status);
void trs_information_s_64(void **data, struct trs_inform_type_s_64 *inform, int64_t *status);
void trs_terminate_s(void **data, struct trs_control_type_s *control, struct trs_inform_type_s *inform);
void trs_terminate_s_64(void **data, struct trs_control_type_s_64 *control, struct trs_inform_type_s_64 *inform);

// C interface for TRB
struct trb_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t more_toraldo;
    int32_t non_monotone;
    int32_t model;
    int32_t norm;
    int32_t semi_bandwidth;
    int32_t lbfgs_vectors;
    int32_t max_dxg;
    int32_t icfs_vectors;
    int32_t mi28_lsize;
    int32_t mi28_rsize;
    int32_t advanced_start;
    float infinity;
    float stop_pg_absolute;
    float stop_pg_relative;
    float stop_s;
    float initial_radius;
    float maximum_radius;
    float stop_rel_cg;
    float eta_successful;
    float eta_very_successful;
    float eta_too_successful;
    float radius_increase;
    float radius_reduce;
    float radius_reduce_max;
    float obj_unbounded;
    float cpu_time_limit;
    float clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool retrospective_trust_region;
    bool renormalize_radius;
    bool two_norm_tr;
    bool exact_gcp;
    bool accurate_bqp;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct trs_control_type_s trs_control;
    struct gltr_control_type_s gltr_control;
    struct psls_control_type_s psls_control;
    struct lms_control_type lms_control;
    struct lms_control_type lms_control_prec;
    struct sha_control_type sha_control;
};

struct trb_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t more_toraldo;
    int64_t non_monotone;
    int64_t model;
    int64_t norm;
    int64_t semi_bandwidth;
    int64_t lbfgs_vectors;
    int64_t max_dxg;
    int64_t icfs_vectors;
    int64_t mi28_lsize;
    int64_t mi28_rsize;
    int64_t advanced_start;
    float infinity;
    float stop_pg_absolute;
    float stop_pg_relative;
    float stop_s;
    float initial_radius;
    float maximum_radius;
    float stop_rel_cg;
    float eta_successful;
    float eta_very_successful;
    float eta_too_successful;
    float radius_increase;
    float radius_reduce;
    float radius_reduce_max;
    float obj_unbounded;
    float cpu_time_limit;
    float clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool retrospective_trust_region;
    bool renormalize_radius;
    bool two_norm_tr;
    bool exact_gcp;
    bool accurate_bqp;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct trs_control_type_s_64 trs_control;
    struct gltr_control_type_s_64 gltr_control;
    struct psls_control_type_s_64 psls_control;
    struct lms_control_type_64 lms_control;
    struct lms_control_type_64 lms_control_prec;
    struct sha_control_type_64 sha_control;
};

struct trb_time_type_s {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_preprocess;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct trb_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t cg_maxit;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    int32_t n_free;
    int32_t factorization_status;
    int32_t factorization_max;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    float obj;
    float norm_pg;
    float radius;
    struct trb_time_type_s time;
    struct trs_inform_type_s trs_inform;
    struct gltr_inform_type_s gltr_inform;
    struct psls_inform_type_s psls_inform;
    struct lms_inform_type_s lms_inform;
    struct lms_inform_type_s lms_inform_prec;
    struct sha_inform_type_s sha_inform;
};

struct trb_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t cg_maxit;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    int64_t n_free;
    int64_t factorization_status;
    int64_t factorization_max;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    float obj;
    float norm_pg;
    float radius;
    struct trb_time_type_s time;
    struct trs_inform_type_s_64 trs_inform;
    struct gltr_inform_type_s_64 gltr_inform;
    struct psls_inform_type_s_64 psls_inform;
    struct lms_inform_type_s_64 lms_inform;
    struct lms_inform_type_s_64 lms_inform_prec;
    struct sha_inform_type_s_64 sha_inform;
};

void trb_initialize_s(void **data, struct trb_control_type_s *control, int32_t *status);
void trb_initialize_s_64(void **data, struct trb_control_type_s_64 *control, int64_t *status);
void trb_read_specfile_s(struct trb_control_type_s *control, char *specfile);
void trb_read_specfile_s_64(struct trb_control_type_s_64 *control, char *specfile);
void trb_import_s(struct trb_control_type_s *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void trb_import_s_64(struct trb_control_type_s_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void trb_reset_control_s(struct trb_control_type_s *control, void **data, int32_t *status);
void trb_reset_control_s_64(struct trb_control_type_s_64 *control, void **data, int64_t *status);
void trb_solve_with_mat_s(void **data, void *userdata, int32_t *status, int32_t n, float *x_l, float *x_u, float *x, float *g, int32_t ne, galahad_f_s *eval_f, galahad_g_s *eval_g, galahad_h_s *eval_h, galahad_prec_s *eval_prec);
void trb_solve_with_mat_s_64(void **data, void *userdata, int64_t *status, int64_t n, float *x_l, float *x_u, float *x, float *g, int64_t ne, galahad_f_s_64 *eval_f, galahad_g_s_64 *eval_g, galahad_h_s_64 *eval_h, galahad_prec_s_64 *eval_prec);
void trb_solve_without_mat_s(void **data, void *userdata, int32_t *status, int32_t n, float *x_l, float *x_u, float *x, float *g, galahad_f_s *eval_f, galahad_g_s *eval_g, galahad_hprod_s *eval_hprod, galahad_shprod_s *eval_shprod, galahad_prec_s *eval_prec);
void trb_solve_without_mat_s_64(void **data, void *userdata, int64_t *status, int64_t n, float *x_l, float *x_u, float *x, float *g, galahad_f_s_64 *eval_f, galahad_g_s_64 *eval_g, galahad_hprod_s_64 *eval_hprod, galahad_shprod_s_64 *eval_shprod, galahad_prec_s_64 *eval_prec);
void trb_solve_reverse_with_mat_s(void **data, int32_t *status, int32_t *eval_status, int32_t n, float *x_l, float *x_u, float *x, float f, float *g, int32_t ne, float *H_val, float *u, float *v);
void trb_solve_reverse_with_mat_s_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, float *x_l, float *x_u, float *x, float f, float *g, int64_t ne, float *H_val, float *u, float *v);
void trb_solve_reverse_without_mat_s(void **data, int32_t *status, int32_t *eval_status, int32_t n, float *x_l, float *x_u, float *x, float f, float *g, float *u, float *v, int32_t *index_nz_v, int32_t *nnz_v, int32_t *index_nz_u, int32_t nnz_u);
void trb_solve_reverse_without_mat_s_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, float *x_l, float *x_u, float *x, float f, float *g, float *u, float *v, int64_t *index_nz_v, int64_t *nnz_v, int64_t *index_nz_u, int64_t nnz_u);
void trb_information_s(void **data, struct trb_inform_type_s *inform, int32_t *status);
void trb_information_s_64(void **data, struct trb_inform_type_s_64 *inform, int64_t *status);
void trb_terminate_s(void **data, struct trb_control_type_s *control, struct trb_inform_type_s *inform);
void trb_terminate_s_64(void **data, struct trb_control_type_s_64 *control, struct trb_inform_type_s_64 *inform);

// C interface for BGO
struct bgo_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t attempts_max;
    int32_t max_evals;
    int32_t sampling_strategy;
    int32_t hypercube_discretization;
    int32_t alive_unit;
    char alive_file[31];
    float infinity;
    float obj_unbounded;
    float cpu_time_limit;
    float clock_time_limit;
    bool random_multistart;
    bool hessian_available;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct ugo_control_type_s ugo_control;
    struct lhs_control_type lhs_control;
    struct trb_control_type_s trb_control;
};

struct bgo_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t attempts_max;
    int64_t max_evals;
    int64_t sampling_strategy;
    int64_t hypercube_discretization;
    int64_t alive_unit;
    char alive_file[31];
    float infinity;
    float obj_unbounded;
    float cpu_time_limit;
    float clock_time_limit;
    bool random_multistart;
    bool hessian_available;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct ugo_control_type_s_64 ugo_control;
    struct lhs_control_type_64 lhs_control;
    struct trb_control_type_s_64 trb_control;
};

struct bgo_time_type_s {
    float total;
    float univariate_global;
    float multivariate_local;
    float clock_total;
    float clock_univariate_global;
    float clock_multivariate_local;
};

struct bgo_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    float obj;
    float norm_pg;
    struct bgo_time_type_s time;
    struct ugo_inform_type_s ugo_inform;
    struct lhs_inform_type lhs_inform;
    struct trb_inform_type_s trb_inform;
};

struct bgo_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    float obj;
    float norm_pg;
    struct bgo_time_type_s time;
    struct ugo_inform_type_s_64 ugo_inform;
    struct lhs_inform_type_64 lhs_inform;
    struct trb_inform_type_s_64 trb_inform;
};

void bgo_initialize_s(void **data, struct bgo_control_type_s *control, int32_t *status);
void bgo_initialize_s_64(void **data, struct bgo_control_type_s_64 *control, int64_t *status);
void bgo_read_specfile_s(struct bgo_control_type_s *control, char *specfile);
void bgo_read_specfile_s_64(struct bgo_control_type_s_64 *control, char *specfile);
void bgo_import_s(struct bgo_control_type_s *control, void **data, int32_t *status, int32_t n, float *x_l, float *x_u, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void bgo_import_s_64(struct bgo_control_type_s_64 *control, void **data, int64_t *status, int64_t n, float *x_l, float *x_u, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void bgo_reset_control_s(struct bgo_control_type_s *control, void **data, int32_t *status);
void bgo_reset_control_s_64(struct bgo_control_type_s_64 *control, void **data, int64_t *status);
void bgo_solve_with_mat_s(void **data, void *userdata, int32_t *status, int32_t n, float *x, float *g, int32_t ne, galahad_f_s *eval_f, galahad_g_s *eval_g, galahad_h_s *eval_h, galahad_hprod_s *eval_hprod, galahad_prec_s *eval_prec);
void bgo_solve_with_mat_s_64(void **data, void *userdata, int64_t *status, int64_t n, float *x, float *g, int64_t ne, galahad_f_s_64 *eval_f, galahad_g_s_64 *eval_g, galahad_h_s_64 *eval_h, galahad_hprod_s_64 *eval_hprod, galahad_prec_s_64 *eval_prec);
void bgo_solve_without_mat_s(void **data, void *userdata, int32_t *status, int32_t n, float *x, float *g, galahad_f_s *eval_f, galahad_g_s *eval_g, galahad_hprod_s *eval_hprod, galahad_shprod_s *eval_shprod, galahad_prec_s *eval_prec);
void bgo_solve_without_mat_s_64(void **data, void *userdata, int64_t *status, int64_t n, float *x, float *g, galahad_f_s_64 *eval_f, galahad_g_s_64 *eval_g, galahad_hprod_s_64 *eval_hprod, galahad_shprod_s_64 *eval_shprod, galahad_prec_s_64 *eval_prec);
void bgo_solve_reverse_with_mat_s(void **data, int32_t *status, int32_t *eval_status, int32_t n, float *x, float f, float *g, int32_t ne, float *H_val, float *u, float *v);
void bgo_solve_reverse_with_mat_s_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, float *x, float f, float *g, int64_t ne, float *H_val, float *u, float *v);
void bgo_solve_reverse_without_mat_s(void **data, int32_t *status, int32_t *eval_status, int32_t n, float *x, float f, float *g, float *u, float *v, int32_t *index_nz_v, int32_t *nnz_v, int32_t *index_nz_u, int32_t nnz_u);
void bgo_solve_reverse_without_mat_s_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, float *x, float f, float *g, float *u, float *v, int64_t *index_nz_v, int64_t *nnz_v, int64_t *index_nz_u, int64_t nnz_u);
void bgo_information_s(void **data, struct bgo_inform_type_s *inform, int32_t *status);
void bgo_information_s_64(void **data, struct bgo_inform_type_s_64 *inform, int64_t *status);
void bgo_terminate_s(void **data, struct bgo_control_type_s *control, struct bgo_inform_type_s *inform);
void bgo_terminate_s_64(void **data, struct bgo_control_type_s_64 *control, struct bgo_inform_type_s_64 *inform);

// C interface for ULS
struct uls_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t warning;
    int32_t out;
    int32_t print_level;
    int32_t print_level_solver;
    int32_t initial_fill_in_factor;
    int32_t min_real_factor_size;
    int32_t min_integer_factor_size;
    int64_t max_factor_size;
    int32_t blas_block_size_factorize;
    int32_t blas_block_size_solve;
    int32_t pivot_control;
    int32_t pivot_search_limit;
    int32_t minimum_size_for_btf;
    int32_t max_iterative_refinements;
    bool stop_if_singular;
    float array_increase_factor;
    float switch_to_full_code_density;
    float array_decrease_factor;
    float relative_pivot_tolerance;
    float absolute_pivot_tolerance;
    float zero_tolerance;
    float acceptable_residual_relative;
    float acceptable_residual_absolute;
    char prefix[31];
};

struct uls_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t warning;
    int64_t out;
    int64_t print_level;
    int64_t print_level_solver;
    int64_t initial_fill_in_factor;
    int64_t min_real_factor_size;
    int64_t min_integer_factor_size;
    int64_t max_factor_size;
    int64_t blas_block_size_factorize;
    int64_t blas_block_size_solve;
    int64_t pivot_control;
    int64_t pivot_search_limit;
    int64_t minimum_size_for_btf;
    int64_t max_iterative_refinements;
    bool stop_if_singular;
    float array_increase_factor;
    float switch_to_full_code_density;
    float array_decrease_factor;
    float relative_pivot_tolerance;
    float absolute_pivot_tolerance;
    float zero_tolerance;
    float acceptable_residual_relative;
    float acceptable_residual_absolute;
    char prefix[31];
};

struct uls_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t more_info;
    int64_t out_of_range;
    int64_t duplicates;
    int64_t entries_dropped;
    int64_t workspace_factors;
    int32_t compresses;
    int64_t entries_in_factors;
    int32_t rank;
    int32_t structural_rank;
    int32_t pivot_control;
    int32_t iterative_refinements;
    bool alternative;
    char solver[21];
    struct gls_ainfo_type_s gls_ainfo;
    struct gls_finfo_type_s gls_finfo;
    struct gls_sinfo_type gls_sinfo;
    struct ma48_ainfo_s ma48_ainfo;
    struct ma48_finfo_s ma48_finfo;
    struct ma48_sinfo ma48_sinfo;
    int32_t lapack_error;
};

struct uls_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t more_info;
    int64_t out_of_range;
    int64_t duplicates;
    int64_t entries_dropped;
    int64_t workspace_factors;
    int64_t compresses;
    int64_t entries_in_factors;
    int64_t rank;
    int64_t structural_rank;
    int64_t pivot_control;
    int64_t iterative_refinements;
    bool alternative;
    char solver[21];
    struct gls_ainfo_type_s_64 gls_ainfo;
    struct gls_finfo_type_s_64 gls_finfo;
    struct gls_sinfo_type_64 gls_sinfo;
    struct ma48_ainfo_s_64 ma48_ainfo;
    struct ma48_finfo_s_64 ma48_finfo;
    struct ma48_sinfo_64 ma48_sinfo;
    int64_t lapack_error;
};

void uls_initialize_s(char *solver, void **data, struct uls_control_type_s *control, int32_t *status);
void uls_initialize_s_64(char *solver, void **data, struct uls_control_type_s_64 *control, int64_t *status);
void uls_read_specfile_s(struct uls_control_type_s *control, char *specfile);
void uls_read_specfile_s_64(struct uls_control_type_s_64 *control, char *specfile);
void uls_factorize_matrix_s(struct uls_control_type_s *control, void **data, int32_t *status, int32_t m, int32_t n, char *type, int32_t ne, float *val, int32_t *row, int32_t *col, int32_t *ptr);
void uls_factorize_matrix_s_64(struct uls_control_type_s_64 *control, void **data, int64_t *status, int64_t m, int64_t n, char *type, int64_t ne, float *val, int64_t *row, int64_t *col, int64_t *ptr);
void uls_reset_control_s(struct uls_control_type_s *control, void **data, int32_t *status);
void uls_reset_control_s_64(struct uls_control_type_s_64 *control, void **data, int64_t *status);
void uls_solve_system_s(void **data, int32_t *status, int32_t m, int32_t n, float *sol, bool trans);
void uls_solve_system_s_64(void **data, int64_t *status, int64_t m, int64_t n, float *sol, bool trans);
void uls_information_s(void **data, struct uls_inform_type_s *inform, int32_t *status);
void uls_information_s_64(void **data, struct uls_inform_type_s_64 *inform, int64_t *status);
void uls_terminate_s(void **data, struct uls_control_type_s *control, struct uls_inform_type_s *inform);
void uls_terminate_s_64(void **data, struct uls_control_type_s_64 *control, struct uls_inform_type_s_64 *inform);

// C interface for SBLS
struct sbls_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t indmin;
    int32_t valmin;
    int32_t len_ulsmin;
    int32_t itref_max;
    int32_t maxit_pcg;
    int32_t new_a;
    int32_t new_h;
    int32_t new_c;
    int32_t preconditioner;
    int32_t semi_bandwidth;
    int32_t factorization;
    int32_t max_col;
    int32_t scaling;
    int32_t ordering;
    float pivot_tol;
    float pivot_tol_for_basis;
    float zero_pivot;
    float static_tolerance;
    float static_level;
    float min_diagonal;
    float stop_absolute;
    float stop_relative;
    bool remove_dependencies;
    bool find_basis_by_transpose;
    bool affine;
    bool allow_singular;
    bool perturb_to_make_definite;
    bool get_norm_residual;
    bool check_basis;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s sls_control;
    struct uls_control_type_s uls_control;
};

struct sbls_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t indmin;
    int64_t valmin;
    int64_t len_ulsmin;
    int64_t itref_max;
    int64_t maxit_pcg;
    int64_t new_a;
    int64_t new_h;
    int64_t new_c;
    int64_t preconditioner;
    int64_t semi_bandwidth;
    int64_t factorization;
    int64_t max_col;
    int64_t scaling;
    int64_t ordering;
    float pivot_tol;
    float pivot_tol_for_basis;
    float zero_pivot;
    float static_tolerance;
    float static_level;
    float min_diagonal;
    float stop_absolute;
    float stop_relative;
    bool remove_dependencies;
    bool find_basis_by_transpose;
    bool affine;
    bool allow_singular;
    bool perturb_to_make_definite;
    bool get_norm_residual;
    bool check_basis;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s_64 sls_control;
    struct uls_control_type_s_64 uls_control;
};

struct sbls_time_type_s {
    float total;
    float form;
    float factorize;
    float apply;
    float clock_total;
    float clock_form;
    float clock_factorize;
    float clock_apply;
};

struct sbls_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t sort_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t preconditioner;
    int32_t factorization;
    int32_t d_plus;
    int32_t rank;
    bool rank_def;
    bool perturbed;
    int32_t iter_pcg;
    float norm_residual;
    bool alternative;
    struct sbls_time_type_s time;
    struct sls_inform_type_s sls_inform;
    struct uls_inform_type_s uls_inform;
};

struct sbls_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t sort_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t preconditioner;
    int64_t factorization;
    int64_t d_plus;
    int64_t rank;
    bool rank_def;
    bool perturbed;
    int64_t iter_pcg;
    float norm_residual;
    bool alternative;
    struct sbls_time_type_s time;
    struct sls_inform_type_s_64 sls_inform;
    struct uls_inform_type_s_64 uls_inform;
};

void sbls_initialize_s(void **data, struct sbls_control_type_s *control, int32_t *status);
void sbls_initialize_s_64(void **data, struct sbls_control_type_s_64 *control, int64_t *status);
void sbls_read_specfile_s(struct sbls_control_type_s *control, char *specfile);
void sbls_read_specfile_s_64(struct sbls_control_type_s_64 *control, char *specfile);
void sbls_import_s(struct sbls_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr, char *C_type, int32_t C_ne, int32_t *C_row, int32_t *C_col, int32_t *C_ptr);
void sbls_import_s_64(struct sbls_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr, char *C_type, int64_t C_ne, int64_t *C_row, int64_t *C_col, int64_t *C_ptr);
void sbls_reset_control_s(struct sbls_control_type_s *control, void **data, int32_t *status);
void sbls_reset_control_s_64(struct sbls_control_type_s_64 *control, void **data, int64_t *status);
void sbls_factorize_matrix_s(void **data, int32_t *status, int32_t n, int32_t h_ne, float *H_val, int32_t a_ne, float *A_val, int32_t c_ne, float *C_val, float *D);
void sbls_factorize_matrix_s_64(void **data, int64_t *status, int64_t n, int64_t h_ne, float *H_val, int64_t a_ne, float *A_val, int64_t c_ne, float *C_val, float *D);
void sbls_solve_system_s(void **data, int32_t *status, int32_t n, int32_t m, float *sol);
void sbls_solve_system_s_64(void **data, int64_t *status, int64_t n, int64_t m, float *sol);
void sbls_information_s(void **data, struct sbls_inform_type_s *inform, int32_t *status);
void sbls_information_s_64(void **data, struct sbls_inform_type_s_64 *inform, int64_t *status);
void sbls_terminate_s(void **data, struct sbls_control_type_s *control, struct sbls_inform_type_s *inform);
void sbls_terminate_s_64(void **data, struct sbls_control_type_s_64 *control, struct sbls_inform_type_s_64 *inform);

// C interface for BLLS
struct blls_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t cold_start;
    int32_t preconditioner;
    int32_t ratio_cg_vs_sd;
    int32_t change_max;
    int32_t cg_maxit;
    int32_t arcsearch_max_steps;
    int32_t sif_file_device;
    float weight;
    float infinity;
    float stop_d;
    float identical_bounds_tol;
    float stop_cg_relative;
    float stop_cg_absolute;
    float alpha_max;
    float alpha_initial;
    float alpha_reduction;
    float arcsearch_acceptance_tol;
    float stabilisation_weight;
    float cpu_time_limit;
    bool direct_subproblem_solve;
    bool exact_arc_search;
    bool advance;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_s sbls_control;
    struct convert_control_type convert_control;
};

struct blls_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t cold_start;
    int64_t preconditioner;
    int64_t ratio_cg_vs_sd;
    int64_t change_max;
    int64_t cg_maxit;
    int64_t arcsearch_max_steps;
    int64_t sif_file_device;
    float weight;
    float infinity;
    float stop_d;
    float identical_bounds_tol;
    float stop_cg_relative;
    float stop_cg_absolute;
    float alpha_max;
    float alpha_initial;
    float alpha_reduction;
    float arcsearch_acceptance_tol;
    float stabilisation_weight;
    float cpu_time_limit;
    bool direct_subproblem_solve;
    bool exact_arc_search;
    bool advance;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_s_64 sbls_control;
    struct convert_control_type_64 convert_control;
};

struct blls_time_type_s {
    float total;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct blls_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    int32_t factorization_status;
    int32_t iter;
    int32_t cg_iter;
    float obj;
    float norm_pg;
    char bad_alloc[81];
    struct blls_time_type_s time;
    struct sbls_inform_type_s sbls_inform;
    struct convert_inform_type_s convert_inform;
};

struct blls_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorization_status;
    int64_t iter;
    int64_t cg_iter;
    float obj;
    float norm_pg;
    char bad_alloc[81];
    struct blls_time_type_s time;
    struct sbls_inform_type_s_64 sbls_inform;
    struct convert_inform_type_s_64 convert_inform;
};

void blls_initialize_s(void **data, struct blls_control_type_s *control, int32_t *status);
void blls_initialize_s_64(void **data, struct blls_control_type_s_64 *control, int64_t *status);
void blls_read_specfile_s(struct blls_control_type_s *control, char *specfile);
void blls_read_specfile_s_64(struct blls_control_type_s_64 *control, char *specfile);
void blls_import_s(struct blls_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t o, char *Ao_type, int32_t Ao_ne, int32_t *Ao_row, int32_t *Ao_col, int32_t Ao_ptr_ne, int32_t *Ao_ptr);
void blls_import_s_64(struct blls_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t o, char *Ao_type, int64_t Ao_ne, int64_t *Ao_row, int64_t *Ao_col, int64_t Ao_ptr_ne, int64_t *Ao_ptr);
void blls_import_without_a_s(struct blls_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t o);
void blls_import_without_a_s_64(struct blls_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t o);
void blls_reset_control_s(struct blls_control_type_s *control, void **data, int32_t *status);
void blls_reset_control_s_64(struct blls_control_type_s_64 *control, void **data, int64_t *status);
void blls_solve_given_a_s(void **data, void *userdata, int32_t *status, int32_t n, int32_t o, int32_t Ao_ne, float *Ao_val, float *b, float *x_l, float *x_u, float *x, float *z, float *r, float *g, int32_t *x_stat, float *w, galahad_constant_prec_s *eval_prec);
void blls_solve_given_a_s_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t o, int64_t Ao_ne, float *Ao_val, float *b, float *x_l, float *x_u, float *x, float *z, float *r, float *g, int64_t *x_stat, float *w, galahad_constant_prec_s_64 *eval_prec);
void blls_solve_reverse_a_prod_s(void **data, int32_t *status, int32_t *eval_status, int32_t n, int32_t o, float *b, float *x_l, float *x_u, float *x, float *z, float *r, float *g, int32_t *x_stat, float *v, float *p, int32_t *nz_v, int32_t *nz_v_start, int32_t *nz_v_end, int32_t *nz_p, int32_t nz_p_end, float *w);
void blls_solve_reverse_a_prod_s_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, int64_t o, float *b, float *x_l, float *x_u, float *x, float *z, float *r, float *g, int64_t *x_stat, float *v, float *p, int64_t *nz_v, int64_t *nz_v_start, int64_t *nz_v_end, int64_t *nz_p, int64_t nz_p_end, float *w);
void blls_information_s(void **data, struct blls_inform_type_s *inform, int32_t *status);
void blls_information_s_64(void **data, struct blls_inform_type_s_64 *inform, int64_t *status);
void blls_terminate_s(void **data, struct blls_control_type_s *control, struct blls_inform_type_s *inform);
void blls_terminate_s_64(void **data, struct blls_control_type_s_64 *control, struct blls_inform_type_s_64 *inform);

// C interface for BQP
struct bqp_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t cold_start;
    int32_t ratio_cg_vs_sd;
    int32_t change_max;
    int32_t cg_maxit;
    int32_t sif_file_device;
    float infinity;
    float stop_p;
    float stop_d;
    float stop_c;
    float identical_bounds_tol;
    float stop_cg_relative;
    float stop_cg_absolute;
    float zero_curvature;
    float cpu_time_limit;
    bool exact_arcsearch;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_s sbls_control;
};

struct bqp_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t cold_start;
    int64_t ratio_cg_vs_sd;
    int64_t change_max;
    int64_t cg_maxit;
    int64_t sif_file_device;
    float infinity;
    float stop_p;
    float stop_d;
    float stop_c;
    float identical_bounds_tol;
    float stop_cg_relative;
    float stop_cg_absolute;
    float zero_curvature;
    float cpu_time_limit;
    bool exact_arcsearch;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_s_64 sbls_control;
};

struct bqp_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    int32_t factorization_status;
    int32_t iter;
    int32_t cg_iter;
    float obj;
    float norm_pg;
    char bad_alloc[81];
    struct bqp_time_type time;
    struct sbls_inform_type_s sbls_inform;
};

struct bqp_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorization_status;
    int64_t iter;
    int64_t cg_iter;
    float obj;
    float norm_pg;
    char bad_alloc[81];
    struct bqp_time_type time;
    struct sbls_inform_type_s_64 sbls_inform;
};

void bqp_initialize_s(void **data, struct bqp_control_type_s *control, int32_t *status);
void bqp_initialize_s_64(void **data, struct bqp_control_type_s_64 *control, int64_t *status);
void bqp_read_specfile_s(struct bqp_control_type_s *control, char *specfile);
void bqp_read_specfile_s_64(struct bqp_control_type_s_64 *control, char *specfile);
void bqp_import_s(struct bqp_control_type_s *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void bqp_import_s_64(struct bqp_control_type_s_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void bqp_import_without_h_s(struct bqp_control_type_s *control, void **data, int32_t *status, int32_t n);
void bqp_import_without_h_s_64(struct bqp_control_type_s_64 *control, void **data, int64_t *status, int64_t n);
void bqp_reset_control_s(struct bqp_control_type_s *control, void **data, int32_t *status);
void bqp_reset_control_s_64(struct bqp_control_type_s_64 *control, void **data, int64_t *status);
void bqp_solve_given_h_s(void **data, int32_t *status, int32_t n, int32_t h_ne, float *H_val, float *g, float f, float *x_l, float *x_u, float *x, float *z, int32_t *x_stat);
void bqp_solve_given_h_s_64(void **data, int64_t *status, int64_t n, int64_t h_ne, float *H_val, float *g, float f, float *x_l, float *x_u, float *x, float *z, int64_t *x_stat);
void bqp_solve_reverse_h_prod_s(void **data, int32_t *status, int32_t n, float *g, float f, float *x_l, float *x_u, float *x, float *z, int32_t *x_stat, float *v, float *prod, int32_t *nz_v, int32_t *nz_v_start, int32_t *nz_v_end, int32_t *nz_prod, int32_t nz_prod_end);
void bqp_solve_reverse_h_prod_s_64(void **data, int64_t *status, int64_t n, float *g, float f, float *x_l, float *x_u, float *x, float *z, int64_t *x_stat, float *v, float *prod, int64_t *nz_v, int64_t *nz_v_start, int64_t *nz_v_end, int64_t *nz_prod, int64_t nz_prod_end);
void bqp_information_s(void **data, struct bqp_inform_type_s *inform, int32_t *status);
void bqp_information_s_64(void **data, struct bqp_inform_type_s_64 *inform, int64_t *status);
void bqp_terminate_s(void **data, struct bqp_control_type_s *control, struct bqp_inform_type_s *inform);
void bqp_terminate_s_64(void **data, struct bqp_control_type_s_64 *control, struct bqp_inform_type_s_64 *inform);

// C interface for FDC
struct fdc_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t indmin;
    int32_t valmin;
    float pivot_tol;
    float zero_pivot;
    float max_infeas;
    bool use_sls;
    bool scale;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s sls_control;
    struct uls_control_type_s uls_control;
};

struct fdc_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t indmin;
    int64_t valmin;
    float pivot_tol;
    float zero_pivot;
    float max_infeas;
    bool use_sls;
    bool scale;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s_64 sls_control;
    struct uls_control_type_s_64 uls_control;
};

struct fdc_time_type_s {
    float total;
    float analyse;
    float factorize;
    float clock_total;
    float clock_analyse;
    float clock_factorize;
};

struct fdc_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    float non_negligible_pivot;
    struct fdc_time_type_s time;
    struct sls_inform_type_s sls_inform;
    struct uls_inform_type_s uls_inform;
};

struct fdc_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    float non_negligible_pivot;
    struct fdc_time_type_s time;
    struct sls_inform_type_s_64 sls_inform;
    struct uls_inform_type_s_64 uls_inform;
};

void fdc_initialize_s(void **data, struct fdc_control_type_s *control, int32_t *status);
void fdc_initialize_s_64(void **data, struct fdc_control_type_s_64 *control, int64_t *status);
void fdc_read_specfile_s(struct fdc_control_type_s *control, char *specfile);
void fdc_read_specfile_s_64(struct fdc_control_type_s_64 *control, char *specfile);
void fdc_find_dependent_rows_s(struct fdc_control_type_s *control, void **data, struct fdc_inform_type_s *inform, int32_t *status, int32_t m, int32_t n, int32_t A_ne, int32_t *A_col, int32_t *A_ptr, float *A_val, float *b, int32_t *n_depen, int32_t *depen);
void fdc_find_dependent_rows_s_64(struct fdc_control_type_s_64 *control, void **data, struct fdc_inform_type_s_64 *inform, int64_t *status, int64_t m, int64_t n, int64_t A_ne, int64_t *A_col, int64_t *A_ptr, float *A_val, float *b, int64_t *n_depen, int64_t *depen);
void fdc_terminate_s(void **data, struct fdc_control_type_s *control, struct fdc_inform_type_s *inform);
void fdc_terminate_s_64(void **data, struct fdc_control_type_s_64 *control, struct fdc_inform_type_s_64 *inform);

// C interface for CRO
struct cro_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t max_schur_complement;
    float infinity;
    float feasibility_tolerance;
    bool check_io;
    bool refine_solution;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s sls_control;
    struct sbls_control_type_s sbls_control;
    struct uls_control_type_s uls_control;
    struct ir_control_type_s ir_control;
};

struct cro_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t max_schur_complement;
    float infinity;
    float feasibility_tolerance;
    bool check_io;
    bool refine_solution;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s_64 sls_control;
    struct sbls_control_type_s_64 sbls_control;
    struct uls_control_type_s_64 uls_control;
    struct ir_control_type_s_64 ir_control;
};

struct cro_time_type_s {
    float total;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct cro_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t dependent;
    struct cro_time_type_s time;
    struct sls_inform_type_s sls_inform;
    struct sbls_inform_type_s sbls_inform;
    struct uls_inform_type_s uls_inform;
    int32_t scu_status;
    struct scu_inform_type scu_inform;
    struct ir_inform_type_s ir_inform;
};

struct cro_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t dependent;
    struct cro_time_type_s time;
    struct sls_inform_type_s_64 sls_inform;
    struct sbls_inform_type_s_64 sbls_inform;
    struct uls_inform_type_s_64 uls_inform;
    int64_t scu_status;
    struct scu_inform_type_64 scu_inform;
    struct ir_inform_type_s_64 ir_inform;
};

void cro_initialize_s(void **data, struct cro_control_type_s *control, int32_t *status);
void cro_initialize_s_64(void **data, struct cro_control_type_s_64 *control, int64_t *status);
void cro_read_specfile_s(struct cro_control_type_s *control, char *specfile);
void cro_read_specfile_s_64(struct cro_control_type_s_64 *control, char *specfile);
void cro_crossover_solution_s(void **data, struct cro_control_type_s *control, struct cro_inform_type_s *inform, int32_t n, int32_t m, int32_t m_equal, int32_t h_ne, float *H_val, int32_t *H_col, int32_t *H_ptr, int32_t a_ne, float *A_val, int32_t *A_col, int32_t *A_ptr, float *g, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat);
void cro_crossover_solution_s_64(void **data, struct cro_control_type_s_64 *control, struct cro_inform_type_s_64 *inform, int64_t n, int64_t m, int64_t m_equal, int64_t h_ne, float *H_val, int64_t *H_col, int64_t *H_ptr, int64_t a_ne, float *A_val, int64_t *A_col, int64_t *A_ptr, float *g, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat);
void cro_terminate_s(void **data, struct cro_control_type_s *control, struct cro_inform_type_s *inform);
void cro_terminate_s_64(void **data, struct cro_control_type_s_64 *control, struct cro_inform_type_s_64 *inform);

// C interface for BQPB
struct bqpb_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float perturb_h;
    float prfeas;
    float dufeas;
    float muzero;
    float tau;
    float gamma_c;
    float gamma_f;
    float reduce_infeas;
    float obj_unbounded;
    float potential_unbounded;
    float identical_bounds_tol;
    float mu_pounce;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_s fdc_control;
    struct sbls_control_type_s sbls_control;
    struct fit_control_type fit_control;
    struct roots_control_type_s roots_control;
    struct cro_control_type_s cro_control;
};

struct bqpb_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float perturb_h;
    float prfeas;
    float dufeas;
    float muzero;
    float tau;
    float gamma_c;
    float gamma_f;
    float reduce_infeas;
    float obj_unbounded;
    float potential_unbounded;
    float identical_bounds_tol;
    float mu_pounce;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_s_64 fdc_control;
    struct sbls_control_type_s_64 sbls_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_s_64 roots_control;
    struct cro_control_type_s_64 cro_control;
};

struct bqpb_time_type_s {
    float total;
    float preprocess;
    float find_dependent;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_preprocess;
    float clock_find_dependent;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct bqpb_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    float init_primal_infeasibility;
    float init_dual_infeasibility;
    float init_complementary_slackness;
    float potential;
    float non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    float checkpointsTime[16];
    struct bqpb_time_type_s time;
    struct fdc_inform_type_s fdc_inform;
    struct sbls_inform_type_s sbls_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type_s cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct bqpb_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    float init_primal_infeasibility;
    float init_dual_infeasibility;
    float init_complementary_slackness;
    float potential;
    float non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    float checkpointsTime[16];
    struct bqpb_time_type_s time;
    struct fdc_inform_type_s_64 fdc_inform;
    struct sbls_inform_type_s_64 sbls_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_s_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void bqpb_initialize_s(void **data, struct bqpb_control_type_s *control, int32_t *status);
void bqpb_initialize_s_64(void **data, struct bqpb_control_type_s_64 *control, int64_t *status);
void bqpb_read_specfile_s(struct bqpb_control_type_s *control, char *specfile);
void bqpb_read_specfile_s_64(struct bqpb_control_type_s_64 *control, char *specfile);
void bqpb_import_s(struct bqpb_control_type_s *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void bqpb_import_s_64(struct bqpb_control_type_s_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void bqpb_reset_control_s(struct bqpb_control_type_s *control, void **data, int32_t *status);
void bqpb_reset_control_s_64(struct bqpb_control_type_s_64 *control, void **data, int64_t *status);
void bqpb_solve_qp_s(void **data, int32_t *status, int32_t n, int32_t h_ne, float *H_val, float *g, float f, float *x_l, float *x_u, float *x, float *z, int32_t *x_stat);
void bqpb_solve_qp_s_64(void **data, int64_t *status, int64_t n, int64_t h_ne, float *H_val, float *g, float f, float *x_l, float *x_u, float *x, float *z, int64_t *x_stat);
void bqpb_solve_sldqp_s(void **data, int32_t *status, int32_t n, float *w, float *x0, float *g, float f, float *x_l, float *x_u, float *x, float *z, int32_t *x_stat);
void bqpb_solve_sldqp_s_64(void **data, int64_t *status, int64_t n, float *w, float *x0, float *g, float f, float *x_l, float *x_u, float *x, float *z, int64_t *x_stat);
void bqpb_information_s(void **data, struct bqpb_inform_type_s *inform, int32_t *status);
void bqpb_information_s_64(void **data, struct bqpb_inform_type_s_64 *inform, int64_t *status);
void bqpb_terminate_s(void **data, struct bqpb_control_type_s *control, struct bqpb_inform_type_s *inform);
void bqpb_terminate_s_64(void **data, struct bqpb_control_type_s_64 *control, struct bqpb_inform_type_s_64 *inform);

// C interface for CCQP
struct ccqp_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float perturb_h;
    float prfeas;
    float dufeas;
    float muzero;
    float tau;
    float gamma_c;
    float gamma_f;
    float reduce_infeas;
    float obj_unbounded;
    float potential_unbounded;
    float identical_bounds_tol;
    float mu_pounce;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_s fdc_control;
    struct sbls_control_type_s sbls_control;
    struct sbls_control_type_s sbls_pounce_control;
    struct fit_control_type fit_control;
    struct roots_control_type_s roots_control;
    struct cro_control_type_s cro_control;
};

struct ccqp_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float perturb_h;
    float prfeas;
    float dufeas;
    float muzero;
    float tau;
    float gamma_c;
    float gamma_f;
    float reduce_infeas;
    float obj_unbounded;
    float potential_unbounded;
    float identical_bounds_tol;
    float mu_pounce;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_s_64 fdc_control;
    struct sbls_control_type_s_64 sbls_control;
    struct sbls_control_type_s_64 sbls_pounce_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_s_64 roots_control;
    struct cro_control_type_s_64 cro_control;
};

struct ccqp_time_type_s {
    float total;
    float preprocess;
    float find_dependent;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_preprocess;
    float clock_find_dependent;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct ccqp_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    float init_primal_infeasibility;
    float init_dual_infeasibility;
    float init_complementary_slackness;
    float potential;
    float non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    float checkpointsTime[16];
    struct ccqp_time_type_s time;
    struct fdc_inform_type_s fdc_inform;
    struct sbls_inform_type_s sbls_inform;
    struct sbls_inform_type_s sbls_pounce_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type_s cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct ccqp_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    float init_primal_infeasibility;
    float init_dual_infeasibility;
    float init_complementary_slackness;
    float potential;
    float non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    float checkpointsTime[16];
    struct ccqp_time_type_s time;
    struct fdc_inform_type_s_64 fdc_inform;
    struct sbls_inform_type_s_64 sbls_inform;
    struct sbls_inform_type_s_64 sbls_pounce_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_s_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void ccqp_initialize_s(void **data, struct ccqp_control_type_s *control, int32_t *status);
void ccqp_initialize_s_64(void **data, struct ccqp_control_type_s_64 *control, int64_t *status);
void ccqp_read_specfile_s(struct ccqp_control_type_s *control, char *specfile);
void ccqp_read_specfile_s_64(struct ccqp_control_type_s_64 *control, char *specfile);
void ccqp_import_s(struct ccqp_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void ccqp_import_s_64(struct ccqp_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void ccqp_reset_control_s(struct ccqp_control_type_s *control, void **data, int32_t *status);
void ccqp_reset_control_s_64(struct ccqp_control_type_s_64 *control, void **data, int64_t *status);
void ccqp_solve_qp_s(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, float *H_val, float *g, float f, int32_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat);
void ccqp_solve_qp_s_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, float *H_val, float *g, float f, int64_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat);
void ccqp_solve_sldqp_s(void **data, int32_t *status, int32_t n, int32_t m, float *w, float *x0, float *g, float f, int32_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat);
void ccqp_solve_sldqp_s_64(void **data, int64_t *status, int64_t n, int64_t m, float *w, float *x0, float *g, float f, int64_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat);
void ccqp_information_s(void **data, struct ccqp_inform_type_s *inform, int32_t *status);
void ccqp_information_s_64(void **data, struct ccqp_inform_type_s_64 *inform, int64_t *status);
void ccqp_terminate_s(void **data, struct ccqp_control_type_s *control, struct ccqp_inform_type_s *inform);
void ccqp_terminate_s_64(void **data, struct ccqp_control_type_s_64 *control, struct ccqp_inform_type_s_64 *inform);

// C interface for CQP
struct cqp_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float perturb_h;
    float prfeas;
    float dufeas;
    float muzero;
    float tau;
    float gamma_c;
    float gamma_f;
    float reduce_infeas;
    float obj_unbounded;
    float potential_unbounded;
    float identical_bounds_tol;
    float mu_pounce;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_s fdc_control;
    struct sbls_control_type_s sbls_control;
    struct fit_control_type fit_control;
    struct roots_control_type_s roots_control;
    struct cro_control_type_s cro_control;
};

struct cqp_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float perturb_h;
    float prfeas;
    float dufeas;
    float muzero;
    float tau;
    float gamma_c;
    float gamma_f;
    float reduce_infeas;
    float obj_unbounded;
    float potential_unbounded;
    float identical_bounds_tol;
    float mu_pounce;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_s_64 fdc_control;
    struct sbls_control_type_s_64 sbls_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_s_64 roots_control;
    struct cro_control_type_s_64 cro_control;
};

struct cqp_time_type_s {
    float total;
    float preprocess;
    float find_dependent;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_preprocess;
    float clock_find_dependent;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct cqp_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    float init_primal_infeasibility;
    float init_dual_infeasibility;
    float init_complementary_slackness;
    float potential;
    float non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    float checkpointsTime[16];
    struct cqp_time_type_s time;
    struct fdc_inform_type_s fdc_inform;
    struct sbls_inform_type_s sbls_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type_s cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct cqp_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    float init_primal_infeasibility;
    float init_dual_infeasibility;
    float init_complementary_slackness;
    float potential;
    float non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    float checkpointsTime[16];
    struct cqp_time_type_s time;
    struct fdc_inform_type_s_64 fdc_inform;
    struct sbls_inform_type_s_64 sbls_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_s_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void cqp_initialize_s(void **data, struct cqp_control_type_s *control, int32_t *status);
void cqp_initialize_s_64(void **data, struct cqp_control_type_s_64 *control, int64_t *status);
void cqp_read_specfile_s(struct cqp_control_type_s *control, char *specfile);
void cqp_read_specfile_s_64(struct cqp_control_type_s_64 *control, char *specfile);
void cqp_import_s(struct cqp_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void cqp_import_s_64(struct cqp_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void cqp_reset_control_s(struct cqp_control_type_s *control, void **data, int32_t *status);
void cqp_reset_control_s_64(struct cqp_control_type_s_64 *control, void **data, int64_t *status);
void cqp_solve_qp_s(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, float *H_val, float *g, float f, int32_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat);
void cqp_solve_qp_s_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, float *H_val, float *g, float f, int64_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat);
void cqp_solve_sldqp_s(void **data, int32_t *status, int32_t n, int32_t m, float *w, float *x0, float *g, float f, int32_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat);
void cqp_solve_sldqp_s_64(void **data, int64_t *status, int64_t n, int64_t m, float *w, float *x0, float *g, float f, int64_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat);
void cqp_information_s(void **data, struct cqp_inform_type_s *inform, int32_t *status);
void cqp_information_s_64(void **data, struct cqp_inform_type_s_64 *inform, int64_t *status);
void cqp_terminate_s(void **data, struct cqp_control_type_s *control, struct cqp_inform_type_s *inform);
void cqp_terminate_s_64(void **data, struct cqp_control_type_s_64 *control, struct cqp_inform_type_s_64 *inform);

// C interface for CLLS
struct clls_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float prfeas;
    float dufeas;
    float muzero;
    float tau;
    float gamma_c;
    float gamma_f;
    float reduce_infeas;
    float identical_bounds_tol;
    float mu_pounce;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_s fdc_control;
    struct sls_control_type_s sls_control;
    struct sls_control_type_s sls_pounce_control;
    struct fit_control_type fit_control;
    struct roots_control_type_s roots_control;
    struct cro_control_type_s cro_control;
};

struct clls_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float prfeas;
    float dufeas;
    float muzero;
    float tau;
    float gamma_c;
    float gamma_f;
    float reduce_infeas;
    float identical_bounds_tol;
    float mu_pounce;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_s_64 fdc_control;
    struct sls_control_type_s_64 sls_control;
    struct sls_control_type_s_64 sls_pounce_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_s_64 roots_control;
    struct cro_control_type_s_64 cro_control;
};

struct clls_time_type_s {
    float total;
    float preprocess;
    float find_dependent;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_preprocess;
    float clock_find_dependent;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct clls_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    float non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    float checkpointsTime[16];
    struct clls_time_type_s time;
    struct fdc_inform_type_s fdc_inform;
    struct sls_inform_type_s sls_inform;
    struct sls_inform_type_s sls_pounce_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type_s cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct clls_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    float non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    float checkpointsTime[16];
    struct clls_time_type_s time;
    struct fdc_inform_type_s_64 fdc_inform;
    struct sls_inform_type_s_64 sls_inform;
    struct sls_inform_type_s_64 sls_pounce_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_s_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void clls_initialize_s(void **data, struct clls_control_type_s *control, int32_t *status);
void clls_initialize_s_64(void **data, struct clls_control_type_s_64 *control, int64_t *status);
void clls_read_specfile_s(struct clls_control_type_s *control, char *specfile);
void clls_read_specfile_s_64(struct clls_control_type_s_64 *control, char *specfile);
void clls_import_s(struct clls_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t o, int32_t m, char *Ao_type, int32_t Ao_ne, int32_t *Ao_row, int32_t *Ao_col, int32_t Ao_ptr_ne, int32_t *Ao_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t A_ptr_ne, int32_t *A_ptr);
void clls_import_s_64(struct clls_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t o, int64_t m, char *Ao_type, int64_t Ao_ne, int64_t *Ao_row, int64_t *Ao_col, int64_t Ao_ptr_ne, int64_t *Ao_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t A_ptr_ne, int64_t *A_ptr);
void clls_reset_control_s(struct clls_control_type_s *control, void **data, int32_t *status);
void clls_reset_control_s_64(struct clls_control_type_s_64 *control, void **data, int64_t *status);
void clls_solve_clls_s(void **data, int32_t *status, int32_t n, int32_t o, int32_t m, int32_t Ao_ne, float *Ao_val, float *b, float regularization_weight, int32_t A_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *r, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat, float *w);
void clls_solve_clls_s_64(void **data, int64_t *status, int64_t n, int64_t o, int64_t m, int64_t Ao_ne, float *Ao_val, float *b, float regularization_weight, int64_t A_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *r, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat, float *w);
void clls_information_s(void **data, struct clls_inform_type_s *inform, int32_t *status);
void clls_information_s_64(void **data, struct clls_inform_type_s_64 *inform, int64_t *status);
void clls_terminate_s(void **data, struct clls_control_type_s *control, struct clls_inform_type_s *inform);
void clls_terminate_s_64(void **data, struct clls_control_type_s_64 *control, struct clls_inform_type_s_64 *inform);

// C interface for DGO
struct dgo_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t max_evals;
    int32_t dictionary_size;
    int32_t alive_unit;
    char alive_file[31];
    float infinity;
    float lipschitz_lower_bound;
    float lipschitz_reliability;
    float lipschitz_control;
    float stop_length;
    float stop_f;
    float obj_unbounded;
    float cpu_time_limit;
    float clock_time_limit;
    bool hessian_available;
    bool prune;
    bool perform_local_optimization;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct hash_control_type hash_control;
    struct ugo_control_type_s ugo_control;
    struct trb_control_type_s trb_control;
};

struct dgo_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t max_evals;
    int64_t dictionary_size;
    int64_t alive_unit;
    char alive_file[31];
    float infinity;
    float lipschitz_lower_bound;
    float lipschitz_reliability;
    float lipschitz_control;
    float stop_length;
    float stop_f;
    float obj_unbounded;
    float cpu_time_limit;
    float clock_time_limit;
    bool hessian_available;
    bool prune;
    bool perform_local_optimization;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct hash_control_type_64 hash_control;
    struct ugo_control_type_s_64 ugo_control;
    struct trb_control_type_s_64 trb_control;
};

struct dgo_time_type_s {
    float total;
    float univariate_global;
    float multivariate_local;
    float clock_total;
    float clock_univariate_global;
    float clock_multivariate_local;
};

struct dgo_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    float obj;
    float norm_pg;
    float length_ratio;
    float f_gap;
    char why_stop[2];
    struct dgo_time_type_s time;
    struct hash_inform_type hash_inform;
    struct ugo_inform_type_s ugo_inform;
    struct trb_inform_type_s trb_inform;
};

struct dgo_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    float obj;
    float norm_pg;
    float length_ratio;
    float f_gap;
    char why_stop[2];
    struct dgo_time_type_s time;
    struct hash_inform_type_64 hash_inform;
    struct ugo_inform_type_s_64 ugo_inform;
    struct trb_inform_type_s_64 trb_inform;
};

void dgo_initialize_s(void **data, struct dgo_control_type_s *control, int32_t *status);
void dgo_initialize_s_64(void **data, struct dgo_control_type_s_64 *control, int64_t *status);
void dgo_read_specfile_s(struct dgo_control_type_s *control, char *specfile);
void dgo_read_specfile_s_64(struct dgo_control_type_s_64 *control, char *specfile);
void dgo_import_s(struct dgo_control_type_s *control, void **data, int32_t *status, int32_t n, float *x_l, float *x_u, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void dgo_import_s_64(struct dgo_control_type_s_64 *control, void **data, int64_t *status, int64_t n, float *x_l, float *x_u, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void dgo_reset_control_s(struct dgo_control_type_s *control, void **data, int32_t *status);
void dgo_reset_control_s_64(struct dgo_control_type_s_64 *control, void **data, int64_t *status);
void dgo_solve_with_mat_s(void **data, void *userdata, int32_t *status, int32_t n, float *x, float *g, int32_t ne, galahad_f_s *eval_f, galahad_g_s *eval_g, galahad_h_s *eval_h, galahad_hprod_s *eval_hprod, galahad_prec_s *eval_prec);
void dgo_solve_with_mat_s_64(void **data, void *userdata, int64_t *status, int64_t n, float *x, float *g, int64_t ne, galahad_f_s_64 *eval_f, galahad_g_s_64 *eval_g, galahad_h_s_64 *eval_h, galahad_hprod_s_64 *eval_hprod, galahad_prec_s_64 *eval_prec);
void dgo_solve_without_mat_s(void **data, void *userdata, int32_t *status, int32_t n, float *x, float *g, galahad_f_s *eval_f, galahad_g_s *eval_g, galahad_hprod_s *eval_hprod, galahad_shprod_s *eval_shprod, galahad_prec_s *eval_prec);
void dgo_solve_without_mat_s_64(void **data, void *userdata, int64_t *status, int64_t n, float *x, float *g, galahad_f_s_64 *eval_f, galahad_g_s_64 *eval_g, galahad_hprod_s_64 *eval_hprod, galahad_shprod_s_64 *eval_shprod, galahad_prec_s_64 *eval_prec);
void dgo_solve_reverse_with_mat_s(void **data, int32_t *status, int32_t *eval_status, int32_t n, float *x, float f, float *g, int32_t ne, float *H_val, float *u, float *v);
void dgo_solve_reverse_with_mat_s_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, float *x, float f, float *g, int64_t ne, float *H_val, float *u, float *v);
void dgo_solve_reverse_without_mat_s(void **data, int32_t *status, int32_t *eval_status, int32_t n, float *x, float f, float *g, float *u, float *v, int32_t *index_nz_v, int32_t *nnz_v, int32_t *index_nz_u, int32_t nnz_u);
void dgo_solve_reverse_without_mat_s_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, float *x, float f, float *g, float *u, float *v, int64_t *index_nz_v, int64_t *nnz_v, int64_t *index_nz_u, int64_t nnz_u);
void dgo_information_s(void **data, struct dgo_inform_type_s *inform, int32_t *status);
void dgo_information_s_64(void **data, struct dgo_inform_type_s_64 *inform, int64_t *status);
void dgo_terminate_s(void **data, struct dgo_control_type_s *control, struct dgo_inform_type_s *inform);
void dgo_terminate_s_64(void **data, struct dgo_control_type_s_64 *control, struct dgo_inform_type_s_64 *inform);

// C interface for DQP
struct dqp_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t dual_starting_point;
    int32_t maxit;
    int32_t max_sc;
    int32_t cauchy_only;
    int32_t arc_search_maxit;
    int32_t cg_maxit;
    int32_t explore_optimal_subspace;
    int32_t restore_problem;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    float rho;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float stop_cg_relative;
    float stop_cg_absolute;
    float cg_zero_curvature;
    float max_growth;
    float identical_bounds_tol;
    float cpu_time_limit;
    float clock_time_limit;
    float initial_perturbation;
    float perturbation_reduction;
    float final_perturbation;
    bool factor_optimal_matrix;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool exact_arc_search;
    bool subspace_direct;
    bool subspace_alternate;
    bool subspace_arc_search;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_s fdc_control;
    struct sls_control_type_s sls_control;
    struct sbls_control_type_s sbls_control;
    struct gltr_control_type_s gltr_control;
};

struct dqp_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t dual_starting_point;
    int64_t maxit;
    int64_t max_sc;
    int64_t cauchy_only;
    int64_t arc_search_maxit;
    int64_t cg_maxit;
    int64_t explore_optimal_subspace;
    int64_t restore_problem;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    float rho;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float stop_cg_relative;
    float stop_cg_absolute;
    float cg_zero_curvature;
    float max_growth;
    float identical_bounds_tol;
    float cpu_time_limit;
    float clock_time_limit;
    float initial_perturbation;
    float perturbation_reduction;
    float final_perturbation;
    bool factor_optimal_matrix;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool exact_arc_search;
    bool subspace_direct;
    bool subspace_alternate;
    bool subspace_arc_search;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_s_64 fdc_control;
    struct sls_control_type_s_64 sls_control;
    struct sbls_control_type_s_64 sbls_control;
    struct gltr_control_type_s_64 gltr_control;
};

struct dqp_time_type_s {
    float total;
    float preprocess;
    float find_dependent;
    float analyse;
    float factorize;
    float solve;
    float search;
    float clock_total;
    float clock_preprocess;
    float clock_find_dependent;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
    float clock_search;
};

struct dqp_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t threads;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    float non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    float checkpointsTime[16];
    struct dqp_time_type_s time;
    struct fdc_inform_type_s fdc_inform;
    struct sls_inform_type_s sls_inform;
    struct sbls_inform_type_s sbls_inform;
    struct gltr_inform_type_s gltr_inform;
    int32_t scu_status;
    struct scu_inform_type scu_inform;
    struct rpd_inform_type rpd_inform;
};

struct dqp_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t threads;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    float non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    float checkpointsTime[16];
    struct dqp_time_type_s time;
    struct fdc_inform_type_s_64 fdc_inform;
    struct sls_inform_type_s_64 sls_inform;
    struct sbls_inform_type_s_64 sbls_inform;
    struct gltr_inform_type_s_64 gltr_inform;
    int64_t scu_status;
    struct scu_inform_type_64 scu_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void dqp_initialize_s(void **data, struct dqp_control_type_s *control, int32_t *status);
void dqp_initialize_s_64(void **data, struct dqp_control_type_s_64 *control, int64_t *status);
void dqp_read_specfile_s(struct dqp_control_type_s *control, char *specfile);
void dqp_read_specfile_s_64(struct dqp_control_type_s_64 *control, char *specfile);
void dqp_import_s(struct dqp_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void dqp_import_s_64(struct dqp_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void dqp_reset_control_s(struct dqp_control_type_s *control, void **data, int32_t *status);
void dqp_reset_control_s_64(struct dqp_control_type_s_64 *control, void **data, int64_t *status);
void dqp_solve_qp_s(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, float *H_val, float *g, float f, int32_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat);
void dqp_solve_qp_s_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, float *H_val, float *g, float f, int64_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat);
void dqp_solve_sldqp_s(void **data, int32_t *status, int32_t n, int32_t m, float *w, float *x0, float *g, float f, int32_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat);
void dqp_solve_sldqp_s_64(void **data, int64_t *status, int64_t n, int64_t m, float *w, float *x0, float *g, float f, int64_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat);
void dqp_information_s(void **data, struct dqp_inform_type_s *inform, int32_t *status);
void dqp_information_s_64(void **data, struct dqp_inform_type_s_64 *inform, int64_t *status);
void dqp_terminate_s(void **data, struct dqp_control_type_s *control, struct dqp_inform_type_s *inform);
void dqp_terminate_s_64(void **data, struct dqp_control_type_s_64 *control, struct dqp_inform_type_s_64 *inform);

// C interface for EQP
struct eqp_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t factorization;
    int32_t max_col;
    int32_t indmin;
    int32_t valmin;
    int32_t len_ulsmin;
    int32_t itref_max;
    int32_t cg_maxit;
    int32_t preconditioner;
    int32_t semi_bandwidth;
    int32_t new_a;
    int32_t new_h;
    int32_t sif_file_device;
    float pivot_tol;
    float pivot_tol_for_basis;
    float zero_pivot;
    float inner_fraction_opt;
    float radius;
    float min_diagonal;
    float max_infeasibility_relative;
    float max_infeasibility_absolute;
    float inner_stop_relative;
    float inner_stop_absolute;
    float inner_stop_inter;
    bool find_basis_by_transpose;
    bool remove_dependencies;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct fdc_control_type_s fdc_control;
    struct sbls_control_type_s sbls_control;
    struct gltr_control_type_s gltr_control;
};

struct eqp_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t factorization;
    int64_t max_col;
    int64_t indmin;
    int64_t valmin;
    int64_t len_ulsmin;
    int64_t itref_max;
    int64_t cg_maxit;
    int64_t preconditioner;
    int64_t semi_bandwidth;
    int64_t new_a;
    int64_t new_h;
    int64_t sif_file_device;
    float pivot_tol;
    float pivot_tol_for_basis;
    float zero_pivot;
    float inner_fraction_opt;
    float radius;
    float min_diagonal;
    float max_infeasibility_relative;
    float max_infeasibility_absolute;
    float inner_stop_relative;
    float inner_stop_absolute;
    float inner_stop_inter;
    bool find_basis_by_transpose;
    bool remove_dependencies;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct fdc_control_type_s_64 fdc_control;
    struct sbls_control_type_s_64 sbls_control;
    struct gltr_control_type_s_64 gltr_control;
};

struct eqp_time_type_s {
    float total;
    float find_dependent;
    float factorize;
    float solve;
    float solve_inter;
    float clock_total;
    float clock_find_dependent;
    float clock_factorize;
    float clock_solve;
};

struct eqp_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t cg_iter;
    int32_t cg_iter_inter;
    int64_t factorization_integer;
    int64_t factorization_real;
    float obj;
    struct eqp_time_type_s time;
    struct fdc_inform_type_s fdc_inform;
    struct sbls_inform_type_s sbls_inform;
    struct gltr_inform_type_s gltr_inform;
};

struct eqp_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t cg_iter;
    int64_t cg_iter_inter;
    int64_t factorization_integer;
    int64_t factorization_real;
    float obj;
    struct eqp_time_type_s time;
    struct fdc_inform_type_s_64 fdc_inform;
    struct sbls_inform_type_s_64 sbls_inform;
    struct gltr_inform_type_s_64 gltr_inform;
};

void eqp_initialize_s(void **data, struct eqp_control_type_s *control, int32_t *status);
void eqp_initialize_s_64(void **data, struct eqp_control_type_s_64 *control, int64_t *status);
void eqp_read_specfile_s(struct eqp_control_type_s *control, char *specfile);
void eqp_read_specfile_s_64(struct eqp_control_type_s_64 *control, char *specfile);
void eqp_import_s(struct eqp_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void eqp_import_s_64(struct eqp_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void eqp_reset_control_s(struct eqp_control_type_s *control, void **data, int32_t *status);
void eqp_reset_control_s_64(struct eqp_control_type_s_64 *control, void **data, int64_t *status);
void eqp_solve_qp_s(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, float *H_val, float *g, float f, int32_t a_ne, float *A_val, float *c, float *x, float *y);
void eqp_solve_qp_s_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, float *H_val, float *g, float f, int64_t a_ne, float *A_val, float *c, float *x, float *y);
void eqp_solve_sldqp_s(void **data, int32_t *status, int32_t n, int32_t m, float *w, float *x0, float *g, float f, int32_t a_ne, float *A_val, float *c, float *x, float *y);
void eqp_solve_sldqp_s_64(void **data, int64_t *status, int64_t n, int64_t m, float *w, float *x0, float *g, float f, int64_t a_ne, float *A_val, float *c, float *x, float *y);
void eqp_resolve_qp_s(void **data, int32_t *status, int32_t n, int32_t m, float *g, float f, float *c, float *x, float *y);
void eqp_resolve_qp_s_64(void **data, int64_t *status, int64_t n, int64_t m, float *g, float f, float *c, float *x, float *y);
void eqp_information_s(void **data, struct eqp_inform_type_s *inform, int32_t *status);
void eqp_information_s_64(void **data, struct eqp_inform_type_s_64 *inform, int64_t *status);
void eqp_terminate_s(void **data, struct eqp_control_type_s *control, struct eqp_inform_type_s *inform);
void eqp_terminate_s_64(void **data, struct eqp_control_type_s_64 *control, struct eqp_inform_type_s_64 *inform);

// C interface for LPA
struct lpa_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t max_iterative_refinements;
    int32_t min_real_factor_size;
    int32_t min_integer_factor_size;
    int32_t random_number_seed;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    float infinity;
    float tol_data;
    float feas_tol;
    float relative_pivot_tolerance;
    float growth_limit;
    float zero_tolerance;
    float change_tolerance;
    float identical_bounds_tol;
    float cpu_time_limit;
    float clock_time_limit;
    bool scale;
    bool dual;
    bool warm_start;
    bool steepest_edge;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
};

struct lpa_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t max_iterative_refinements;
    int64_t min_real_factor_size;
    int64_t min_integer_factor_size;
    int64_t random_number_seed;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    float infinity;
    float tol_data;
    float feas_tol;
    float relative_pivot_tolerance;
    float growth_limit;
    float zero_tolerance;
    float change_tolerance;
    float identical_bounds_tol;
    float cpu_time_limit;
    float clock_time_limit;
    bool scale;
    bool dual;
    bool warm_start;
    bool steepest_edge;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
};

struct lpa_time_type_s {
    float total;
    float preprocess;
    float clock_total;
    float clock_preprocess;
};

struct lpa_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t la04_job;
    int32_t la04_job_info;
    float obj;
    float primal_infeasibility;
    bool feasible;
    float RINFO[40];
    struct lpa_time_type_s time;
    struct rpd_inform_type rpd_inform;
};

struct lpa_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t la04_job;
    int64_t la04_job_info;
    float obj;
    float primal_infeasibility;
    bool feasible;
    float RINFO[40];
    struct lpa_time_type_s time;
    struct rpd_inform_type_64 rpd_inform;
};

void lpa_initialize_s(void **data, struct lpa_control_type_s *control, int32_t *status);
void lpa_initialize_s_64(void **data, struct lpa_control_type_s_64 *control, int64_t *status);
void lpa_read_specfile_s(struct lpa_control_type_s *control, char *specfile);
void lpa_read_specfile_s_64(struct lpa_control_type_s_64 *control, char *specfile);
void lpa_import_s(struct lpa_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void lpa_import_s_64(struct lpa_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void lpa_reset_control_s(struct lpa_control_type_s *control, void **data, int32_t *status);
void lpa_reset_control_s_64(struct lpa_control_type_s_64 *control, void **data, int64_t *status);
void lpa_solve_lp_s(void **data, int32_t *status, int32_t n, int32_t m, float *g, float f, int32_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat);
void lpa_solve_lp_s_64(void **data, int64_t *status, int64_t n, int64_t m, float *g, float f, int64_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat);
void lpa_information_s(void **data, struct lpa_inform_type_s *inform, int32_t *status);
void lpa_information_s_64(void **data, struct lpa_inform_type_s_64 *inform, int64_t *status);
void lpa_terminate_s(void **data, struct lpa_control_type_s *control, struct lpa_inform_type_s *inform);
void lpa_terminate_s_64(void **data, struct lpa_control_type_s_64 *control, struct lpa_inform_type_s_64 *inform);

// C interface for LPB
struct lpb_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float prfeas;
    float dufeas;
    float muzero;
    float tau;
    float gamma_c;
    float gamma_f;
    float reduce_infeas;
    float obj_unbounded;
    float potential_unbounded;
    float identical_bounds_tol;
    float mu_pounce;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_s fdc_control;
    struct sbls_control_type_s sbls_control;
    struct fit_control_type fit_control;
    struct roots_control_type_s roots_control;
    struct cro_control_type_s cro_control;
};

struct lpb_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float prfeas;
    float dufeas;
    float muzero;
    float tau;
    float gamma_c;
    float gamma_f;
    float reduce_infeas;
    float obj_unbounded;
    float potential_unbounded;
    float identical_bounds_tol;
    float mu_pounce;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_s_64 fdc_control;
    struct sbls_control_type_s_64 sbls_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_s_64 roots_control;
    struct cro_control_type_s_64 cro_control;
};

struct lpb_time_type_s {
    float total;
    float preprocess;
    float find_dependent;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_preprocess;
    float clock_find_dependent;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct lpb_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    float init_primal_infeasibility;
    float init_dual_infeasibility;
    float init_complementary_slackness;
    float potential;
    float non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    float checkpointsTime[16];
    struct lpb_time_type_s time;
    struct fdc_inform_type_s fdc_inform;
    struct sbls_inform_type_s sbls_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type_s cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct lpb_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    float init_primal_infeasibility;
    float init_dual_infeasibility;
    float init_complementary_slackness;
    float potential;
    float non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    float checkpointsTime[16];
    struct lpb_time_type_s time;
    struct fdc_inform_type_s_64 fdc_inform;
    struct sbls_inform_type_s_64 sbls_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_s_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void lpb_initialize_s(void **data, struct lpb_control_type_s *control, int32_t *status);
void lpb_initialize_s_64(void **data, struct lpb_control_type_s_64 *control, int64_t *status);
void lpb_read_specfile_s(struct lpb_control_type_s *control, char *specfile);
void lpb_read_specfile_s_64(struct lpb_control_type_s_64 *control, char *specfile);
void lpb_import_s(struct lpb_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void lpb_import_s_64(struct lpb_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void lpb_reset_control_s(struct lpb_control_type_s *control, void **data, int32_t *status);
void lpb_reset_control_s_64(struct lpb_control_type_s_64 *control, void **data, int64_t *status);
void lpb_solve_lp_s(void **data, int32_t *status, int32_t n, int32_t m, float *g, float f, int32_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat);
void lpb_solve_lp_s_64(void **data, int64_t *status, int64_t n, int64_t m, float *g, float f, int64_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat);
void lpb_information_s(void **data, struct lpb_inform_type_s *inform, int32_t *status);
void lpb_information_s_64(void **data, struct lpb_inform_type_s_64 *inform, int64_t *status);
void lpb_terminate_s(void **data, struct lpb_control_type_s *control, struct lpb_inform_type_s *inform);
void lpb_terminate_s_64(void **data, struct lpb_control_type_s_64 *control, struct lpb_inform_type_s_64 *inform);

// C interface for LSQP
struct lsqp_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t factor;
    int32_t max_col;
    int32_t indmin;
    int32_t valmin;
    int32_t itref_max;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t extrapolate;
    int32_t path_history;
    int32_t path_derivatives;
    int32_t fit_order;
    int32_t sif_file_device;
    float infinity;
    float stop_p;
    float stop_d;
    float stop_c;
    float prfeas;
    float dufeas;
    float muzero;
    float reduce_infeas;
    float potential_unbounded;
    float pivot_tol;
    float pivot_tol_for_dependencies;
    float zero_pivot;
    float identical_bounds_tol;
    float mu_min;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool feasol;
    bool balance_initial_complentarity;
    bool use_corrector;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct fdc_control_type_s fdc_control;
    struct sbls_control_type_s sbls_control;
};

struct lsqp_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t factor;
    int64_t max_col;
    int64_t indmin;
    int64_t valmin;
    int64_t itref_max;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t extrapolate;
    int64_t path_history;
    int64_t path_derivatives;
    int64_t fit_order;
    int64_t sif_file_device;
    float infinity;
    float stop_p;
    float stop_d;
    float stop_c;
    float prfeas;
    float dufeas;
    float muzero;
    float reduce_infeas;
    float potential_unbounded;
    float pivot_tol;
    float pivot_tol_for_dependencies;
    float zero_pivot;
    float identical_bounds_tol;
    float mu_min;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool feasol;
    bool balance_initial_complentarity;
    bool use_corrector;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct fdc_control_type_s_64 fdc_control;
    struct sbls_control_type_s_64 sbls_control;
};

struct lsqp_time_type_s {
    float total;
    float preprocess;
    float find_dependent;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_preprocess;
    float clock_find_dependent;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct lsqp_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    float obj;
    float potential;
    float non_negligible_pivot;
    bool feasible;
    struct lsqp_time_type_s time;
    struct fdc_inform_type_s fdc_inform;
    struct sbls_inform_type_s sbls_inform;
};

struct lsqp_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    float obj;
    float potential;
    float non_negligible_pivot;
    bool feasible;
    struct lsqp_time_type_s time;
    struct fdc_inform_type_s_64 fdc_inform;
    struct sbls_inform_type_s_64 sbls_inform;
};

void lsqp_initialize_s(void **data, struct lsqp_control_type_s *control, int32_t *status);
void lsqp_initialize_s_64(void **data, struct lsqp_control_type_s_64 *control, int64_t *status);
void lsqp_read_specfile_s(struct lsqp_control_type_s *control, char *specfile);
void lsqp_read_specfile_s_64(struct lsqp_control_type_s_64 *control, char *specfile);
void lsqp_import_s(struct lsqp_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void lsqp_import_s_64(struct lsqp_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void lsqp_reset_control_s(struct lsqp_control_type_s *control, void **data, int32_t *status);
void lsqp_reset_control_s_64(struct lsqp_control_type_s_64 *control, void **data, int64_t *status);
void lsqp_solve_qp_s(void **data, int32_t *status, int32_t n, int32_t m, float *w, float *x0, float *g, float f, int32_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat);
void lsqp_solve_qp_s_64(void **data, int64_t *status, int64_t n, int64_t m, float *w, float *x0, float *g, float f, int64_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat);
void lsqp_information_s(void **data, struct lsqp_inform_type_s *inform, int32_t *status);
void lsqp_information_s_64(void **data, struct lsqp_inform_type_s_64 *inform, int64_t *status);
void lsqp_terminate_s(void **data, struct lsqp_control_type_s *control, struct lsqp_inform_type_s *inform);
void lsqp_terminate_s_64(void **data, struct lsqp_control_type_s_64 *control, struct lsqp_inform_type_s_64 *inform);

// C interface for NLS
struct nls_subproblem_control_type_s {
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t jacobian_available;
    int32_t hessian_available;
    int32_t model;
    int32_t norm;
    int32_t non_monotone;
    int32_t weight_update_strategy;
    float stop_c_absolute;
    float stop_c_relative;
    float stop_g_absolute;
    float stop_g_relative;
    float stop_s;
    float power;
    float initial_weight;
    float minimum_weight;
    float initial_inner_weight;
    float eta_successful;
    float eta_very_successful;
    float eta_too_successful;
    float weight_decrease_min;
    float weight_decrease;
    float weight_increase;
    float weight_increase_max;
    float reduce_gap;
    float tiny_gap;
    float large_root;
    float switch_to_newton;
    float cpu_time_limit;
    float clock_time_limit;
    bool subproblem_direct;
    bool renormalize_weight;
    bool magic_step;
    bool print_obj;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_s rqs_control;
    struct glrt_control_type_s glrt_control;
    struct psls_control_type_s psls_control;
    struct bsc_control_type bsc_control;
    struct roots_control_type_s roots_control;
};

struct nls_subproblem_control_type_s_64 {
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t jacobian_available;
    int64_t hessian_available;
    int64_t model;
    int64_t norm;
    int64_t non_monotone;
    int64_t weight_update_strategy;
    float stop_c_absolute;
    float stop_c_relative;
    float stop_g_absolute;
    float stop_g_relative;
    float stop_s;
    float power;
    float initial_weight;
    float minimum_weight;
    float initial_inner_weight;
    float eta_successful;
    float eta_very_successful;
    float eta_too_successful;
    float weight_decrease_min;
    float weight_decrease;
    float weight_increase;
    float weight_increase_max;
    float reduce_gap;
    float tiny_gap;
    float large_root;
    float switch_to_newton;
    float cpu_time_limit;
    float clock_time_limit;
    bool subproblem_direct;
    bool renormalize_weight;
    bool magic_step;
    bool print_obj;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_s_64 rqs_control;
    struct glrt_control_type_s_64 glrt_control;
    struct psls_control_type_s_64 psls_control;
    struct bsc_control_type_64 bsc_control;
    struct roots_control_type_s_64 roots_control;
};

struct nls_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t jacobian_available;
    int32_t hessian_available;
    int32_t model;
    int32_t norm;
    int32_t non_monotone;
    int32_t weight_update_strategy;
    float stop_c_absolute;
    float stop_c_relative;
    float stop_g_absolute;
    float stop_g_relative;
    float stop_s;
    float power;
    float initial_weight;
    float minimum_weight;
    float initial_inner_weight;
    float eta_successful;
    float eta_very_successful;
    float eta_too_successful;
    float weight_decrease_min;
    float weight_decrease;
    float weight_increase;
    float weight_increase_max;
    float reduce_gap;
    float tiny_gap;
    float large_root;
    float switch_to_newton;
    float cpu_time_limit;
    float clock_time_limit;
    bool subproblem_direct;
    bool renormalize_weight;
    bool magic_step;
    bool print_obj;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_s rqs_control;
    struct glrt_control_type_s glrt_control;
    struct psls_control_type_s psls_control;
    struct bsc_control_type bsc_control;
    struct roots_control_type_s roots_control;
    struct nls_subproblem_control_type_s subproblem_control;
};

struct nls_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t jacobian_available;
    int64_t hessian_available;
    int64_t model;
    int64_t norm;
    int64_t non_monotone;
    int64_t weight_update_strategy;
    float stop_c_absolute;
    float stop_c_relative;
    float stop_g_absolute;
    float stop_g_relative;
    float stop_s;
    float power;
    float initial_weight;
    float minimum_weight;
    float initial_inner_weight;
    float eta_successful;
    float eta_very_successful;
    float eta_too_successful;
    float weight_decrease_min;
    float weight_decrease;
    float weight_increase;
    float weight_increase_max;
    float reduce_gap;
    float tiny_gap;
    float large_root;
    float switch_to_newton;
    float cpu_time_limit;
    float clock_time_limit;
    bool subproblem_direct;
    bool renormalize_weight;
    bool magic_step;
    bool print_obj;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_s_64 rqs_control;
    struct glrt_control_type_s_64 glrt_control;
    struct psls_control_type_s_64 psls_control;
    struct bsc_control_type_64 bsc_control;
    struct roots_control_type_s_64 roots_control;
    struct nls_subproblem_control_type_s_64 subproblem_control;
};

struct nls_time_type_s {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_preprocess;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct nls_subproblem_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int32_t iter;
    int32_t cg_iter;
    int32_t c_eval;
    int32_t j_eval;
    int32_t h_eval;
    int32_t factorization_max;
    int32_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    float factorization_average;
    float obj;
    float norm_c;
    float norm_g;
    float weight;
    struct nls_time_type_s time;
    struct rqs_inform_type_s rqs_inform;
    struct glrt_inform_type_s glrt_inform;
    struct psls_inform_type_s psls_inform;
    struct bsc_inform_type_s bsc_inform;
    struct roots_inform_type roots_inform;
};

struct nls_subproblem_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int64_t iter;
    int64_t cg_iter;
    int64_t c_eval;
    int64_t j_eval;
    int64_t h_eval;
    int64_t factorization_max;
    int64_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    float factorization_average;
    float obj;
    float norm_c;
    float norm_g;
    float weight;
    struct nls_time_type_s time;
    struct rqs_inform_type_s_64 rqs_inform;
    struct glrt_inform_type_s_64 glrt_inform;
    struct psls_inform_type_s_64 psls_inform;
    struct bsc_inform_type_s_64 bsc_inform;
    struct roots_inform_type_64 roots_inform;
};

struct nls_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int32_t iter;
    int32_t cg_iter;
    int32_t c_eval;
    int32_t j_eval;
    int32_t h_eval;
    int32_t factorization_max;
    int32_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    float factorization_average;
    float obj;
    float norm_c;
    float norm_g;
    float weight;
    struct nls_time_type_s time;
    struct rqs_inform_type_s rqs_inform;
    struct glrt_inform_type_s glrt_inform;
    struct psls_inform_type_s psls_inform;
    struct bsc_inform_type_s bsc_inform;
    struct roots_inform_type roots_inform;
    struct nls_subproblem_inform_type_s subproblem_inform;
};

struct nls_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int64_t iter;
    int64_t cg_iter;
    int64_t c_eval;
    int64_t j_eval;
    int64_t h_eval;
    int64_t factorization_max;
    int64_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    float factorization_average;
    float obj;
    float norm_c;
    float norm_g;
    float weight;
    struct nls_time_type_s time;
    struct rqs_inform_type_s_64 rqs_inform;
    struct glrt_inform_type_s_64 glrt_inform;
    struct psls_inform_type_s_64 psls_inform;
    struct bsc_inform_type_s_64 bsc_inform;
    struct roots_inform_type_64 roots_inform;
    struct nls_subproblem_inform_type_s_64 subproblem_inform;
};

void nls_initialize_s(void **data, struct nls_control_type_s *control, struct nls_inform_type_s *inform);
void nls_initialize_s_64(void **data, struct nls_control_type_s_64 *control, struct nls_inform_type_s_64 *inform);
void nls_read_specfile_s(struct nls_control_type_s *control, char *specfile);
void nls_read_specfile_s_64(struct nls_control_type_s_64 *control, char *specfile);
void nls_import_s(struct nls_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *J_type, int32_t J_ne, int32_t *J_row, int32_t *J_col, int32_t *J_ptr, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *P_type, int32_t P_ne, int32_t *P_row, int32_t *P_col, int32_t *P_ptr, float *w);
void nls_import_s_64(struct nls_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *J_type, int64_t J_ne, int64_t *J_row, int64_t *J_col, int64_t *J_ptr, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *P_type, int64_t P_ne, int64_t *P_row, int64_t *P_col, int64_t *P_ptr, float *w);
void nls_reset_control_s(struct nls_control_type_s *control, void **data, int32_t *status);
void nls_reset_control_s_64(struct nls_control_type_s_64 *control, void **data, int64_t *status);
void nls_solve_with_mat_s(void **data, void *userdata, int32_t *status, int32_t n, int32_t m, float *x, float *c, float *g, galahad_r_s *eval_r, int32_t j_ne, galahad_jr_s *eval_jr, int32_t h_ne, galahad_hr_s *eval_hr, int32_t p_ne, galahad_shrprod_s *eval_shrprod);
void nls_solve_with_mat_s_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t m, float *x, float *c, float *g, galahad_r_s_64 *eval_r, int64_t j_ne, galahad_jr_s_64 *eval_jr, int64_t h_ne, galahad_hr_s_64 *eval_hr, int64_t p_ne, galahad_shrprod_s_64 *eval_shrprod);
void nls_solve_without_mat_s(void **data, void *userdata, int32_t *status, int32_t n, int32_t m, float *x, float *c, float *g, galahad_r_s *eval_r, galahad_jrprod_s *eval_jrprod, galahad_hrprod_s *eval_hrprod, int32_t p_ne, galahad_shrprod_s *eval_shrprod);
void nls_solve_without_mat_s_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t m, float *x, float *c, float *g, galahad_r_s_64 *eval_r, galahad_jrprod_s_64 *eval_jrprod, galahad_hrprod_s_64 *eval_hrprod, int64_t p_ne, galahad_shrprod_s_64 *eval_shrprod);
void nls_solve_reverse_with_mat_s(void **data, int32_t *status, int32_t *eval_status, int32_t n, int32_t m, float *x, float *c, float *g, int32_t j_ne, float *J_val, float *y, int32_t h_ne, float *H_val, float *v, int32_t p_ne, float *P_val);
void nls_solve_reverse_with_mat_s_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, int64_t m, float *x, float *c, float *g, int64_t j_ne, float *J_val, float *y, int64_t h_ne, float *H_val, float *v, int64_t p_ne, float *P_val);
void nls_solve_reverse_without_mat_s(void **data, int32_t *status, int32_t *eval_status, int32_t n, int32_t m, float *x, float *c, float *g, bool *transpose, float *u, float *v, float *y, int32_t p_ne, float *P_val);
void nls_solve_reverse_without_mat_s_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, int64_t m, float *x, float *c, float *g, bool *transpose, float *u, float *v, float *y, int64_t p_ne, float *P_val);
void nls_information_s(void **data, struct nls_inform_type_s *inform, int32_t *status);
void nls_information_s_64(void **data, struct nls_inform_type_s_64 *inform, int64_t *status);
void nls_terminate_s(void **data, struct nls_control_type_s *control, struct nls_inform_type_s *inform);
void nls_terminate_s_64(void **data, struct nls_control_type_s_64 *control, struct nls_inform_type_s_64 *inform);

// C interface for QPA
struct qpa_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t factor;
    int32_t max_col;
    int32_t max_sc;
    int32_t indmin;
    int32_t valmin;
    int32_t itref_max;
    int32_t infeas_check_interval;
    int32_t cg_maxit;
    int32_t precon;
    int32_t nsemib;
    int32_t full_max_fill;
    int32_t deletion_strategy;
    int32_t restore_problem;
    int32_t monitor_residuals;
    int32_t cold_start;
    int32_t sif_file_device;
    float infinity;
    float feas_tol;
    float obj_unbounded;
    float increase_rho_g_factor;
    float infeas_g_improved_by_factor;
    float increase_rho_b_factor;
    float infeas_b_improved_by_factor;
    float pivot_tol;
    float pivot_tol_for_dependencies;
    float zero_pivot;
    float inner_stop_relative;
    float inner_stop_absolute;
    float multiplier_tol;
    float cpu_time_limit;
    float clock_time_limit;
    bool treat_zero_bounds_as_general;
    bool solve_qp;
    bool solve_within_bounds;
    bool randomize;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char prefix[31];
    bool each_interval;
    struct sls_control_type_s sls_control;
};

struct qpa_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t factor;
    int64_t max_col;
    int64_t max_sc;
    int64_t indmin;
    int64_t valmin;
    int64_t itref_max;
    int64_t infeas_check_interval;
    int64_t cg_maxit;
    int64_t precon;
    int64_t nsemib;
    int64_t full_max_fill;
    int64_t deletion_strategy;
    int64_t restore_problem;
    int64_t monitor_residuals;
    int64_t cold_start;
    int64_t sif_file_device;
    float infinity;
    float feas_tol;
    float obj_unbounded;
    float increase_rho_g_factor;
    float infeas_g_improved_by_factor;
    float increase_rho_b_factor;
    float infeas_b_improved_by_factor;
    float pivot_tol;
    float pivot_tol_for_dependencies;
    float zero_pivot;
    float inner_stop_relative;
    float inner_stop_absolute;
    float multiplier_tol;
    float cpu_time_limit;
    float clock_time_limit;
    bool treat_zero_bounds_as_general;
    bool solve_qp;
    bool solve_within_bounds;
    bool randomize;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char prefix[31];
    bool each_interval;
    struct sls_control_type_s_64 sls_control;
};

struct qpa_time_type_s {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_preprocess;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct qpa_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t major_iter;
    int32_t iter;
    int32_t cg_iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nmods;
    int32_t num_g_infeas;
    int32_t num_b_infeas;
    float obj;
    float infeas_g;
    float infeas_b;
    float merit;
    struct qpa_time_type_s time;
    struct sls_inform_type_s sls_inform;
};

struct qpa_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t major_iter;
    int64_t iter;
    int64_t cg_iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nmods;
    int64_t num_g_infeas;
    int64_t num_b_infeas;
    float obj;
    float infeas_g;
    float infeas_b;
    float merit;
    struct qpa_time_type_s time;
    struct sls_inform_type_s_64 sls_inform;
};

void qpa_initialize_s(void **data, struct qpa_control_type_s *control, int32_t *status);
void qpa_initialize_s_64(void **data, struct qpa_control_type_s_64 *control, int64_t *status);
void qpa_read_specfile_s(struct qpa_control_type_s *control, char *specfile);
void qpa_read_specfile_s_64(struct qpa_control_type_s_64 *control, char *specfile);
void qpa_import_s(struct qpa_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void qpa_import_s_64(struct qpa_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void qpa_reset_control_s(struct qpa_control_type_s *control, void **data, int32_t *status);
void qpa_reset_control_s_64(struct qpa_control_type_s_64 *control, void **data, int64_t *status);
void qpa_solve_qp_s(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, float *H_val, float *g, float f, int32_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat);
void qpa_solve_qp_s_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, float *H_val, float *g, float f, int64_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat);
void qpa_solve_l1qp_s(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, float *H_val, float *g, float f, float rho_g, float rho_b, int32_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat);
void qpa_solve_l1qp_s_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, float *H_val, float *g, float f, float rho_g, float rho_b, int64_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat);
void qpa_solve_bcl1qp_s(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, float *H_val, float *g, float f, float rho_g, int32_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat);
void qpa_solve_bcl1qp_s_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, float *H_val, float *g, float f, float rho_g, int64_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat);
void qpa_information_s(void **data, struct qpa_inform_type_s *inform, int32_t *status);
void qpa_information_s_64(void **data, struct qpa_inform_type_s_64 *inform, int64_t *status);
void qpa_terminate_s(void **data, struct qpa_control_type_s *control, struct qpa_inform_type_s *inform);
void qpa_terminate_s_64(void **data, struct qpa_control_type_s_64 *control, struct qpa_inform_type_s_64 *inform);

// C interface for QPB
struct qpb_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t itref_max;
    int32_t cg_maxit;
    int32_t indicator_type;
    int32_t restore_problem;
    int32_t extrapolate;
    int32_t path_history;
    int32_t factor;
    int32_t max_col;
    int32_t indmin;
    int32_t valmin;
    int32_t infeas_max;
    int32_t precon;
    int32_t nsemib;
    int32_t path_derivatives;
    int32_t fit_order;
    int32_t sif_file_device;
    float infinity;
    float stop_p;
    float stop_d;
    float stop_c;
    float theta_d;
    float theta_c;
    float beta;
    float prfeas;
    float dufeas;
    float muzero;
    float reduce_infeas;
    float obj_unbounded;
    float pivot_tol;
    float pivot_tol_for_dependencies;
    float zero_pivot;
    float identical_bounds_tol;
    float inner_stop_relative;
    float inner_stop_absolute;
    float initial_radius;
    float mu_min;
    float inner_fraction_opt;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool center;
    bool primal;
    bool puiseux;
    bool feasol;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct lsqp_control_type_s lsqp_control;
    struct fdc_control_type_s fdc_control;
    struct sbls_control_type_s sbls_control;
    struct gltr_control_type_s gltr_control;
    struct fit_control_type fit_control;
};

struct qpb_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t itref_max;
    int64_t cg_maxit;
    int64_t indicator_type;
    int64_t restore_problem;
    int64_t extrapolate;
    int64_t path_history;
    int64_t factor;
    int64_t max_col;
    int64_t indmin;
    int64_t valmin;
    int64_t infeas_max;
    int64_t precon;
    int64_t nsemib;
    int64_t path_derivatives;
    int64_t fit_order;
    int64_t sif_file_device;
    float infinity;
    float stop_p;
    float stop_d;
    float stop_c;
    float theta_d;
    float theta_c;
    float beta;
    float prfeas;
    float dufeas;
    float muzero;
    float reduce_infeas;
    float obj_unbounded;
    float pivot_tol;
    float pivot_tol_for_dependencies;
    float zero_pivot;
    float identical_bounds_tol;
    float inner_stop_relative;
    float inner_stop_absolute;
    float initial_radius;
    float mu_min;
    float inner_fraction_opt;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool center;
    bool primal;
    bool puiseux;
    bool feasol;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct lsqp_control_type_s_64 lsqp_control;
    struct fdc_control_type_s_64 fdc_control;
    struct sbls_control_type_s_64 sbls_control;
    struct gltr_control_type_s_64 gltr_control;
    struct fit_control_type_64 fit_control;
};

struct qpb_time_type_s {
    float total;
    float preprocess;
    float find_dependent;
    float analyse;
    float factorize;
    float solve;
    float phase1_total;
    float phase1_analyse;
    float phase1_factorize;
    float phase1_solve;
    float clock_total;
    float clock_preprocess;
    float clock_find_dependent;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
    float clock_phase1_total;
    float clock_phase1_analyse;
    float clock_phase1_factorize;
    float clock_phase1_solve;
};

struct qpb_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t nmods;
    float obj;
    float non_negligible_pivot;
    bool feasible;
    struct qpb_time_type_s time;
    struct lsqp_inform_type_s lsqp_inform;
    struct fdc_inform_type_s fdc_inform;
    struct sbls_inform_type_s sbls_inform;
    struct gltr_inform_type_s gltr_inform;
    struct fit_inform_type fit_inform;
};

struct qpb_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t nmods;
    float obj;
    float non_negligible_pivot;
    bool feasible;
    struct qpb_time_type_s time;
    struct lsqp_inform_type_s_64 lsqp_inform;
    struct fdc_inform_type_s_64 fdc_inform;
    struct sbls_inform_type_s_64 sbls_inform;
    struct gltr_inform_type_s_64 gltr_inform;
    struct fit_inform_type_64 fit_inform;
};

void qpb_initialize_s(void **data, struct qpb_control_type_s *control, int32_t *status);
void qpb_initialize_s_64(void **data, struct qpb_control_type_s_64 *control, int64_t *status);
void qpb_read_specfile_s(struct qpb_control_type_s *control, char *specfile);
void qpb_read_specfile_s_64(struct qpb_control_type_s_64 *control, char *specfile);
void qpb_import_s(struct qpb_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void qpb_import_s_64(struct qpb_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void qpb_reset_control_s(struct qpb_control_type_s *control, void **data, int32_t *status);
void qpb_reset_control_s_64(struct qpb_control_type_s_64 *control, void **data, int64_t *status);
void qpb_solve_qp_s(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, float *H_val, float *g, float f, int32_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int32_t *x_stat, int32_t *c_stat);
void qpb_solve_qp_s_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, float *H_val, float *g, float f, int64_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y, float *z, int64_t *x_stat, int64_t *c_stat);
void qpb_information_s(void **data, struct qpb_inform_type_s *inform, int32_t *status);
void qpb_information_s_64(void **data, struct qpb_inform_type_s_64 *inform, int64_t *status);
void qpb_terminate_s(void **data, struct qpb_control_type_s *control, struct qpb_inform_type_s *inform);
void qpb_terminate_s_64(void **data, struct qpb_control_type_s_64 *control, struct qpb_inform_type_s_64 *inform);

// C interface for SLLS
struct slls_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t cold_start;
    int32_t preconditioner;
    int32_t ratio_cg_vs_sd;
    int32_t change_max;
    int32_t cg_maxit;
    int32_t arcsearch_max_steps;
    int32_t sif_file_device;
    float weight;
    float stop_d;
    float stop_cg_relative;
    float stop_cg_absolute;
    float alpha_max;
    float alpha_initial;
    float alpha_reduction;
    float arcsearch_acceptance_tol;
    float stabilisation_weight;
    float cpu_time_limit;
    bool direct_subproblem_solve;
    bool exact_arc_search;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_s sbls_control;
    struct convert_control_type convert_control;
};

struct slls_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t cold_start;
    int64_t preconditioner;
    int64_t ratio_cg_vs_sd;
    int64_t change_max;
    int64_t cg_maxit;
    int64_t arcsearch_max_steps;
    int64_t sif_file_device;
    float weight;
    float stop_d;
    float stop_cg_relative;
    float stop_cg_absolute;
    float alpha_max;
    float alpha_initial;
    float alpha_reduction;
    float arcsearch_acceptance_tol;
    float stabilisation_weight;
    float cpu_time_limit;
    bool direct_subproblem_solve;
    bool exact_arc_search;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_s_64 sbls_control;
    struct convert_control_type_64 convert_control;
};

struct slls_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    int32_t factorization_status;
    int32_t iter;
    int32_t cg_iter;
    float obj;
    float norm_pg;
    char bad_alloc[81];
    struct slls_time_type time;
    struct sbls_inform_type_s sbls_inform;
    struct convert_inform_type_s convert_inform;
};

struct slls_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorization_status;
    int64_t iter;
    int64_t cg_iter;
    float obj;
    float norm_pg;
    char bad_alloc[81];
    struct slls_time_type time;
    struct sbls_inform_type_s_64 sbls_inform;
    struct convert_inform_type_s_64 convert_inform;
};

void slls_initialize_s(void **data, struct slls_control_type_s *control, int32_t *status);
void slls_initialize_s_64(void **data, struct slls_control_type_s_64 *control, int64_t *status);
void slls_read_specfile_s(struct slls_control_type_s *control, char *specfile);
void slls_read_specfile_s_64(struct slls_control_type_s_64 *control, char *specfile);
void slls_import_s(struct slls_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *Ao_type, int32_t Ao_ne, int32_t *Ao_row, int32_t *Ao_col, int32_t Ao_ptr_ne, int32_t *Ao_ptr);
void slls_import_s_64(struct slls_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *Ao_type, int64_t Ao_ne, int64_t *Ao_row, int64_t *Ao_col, int64_t Ao_ptr_ne, int64_t *Ao_ptr);
void slls_import_without_a_s(struct slls_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t o);
void slls_import_without_a_s_64(struct slls_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t o);
void slls_reset_control_s(struct slls_control_type_s *control, void **data, int32_t *status);
void slls_reset_control_s_64(struct slls_control_type_s_64 *control, void **data, int64_t *status);
void slls_solve_given_a_s(void **data, void *userdata, int32_t *status, int32_t n, int32_t o, int32_t Ao_ne, float *Ao_val, float *b, float *x, float *z, float *r, float *g, int32_t *x_stat, galahad_constant_prec_s *eval_prec);
void slls_solve_given_a_s_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t o, int64_t Ao_ne, float *Ao_val, float *b, float *x, float *z, float *r, float *g, int64_t *x_stat, galahad_constant_prec_s_64 *eval_prec);
void slls_solve_reverse_a_prod_s(void **data, int32_t *status, int32_t *eval_status, int32_t n, int32_t o, float *b, float *x, float *z, float *r, float *g, int32_t *x_stat, float *v, float *p, int32_t *nz_v, int32_t *nz_v_start, int32_t *nz_v_end, int32_t *nz_p, int32_t nz_p_end);
void slls_solve_reverse_a_prod_s_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, int64_t o, float *b, float *x, float *z, float *r, float *g, int64_t *x_stat, float *v, float *p, int64_t *nz_v, int64_t *nz_v_start, int64_t *nz_v_end, int64_t *nz_p, int64_t nz_p_end);
void slls_information_s(void **data, struct slls_inform_type_s *inform, int32_t *status);
void slls_information_s_64(void **data, struct slls_inform_type_s_64 *inform, int64_t *status);
void slls_terminate_s(void **data, struct slls_control_type_s *control, struct slls_inform_type_s *inform);
void slls_terminate_s_64(void **data, struct slls_control_type_s_64 *control, struct slls_inform_type_s_64 *inform);

// C interface for TRU
struct tru_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t non_monotone;
    int32_t model;
    int32_t norm;
    int32_t semi_bandwidth;
    int32_t lbfgs_vectors;
    int32_t max_dxg;
    int32_t icfs_vectors;
    int32_t mi28_lsize;
    int32_t mi28_rsize;
    int32_t advanced_start;
    float stop_g_absolute;
    float stop_g_relative;
    float stop_s;
    float initial_radius;
    float maximum_radius;
    float eta_successful;
    float eta_very_successful;
    float eta_too_successful;
    float radius_increase;
    float radius_reduce;
    float radius_reduce_max;
    float obj_unbounded;
    float cpu_time_limit;
    float clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool retrospective_trust_region;
    bool renormalize_radius;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct trs_control_type_s trs_control;
    struct gltr_control_type_s gltr_control;
    struct dps_control_type_s dps_control;
    struct psls_control_type_s psls_control;
    struct lms_control_type lms_control;
    struct lms_control_type lms_control_prec;
    struct sec_control_type_s sec_control;
    struct sha_control_type sha_control;
};

struct tru_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t non_monotone;
    int64_t model;
    int64_t norm;
    int64_t semi_bandwidth;
    int64_t lbfgs_vectors;
    int64_t max_dxg;
    int64_t icfs_vectors;
    int64_t mi28_lsize;
    int64_t mi28_rsize;
    int64_t advanced_start;
    float stop_g_absolute;
    float stop_g_relative;
    float stop_s;
    float initial_radius;
    float maximum_radius;
    float eta_successful;
    float eta_very_successful;
    float eta_too_successful;
    float radius_increase;
    float radius_reduce;
    float radius_reduce_max;
    float obj_unbounded;
    float cpu_time_limit;
    float clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool retrospective_trust_region;
    bool renormalize_radius;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct trs_control_type_s_64 trs_control;
    struct gltr_control_type_s_64 gltr_control;
    struct dps_control_type_s_64 dps_control;
    struct psls_control_type_s_64 psls_control;
    struct lms_control_type_64 lms_control;
    struct lms_control_type_64 lms_control_prec;
    struct sec_control_type_s_64 sec_control;
    struct sha_control_type_64 sha_control;
};

struct tru_time_type_s {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_preprocess;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct tru_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    int32_t factorization_max;
    int32_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    float factorization_average;
    float obj;
    float norm_g;
    float radius;
    struct tru_time_type_s time;
    struct trs_inform_type_s trs_inform;
    struct gltr_inform_type_s gltr_inform;
    struct dps_inform_type_s dps_inform;
    struct psls_inform_type_s psls_inform;
    struct lms_inform_type_s lms_inform;
    struct lms_inform_type_s lms_inform_prec;
    struct sec_inform_type sec_inform;
    struct sha_inform_type_s sha_inform;
};

struct tru_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    int64_t factorization_max;
    int64_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    float factorization_average;
    float obj;
    float norm_g;
    float radius;
    struct tru_time_type_s time;
    struct trs_inform_type_s_64 trs_inform;
    struct gltr_inform_type_s_64 gltr_inform;
    struct dps_inform_type_s_64 dps_inform;
    struct psls_inform_type_s_64 psls_inform;
    struct lms_inform_type_s_64 lms_inform;
    struct lms_inform_type_s_64 lms_inform_prec;
    struct sec_inform_type_64 sec_inform;
    struct sha_inform_type_s_64 sha_inform;
};

void tru_initialize_s(void **data, struct tru_control_type_s *control, int32_t *status);
void tru_initialize_s_64(void **data, struct tru_control_type_s_64 *control, int64_t *status);
void tru_read_specfile_s(struct tru_control_type_s *control, char *specfile);
void tru_read_specfile_s_64(struct tru_control_type_s_64 *control, char *specfile);
void tru_import_s(struct tru_control_type_s *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void tru_import_s_64(struct tru_control_type_s_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void tru_reset_control_s(struct tru_control_type_s *control, void **data, int32_t *status);
void tru_reset_control_s_64(struct tru_control_type_s_64 *control, void **data, int64_t *status);
void tru_solve_with_mat_s(void **data, void *userdata, int32_t *status, int32_t n, float *x, float *g, int32_t ne, galahad_f_s *eval_f, galahad_g_s *eval_g, galahad_h_s *eval_h, galahad_prec_s *eval_prec);
void tru_solve_with_mat_s_64(void **data, void *userdata, int64_t *status, int64_t n, float *x, float *g, int64_t ne, galahad_f_s_64 *eval_f, galahad_g_s_64 *eval_g, galahad_h_s_64 *eval_h, galahad_prec_s_64 *eval_prec);
void tru_solve_without_mat_s(void **data, void *userdata, int32_t *status, int32_t n, float *x, float *g, galahad_f_s *eval_f, galahad_g_s *eval_g, galahad_hprod_s *eval_hprod, galahad_prec_s *eval_prec);
void tru_solve_without_mat_s_64(void **data, void *userdata, int64_t *status, int64_t n, float *x, float *g, galahad_f_s_64 *eval_f, galahad_g_s_64 *eval_g, galahad_hprod_s_64 *eval_hprod, galahad_prec_s_64 *eval_prec);
void tru_solve_reverse_with_mat_s(void **data, int32_t *status, int32_t *eval_status, int32_t n, float *x, float f, float *g, int32_t ne, float *H_val, float *u, float *v);
void tru_solve_reverse_with_mat_s_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, float *x, float f, float *g, int64_t ne, float *H_val, float *u, float *v);
void tru_solve_reverse_without_mat_s(void **data, int32_t *status, int32_t *eval_status, int32_t n, float *x, float f, float *g, float *u, float *v);
void tru_solve_reverse_without_mat_s_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, float *x, float f, float *g, float *u, float *v);
void tru_information_s(void **data, struct tru_inform_type_s *inform, int32_t *status);
void tru_information_s_64(void **data, struct tru_inform_type_s_64 *inform, int64_t *status);
void tru_terminate_s(void **data, struct tru_control_type_s *control, struct tru_inform_type_s *inform);
void tru_terminate_s_64(void **data, struct tru_control_type_s_64 *control, struct tru_inform_type_s_64 *inform);

// C interface for WCP
struct wcp_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t initial_point;
    int32_t factor;
    int32_t max_col;
    int32_t indmin;
    int32_t valmin;
    int32_t itref_max;
    int32_t infeas_max;
    int32_t perturbation_strategy;
    int32_t restore_problem;
    float infinity;
    float stop_p;
    float stop_d;
    float stop_c;
    float prfeas;
    float dufeas;
    float mu_target;
    float mu_accept_fraction;
    float mu_increase_factor;
    float required_infeas_reduction;
    float implicit_tol;
    float pivot_tol;
    float pivot_tol_for_dependencies;
    float zero_pivot;
    float perturb_start;
    float alpha_scale;
    float identical_bounds_tol;
    float reduce_perturb_factor;
    float reduce_perturb_multiplier;
    float insufficiently_feasible;
    float perturbation_small;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool balance_initial_complementarity;
    bool use_corrector;
    bool space_critical;
    bool deallocate_error_fatal;
    bool record_x_status;
    bool record_c_status;
    char prefix[31];
    struct fdc_control_type_s fdc_control;
    struct sbls_control_type_s sbls_control;
};

struct wcp_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t initial_point;
    int64_t factor;
    int64_t max_col;
    int64_t indmin;
    int64_t valmin;
    int64_t itref_max;
    int64_t infeas_max;
    int64_t perturbation_strategy;
    int64_t restore_problem;
    float infinity;
    float stop_p;
    float stop_d;
    float stop_c;
    float prfeas;
    float dufeas;
    float mu_target;
    float mu_accept_fraction;
    float mu_increase_factor;
    float required_infeas_reduction;
    float implicit_tol;
    float pivot_tol;
    float pivot_tol_for_dependencies;
    float zero_pivot;
    float perturb_start;
    float alpha_scale;
    float identical_bounds_tol;
    float reduce_perturb_factor;
    float reduce_perturb_multiplier;
    float insufficiently_feasible;
    float perturbation_small;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool balance_initial_complementarity;
    bool use_corrector;
    bool space_critical;
    bool deallocate_error_fatal;
    bool record_x_status;
    bool record_c_status;
    char prefix[31];
    struct fdc_control_type_s_64 fdc_control;
    struct sbls_control_type_s_64 sbls_control;
};

struct wcp_time_type_s {
    float total;
    float preprocess;
    float find_dependent;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_preprocess;
    float clock_find_dependent;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct wcp_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t c_implicit;
    int32_t x_implicit;
    int32_t y_implicit;
    int32_t z_implicit;
    float obj;
    float mu_final_target_max;
    float non_negligible_pivot;
    bool feasible;
    struct wcp_time_type_s time;
    struct fdc_inform_type_s fdc_inform;
    struct sbls_inform_type_s sbls_inform;
};

struct wcp_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t c_implicit;
    int64_t x_implicit;
    int64_t y_implicit;
    int64_t z_implicit;
    float obj;
    float mu_final_target_max;
    float non_negligible_pivot;
    bool feasible;
    struct wcp_time_type_s time;
    struct fdc_inform_type_s_64 fdc_inform;
    struct sbls_inform_type_s_64 sbls_inform;
};

void wcp_initialize_s(void **data, struct wcp_control_type_s *control, int32_t *status);
void wcp_initialize_s_64(void **data, struct wcp_control_type_s_64 *control, int64_t *status);
void wcp_read_specfile_s(struct wcp_control_type_s *control, char *specfile);
void wcp_read_specfile_s_64(struct wcp_control_type_s_64 *control, char *specfile);
void wcp_import_s(struct wcp_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void wcp_import_s_64(struct wcp_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void wcp_reset_control_s(struct wcp_control_type_s *control, void **data, int32_t *status);
void wcp_reset_control_s_64(struct wcp_control_type_s_64 *control, void **data, int64_t *status);
void wcp_find_wcp_s(void **data, int32_t *status, int32_t n, int32_t m, float *g, int32_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y_l, float *y_u, float *z_l, float *z_u, int32_t *x_stat, int32_t *c_stat);
void wcp_find_wcp_s_64(void **data, int64_t *status, int64_t n, int64_t m, float *g, int64_t a_ne, float *A_val, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *c, float *y_l, float *y_u, float *z_l, float *z_u, int64_t *x_stat, int64_t *c_stat);
void wcp_information_s(void **data, struct wcp_inform_type_s *inform, int32_t *status);
void wcp_information_s_64(void **data, struct wcp_inform_type_s_64 *inform, int64_t *status);
void wcp_terminate_s(void **data, struct wcp_control_type_s *control, struct wcp_inform_type_s *inform);
void wcp_terminate_s_64(void **data, struct wcp_control_type_s_64 *control, struct wcp_inform_type_s_64 *inform);

// C interface for LLSR
struct llsr_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t new_a;
    int32_t new_s;
    int32_t max_factorizations;
    int32_t taylor_max_degree;
    float initial_multiplier;
    float lower;
    float upper;
    float stop_normal;
    bool use_initial_multiplier;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sbls_control_type_s sbls_control;
    struct sls_control_type_s sls_control;
    struct ir_control_type_s ir_control;
};

struct llsr_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t new_a;
    int64_t new_s;
    int64_t max_factorizations;
    int64_t taylor_max_degree;
    float initial_multiplier;
    float lower;
    float upper;
    float stop_normal;
    bool use_initial_multiplier;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sbls_control_type_s_64 sbls_control;
    struct sls_control_type_s_64 sls_control;
    struct ir_control_type_s_64 ir_control;
};

struct llsr_time_type_s {
    float total;
    float assemble;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_assemble;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct llsr_history_type_s {
    float lambda;
    float x_norm;
    float r_norm;
};

struct llsr_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    int32_t factorizations;
    int32_t len_history;
    float r_norm;
    float x_norm;
    float multiplier;
    char bad_alloc[81];
    struct llsr_time_type_s time;
    struct llsr_history_type_s history[100];
    struct sbls_inform_type_s sbls_inform;
    struct sls_inform_type_s sls_inform;
    struct ir_inform_type_s ir_inform;
};

struct llsr_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorizations;
    int64_t len_history;
    float r_norm;
    float x_norm;
    float multiplier;
    char bad_alloc[81];
    struct llsr_time_type_s time;
    struct llsr_history_type_s history[100];
    struct sbls_inform_type_s_64 sbls_inform;
    struct sls_inform_type_s_64 sls_inform;
    struct ir_inform_type_s_64 ir_inform;
};

void llsr_initialize_s(void **data, struct llsr_control_type_s *control, int32_t *status);
void llsr_initialize_s_64(void **data, struct llsr_control_type_s_64 *control, int64_t *status);
void llsr_read_specfile_s(struct llsr_control_type_s *control, char *specfile);
void llsr_read_specfile_s_64(struct llsr_control_type_s_64 *control, char *specfile);
void llsr_import_s(struct llsr_control_type_s *control, void **data, int32_t *status, int32_t m, int32_t n, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void llsr_import_s_64(struct llsr_control_type_s_64 *control, void **data, int64_t *status, int64_t m, int64_t n, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void llsr_import_scaling_s(struct llsr_control_type_s *control, void **data, int32_t *status, int32_t n, char *S_type, int32_t S_ne, int32_t *S_row, int32_t *S_col, int32_t *S_ptr);
void llsr_import_scaling_s_64(struct llsr_control_type_s_64 *control, void **data, int64_t *status, int64_t n, char *S_type, int64_t S_ne, int64_t *S_row, int64_t *S_col, int64_t *S_ptr);
void llsr_reset_control_s(struct llsr_control_type_s *control, void **data, int32_t *status);
void llsr_reset_control_s_64(struct llsr_control_type_s_64 *control, void **data, int64_t *status);
void llsr_solve_problem_s(void **data, int32_t *status, int32_t m, int32_t n, float power, float weight, int32_t A_ne, float *A_val, float *b, float *x, int32_t S_ne, float *S_val);
void llsr_solve_problem_s_64(void **data, int64_t *status, int64_t m, int64_t n, float power, float weight, int64_t A_ne, float *A_val, float *b, float *x, int64_t S_ne, float *S_val);
void llsr_information_s(void **data, struct llsr_inform_type_s *inform, int32_t *status);
void llsr_information_s_64(void **data, struct llsr_inform_type_s_64 *inform, int64_t *status);
void llsr_terminate_s(void **data, struct llsr_control_type_s *control, struct llsr_inform_type_s *inform);
void llsr_terminate_s_64(void **data, struct llsr_control_type_s_64 *control, struct llsr_inform_type_s_64 *inform);

// C interface for LLST
struct llst_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t new_a;
    int32_t new_s;
    int32_t max_factorizations;
    int32_t taylor_max_degree;
    float initial_multiplier;
    float lower;
    float upper;
    float stop_normal;
    bool equality_problem;
    bool use_initial_multiplier;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sbls_control_type_s sbls_control;
    struct sls_control_type_s sls_control;
    struct ir_control_type_s ir_control;
};

struct llst_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t new_a;
    int64_t new_s;
    int64_t max_factorizations;
    int64_t taylor_max_degree;
    float initial_multiplier;
    float lower;
    float upper;
    float stop_normal;
    bool equality_problem;
    bool use_initial_multiplier;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sbls_control_type_s_64 sbls_control;
    struct sls_control_type_s_64 sls_control;
    struct ir_control_type_s_64 ir_control;
};

struct llst_time_type_s {
    float total;
    float assemble;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_assemble;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct llst_history_type_s {
    float lambda;
    float x_norm;
    float r_norm;
};

struct llst_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    int32_t factorizations;
    int32_t len_history;
    float r_norm;
    float x_norm;
    float multiplier;
    char bad_alloc[81];
    struct llst_time_type_s time;
    struct llst_history_type_s history[100];
    struct sbls_inform_type_s sbls_inform;
    struct sls_inform_type_s sls_inform;
    struct ir_inform_type_s ir_inform;
};

struct llst_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorizations;
    int64_t len_history;
    float r_norm;
    float x_norm;
    float multiplier;
    char bad_alloc[81];
    struct llst_time_type_s time;
    struct llst_history_type_s history[100];
    struct sbls_inform_type_s_64 sbls_inform;
    struct sls_inform_type_s_64 sls_inform;
    struct ir_inform_type_s_64 ir_inform;
};

void llst_initialize_s(void **data, struct llst_control_type_s *control, int32_t *status);
void llst_initialize_s_64(void **data, struct llst_control_type_s_64 *control, int64_t *status);
void llst_read_specfile_s(struct llst_control_type_s *control, char *specfile);
void llst_read_specfile_s_64(struct llst_control_type_s_64 *control, char *specfile);
void llst_import_s(struct llst_control_type_s *control, void **data, int32_t *status, int32_t m, int32_t n, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void llst_import_s_64(struct llst_control_type_s_64 *control, void **data, int64_t *status, int64_t m, int64_t n, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void llst_import_scaling_s(struct llst_control_type_s *control, void **data, int32_t *status, int32_t n, char *S_type, int32_t S_ne, int32_t *S_row, int32_t *S_col, int32_t *S_ptr);
void llst_import_scaling_s_64(struct llst_control_type_s_64 *control, void **data, int64_t *status, int64_t n, char *S_type, int64_t S_ne, int64_t *S_row, int64_t *S_col, int64_t *S_ptr);
void llst_reset_control_s(struct llst_control_type_s *control, void **data, int32_t *status);
void llst_reset_control_s_64(struct llst_control_type_s_64 *control, void **data, int64_t *status);
void llst_solve_problem_s(void **data, int32_t *status, int32_t m, int32_t n, float radius, int32_t A_ne, float *A_val, float *b, float *x, int32_t S_ne, float *S_val);
void llst_solve_problem_s_64(void **data, int64_t *status, int64_t m, int64_t n, float radius, int64_t A_ne, float *A_val, float *b, float *x, int64_t S_ne, float *S_val);
void llst_information_s(void **data, struct llst_inform_type_s *inform, int32_t *status);
void llst_information_s_64(void **data, struct llst_inform_type_s_64 *inform, int64_t *status);
void llst_terminate_s(void **data, struct llst_control_type_s *control, struct llst_inform_type_s *inform);
void llst_terminate_s_64(void **data, struct llst_control_type_s_64 *control, struct llst_inform_type_s_64 *inform);

// C interface for BLLSB
struct bllsb_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float prfeas;
    float dufeas;
    float muzero;
    float tau;
    float gamma_c;
    float gamma_f;
    float reduce_infeas;
    float identical_bounds_tol;
    float mu_pounce;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_s fdc_control;
    struct sls_control_type_s sls_control;
    struct sls_control_type_s sls_pounce_control;
    struct fit_control_type fit_control;
    struct roots_control_type_s roots_control;
    struct cro_control_type_s cro_control;
};

struct bllsb_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float prfeas;
    float dufeas;
    float muzero;
    float tau;
    float gamma_c;
    float gamma_f;
    float reduce_infeas;
    float identical_bounds_tol;
    float mu_pounce;
    float indicator_tol_p;
    float indicator_tol_pd;
    float indicator_tol_tapia;
    float cpu_time_limit;
    float clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_s_64 fdc_control;
    struct sls_control_type_s_64 sls_control;
    struct sls_control_type_s_64 sls_pounce_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_s_64 roots_control;
    struct cro_control_type_s_64 cro_control;
};

struct bllsb_time_type_s {
    float total;
    float preprocess;
    float find_dependent;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_preprocess;
    float clock_find_dependent;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct bllsb_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    float non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    float checkpointsTime[16];
    struct bllsb_time_type_s time;
    struct fdc_inform_type_s fdc_inform;
    struct sls_inform_type_s sls_inform;
    struct sls_inform_type_s sls_pounce_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type_s cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct bllsb_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    float non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    float checkpointsTime[16];
    struct bllsb_time_type_s time;
    struct fdc_inform_type_s_64 fdc_inform;
    struct sls_inform_type_s_64 sls_inform;
    struct sls_inform_type_s_64 sls_pounce_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_s_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void bllsb_initialize_s(void **data, struct bllsb_control_type_s *control, int32_t *status);
void bllsb_initialize_s_64(void **data, struct bllsb_control_type_s_64 *control, int64_t *status);
void bllsb_read_specfile_s(struct bllsb_control_type_s *control, char *specfile);
void bllsb_read_specfile_s_64(struct bllsb_control_type_s_64 *control, char *specfile);
void bllsb_import_s(struct bllsb_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t o, char *Ao_type, int32_t Ao_ne, int32_t *Ao_row, int32_t *Ao_col, int32_t Ao_ptr_ne, int32_t *Ao_ptr);
void bllsb_import_s_64(struct bllsb_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t o, char *Ao_type, int64_t Ao_ne, int64_t *Ao_row, int64_t *Ao_col, int64_t Ao_ptr_ne, int64_t *Ao_ptr);
void bllsb_reset_control_s(struct bllsb_control_type_s *control, void **data, int32_t *status);
void bllsb_reset_control_s_64(struct bllsb_control_type_s_64 *control, void **data, int64_t *status);
void bllsb_solve_blls_s(void **data, int32_t *status, int32_t n, int32_t o, int32_t Ao_ne, float *Ao_val, float *b, float regularization_weight, float *x_l, float *x_u, float *x, float *r, float *z, int32_t *x_stat, float *w);
void bllsb_solve_blls_s_64(void **data, int64_t *status, int64_t n, int64_t o, int64_t Ao_ne, float *Ao_val, float *b, float regularization_weight, float *x_l, float *x_u, float *x, float *r, float *z, int64_t *x_stat, float *w);
void bllsb_information_s(void **data, struct bllsb_inform_type_s *inform, int32_t *status);
void bllsb_information_s_64(void **data, struct bllsb_inform_type_s_64 *inform, int64_t *status);
void bllsb_terminate_s(void **data, struct bllsb_control_type_s *control, struct bllsb_inform_type_s *inform);
void bllsb_terminate_s_64(void **data, struct bllsb_control_type_s_64 *control, struct bllsb_inform_type_s_64 *inform);

// C interface for SSLS
struct ssls_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s sls_control;
};

struct ssls_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_s_64 sls_control;
};

struct ssls_time_type_s {
    float total;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct ssls_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t rank;
    bool rank_def;
    struct ssls_time_type_s time;
    struct sls_inform_type_s sls_inform;
};

struct ssls_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t rank;
    bool rank_def;
    struct ssls_time_type_s time;
    struct sls_inform_type_s_64 sls_inform;
};

void ssls_initialize_s(void **data, struct ssls_control_type_s *control, int32_t *status);
void ssls_initialize_s_64(void **data, struct ssls_control_type_s_64 *control, int64_t *status);
void ssls_read_specfile_s(struct ssls_control_type_s *control, char *specfile);
void ssls_read_specfile_s_64(struct ssls_control_type_s_64 *control, char *specfile);
void ssls_import_s(struct ssls_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr, char *C_type, int32_t C_ne, int32_t *C_row, int32_t *C_col, int32_t *C_ptr);
void ssls_import_s_64(struct ssls_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr, char *C_type, int64_t C_ne, int64_t *C_row, int64_t *C_col, int64_t *C_ptr);
void ssls_reset_control_s(struct ssls_control_type_s *control, void **data, int32_t *status);
void ssls_reset_control_s_64(struct ssls_control_type_s_64 *control, void **data, int64_t *status);
void ssls_factorize_matrix_s(void **data, int32_t *status, int32_t h_ne, float *H_val, int32_t a_ne, float *A_val, int32_t c_ne, float *C_val);
void ssls_factorize_matrix_s_64(void **data, int64_t *status, int64_t h_ne, float *H_val, int64_t a_ne, float *A_val, int64_t c_ne, float *C_val);
void ssls_solve_system_s(void **data, int32_t *status, int32_t n, int32_t m, float *sol);
void ssls_solve_system_s_64(void **data, int64_t *status, int64_t n, int64_t m, float *sol);
void ssls_information_s(void **data, struct ssls_inform_type_s *inform, int32_t *status);
void ssls_information_s_64(void **data, struct ssls_inform_type_s_64 *inform, int64_t *status);
void ssls_terminate_s(void **data, struct ssls_control_type_s *control, struct ssls_inform_type_s *inform);
void ssls_terminate_s_64(void **data, struct ssls_control_type_s_64 *control, struct ssls_inform_type_s_64 *inform);

// C interface for EXPO
struct expo_control_type_s {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t max_it;
    int32_t max_eval;
    int32_t alive_unit;
    char alive_file[31];
    int32_t update_multipliers_itmin;
    float update_multipliers_tol;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float stop_s;
    float initial_mu;
    float mu_reduce;
    float obj_unbounded;
    float try_advanced_start;
    float try_sqp_start;
    float stop_advanced_start;
    float cpu_time_limit;
    float clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct bsc_control_type bsc_control;
    struct tru_control_type_s tru_control;
    struct ssls_control_type_s ssls_control;
};

struct expo_control_type_s_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t max_it;
    int64_t max_eval;
    int64_t alive_unit;
    char alive_file[31];
    int64_t update_multipliers_itmin;
    float update_multipliers_tol;
    float infinity;
    float stop_abs_p;
    float stop_rel_p;
    float stop_abs_d;
    float stop_rel_d;
    float stop_abs_c;
    float stop_rel_c;
    float stop_s;
    float initial_mu;
    float mu_reduce;
    float obj_unbounded;
    float try_advanced_start;
    float try_sqp_start;
    float stop_advanced_start;
    float cpu_time_limit;
    float clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct bsc_control_type_64 bsc_control;
    struct tru_control_type_s_64 tru_control;
    struct ssls_control_type_s_64 ssls_control;
};

struct expo_time_type_s {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    float clock_total;
    float clock_preprocess;
    float clock_analyse;
    float clock_factorize;
    float clock_solve;
};

struct expo_inform_type_s {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int32_t iter;
    int32_t fc_eval;
    int32_t gj_eval;
    int32_t hl_eval;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    struct expo_time_type_s time;
    struct bsc_inform_type_s bsc_inform;
    struct tru_inform_type_s tru_inform;
    struct ssls_inform_type_s ssls_inform;
};

struct expo_inform_type_s_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int64_t iter;
    int64_t fc_eval;
    int64_t gj_eval;
    int64_t hl_eval;
    float obj;
    float primal_infeasibility;
    float dual_infeasibility;
    float complementary_slackness;
    struct expo_time_type_s time;
    struct bsc_inform_type_s_64 bsc_inform;
    struct tru_inform_type_s_64 tru_inform;
    struct ssls_inform_type_s_64 ssls_inform;
};

void expo_initialize_s(void **data, struct expo_control_type_s *control, struct expo_inform_type_s *inform);
void expo_initialize_s_64(void **data, struct expo_control_type_s_64 *control, struct expo_inform_type_s_64 *inform);
void expo_read_specfile_s(struct expo_control_type_s *control, char *specfile);
void expo_read_specfile_s_64(struct expo_control_type_s_64 *control, char *specfile);
void expo_import_s(struct expo_control_type_s *control, void **data, int32_t *status, int32_t n, int32_t m, char *J_type, int32_t J_ne, int32_t *J_row, int32_t *J_col, int32_t *J_ptr, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void expo_import_s_64(struct expo_control_type_s_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *J_type, int64_t J_ne, int64_t *J_row, int64_t *J_col, int64_t *J_ptr, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void expo_reset_control_s(struct expo_control_type_s *control, void **data, int32_t *status);
void expo_reset_control_s_64(struct expo_control_type_s_64 *control, void **data, int64_t *status);
void expo_solve_hessian_direct_s(void **data, void *userdata, int32_t *status, int32_t n, int32_t m, int32_t J_ne, int32_t H_ne, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *y, float *z, float *c, float *gl, galahad_fc_s *eval_fc, galahad_gj_s *eval_gj, galahad_hl_s *eval_hl);
void expo_solve_hessian_direct_s_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t m, int64_t J_ne, int64_t H_ne, float *c_l, float *c_u, float *x_l, float *x_u, float *x, float *y, float *z, float *c, float *gl, galahad_fc_s_64 *eval_fc, galahad_gj_s_64 *eval_gj, galahad_hl_s_64 *eval_hl);
void expo_information_s(void **data, struct expo_inform_type_s *inform, int32_t *status);
void expo_information_s_64(void **data, struct expo_inform_type_s_64 *inform, int64_t *status);
void expo_terminate_s(void **data, struct expo_control_type_s *control, struct expo_inform_type_s *inform);
void expo_terminate_s_64(void **data, struct expo_control_type_s_64 *control, struct expo_inform_type_s_64 *inform);

// end include guard
#endif

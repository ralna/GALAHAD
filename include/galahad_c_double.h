// include guard
#ifndef GALAHAD_C_DOUBLE_H
#define GALAHAD_C_DOUBLE_H

// Callbacks
typedef int32_t galahad_f(int32_t n, const double x[], double *f, const void *userdata);
typedef int32_t galahad_g(int32_t n, const double x[], double g[], const void *userdata);
typedef int32_t galahad_h(int32_t n, int32_t ne, const double x[], double h[], const void *userdata);
typedef int32_t galahad_prec(int32_t n, const double x[], double u[], const double v[], const void *userdata);
typedef int32_t galahad_hprod(int32_t n, const double x[], double u[], const double v[], bool got_h, const void *userdata);
typedef int32_t galahad_shprod(int32_t n, const double x[], int32_t nnz_v, const int32_t index_nz_v[], const double v[], int32_t *nnz_u, int32_t index_nz_u[], double u[], bool got_h, const void *userdata);
typedef int32_t galahad_constant_prec(int32_t n, const double v[], double p[], const void *userdata);
typedef int32_t galahad_r(int32_t n, int32_t m, const double x[], double r[], const void *userdata);
typedef int32_t galahad_jr(int32_t n, int32_t m, int32_t jne, const double x[], double jr[], const void *userdata);
typedef int32_t galahad_hr(int32_t n, int32_t m, int32_t hne, const double x[], const double y[], double hr[], const void *userdata);
typedef int32_t galahad_jrprod(int32_t n, int32_t m, const double x[], const bool transpose, double u[], const double v[], bool got_j, const void *userdata);
typedef int32_t galahad_hrprod(int32_t n, int32_t m, const double x[], const double y[], double u[], const double v[], bool got_h, const void *userdata);
typedef int32_t galahad_shrprod(int32_t n, int32_t m, int32_t pne, const double x[], const double v[], double pval[], bool got_h, const void *userdata);
typedef int32_t galahad_fc(int32_t n, int32_t m, const double x[], double *f, double c[], const void *userdata);
typedef int32_t galahad_gj(int32_t n, int32_t m, int32_t jne, const double x[], double g[], double j[], const void *userdata);
typedef int32_t galahad_hl(int32_t n, int32_t m, int32_t hne, const double x[], const double y[], double h[], const void *userdata);
typedef int32_t galahad_fgh(double x, double *f, double *g, double *h, const void *userdata);

typedef int64_t galahad_f_64(int64_t n, const double x[], double *f, const void *userdata);
typedef int64_t galahad_g_64(int64_t n, const double x[], double g[], const void *userdata);
typedef int64_t galahad_h_64(int64_t n, int64_t ne, const double x[], double h[], const void *userdata);
typedef int64_t galahad_prec_64(int64_t n, const double x[], double u[], const double v[], const void *userdata);
typedef int64_t galahad_hprod_64(int64_t n, const double x[], double u[], const double v[], bool got_h, const void *userdata);
typedef int64_t galahad_shprod_64(int64_t n, const double x[], int64_t nnz_v, const int64_t index_nz_v[], const double v[], int64_t *nnz_u, int64_t index_nz_u[], double u[], bool got_h, const void *userdata);
typedef int64_t galahad_constant_prec_64(int64_t n, const double v[], double p[], const void *userdata);
typedef int64_t galahad_r_64(int64_t n, int64_t m, const double x[], double r[], const void *userdata);
typedef int64_t galahad_jr_64(int64_t n, int64_t m, int64_t jne, const double x[], double jr[], const void *userdata);
typedef int64_t galahad_hr_64(int64_t n, int64_t m, int64_t hne, const double x[], const double y[], double hr[], const void *userdata);
typedef int64_t galahad_jrprod_64(int64_t n, int64_t m, const double x[], const bool transpose, double u[], const double v[], bool got_j, const void *userdata);
typedef int64_t galahad_hrprod_64(int64_t n, int64_t m, const double x[], const double y[], double u[], const double v[], bool got_h, const void *userdata);
typedef int64_t galahad_shrprod_64(int64_t n, int64_t m, int64_t pne, const double x[], const double v[], double pval[], bool got_h, const void *userdata);
typedef int64_t galahad_fc_64(int64_t n, int64_t m, const double x[], double *f, double c[], const void *userdata);
typedef int64_t galahad_gj_64(int64_t n, int64_t m, int64_t jne, const double x[], double g[], double j[], const void *userdata);
typedef int64_t galahad_hl_64(int64_t n, int64_t m, int64_t hne, const double x[], const double y[], double h[], const void *userdata);
typedef int64_t galahad_fgh_64(double x, double *f, double *g, double *h, const void *userdata);

// C interface for BSC
struct bsc_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t max_col_a;
    int32_t exceeds_max_col;
    double time;
    double clock_time;
};

struct bsc_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t max_col_a;
    int64_t exceeds_max_col;
    double time;
    double clock_time;
};

void bsc_initialize(void **data, struct bsc_control_type *control, int32_t *status);
void bsc_initialize_64(void **data, struct bsc_control_type_64 *control, int64_t *status);
void bsc_import(struct bsc_control_type *control, void **data, int32_t *status, int32_t m, int32_t n, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr, int32_t *S_ne);
void bsc_import_64(struct bsc_control_type_64 *control, void **data, int64_t *status, int64_t m, int64_t n, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr, int64_t *S_ne);
void bsc_reset_control(struct bsc_control_type *control, void **data, int32_t *status);
void bsc_reset_control_64(struct bsc_control_type_64 *control, void **data, int64_t *status);
void bsc_form_s(void **data, int32_t *status, int32_t m, int32_t n, int32_t a_ne, double *A_val, int32_t s_ne, int32_t *S_row, int32_t *S_col, int32_t *S_ptr, double *S_val, double *D);
void bsc_form_s_64(void **data, int64_t *status, int64_t m, int64_t n, int64_t a_ne, double *A_val, int64_t s_ne, int64_t *S_row, int64_t *S_col, int64_t *S_ptr, double *S_val, double *D);
void bsc_information(void **data, struct bsc_inform_type *inform, int32_t *status);
void bsc_information_64(void **data, struct bsc_inform_type_64 *inform, int64_t *status);
void bsc_terminate(void **data, struct bsc_control_type *control, struct bsc_inform_type *inform);
void bsc_terminate_64(void **data, struct bsc_control_type_64 *control, struct bsc_inform_type_64 *inform);

// C interface for CONVERT
struct convert_time_type {
    double total;
    double clock_total;
};

struct convert_inform_type {
    int32_t status;
    int32_t alloc_status;
    int32_t duplicates;
    char bad_alloc[81];
    struct convert_time_type time;
};

struct convert_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t duplicates;
    char bad_alloc[81];
    struct convert_time_type time;
};

void convert_initialize(void **data, struct convert_control_type *control, int32_t *status);
void convert_initialize_64(void **data, struct convert_control_type_64 *control, int64_t *status);
void convert_information(void **data, struct convert_inform_type *inform, int32_t *status);
void convert_information_64(void **data, struct convert_inform_type_64 *inform, int64_t *status);
void convert_terminate(void **data, struct convert_control_type *control, struct convert_inform_type *inform);
void convert_terminate_64(void **data, struct convert_control_type_64 *control, struct convert_inform_type_64 *inform);

// C interface for FIT
void fit_initialize(void **data, struct fit_control_type *control, int32_t *status);
void fit_initialize_64(void **data, struct fit_control_type_64 *control, int64_t *status);
void fit_information(void **data, struct fit_inform_type *inform, int32_t *status);
void fit_information_64(void **data, struct fit_inform_type_64 *inform, int64_t *status);
void fit_terminate(void **data, struct fit_control_type *control, struct fit_inform_type *inform);
void fit_terminate_64(void **data, struct fit_control_type_64 *control, struct fit_inform_type_64 *inform);

// C interface for GLRT
struct glrt_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t itmax;
    int32_t stopping_rule;
    int32_t freq;
    int32_t extra_vectors;
    int32_t ritz_printout_device;
    double stop_relative;
    double stop_absolute;
    double fraction_opt;
    double rminvr_zero;
    double f_0;
    bool unitm;
    bool impose_descent;
    bool space_critical;
    bool deallocate_error_fatal;
    bool print_ritz_values;
    char ritz_file_name[31];
    char prefix[31];
};

struct glrt_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t itmax;
    int64_t stopping_rule;
    int64_t freq;
    int64_t extra_vectors;
    int64_t ritz_printout_device;
    double stop_relative;
    double stop_absolute;
    double fraction_opt;
    double rminvr_zero;
    double f_0;
    bool unitm;
    bool impose_descent;
    bool space_critical;
    bool deallocate_error_fatal;
    bool print_ritz_values;
    char ritz_file_name[31];
    char prefix[31];
};

struct glrt_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    double obj;
    double obj_regularized;
    double multiplier;
    double xpo_norm;
    double leftmost;
    bool negative_curvature;
    bool hard_case;
};

struct glrt_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    double obj;
    double obj_regularized;
    double multiplier;
    double xpo_norm;
    double leftmost;
    bool negative_curvature;
    bool hard_case;
};

void glrt_initialize(void **data, struct glrt_control_type *control, int32_t *status);
void glrt_initialize_64(void **data, struct glrt_control_type_64 *control, int64_t *status);
void glrt_read_specfile(struct glrt_control_type *control, char *specfile);
void glrt_read_specfile_64(struct glrt_control_type_64 *control, char *specfile);
void glrt_import_control(struct glrt_control_type *control, void **data, int32_t *status);
void glrt_import_control_64(struct glrt_control_type_64 *control, void **data, int64_t *status);
void glrt_solve_problem(void **data, int32_t *status, int32_t n, double power, double weight, double *x, double *r, double *vector);
void glrt_solve_problem_64(void **data, int64_t *status, int64_t n, double power, double weight, double *x, double *r, double *vector);
void glrt_information(void **data, struct glrt_inform_type *inform, int32_t *status);
void glrt_information_64(void **data, struct glrt_inform_type_64 *inform, int64_t *status);
void glrt_terminate(void **data, struct glrt_control_type *control, struct glrt_inform_type *inform);
void glrt_terminate_64(void **data, struct glrt_control_type_64 *control, struct glrt_inform_type_64 *inform);

// C interface for GLS
struct gls_control_type {
    bool f_indexing;
    int32_t lp;
    int32_t wp;
    int32_t mp;
    int32_t ldiag;
    int32_t btf;
    int32_t maxit;
    int32_t factor_blocking;
    int32_t solve_blas;
    int32_t la;
    int32_t la_int;
    int32_t maxla;
    int32_t pivoting;
    int32_t fill_in;
    double multiplier;
    double reduce;
    double u;
    double switch_full;
    double drop;
    double tolerance;
    double cgce;
    bool diagonal_pivoting;
    bool struct_abort;
};

struct gls_control_type_64 {
    bool f_indexing;
    int64_t lp;
    int64_t wp;
    int64_t mp;
    int64_t ldiag;
    int64_t btf;
    int64_t maxit;
    int64_t factor_blocking;
    int64_t solve_blas;
    int64_t la;
    int64_t la_int;
    int64_t maxla;
    int64_t pivoting;
    int64_t fill_in;
    double multiplier;
    double reduce;
    double u;
    double switch_full;
    double drop;
    double tolerance;
    double cgce;
    bool diagonal_pivoting;
    bool struct_abort;
};

struct gls_ainfo_type {
    int32_t flag;
    int32_t more;
    int32_t len_analyse;
    int32_t len_factorize;
    int32_t ncmpa;
    int32_t rank;
    int32_t drop;
    int32_t struc_rank;
    int32_t oor;
    int32_t dup;
    int32_t stat;
    int32_t lblock;
    int32_t sblock;
    int32_t tblock;
    double ops;
};

struct gls_ainfo_type_64 {
    int64_t flag;
    int64_t more;
    int64_t len_analyse;
    int64_t len_factorize;
    int64_t ncmpa;
    int64_t rank;
    int64_t drop;
    int64_t struc_rank;
    int64_t oor;
    int64_t dup;
    int64_t stat;
    int64_t lblock;
    int64_t sblock;
    int64_t tblock;
    double ops;
};

struct gls_finfo_type {
    int32_t flag;
    int32_t more;
    int32_t size_factor;
    int32_t len_factorize;
    int32_t drop;
    int32_t rank;
    int32_t stat;
    double ops;
};

struct gls_finfo_type_64 {
    int64_t flag;
    int64_t more;
    int64_t size_factor;
    int64_t len_factorize;
    int64_t drop;
    int64_t rank;
    int64_t stat;
    double ops;
};

void gls_initialize(void **data, struct gls_control_type *control);
void gls_initialize_64(void **data, struct gls_control_type_64 *control);
void gls_read_specfile(struct gls_control_type *control, char *specfile);
void gls_read_specfile_64(struct gls_control_type_64 *control, char *specfile);
void gls_import(struct gls_control_type *control, void **data, int32_t *status);
void gls_import_64(struct gls_control_type_64 *control, void **data, int64_t *status);
void gls_reset_control(struct gls_control_type *control, void **data, int32_t *status);
void gls_reset_control_64(struct gls_control_type_64 *control, void **data, int64_t *status);
void gls_information(void **data, struct gls_ainfo_type *ainfo, struct gls_finfo_type *finfo, struct gls_sinfo_type *sinfo, int32_t *status);
void gls_information_64(void **data, struct gls_ainfo_type_64 *ainfo, struct gls_finfo_type_64 *finfo, struct gls_sinfo_type_64 *sinfo, int64_t *status);
void gls_finalize(void **data, struct gls_control_type *control, int32_t *status);
void gls_finalize_64(void **data, struct gls_control_type_64 *control, int64_t *status);

// C interface for GLTR
struct gltr_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t itmax;
    int32_t Lanczos_itmax;
    int32_t extra_vectors;
    int32_t ritz_printout_device;
    double stop_relative;
    double stop_absolute;
    double fraction_opt;
    double f_min;
    double rminvr_zero;
    double f_0;
    bool unitm;
    bool steihaug_toint;
    bool boundary;
    bool equality_problem;
    bool space_critical;
    bool deallocate_error_fatal;
    bool print_ritz_values;
    char ritz_file_name[31];
    char prefix[31];
};

struct gltr_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t itmax;
    int64_t Lanczos_itmax;
    int64_t extra_vectors;
    int64_t ritz_printout_device;
    double stop_relative;
    double stop_absolute;
    double fraction_opt;
    double f_min;
    double rminvr_zero;
    double f_0;
    bool unitm;
    bool steihaug_toint;
    bool boundary;
    bool equality_problem;
    bool space_critical;
    bool deallocate_error_fatal;
    bool print_ritz_values;
    char ritz_file_name[31];
    char prefix[31];
};

struct gltr_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    double obj;
    double multiplier;
    double mnormx;
    double piv;
    double curv;
    double rayleigh;
    double leftmost;
    bool negative_curvature;
    bool hard_case;
};

struct gltr_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    double obj;
    double multiplier;
    double mnormx;
    double piv;
    double curv;
    double rayleigh;
    double leftmost;
    bool negative_curvature;
    bool hard_case;
};

void gltr_initialize(void **data, struct gltr_control_type *control, int32_t *status);
void gltr_initialize_64(void **data, struct gltr_control_type_64 *control, int64_t *status);
void gltr_read_specfile(struct gltr_control_type *control, char *specfile);
void gltr_read_specfile_64(struct gltr_control_type_64 *control, char *specfile);
void gltr_import_control(struct gltr_control_type *control, void **data, int32_t *status);
void gltr_import_control_64(struct gltr_control_type_64 *control, void **data, int64_t *status);
void gltr_solve_problem(void **data, int32_t *status, int32_t n, double radius, double *x, double *r, double *vector);
void gltr_solve_problem_64(void **data, int64_t *status, int64_t n, double radius, double *x, double *r, double *vector);
void gltr_information(void **data, struct gltr_inform_type *inform, int32_t *status);
void gltr_information_64(void **data, struct gltr_inform_type_64 *inform, int64_t *status);
void gltr_terminate(void **data, struct gltr_control_type *control, struct gltr_inform_type *inform);
void gltr_terminate_64(void **data, struct gltr_control_type_64 *control, struct gltr_inform_type_64 *inform);

// C interface for HASH
void hash_initialize(int32_t nchar, int32_t length, void **data, struct hash_control_type *control, struct hash_inform_type *inform);
void hash_initialize_64(int64_t nchar, int64_t length, void **data, struct hash_control_type_64 *control, struct hash_inform_type_64 *inform);
void hash_information(void **data, struct hash_inform_type *inform, int32_t *status);
void hash_information_64(void **data, struct hash_inform_type_64 *inform, int64_t *status);
void hash_terminate(void **data, struct hash_control_type *control, struct hash_inform_type *inform);
void hash_terminate_64(void **data, struct hash_control_type_64 *control, struct hash_inform_type_64 *inform);

// C interface for HSL
struct ma48_control {
    int32_t f_arrays;
    double multiplier;
    double u;
    double switch_;
    double drop;
    double tolerance;
    double cgce;
    int32_t lp;
    int32_t wp;
    int32_t mp;
    int32_t ldiag;
    int32_t btf;
    int32_t struct_;
    int32_t maxit;
    int32_t factor_blocking;
    int32_t solve_blas;
    int32_t pivoting;
    int32_t diagonal_pivoting;
    int32_t fill_in;
    int32_t switch_mode;
};

struct ma48_control_64 {
    int64_t f_arrays;
    double multiplier;
    double u;
    double switch_;
    double drop;
    double tolerance;
    double cgce;
    int64_t lp;
    int64_t wp;
    int64_t mp;
    int64_t ldiag;
    int64_t btf;
    int64_t struct_;
    int64_t maxit;
    int64_t factor_blocking;
    int64_t solve_blas;
    int64_t pivoting;
    int64_t diagonal_pivoting;
    int64_t fill_in;
    int64_t switch_mode;
};

struct ma48_ainfo {
    double ops;
    int32_t flag;
    int32_t more;
    int64_t lena_analyse;
    int64_t lenj_analyse;
    int64_t lena_factorize;
    int64_t leni_factorize;
    int32_t ncmpa;
    int32_t rank;
    int64_t drop;
    int32_t struc_rank;
    int64_t oor;
    int64_t dup;
    int32_t stat;
    int32_t lblock;
    int32_t sblock;
    int64_t tblock;
};

struct ma48_ainfo_64 {
    double ops;
    int64_t flag;
    int64_t more;
    int64_t lena_analyse;
    int64_t lenj_analyse;
    int64_t lena_factorize;
    int64_t leni_factorize;
    int64_t ncmpa;
    int64_t rank;
    int64_t drop;
    int64_t struc_rank;
    int64_t oor;
    int64_t dup;
    int64_t stat;
    int64_t lblock;
    int64_t sblock;
    int64_t tblock;
};

struct ma48_finfo {
    double ops;
    int32_t flag;
    int32_t more;
    int64_t size_factor;
    int64_t lena_factorize;
    int64_t leni_factorize;
    int64_t drop;
    int32_t rank;
    int32_t stat;
};

struct ma48_finfo_64 {
    double ops;
    int64_t flag;
    int64_t more;
    int64_t size_factor;
    int64_t lena_factorize;
    int64_t leni_factorize;
    int64_t drop;
    int64_t rank;
    int64_t stat;
};

struct ma57_control {
    int32_t f_arrays;
    double multiplier;
    double reduce;
    double u;
    double static_tolerance;
    double static_level;
    double tolerance;
    double convergence;
    double consist;
    int32_t lp;
    int32_t wp;
    int32_t mp;
    int32_t sp;
    int32_t ldiag;
    int32_t nemin;
    int32_t factorblocking;
    int32_t solveblocking;
    int32_t la;
    int32_t liw;
    int32_t maxla;
    int32_t maxliw;
    int32_t pivoting;
    int32_t thresh;
    int32_t ordering;
    int32_t scaling;
    int32_t rank_deficient;
    int32_t ispare[5];
    double rspare[10];
};

struct ma57_control_64 {
    int64_t f_arrays;
    double multiplier;
    double reduce;
    double u;
    double static_tolerance;
    double static_level;
    double tolerance;
    double convergence;
    double consist;
    int64_t lp;
    int64_t wp;
    int64_t mp;
    int64_t sp;
    int64_t ldiag;
    int64_t nemin;
    int64_t factorblocking;
    int64_t solveblocking;
    int64_t la;
    int64_t liw;
    int64_t maxla;
    int64_t maxliw;
    int64_t pivoting;
    int64_t thresh;
    int64_t ordering;
    int64_t scaling;
    int64_t rank_deficient;
    int64_t ispare[5];
    double rspare[10];
};

struct ma57_ainfo {
    double opsa;
    double opse;
    int32_t flag;
    int32_t more;
    int32_t nsteps;
    int32_t nrltot;
    int32_t nirtot;
    int32_t nrlnec;
    int32_t nirnec;
    int32_t nrladu;
    int32_t niradu;
    int32_t ncmpa;
    int32_t ordering;
    int32_t oor;
    int32_t dup;
    int32_t maxfrt;
    int32_t stat;
    int32_t ispare[5];
    double rspare[10];
};

struct ma57_ainfo_64 {
    double opsa;
    double opse;
    int64_t flag;
    int64_t more;
    int64_t nsteps;
    int64_t nrltot;
    int64_t nirtot;
    int64_t nrlnec;
    int64_t nirnec;
    int64_t nrladu;
    int64_t niradu;
    int64_t ncmpa;
    int64_t ordering;
    int64_t oor;
    int64_t dup;
    int64_t maxfrt;
    int64_t stat;
    int64_t ispare[5];
    double rspare[10];
};

struct ma57_finfo {
    double opsa;
    double opse;
    double opsb;
    double maxchange;
    double smin;
    double smax;
    int32_t flag;
    int32_t more;
    int32_t maxfrt;
    int32_t nebdu;
    int32_t nrlbdu;
    int32_t nirbdu;
    int32_t nrltot;
    int32_t nirtot;
    int32_t nrlnec;
    int32_t nirnec;
    int32_t ncmpbr;
    int32_t ncmpbi;
    int32_t ntwo;
    int32_t neig;
    int32_t delay;
    int32_t signc;
    int32_t static_;
    int32_t modstep;
    int32_t rank;
    int32_t stat;
    int32_t ispare[5];
    double rspare[10];
};

struct ma57_finfo_64 {
    double opsa;
    double opse;
    double opsb;
    double maxchange;
    double smin;
    double smax;
    int64_t flag;
    int64_t more;
    int64_t maxfrt;
    int64_t nebdu;
    int64_t nrlbdu;
    int64_t nirbdu;
    int64_t nrltot;
    int64_t nirtot;
    int64_t nrlnec;
    int64_t nirnec;
    int64_t ncmpbr;
    int64_t ncmpbi;
    int64_t ntwo;
    int64_t neig;
    int64_t delay;
    int64_t signc;
    int64_t static_;
    int64_t modstep;
    int64_t rank;
    int64_t stat;
    int64_t ispare[5];
    double rspare[10];
};

struct ma57_sinfo {
    double cond;
    double cond2;
    double berr;
    double berr2;
    double error;
    int32_t flag;
    int32_t stat;
    int32_t ispare[5];
    double rspare[10];
};

struct ma57_sinfo_64 {
    double cond;
    double cond2;
    double berr;
    double berr2;
    double error;
    int64_t flag;
    int64_t stat;
    int64_t ispare[5];
    double rspare[10];
};

struct ma77_control {
    int32_t f_arrays;
    int32_t print_level;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int32_t bits;
    int32_t buffer_lpage[2];
    int32_t buffer_npage[2];
    int64_t file_size;
    int64_t maxstore;
    int64_t storage[3];
    int32_t nemin;
    int32_t maxit;
    int32_t infnorm;
    double thresh;
    int32_t nb54;
    int32_t action;
    double multiplier;
    int32_t nb64;
    int32_t nbi;
    double small;
    double static_;
    int64_t storage_indef;
    double u;
    double umin;
    double consist_tol;
    int32_t ispare[5];
    int64_t lspare[5];
    double rspare[5];
};

struct ma77_control_64 {
    int64_t f_arrays;
    int64_t print_level;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t bits;
    int64_t buffer_lpage[2];
    int64_t buffer_npage[2];
    int64_t file_size;
    int64_t maxstore;
    int64_t storage[3];
    int64_t nemin;
    int64_t maxit;
    int64_t infnorm;
    double thresh;
    int64_t nb54;
    int64_t action;
    double multiplier;
    int64_t nb64;
    int64_t nbi;
    double small;
    double static_;
    int64_t storage_indef;
    double u;
    double umin;
    double consist_tol;
    int64_t ispare[5];
    int64_t lspare[5];
    double rspare[5];
};

struct ma77_info {
    double detlog;
    int32_t detsign;
    int32_t flag;
    int32_t iostat;
    int32_t matrix_dup;
    int32_t matrix_rank;
    int32_t matrix_outrange;
    int32_t maxdepth;
    int32_t maxfront;
    int64_t minstore;
    int32_t ndelay;
    int64_t nfactor;
    int64_t nflops;
    int32_t niter;
    int32_t nsup;
    int32_t num_neg;
    int32_t num_nothresh;
    int32_t num_perturbed;
    int32_t ntwo;
    int32_t stat;
    int32_t index[4];
    int64_t nio_read[2];
    int64_t nio_write[2];
    int64_t nwd_read[2];
    int64_t nwd_write[2];
    int32_t num_file[4];
    int64_t storage[4];
    int32_t tree_nodes;
    int32_t unit_restart;
    int32_t unused;
    double usmall;
    int32_t ispare[5];
    int64_t lspare[5];
    double rspare[5];
};

struct ma77_info_64 {
    double detlog;
    int64_t detsign;
    int64_t flag;
    int64_t iostat;
    int64_t matrix_dup;
    int64_t matrix_rank;
    int64_t matrix_outrange;
    int64_t maxdepth;
    int64_t maxfront;
    int64_t minstore;
    int64_t ndelay;
    int64_t nfactor;
    int64_t nflops;
    int64_t niter;
    int64_t nsup;
    int64_t num_neg;
    int64_t num_nothresh;
    int64_t num_perturbed;
    int64_t ntwo;
    int64_t stat;
    int64_t index[4];
    int64_t nio_read[2];
    int64_t nio_write[2];
    int64_t nwd_read[2];
    int64_t nwd_write[2];
    int64_t num_file[4];
    int64_t storage[4];
    int64_t tree_nodes;
    int64_t unit_restart;
    int64_t unused;
    double usmall;
    int64_t ispare[5];
    int64_t lspare[5];
    double rspare[5];
};

struct ma86_control {
    int32_t f_arrays;
    int32_t diagnostics_level;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int32_t nemin;
    int32_t nb;
    int32_t action;
    int32_t nbi;
    int32_t pool_size;
    double small_;
    double static_;
    double u;
    double umin;
    int32_t scaling;
};

struct ma86_control_64 {
    int64_t f_arrays;
    int64_t diagnostics_level;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t nemin;
    int64_t nb;
    int64_t action;
    int64_t nbi;
    int64_t pool_size;
    double small_;
    double static_;
    double u;
    double umin;
    int64_t scaling;
};

struct ma86_info {
    double detlog;
    int32_t detsign;
    int32_t flag;
    int32_t matrix_rank;
    int32_t maxdepth;
    int32_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int32_t num_neg;
    int32_t num_nodes;
    int32_t num_nothresh;
    int32_t num_perturbed;
    int32_t num_two;
    int32_t pool_size;
    int32_t stat;
    double usmall;
};

struct ma86_info_64 {
    double detlog;
    int64_t detsign;
    int64_t flag;
    int64_t matrix_rank;
    int64_t maxdepth;
    int64_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int64_t num_neg;
    int64_t num_nodes;
    int64_t num_nothresh;
    int64_t num_perturbed;
    int64_t num_two;
    int64_t pool_size;
    int64_t stat;
    double usmall;
};

struct ma87_control {
    int32_t f_arrays;
    int32_t diagnostics_level;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int32_t nemin;
    int32_t nb;
    int32_t pool_size;
    double diag_zero_minus;
    double diag_zero_plus;
    char unused[40];
};

struct ma87_control_64 {
    int64_t f_arrays;
    int64_t diagnostics_level;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t nemin;
    int64_t nb;
    int64_t pool_size;
    double diag_zero_minus;
    double diag_zero_plus;
    char unused[40];
};

struct ma87_info {
    double detlog;
    int32_t flag;
    int32_t maxdepth;
    int64_t num_factor;
    int64_t num_flops;
    int32_t num_nodes;
    int32_t pool_size;
    int32_t stat;
    int32_t num_zero;
    char unused[40];
};

struct ma87_info_64 {
    double detlog;
    int64_t flag;
    int64_t maxdepth;
    int64_t num_factor;
    int64_t num_flops;
    int64_t num_nodes;
    int64_t pool_size;
    int64_t stat;
    int64_t num_zero;
    char unused[40];
};

struct ma97_control {
    int32_t f_arrays;
    int32_t action;
    int32_t nemin;
    double multiplier;
    int32_t ordering;
    int32_t print_level;
    int32_t scaling;
    double small;
    double u;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int64_t factor_min;
    int32_t solve_blas3;
    int64_t solve_min;
    int32_t solve_mf;
    double consist_tol;
    int32_t ispare[5];
    double rspare[10];
};

struct ma97_control_64 {
    int64_t f_arrays;
    int64_t action;
    int64_t nemin;
    double multiplier;
    int64_t ordering;
    int64_t print_level;
    int64_t scaling;
    double small;
    double u;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t factor_min;
    int64_t solve_blas3;
    int64_t solve_min;
    int64_t solve_mf;
    double consist_tol;
    int64_t ispare[5];
    double rspare[10];
};

struct ma97_info {
    int32_t flag;
    int32_t flag68;
    int32_t flag77;
    int32_t matrix_dup;
    int32_t matrix_rank;
    int32_t matrix_outrange;
    int32_t matrix_missing_diag;
    int32_t maxdepth;
    int32_t maxfront;
    int32_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int32_t num_neg;
    int32_t num_sup;
    int32_t num_two;
    int32_t ordering;
    int32_t stat;
    int32_t maxsupernode;
    int32_t ispare[4];
    double rspare[10];
};

struct ma97_info_64 {
    int64_t flag;
    int64_t flag68;
    int64_t flag77;
    int64_t matrix_dup;
    int64_t matrix_rank;
    int64_t matrix_outrange;
    int64_t matrix_missing_diag;
    int64_t maxdepth;
    int64_t maxfront;
    int64_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int64_t num_neg;
    int64_t num_sup;
    int64_t num_two;
    int64_t ordering;
    int64_t stat;
    int64_t maxsupernode;
    int64_t ispare[4];
    double rspare[10];
};

struct mi20_control {
    int32_t f_arrays;
    int32_t aggressive;
    int32_t c_fail;
    int32_t max_levels;
    int32_t max_points;
    double reduction;
    int32_t st_method;
    double st_parameter;
    int32_t testing;
    double trunc_parameter;
    int32_t coarse_solver;
    int32_t coarse_solver_its;
    double damping;
    double err_tol;
    int32_t levels;
    int32_t pre_smoothing;
    int32_t smoother;
    int32_t post_smoothing;
    int32_t v_iterations;
    int32_t print_level;
    int32_t print;
    int32_t error;
    int32_t one_pass_coarsen;
};

struct mi20_control_64 {
    int64_t f_arrays;
    int64_t aggressive;
    int64_t c_fail;
    int64_t max_levels;
    int64_t max_points;
    double reduction;
    int64_t st_method;
    double st_parameter;
    int64_t testing;
    double trunc_parameter;
    int64_t coarse_solver;
    int64_t coarse_solver_its;
    double damping;
    double err_tol;
    int64_t levels;
    int64_t pre_smoothing;
    int64_t smoother;
    int64_t post_smoothing;
    int64_t v_iterations;
    int64_t print_level;
    int64_t print;
    int64_t error;
    int64_t one_pass_coarsen;
};

struct mi20_solve_control {
    double abs_tol;
    double breakdown_tol;
    int32_t gmres_restart;
    bool init_guess;
    int32_t krylov_solver;
    int32_t max_its;
    int32_t preconditioner_side;
    double rel_tol;
};

struct mi20_solve_control_64 {
    double abs_tol;
    double breakdown_tol;
    int64_t gmres_restart;
    bool init_guess;
    int64_t krylov_solver;
    int64_t max_its;
    int64_t preconditioner_side;
    double rel_tol;
};

struct mi20_info {
    int32_t flag;
    int32_t clevels;
    int32_t cpoints;
    int32_t cnnz;
    int32_t stat;
    int32_t getrf_info;
    int32_t iterations;
    double residual;
};

struct mi20_info_64 {
    int64_t flag;
    int64_t clevels;
    int64_t cpoints;
    int64_t cnnz;
    int64_t stat;
    int64_t getrf_info;
    int64_t iterations;
    double residual;
};

struct mi28_control {
    int32_t f_arrays;
    double alpha;
    bool check;
    int32_t iorder;
    int32_t iscale;
    double lowalpha;
    int32_t maxshift;
    bool rrt;
    double shift_factor;
    double shift_factor2;
    double small;
    double tau1;
    double tau2;
    int32_t unit_error;
    int32_t unit_warning;
};

struct mi28_control_64 {
    int64_t f_arrays;
    double alpha;
    bool check;
    int64_t iorder;
    int64_t iscale;
    double lowalpha;
    int64_t maxshift;
    bool rrt;
    double shift_factor;
    double shift_factor2;
    double small;
    double tau1;
    double tau2;
    int64_t unit_error;
    int64_t unit_warning;
};

struct mi28_info {
    int32_t band_after;
    int32_t band_before;
    int32_t dup;
    int32_t flag;
    int32_t flag61;
    int32_t flag64;
    int32_t flag68;
    int32_t flag77;
    int32_t nrestart;
    int32_t nshift;
    int32_t oor;
    double profile_before;
    double profile_after;
    int64_t size_r;
    int32_t stat;
    double alpha;
};

struct mi28_info_64 {
    int64_t band_after;
    int64_t band_before;
    int64_t dup;
    int64_t flag;
    int64_t flag61;
    int64_t flag64;
    int64_t flag68;
    int64_t flag77;
    int64_t nrestart;
    int64_t nshift;
    int64_t oor;
    double profile_before;
    double profile_after;
    int64_t size_r;
    int64_t stat;
    double alpha;
};

// C interface for IR
struct ir_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t itref_max;
    double acceptable_residual_relative;
    double acceptable_residual_absolute;
    double required_residual_relative;
    bool record_residuals;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct ir_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t itref_max;
    double acceptable_residual_relative;
    double acceptable_residual_absolute;
    double required_residual_relative;
    bool record_residuals;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct ir_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    double norm_initial_residual;
    double norm_final_residual;
};

struct ir_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    double norm_initial_residual;
    double norm_final_residual;
};

void ir_initialize(void **data, struct ir_control_type *control, int32_t *status);
void ir_initialize_64(void **data, struct ir_control_type_64 *control, int64_t *status);
void ir_information(void **data, struct ir_inform_type *inform, int32_t *status);
void ir_information_64(void **data, struct ir_inform_type_64 *inform, int64_t *status);
void ir_terminate(void **data, struct ir_control_type *control, struct ir_inform_type *inform);
void ir_terminate_64(void **data, struct ir_control_type_64 *control, struct ir_inform_type_64 *inform);

// C interface for L2RT
struct l2rt_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t itmin;
    int32_t itmax;
    int32_t bitmax;
    int32_t extra_vectors;
    int32_t stopping_rule;
    int32_t freq;
    double stop_relative;
    double stop_absolute;
    double fraction_opt;
    double time_limit;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct l2rt_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t itmin;
    int64_t itmax;
    int64_t bitmax;
    int64_t extra_vectors;
    int64_t stopping_rule;
    int64_t freq;
    double stop_relative;
    double stop_absolute;
    double fraction_opt;
    double time_limit;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct l2rt_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    int32_t biters;
    int32_t biter_min;
    int32_t biter_max;
    double obj;
    double multiplier;
    double x_norm;
    double r_norm;
    double Atr_norm;
    double biter_mean;
};

struct l2rt_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    int64_t biters;
    int64_t biter_min;
    int64_t biter_max;
    double obj;
    double multiplier;
    double x_norm;
    double r_norm;
    double Atr_norm;
    double biter_mean;
};

void l2rt_initialize(void **data, struct l2rt_control_type *control, int32_t *status);
void l2rt_initialize_64(void **data, struct l2rt_control_type_64 *control, int64_t *status);
void l2rt_read_specfile(struct l2rt_control_type *control, char *specfile);
void l2rt_read_specfile_64(struct l2rt_control_type_64 *control, char *specfile);
void l2rt_import_control(struct l2rt_control_type *control, void **data, int32_t *status);
void l2rt_import_control_64(struct l2rt_control_type_64 *control, void **data, int64_t *status);
void l2rt_solve_problem(void **data, int32_t *status, int32_t m, int32_t n, double power, double weight, double shift, double *x, double *u, double *v);
void l2rt_solve_problem_64(void **data, int64_t *status, int64_t m, int64_t n, double power, double weight, double shift, double *x, double *u, double *v);
void l2rt_information(void **data, struct l2rt_inform_type *inform, int32_t *status);
void l2rt_information_64(void **data, struct l2rt_inform_type_64 *inform, int64_t *status);
void l2rt_terminate(void **data, struct l2rt_control_type *control, struct l2rt_inform_type *inform);
void l2rt_terminate_64(void **data, struct l2rt_control_type_64 *control, struct l2rt_inform_type_64 *inform);

// C interface for LHS
void lhs_initialize(void **data, struct lhs_control_type *control, struct lhs_inform_type *inform);
void lhs_initialize_64(void **data, struct lhs_control_type_64 *control, struct lhs_inform_type_64 *inform);
void lhs_read_specfile(struct lhs_control_type *control, char *specfile);
void lhs_read_specfile_64(struct lhs_control_type_64 *control, char *specfile);
void lhs_ihs(int32_t n_dimen, int32_t n_points, int32_t *seed, int32_t *X, struct lhs_control_type *control, struct lhs_inform_type *inform, void **data);
void lhs_ihs_64(int64_t n_dimen, int64_t n_points, int64_t *seed, int64_t *X, struct lhs_control_type_64 *control, struct lhs_inform_type_64 *inform, void **data);
void lhs_get_seed(int32_t *seed);
void lhs_get_seed_64(int64_t *seed);
void lhs_information(void **data, struct lhs_inform_type *inform, int32_t *status);
void lhs_information_64(void **data, struct lhs_inform_type_64 *inform, int64_t *status);
void lhs_terminate(void **data, struct lhs_control_type *control, struct lhs_inform_type *inform);
void lhs_terminate_64(void **data, struct lhs_control_type_64 *control, struct lhs_inform_type_64 *inform);

// C interface for LMS
struct lms_time_type {
    double total;
    double setup;
    double form;
    double apply;
    double clock_total;
    double clock_setup;
    double clock_form;
    double clock_apply;
};

struct lms_inform_type {
    int32_t status;
    int32_t alloc_status;
    int32_t length;
    bool updates_skipped;
    char bad_alloc[81];
    struct lms_time_type time;
};

struct lms_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t length;
    bool updates_skipped;
    char bad_alloc[81];
    struct lms_time_type time;
};

void lms_initialize(void **data, struct lms_control_type *control, int32_t *status);
void lms_initialize_64(void **data, struct lms_control_type_64 *control, int64_t *status);
void lms_information(void **data, struct lms_inform_type *inform, int32_t *status);
void lms_information_64(void **data, struct lms_inform_type_64 *inform, int64_t *status);
void lms_terminate(void **data, struct lms_control_type *control, struct lms_inform_type *inform);
void lms_terminate_64(void **data, struct lms_control_type_64 *control, struct lms_inform_type_64 *inform);

// C interface for LSRT
struct lsrt_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t itmin;
    int32_t itmax;
    int32_t bitmax;
    int32_t extra_vectors;
    int32_t stopping_rule;
    int32_t freq;
    double stop_relative;
    double stop_absolute;
    double fraction_opt;
    double time_limit;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct lsrt_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t itmin;
    int64_t itmax;
    int64_t bitmax;
    int64_t extra_vectors;
    int64_t stopping_rule;
    int64_t freq;
    double stop_relative;
    double stop_absolute;
    double fraction_opt;
    double time_limit;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct lsrt_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    int32_t biters;
    int32_t biter_min;
    int32_t biter_max;
    double obj;
    double multiplier;
    double x_norm;
    double r_norm;
    double Atr_norm;
    double biter_mean;
};

struct lsrt_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    int64_t biters;
    int64_t biter_min;
    int64_t biter_max;
    double obj;
    double multiplier;
    double x_norm;
    double r_norm;
    double Atr_norm;
    double biter_mean;
};

void lsrt_initialize(void **data, struct lsrt_control_type *control, int32_t *status);
void lsrt_initialize_64(void **data, struct lsrt_control_type_64 *control, int64_t *status);
void lsrt_read_specfile(struct lsrt_control_type *control, char *specfile);
void lsrt_read_specfile_64(struct lsrt_control_type_64 *control, char *specfile);
void lsrt_import_control(struct lsrt_control_type *control, void **data, int32_t *status);
void lsrt_import_control_64(struct lsrt_control_type_64 *control, void **data, int64_t *status);
void lsrt_solve_problem(void **data, int32_t *status, int32_t m, int32_t n, double power, double weight, double *x, double *u, double *v);
void lsrt_solve_problem_64(void **data, int64_t *status, int64_t m, int64_t n, double power, double weight, double *x, double *u, double *v);
void lsrt_information(void **data, struct lsrt_inform_type *inform, int32_t *status);
void lsrt_information_64(void **data, struct lsrt_inform_type_64 *inform, int64_t *status);
void lsrt_terminate(void **data, struct lsrt_control_type *control, struct lsrt_inform_type *inform);
void lsrt_terminate_64(void **data, struct lsrt_control_type_64 *control, struct lsrt_inform_type_64 *inform);

// C interface for LSTR
struct lstr_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t itmin;
    int32_t itmax;
    int32_t itmax_on_boundary;
    int32_t bitmax;
    int32_t extra_vectors;
    double stop_relative;
    double stop_absolute;
    double fraction_opt;
    double time_limit;
    bool steihaug_toint;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct lstr_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t itmin;
    int64_t itmax;
    int64_t itmax_on_boundary;
    int64_t bitmax;
    int64_t extra_vectors;
    double stop_relative;
    double stop_absolute;
    double fraction_opt;
    double time_limit;
    bool steihaug_toint;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct lstr_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t iter_pass2;
    int32_t biters;
    int32_t biter_min;
    int32_t biter_max;
    double multiplier;
    double x_norm;
    double r_norm;
    double Atr_norm;
    double biter_mean;
};

struct lstr_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t iter_pass2;
    int64_t biters;
    int64_t biter_min;
    int64_t biter_max;
    double multiplier;
    double x_norm;
    double r_norm;
    double Atr_norm;
    double biter_mean;
};

void lstr_initialize(void **data, struct lstr_control_type *control, int32_t *status);
void lstr_initialize_64(void **data, struct lstr_control_type_64 *control, int64_t *status);
void lstr_read_specfile(struct lstr_control_type *control, char *specfile);
void lstr_read_specfile_64(struct lstr_control_type_64 *control, char *specfile);
void lstr_import_control(struct lstr_control_type *control, void **data, int32_t *status);
void lstr_import_control_64(struct lstr_control_type_64 *control, void **data, int64_t *status);
void lstr_solve_problem(void **data, int32_t *status, int32_t m, int32_t n, double radius, double *x, double *u, double *v);
void lstr_solve_problem_64(void **data, int64_t *status, int64_t m, int64_t n, double radius, double *x, double *u, double *v);
void lstr_information(void **data, struct lstr_inform_type *inform, int32_t *status);
void lstr_information_64(void **data, struct lstr_inform_type_64 *inform, int64_t *status);
void lstr_terminate(void **data, struct lstr_control_type *control, struct lstr_inform_type *inform);
void lstr_terminate_64(void **data, struct lstr_control_type_64 *control, struct lstr_inform_type_64 *inform);

// C interface for NODEND
struct nodend_time_type {
    double total;
    double metis;
    double clock_total;
    double clock_metis;
};

struct nodend_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    char version[4];
    struct nodend_time_type time;
};

struct nodend_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    char version[4];
    struct nodend_time_type time;
};

void nodend_initialize(void **data, struct nodend_control_type *control, int32_t *status);
void nodend_initialize_64(void **data, struct nodend_control_type_64 *control, int64_t *status);
void nodend_read_specfile(struct nodend_control_type *control, char *specfile);
void nodend_read_specfile_64(struct nodend_control_type_64 *control, char *specfile);
void nodend_order(struct nodend_control_type *control, void **data, int32_t *status, int32_t n, int32_t *perm, char *A_type, int32_t ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void nodend_order_64(struct nodend_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t *perm, char *A_type, int64_t ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void nodend_information(void **data, struct nodend_inform_type *inform, int32_t *status);
void nodend_information_64(void **data, struct nodend_inform_type_64 *inform, int64_t *status);
void nodend_terminate(void **data);
void nodend_terminate_64(void **data);

// C interface for PRESOLVE
struct presolve_control_type {
    bool f_indexing;
    int32_t termination;
    int32_t max_nbr_transforms;
    int32_t max_nbr_passes;
    double c_accuracy;
    double z_accuracy;
    double infinity;
    int32_t out;
    int32_t errout;
    int32_t print_level;
    bool dual_transformations;
    bool redundant_xc;
    int32_t primal_constraints_freq;
    int32_t dual_constraints_freq;
    int32_t singleton_columns_freq;
    int32_t doubleton_columns_freq;
    int32_t unc_variables_freq;
    int32_t dependent_variables_freq;
    int32_t sparsify_rows_freq;
    int32_t max_fill;
    int32_t transf_file_nbr;
    int32_t transf_buffer_size;
    int32_t transf_file_status;
    char transf_file_name[31];
    int32_t y_sign;
    int32_t inactive_y;
    int32_t z_sign;
    int32_t inactive_z;
    int32_t final_x_bounds;
    int32_t final_z_bounds;
    int32_t final_c_bounds;
    int32_t final_y_bounds;
    int32_t check_primal_feasibility;
    int32_t check_dual_feasibility;
    double pivot_tol;
    double min_rel_improve;
    double max_growth_factor;
};

struct presolve_control_type_64 {
    bool f_indexing;
    int64_t termination;
    int64_t max_nbr_transforms;
    int64_t max_nbr_passes;
    double c_accuracy;
    double z_accuracy;
    double infinity;
    int64_t out;
    int64_t errout;
    int64_t print_level;
    bool dual_transformations;
    bool redundant_xc;
    int64_t primal_constraints_freq;
    int64_t dual_constraints_freq;
    int64_t singleton_columns_freq;
    int64_t doubleton_columns_freq;
    int64_t unc_variables_freq;
    int64_t dependent_variables_freq;
    int64_t sparsify_rows_freq;
    int64_t max_fill;
    int64_t transf_file_nbr;
    int64_t transf_buffer_size;
    int64_t transf_file_status;
    char transf_file_name[31];
    int64_t y_sign;
    int64_t inactive_y;
    int64_t z_sign;
    int64_t inactive_z;
    int64_t final_x_bounds;
    int64_t final_z_bounds;
    int64_t final_c_bounds;
    int64_t final_y_bounds;
    int64_t check_primal_feasibility;
    int64_t check_dual_feasibility;
    double pivot_tol;
    double min_rel_improve;
    double max_growth_factor;
};

void presolve_initialize(void **data, struct presolve_control_type *control, int32_t *status);
void presolve_initialize_64(void **data, struct presolve_control_type_64 *control, int64_t *status);
void presolve_read_specfile(struct presolve_control_type *control, char *specfile);
void presolve_read_specfile_64(struct presolve_control_type_64 *control, char *specfile);
void presolve_import_problem(struct presolve_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, double *H_val, double *g, double f, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, int32_t *n_out, int32_t *m_out, int32_t *H_ne_out, int32_t *A_ne_out);
void presolve_import_problem_64(struct presolve_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, double *H_val, double *g, double f, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, int64_t *n_out, int64_t *m_out, int64_t *H_ne_out, int64_t *A_ne_out);
void presolve_transform_problem(void **data, int32_t *status, int32_t n, int32_t m, int32_t H_ne, int32_t *H_col, int32_t *H_ptr, double *H_val, double *g, double *f, int32_t A_ne, int32_t *A_col, int32_t *A_ptr, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *y_l, double *y_u, double *z_l, double *z_u);
void presolve_transform_problem_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t H_ne, int64_t *H_col, int64_t *H_ptr, double *H_val, double *g, double *f, int64_t A_ne, int64_t *A_col, int64_t *A_ptr, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *y_l, double *y_u, double *z_l, double *z_u);
void presolve_restore_solution(void **data, int32_t *status, int32_t n_in, int32_t m_in, double *x_in, double *c_in, double *y_in, double *z_in, int32_t n, int32_t m, double *x, double *c, double *y, double *z);
void presolve_restore_solution_64(void **data, int64_t *status, int64_t n_in, int64_t m_in, double *x_in, double *c_in, double *y_in, double *z_in, int64_t n, int64_t m, double *x, double *c, double *y, double *z);
void presolve_information(void **data, struct presolve_inform_type *inform, int32_t *status);
void presolve_information_64(void **data, struct presolve_inform_type_64 *inform, int64_t *status);
void presolve_terminate(void **data, struct presolve_control_type *control, struct presolve_inform_type *inform);
void presolve_terminate_64(void **data, struct presolve_control_type_64 *control, struct presolve_inform_type_64 *inform);

// C interface for ROOTS
struct roots_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    double tol;
    double zero_coef;
    double zero_f;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct roots_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    double tol;
    double zero_coef;
    double zero_f;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

void roots_initialize(void **data, struct roots_control_type *control, int32_t *status);
void roots_initialize_64(void **data, struct roots_control_type_64 *control, int64_t *status);
void roots_information(void **data, struct roots_inform_type *inform, int32_t *status);
void roots_information_64(void **data, struct roots_inform_type_64 *inform, int64_t *status);
void roots_terminate(void **data, struct roots_control_type *control, struct roots_inform_type *inform);
void roots_terminate_64(void **data, struct roots_control_type_64 *control, struct roots_inform_type_64 *inform);

// C interface for RPD
void rpd_initialize(void **data, struct rpd_control_type *control, int32_t *status);
void rpd_initialize_64(void **data, struct rpd_control_type_64 *control, int64_t *status);
void rpd_get_stats(char *qplib_file, int32_t qplib_file_len, struct rpd_control_type *control, void **data, int32_t *status, char *p_type, int32_t *n, int32_t *m, int32_t *h_ne, int32_t *a_ne, int32_t *h_c_ne);
void rpd_get_stats_64(char *qplib_file, int64_t qplib_file_len, struct rpd_control_type_64 *control, void **data, int64_t *status, char *p_type, int64_t *n, int64_t *m, int64_t *h_ne, int64_t *a_ne, int64_t *h_c_ne);
void rpd_get_g(void **data, int32_t *status, int32_t n, double *g);
void rpd_get_g_64(void **data, int64_t *status, int64_t n, double *g);
void rpd_get_f(void **data, int32_t *status, double *f);
void rpd_get_f_64(void **data, int64_t *status, double *f);
void rpd_get_xlu(void **data, int32_t *status, int32_t n, double *x_l, double *x_u);
void rpd_get_xlu_64(void **data, int64_t *status, int64_t n, double *x_l, double *x_u);
void rpd_get_clu(void **data, int32_t *status, int32_t m, double *c_l, double *c_u);
void rpd_get_clu_64(void **data, int64_t *status, int64_t m, double *c_l, double *c_u);
void rpd_get_h(void **data, int32_t *status, int32_t h_ne, int32_t *h_row, int32_t *h_col, double *h_val);
void rpd_get_h_64(void **data, int64_t *status, int64_t h_ne, int64_t *h_row, int64_t *h_col, double *h_val);
void rpd_get_a(void **data, int32_t *status, int32_t a_ne, int32_t *a_row, int32_t *a_col, double *a_val);
void rpd_get_a_64(void **data, int64_t *status, int64_t a_ne, int64_t *a_row, int64_t *a_col, double *a_val);
void rpd_get_h_c(void **data, int32_t *status, int32_t h_c_ne, int32_t *h_c_ptr, int32_t *h_c_row, int32_t *h_c_col, double *h_c_val);
void rpd_get_h_c_64(void **data, int64_t *status, int64_t h_c_ne, int64_t *h_c_ptr, int64_t *h_c_row, int64_t *h_c_col, double *h_c_val);
void rpd_get_x_type(void **data, int32_t *status, int32_t n, int32_t *x_type);
void rpd_get_x_type_64(void **data, int64_t *status, int64_t n, int64_t *x_type);
void rpd_get_x(void **data, int32_t *status, int32_t n, double *x);
void rpd_get_x_64(void **data, int64_t *status, int64_t n, double *x);
void rpd_get_y(void **data, int32_t *status, int32_t m, double *y);
void rpd_get_y_64(void **data, int64_t *status, int64_t m, double *y);
void rpd_get_z(void **data, int32_t *status, int32_t n, double *z);
void rpd_get_z_64(void **data, int64_t *status, int64_t n, double *z);
void rpd_information(void **data, struct rpd_inform_type *inform, int32_t *status);
void rpd_information_64(void **data, struct rpd_inform_type_64 *inform, int64_t *status);
void rpd_terminate(void **data, struct rpd_control_type *control, struct rpd_inform_type *inform);
void rpd_terminate_64(void **data, struct rpd_control_type_64 *control, struct rpd_inform_type_64 *inform);

// C interface for SCU
void scu_initialize(void **data, struct scu_control_type *control, int32_t *status);
void scu_initialize_64(void **data, struct scu_control_type *control, int64_t *status);
void scu_information(void **data, struct scu_inform_type *inform, int32_t *status);
void scu_information_64(void **data, struct scu_inform_type_64 *inform, int64_t *status);
void scu_terminate(void **data, struct scu_control_type *control, struct scu_inform_type *inform);
void scu_terminate_64(void **data, struct scu_control_type *control, struct scu_inform_type_64 *inform);

// C interface for SEC
struct sec_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    double h_initial;
    double update_skip_tol;
    char prefix[31];
};

struct sec_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    double h_initial;
    double update_skip_tol;
    char prefix[31];
};

void sec_initialize(struct sec_control_type *control, int32_t *status);
void sec_initialize_64(struct sec_control_type_64 *control, int64_t *status);
void sec_information(void **data, struct sec_inform_type *inform, int32_t *status);
void sec_information_64(void **data, struct sec_inform_type_64 *inform, int64_t *status);
void sec_terminate(void **data, struct sec_control_type *control, struct sec_inform_type *inform);
void sec_terminate_64(void **data, struct sec_control_type_64 *control, struct sec_inform_type_64 *inform);

// C interface for SHA
struct sha_inform_type {
    int32_t status;
    int32_t alloc_status;
    int32_t max_degree;
    int32_t differences_needed;
    int32_t max_reduced_degree;
    int32_t approximation_algorithm_used;
    int32_t bad_row;
    double max_off_diagonal_difference;
    char bad_alloc[81];
};

struct sha_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t max_degree;
    int64_t differences_needed;
    int64_t max_reduced_degree;
    int64_t approximation_algorithm_used;
    int64_t bad_row;
    double max_off_diagonal_difference;
    char bad_alloc[81];
};

void sha_initialize(void **data, struct sha_control_type *control, int32_t *status);
void sha_initialize_64(void **data, struct sha_control_type_64 *control, int64_t *status);
void sha_reset_control(struct sha_control_type *control, void **data, int32_t *status);
void sha_reset_control_64(struct sha_control_type_64 *control, void **data, int64_t *status);
void sha_analyse_matrix(struct sha_control_type *control, void **data, int32_t *status, int32_t n, int32_t ne, int32_t *row, int32_t *col, int32_t *m);
void sha_analyse_matrix_64(struct sha_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t ne, int64_t *row, int64_t *col, int64_t *m);
void sha_recover_matrix(void **data, int32_t *status, int32_t ne, int32_t m, int32_t ls1, int32_t ls2, double **strans, int32_t ly1, int32_t ly2, double **ytrans, double *val, int32_t *precedence);
void sha_recover_matrix_64(void **data, int64_t *status, int64_t ne, int64_t m, int64_t ls1, int64_t ls2, double **strans, int64_t ly1, int64_t ly2, double **ytrans, double *val, int64_t *precedence);
void sha_information(void **data, struct sha_inform_type *inform, int32_t *status);
void sha_information_64(void **data, struct sha_inform_type_64 *inform, int64_t *status);
void sha_terminate(void **data, struct sha_control_type *control, struct sha_inform_type *inform);
void sha_terminate_64(void **data, struct sha_control_type_64 *control, struct sha_inform_type_64 *inform);

// C interface for SILS
struct sils_control_type {
    bool f_indexing;
    int32_t ICNTL[30];
    int32_t lp;
    int32_t wp;
    int32_t mp;
    int32_t sp;
    int32_t ldiag;
    int32_t la;
    int32_t liw;
    int32_t maxla;
    int32_t maxliw;
    int32_t pivoting;
    int32_t nemin;
    int32_t factorblocking;
    int32_t solveblocking;
    int32_t thresh;
    int32_t ordering;
    int32_t scaling;
    double CNTL[5];
    double multiplier;
    double reduce;
    double u;
    double static_tolerance;
    double static_level;
    double tolerance;
    double convergence;
};

struct sils_control_type_64 {
    bool f_indexing;
    int64_t ICNTL[30];
    int64_t lp;
    int64_t wp;
    int64_t mp;
    int64_t sp;
    int64_t ldiag;
    int64_t la;
    int64_t liw;
    int64_t maxla;
    int64_t maxliw;
    int64_t pivoting;
    int64_t nemin;
    int64_t factorblocking;
    int64_t solveblocking;
    int64_t thresh;
    int64_t ordering;
    int64_t scaling;
    double CNTL[5];
    double multiplier;
    double reduce;
    double u;
    double static_tolerance;
    double static_level;
    double tolerance;
    double convergence;
};

struct sils_ainfo_type {
    int32_t flag;
    int32_t more;
    int32_t nsteps;
    int32_t nrltot;
    int32_t nirtot;
    int32_t nrlnec;
    int32_t nirnec;
    int32_t nrladu;
    int32_t niradu;
    int32_t ncmpa;
    int32_t oor;
    int32_t dup;
    int32_t maxfrt;
    int32_t stat;
    int32_t faulty;
    double opsa;
    double opse;
};

struct sils_ainfo_type_64 {
    int64_t flag;
    int64_t more;
    int64_t nsteps;
    int64_t nrltot;
    int64_t nirtot;
    int64_t nrlnec;
    int64_t nirnec;
    int64_t nrladu;
    int64_t niradu;
    int64_t ncmpa;
    int64_t oor;
    int64_t dup;
    int64_t maxfrt;
    int64_t stat;
    int64_t faulty;
    double opsa;
    double opse;
};

struct sils_finfo_type {
    int32_t flag;
    int32_t more;
    int32_t maxfrt;
    int32_t nebdu;
    int32_t nrlbdu;
    int32_t nirbdu;
    int32_t nrltot;
    int32_t nirtot;
    int32_t nrlnec;
    int32_t nirnec;
    int32_t ncmpbr;
    int32_t ncmpbi;
    int32_t ntwo;
    int32_t neig;
    int32_t delay;
    int32_t signc;
    int32_t nstatic;
    int32_t modstep;
    int32_t rank;
    int32_t stat;
    int32_t faulty;
    int32_t step;
    double opsa;
    double opse;
    double opsb;
    double maxchange;
    double smin;
    double smax;
};

struct sils_finfo_type_64 {
    int64_t flag;
    int64_t more;
    int64_t maxfrt;
    int64_t nebdu;
    int64_t nrlbdu;
    int64_t nirbdu;
    int64_t nrltot;
    int64_t nirtot;
    int64_t nrlnec;
    int64_t nirnec;
    int64_t ncmpbr;
    int64_t ncmpbi;
    int64_t ntwo;
    int64_t neig;
    int64_t delay;
    int64_t signc;
    int64_t nstatic;
    int64_t modstep;
    int64_t rank;
    int64_t stat;
    int64_t faulty;
    int64_t step;
    double opsa;
    double opse;
    double opsb;
    double maxchange;
    double smin;
    double smax;
};

struct sils_sinfo_type {
    int32_t flag;
    int32_t stat;
    double cond;
    double cond2;
    double berr;
    double berr2;
    double error;
};

struct sils_sinfo_type_64 {
    int64_t flag;
    int64_t stat;
    double cond;
    double cond2;
    double berr;
    double berr2;
    double error;
};

void sils_initialize(void **data, struct sils_control_type *control, int32_t *status);
void sils_initialize_64(void **data, struct sils_control_type_64 *control, int64_t *status);
void sils_read_specfile(struct sils_control_type *control, char *specfile);
void sils_read_specfile_64(struct sils_control_type_64 *control, char *specfile);
void sils_import(struct sils_control_type *control, void **data, int32_t *status);
void sils_import_64(struct sils_control_type_64 *control, void **data, int64_t *status);
void sils_reset_control(struct sils_control_type *control, void **data, int32_t *status);
void sils_reset_control_64(struct sils_control_type_64 *control, void **data, int64_t *status);
void sils_information(void **data, struct sils_ainfo_type *ainfo, struct sils_finfo_type *finfo, struct sils_sinfo_type *sinfo, int32_t *status);
void sils_information_64(void **data, struct sils_ainfo_type_64 *ainfo, struct sils_finfo_type_64 *finfo, struct sils_sinfo_type_64 *sinfo, int64_t *status);
void sils_finalize(void **data, struct sils_control_type *control, int32_t *status);
void sils_finalize_64(void **data, struct sils_control_type_64 *control, int64_t *status);

// C interface for UGO
struct ugo_control_type {
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t initial_points;
    int32_t storage_increment;
    int32_t buffer;
    int32_t lipschitz_estimate_used;
    int32_t next_interval_selection;
    int32_t refine_with_newton;
    int32_t alive_unit;
    char alive_file[31];
    double stop_length;
    double small_g_for_newton;
    double small_g;
    double obj_sufficient;
    double global_lipschitz_constant;
    double reliability_parameter;
    double lipschitz_lower_bound;
    double cpu_time_limit;
    double clock_time_limit;
    bool second_derivative_available;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct ugo_control_type_64 {
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t initial_points;
    int64_t storage_increment;
    int64_t buffer;
    int64_t lipschitz_estimate_used;
    int64_t next_interval_selection;
    int64_t refine_with_newton;
    int64_t alive_unit;
    char alive_file[31];
    double stop_length;
    double small_g_for_newton;
    double small_g;
    double obj_sufficient;
    double global_lipschitz_constant;
    double reliability_parameter;
    double lipschitz_lower_bound;
    double cpu_time_limit;
    double clock_time_limit;
    bool second_derivative_available;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
};

struct ugo_time_type {
    float total;
    double clock_total;
};

struct ugo_inform_type {
    int32_t status;
    int32_t eval_status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    struct ugo_time_type time;
};

struct ugo_inform_type_64 {
    int64_t status;
    int64_t eval_status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    struct ugo_time_type time;
};

void ugo_initialize(void **data, struct ugo_control_type *control, int32_t *status);
void ugo_initialize_64(void **data, struct ugo_control_type_64 *control, int64_t *status);
void ugo_read_specfile(struct ugo_control_type *control, char *specfile);
void ugo_read_specfile_64(struct ugo_control_type_64 *control, char *specfile);
void ugo_import(struct ugo_control_type *control, void **data, int32_t *status, double *x_l, double *x_u);
void ugo_import_64(struct ugo_control_type_64 *control, void **data, int64_t *status, double *x_l, double *x_u);
void ugo_reset_control(struct ugo_control_type *control, void **data, int32_t *status);
void ugo_reset_control_64(struct ugo_control_type_64 *control, void **data, int64_t *status);
void ugo_solve_direct(void **data, void *userdata, int32_t *status, double *x, double *f, double *g, double *h, galahad_fgh *eval_fgh);
void ugo_solve_direct_64(void **data, void *userdata, int64_t *status, double *x, double *f, double *g, double *h, galahad_fgh_64 *eval_fgh);
void ugo_solve_reverse(void **data, int32_t *status, int32_t *eval_status, double *x, double *f, double *g, double *h);
void ugo_solve_reverse_64(void **data, int64_t *status, int64_t *eval_status, double *x, double *f, double *g, double *h);
void ugo_information(void **data, struct ugo_inform_type *inform, int32_t *status);
void ugo_information_64(void **data, struct ugo_inform_type_64 *inform, int64_t *status);
void ugo_terminate(void **data, struct ugo_control_type *control, struct ugo_inform_type *inform);
void ugo_terminate_64(void **data, struct ugo_control_type_64 *control, struct ugo_inform_type_64 *inform);

// C interface for SSIDS
struct spral_ssids_options {
    int32_t array_base;
    int32_t print_level;
    int32_t unit_diagnostics;
    int32_t unit_error;
    int32_t unit_warning;
    int32_t ordering;
    int32_t nemin;
    bool ignore_numa;
    bool use_gpu;
    bool gpu_only;
    int64_t min_gpu_work;
    float max_load_inbalance;
    float gpu_perf_coeff;
    int32_t scaling;
    int64_t small_subtree_threshold;
    int32_t cpu_block_size;
    bool action;
    int32_t pivot_method;
    double small;
    double u;
    struct nodend_control_type nodend_control;
    int32_t nstream;
    double multiplier;
    float min_loadbalance;
    int32_t failed_pivot_method;
};

struct spral_ssids_options_64 {
    int64_t array_base;
    int64_t print_level;
    int64_t unit_diagnostics;
    int64_t unit_error;
    int64_t unit_warning;
    int64_t ordering;
    int64_t nemin;
    bool ignore_numa;
    bool use_gpu;
    bool gpu_only;
    int64_t min_gpu_work;
    float max_load_inbalance;
    float gpu_perf_coeff;
    int64_t scaling;
    int64_t small_subtree_threshold;
    int64_t cpu_block_size;
    bool action;
    int64_t pivot_method;
    double small;
    double u;
    struct nodend_control_type_64 nodend_control;
    int64_t nstream;
    double multiplier;
    float min_loadbalance;
    int64_t failed_pivot_method;
};

struct spral_ssids_inform {
    int32_t flag;
    int32_t matrix_dup;
    int32_t matrix_missing_diag;
    int32_t matrix_outrange;
    int32_t matrix_rank;
    int32_t maxdepth;
    int32_t maxfront;
    int32_t maxsupernode;
    int32_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int32_t num_neg;
    int32_t num_sup;
    int32_t num_two;
    int32_t stat;
    int32_t cuda_error;
    int32_t cublas_error;
    struct nodend_inform_type nodend_inform;
    int32_t not_first_pass;
    int32_t not_second_pass;
    int32_t nparts;
    int64_t cpu_flops;
    int64_t gpu_flops;
};

struct spral_ssids_inform_64 {
    int64_t flag;
    int64_t matrix_dup;
    int64_t matrix_missing_diag;
    int64_t matrix_outrange;
    int64_t matrix_rank;
    int64_t maxdepth;
    int64_t maxfront;
    int64_t maxsupernode;
    int64_t num_delay;
    int64_t num_factor;
    int64_t num_flops;
    int64_t num_neg;
    int64_t num_sup;
    int64_t num_two;
    int64_t stat;
    int64_t cuda_error;
    int64_t cublas_error;
    struct nodend_inform_type_64 nodend_inform;
    int64_t not_first_pass;
    int64_t not_second_pass;
    int64_t nparts;
    int64_t cpu_flops;
    int64_t gpu_flops;
};

void spral_ssids_default_options(struct spral_ssids_options *options);
void spral_ssids_default_options_64(struct spral_ssids_options_64 *options);
void spral_ssids_analyse(bool check, int32_t n, int32_t *order, int64_t *ptr, int32_t *row, double *val, void **akeep, struct spral_ssids_options *options, struct spral_ssids_inform *inform);
void spral_ssids_analyse_64(bool check, int64_t n, int64_t *order, int64_t *ptr, int64_t *row, double *val, void **akeep, struct spral_ssids_options_64 *options, struct spral_ssids_inform_64 *inform);
void spral_ssids_analyse_ptr32(bool check, int32_t n, int32_t *order, int32_t *ptr, int32_t *row, double *val, void **akeep, struct spral_ssids_options *options, struct spral_ssids_inform *inform);
void spral_ssids_analyse_ptr32_64(bool check, int64_t n, int64_t *order, int64_t *ptr, int64_t *row, double *val, void **akeep, struct spral_ssids_options_64 *options, struct spral_ssids_inform_64 *inform);
void spral_ssids_analyse_coord(int32_t n, int32_t *order, int64_t ne, int32_t *row, int32_t *col, double *val, void **akeep, struct spral_ssids_options *options, struct spral_ssids_inform *inform);
void spral_ssids_analyse_coord_64(int64_t n, int64_t *order, int64_t ne, int64_t *row, int64_t *col, double *val, void **akeep, struct spral_ssids_options_64 *options, struct spral_ssids_inform_64 *inform);
void spral_ssids_factor(bool posdef, int64_t *ptr, int32_t *row, double *val, double *scale, void *akeep, void **fkeep, struct spral_ssids_options *options, struct spral_ssids_inform *inform);
void spral_ssids_factor_64(bool posdef, int64_t *ptr, int64_t *row, double *val, double *scale, void *akeep, void **fkeep, struct spral_ssids_options_64 *options, struct spral_ssids_inform_64 *inform);
void spral_ssids_factor_ptr32(bool posdef, int32_t *ptr, int32_t *row, double *val, double *scale, void *akeep, void **fkeep, struct spral_ssids_options *options, struct spral_ssids_inform *inform);
void spral_ssids_factor_ptr32_64(bool posdef, int64_t *ptr, int64_t *row, double *val, double *scale, void *akeep, void **fkeep, struct spral_ssids_options_64 *options, struct spral_ssids_inform_64 *inform);
void spral_ssids_solve1(int32_t job, double *x1, void *akeep, void *fkeep, struct spral_ssids_options *options, struct spral_ssids_inform *inform);
void spral_ssids_solve1_64(int64_t job, double *x1, void *akeep, void *fkeep, struct spral_ssids_options_64 *options, struct spral_ssids_inform_64 *inform);
void spral_ssids_solve(int32_t job, int32_t nrhs, double *x, int32_t ldx, void *akeep, void *fkeep, struct spral_ssids_options *options, struct spral_ssids_inform *inform);
void spral_ssids_solve_64(int64_t job, int64_t nrhs, double *x, int64_t ldx, void *akeep, void *fkeep, struct spral_ssids_options_64 *options, struct spral_ssids_inform_64 *inform);
int32_t spral_ssids_free_akeep(void **akeep);
int64_t spral_ssids_free_akeep_64(void **akeep);
int32_t spral_ssids_free_fkeep(void **fkeep);
int64_t spral_ssids_free_fkeep_64(void **fkeep);
int32_t spral_ssids_free(void **akeep, void **fkeep);
int64_t spral_ssids_free_64(void **akeep, void **fkeep);
void spral_ssids_enquire_posdef(void *akeep, void *fkeep, struct spral_ssids_options *options, struct spral_ssids_inform *inform, double *d);
void spral_ssids_enquire_posdef_64(void *akeep, void *fkeep, struct spral_ssids_options_64 *options, struct spral_ssids_inform_64 *inform, double *d);
void spral_ssids_enquire_indef(void *akeep, void *fkeep, struct spral_ssids_options *options, struct spral_ssids_inform *inform, int32_t *piv_order, double *d);
void spral_ssids_enquire_indef_64(void *akeep, void *fkeep, struct spral_ssids_options_64 *options, struct spral_ssids_inform_64 *inform, int64_t *piv_order, double *d);
void spral_ssids_alter(double *d, void *akeep, void *fkeep, struct spral_ssids_options *options, struct spral_ssids_inform *inform);
void spral_ssids_alter_64(double *d, void *akeep, void *fkeep, struct spral_ssids_options_64 *options, struct spral_ssids_inform_64 *inform);

// C interface for SLS
struct sls_control_type {
    bool f_indexing;
    int32_t error;
    int32_t warning;
    int32_t out;
    int32_t statistics;
    int32_t print_level;
    int32_t print_level_solver;
    int32_t bits;
    int32_t block_size_kernel;
    int32_t block_size_elimination;
    int32_t blas_block_size_factorize;
    int32_t blas_block_size_solve;
    int32_t node_amalgamation;
    int32_t initial_pool_size;
    int32_t min_real_factor_size;
    int32_t min_integer_factor_size;
    int64_t max_real_factor_size;
    int64_t max_integer_factor_size;
    int64_t max_in_core_store;
    double array_increase_factor;
    double array_decrease_factor;
    int32_t pivot_control;
    int32_t ordering;
    int32_t full_row_threshold;
    int32_t row_search_indefinite;
    int32_t scaling;
    int32_t scale_maxit;
    double scale_thresh;
    double relative_pivot_tolerance;
    double minimum_pivot_tolerance;
    double absolute_pivot_tolerance;
    double zero_tolerance;
    double zero_pivot_tolerance;
    double negative_pivot_tolerance;
    double static_pivot_tolerance;
    double static_level_switch;
    double consistency_tolerance;
    int32_t max_iterative_refinements;
    double acceptable_residual_relative;
    double acceptable_residual_absolute;
    bool multiple_rhs;
    bool generate_matrix_file;
    int32_t matrix_file_device;
    char matrix_file_name[31];
    char out_of_core_directory[401];
    char out_of_core_integer_factor_file[401];
    char out_of_core_real_factor_file[401];
    char out_of_core_real_work_file[401];
    char out_of_core_indefinite_file[401];
    char out_of_core_restart_file[501];
    char prefix[31];
    struct nodend_control_type nodend_control;
};

struct sls_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t warning;
    int64_t out;
    int64_t statistics;
    int64_t print_level;
    int64_t print_level_solver;
    int64_t bits;
    int64_t block_size_kernel;
    int64_t block_size_elimination;
    int64_t blas_block_size_factorize;
    int64_t blas_block_size_solve;
    int64_t node_amalgamation;
    int64_t initial_pool_size;
    int64_t min_real_factor_size;
    int64_t min_integer_factor_size;
    int64_t max_real_factor_size;
    int64_t max_integer_factor_size;
    int64_t max_in_core_store;
    double array_increase_factor;
    double array_decrease_factor;
    int64_t pivot_control;
    int64_t ordering;
    int64_t full_row_threshold;
    int64_t row_search_indefinite;
    int64_t scaling;
    int64_t scale_maxit;
    double scale_thresh;
    double relative_pivot_tolerance;
    double minimum_pivot_tolerance;
    double absolute_pivot_tolerance;
    double zero_tolerance;
    double zero_pivot_tolerance;
    double negative_pivot_tolerance;
    double static_pivot_tolerance;
    double static_level_switch;
    double consistency_tolerance;
    int64_t max_iterative_refinements;
    double acceptable_residual_relative;
    double acceptable_residual_absolute;
    bool multiple_rhs;
    bool generate_matrix_file;
    int64_t matrix_file_device;
    char matrix_file_name[31];
    char out_of_core_directory[401];
    char out_of_core_integer_factor_file[401];
    char out_of_core_real_factor_file[401];
    char out_of_core_real_work_file[401];
    char out_of_core_indefinite_file[401];
    char out_of_core_restart_file[501];
    char prefix[31];
    struct nodend_control_type_64 nodend_control;
};

struct sls_time_type {
    double total;
    double analyse;
    double factorize;
    double solve;
    double order_external;
    double analyse_external;
    double factorize_external;
    double solve_external;
    double clock_total;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
    double clock_order_external;
    double clock_analyse_external;
    double clock_factorize_external;
    double clock_solve_external;
};

struct sls_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t more_info;
    int32_t entries;
    int32_t out_of_range;
    int32_t duplicates;
    int32_t upper;
    int32_t missing_diagonals;
    int32_t max_depth_assembly_tree;
    int32_t nodes_assembly_tree;
    int64_t real_size_desirable;
    int64_t integer_size_desirable;
    int64_t real_size_necessary;
    int64_t integer_size_necessary;
    int64_t real_size_factors;
    int64_t integer_size_factors;
    int64_t entries_in_factors;
    int32_t max_task_pool_size;
    int32_t max_front_size;
    int32_t compresses_real;
    int32_t compresses_integer;
    int32_t two_by_two_pivots;
    int32_t semi_bandwidth;
    int32_t delayed_pivots;
    int32_t pivot_sign_changes;
    int32_t static_pivots;
    int32_t first_modified_pivot;
    int32_t rank;
    int32_t negative_eigenvalues;
    int32_t num_zero;
    int32_t iterative_refinements;
    int64_t flops_assembly;
    int64_t flops_elimination;
    int64_t flops_blas;
    double largest_modified_pivot;
    double minimum_scaling_factor;
    double maximum_scaling_factor;
    double condition_number_1;
    double condition_number_2;
    double backward_error_1;
    double backward_error_2;
    double forward_error;
    bool alternative;
    char solver[21];
    struct sls_time_type time;
    struct sils_ainfo_type sils_ainfo;
    struct sils_finfo_type sils_finfo;
    struct sils_sinfo_type sils_sinfo;
    struct ma57_ainfo ma57_ainfo;
    struct ma57_finfo ma57_finfo;
    struct ma57_sinfo ma57_sinfo;
    struct ma77_info ma77_info;
    struct ma86_info ma86_info;
    struct ma87_info ma87_info;
    struct ma97_info ma97_info;
    struct spral_ssids_inform ssids_inform;
    struct nodend_inform_type nodend_inform;
    int32_t mc61_info[10];
    double mc61_rinfo[15];
    struct mc64_info mc64_info;
    struct mc68_info mc68_info;
    int32_t mc77_info[10];
    double mc77_rinfo[10];
    int32_t mumps_error;
    int32_t mumps_info[80];
    double mumps_rinfo[40];
    int32_t pardiso_error;
    int32_t pardiso_IPARM[64];
    double pardiso_DPARM[64];
    int32_t mkl_pardiso_error;
    int32_t mkl_pardiso_IPARM[64];
    int32_t pastix_info;
    int32_t wsmp_error;
    int32_t wsmp_iparm[64];
    double wsmp_dparm[64];
    int32_t mpi_ierr;
    int32_t lapack_error;
};

struct sls_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t more_info;
    int64_t entries;
    int64_t out_of_range;
    int64_t duplicates;
    int64_t upper;
    int64_t missing_diagonals;
    int64_t max_depth_assembly_tree;
    int64_t nodes_assembly_tree;
    int64_t real_size_desirable;
    int64_t integer_size_desirable;
    int64_t real_size_necessary;
    int64_t integer_size_necessary;
    int64_t real_size_factors;
    int64_t integer_size_factors;
    int64_t entries_in_factors;
    int64_t max_task_pool_size;
    int64_t max_front_size;
    int64_t compresses_real;
    int64_t compresses_integer;
    int64_t two_by_two_pivots;
    int64_t semi_bandwidth;
    int64_t delayed_pivots;
    int64_t pivot_sign_changes;
    int64_t static_pivots;
    int64_t first_modified_pivot;
    int64_t rank;
    int64_t negative_eigenvalues;
    int64_t num_zero;
    int64_t iterative_refinements;
    int64_t flops_assembly;
    int64_t flops_elimination;
    int64_t flops_blas;
    double largest_modified_pivot;
    double minimum_scaling_factor;
    double maximum_scaling_factor;
    double condition_number_1;
    double condition_number_2;
    double backward_error_1;
    double backward_error_2;
    double forward_error;
    bool alternative;
    char solver[21];
    struct sls_time_type time;
    struct sils_ainfo_type_64 sils_ainfo;
    struct sils_finfo_type_64 sils_finfo;
    struct sils_sinfo_type_64 sils_sinfo;
    struct ma57_ainfo_64 ma57_ainfo;
    struct ma57_finfo_64 ma57_finfo;
    struct ma57_sinfo_64 ma57_sinfo;
    struct ma77_info_64 ma77_info;
    struct ma86_info_64 ma86_info;
    struct ma87_info_64 ma87_info;
    struct ma97_info_64 ma97_info;
    struct spral_ssids_inform_64 ssids_inform;
    struct nodend_inform_type_64 nodend_inform;
    int64_t mc61_info[10];
    double mc61_rinfo[15];
    struct mc64_info_64 mc64_info;
    struct mc68_info_64 mc68_info;
    int64_t mc77_info[10];
    double mc77_rinfo[10];
    int64_t mumps_error;
    int64_t mumps_info[80];
    double mumps_rinfo[40];
    int64_t pardiso_error;
    int64_t pardiso_IPARM[64];
    double pardiso_DPARM[64];
    int64_t mkl_pardiso_error;
    int64_t mkl_pardiso_IPARM[64];
    int64_t pastix_info;
    int64_t wsmp_error;
    int64_t wsmp_iparm[64];
    double wsmp_dparm[64];
    int64_t mpi_ierr;
    int64_t lapack_error;
};

void sls_initialize(char *solver, void **data, struct sls_control_type *control, int32_t *status);
void sls_initialize_64(char *solver, void **data, struct sls_control_type_64 *control, int64_t *status);
void sls_read_specfile(struct sls_control_type *control, char *specfile);
void sls_read_specfile_64(struct sls_control_type_64 *control, char *specfile);
void sls_analyse_matrix(struct sls_control_type *control, void **data, int32_t *status, int32_t n, char *type, int32_t ne, int32_t *row, int32_t *col, int32_t *ptr);
void sls_analyse_matrix_64(struct sls_control_type_64 *control, void **data, int64_t *status, int64_t n, char *type, int64_t ne, int64_t *row, int64_t *col, int64_t *ptr);
void sls_reset_control(struct sls_control_type *control, void **data, int32_t *status);
void sls_reset_control_64(struct sls_control_type_64 *control, void **data, int64_t *status);
void sls_factorize_matrix(void **data, int32_t *status, int32_t ne, double *val);
void sls_factorize_matrix_64(void **data, int64_t *status, int64_t ne, double *val);
void sls_solve_system(void **data, int32_t *status, int32_t n, double *sol);
void sls_solve_system_64(void **data, int64_t *status, int64_t n, double *sol);
void sls_partial_solve_system(char *part, void **data, int32_t *status, int32_t n, double *sol);
void sls_partial_solve_system_64(char *part, void **data, int64_t *status, int64_t n, double *sol);
void sls_information(void **data, struct sls_inform_type *inform, int32_t *status);
void sls_information_64(void **data, struct sls_inform_type_64 *inform, int64_t *status);
void sls_terminate(void **data, struct sls_control_type *control, struct sls_inform_type *inform);
void sls_terminate_64(void **data, struct sls_control_type_64 *control, struct sls_inform_type_64 *inform);

// C interface for RQS
struct rqs_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t problem;
    int32_t print_level;
    int32_t dense_factorization;
    int32_t new_h;
    int32_t new_m;
    int32_t new_a;
    int32_t max_factorizations;
    int32_t inverse_itmax;
    int32_t taylor_max_degree;
    double initial_multiplier;
    double lower;
    double upper;
    double stop_normal;
    double stop_hard;
    double start_invit_tol;
    double start_invitmax_tol;
    bool use_initial_multiplier;
    bool initialize_approx_eigenvector;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type sls_control;
    struct ir_control_type ir_control;
};

struct rqs_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t problem;
    int64_t print_level;
    int64_t dense_factorization;
    int64_t new_h;
    int64_t new_m;
    int64_t new_a;
    int64_t max_factorizations;
    int64_t inverse_itmax;
    int64_t taylor_max_degree;
    double initial_multiplier;
    double lower;
    double upper;
    double stop_normal;
    double stop_hard;
    double start_invit_tol;
    double start_invitmax_tol;
    bool use_initial_multiplier;
    bool initialize_approx_eigenvector;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_64 sls_control;
    struct ir_control_type_64 ir_control;
};

struct rqs_time_type {
    double total;
    double assemble;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_assemble;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct rqs_history_type {
    double lambda;
    double x_norm;
};

struct rqs_inform_type {
    int32_t status;
    int32_t alloc_status;
    int32_t factorizations;
    int64_t max_entries_factors;
    int32_t len_history;
    double obj;
    double obj_regularized;
    double x_norm;
    double multiplier;
    double pole;
    bool dense_factorization;
    bool hard_case;
    char bad_alloc[81];
    struct rqs_time_type time;
    struct rqs_history_type history[100];
    struct sls_inform_type sls_inform;
    struct ir_inform_type ir_inform;
};

struct rqs_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorizations;
    int64_t max_entries_factors;
    int64_t len_history;
    double obj;
    double obj_regularized;
    double x_norm;
    double multiplier;
    double pole;
    bool dense_factorization;
    bool hard_case;
    char bad_alloc[81];
    struct rqs_time_type time;
    struct rqs_history_type history[100];
    struct sls_inform_type_64 sls_inform;
    struct ir_inform_type_64 ir_inform;
};

void rqs_initialize(void **data, struct rqs_control_type *control, int32_t *status);
void rqs_initialize_64(void **data, struct rqs_control_type_64 *control, int64_t *status);
void rqs_read_specfile(struct rqs_control_type *control, char *specfile);
void rqs_read_specfile_64(struct rqs_control_type_64 *control, char *specfile);
void rqs_import(struct rqs_control_type *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void rqs_import_64(struct rqs_control_type_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void rqs_import_m(void **data, int32_t *status, int32_t n, char *M_type, int32_t M_ne, int32_t *M_row, int32_t *M_col, int32_t *M_ptr);
void rqs_import_m_64(void **data, int64_t *status, int64_t n, char *M_type, int64_t M_ne, int64_t *M_row, int64_t *M_col, int64_t *M_ptr);
void rqs_import_a(void **data, int32_t *status, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void rqs_import_a_64(void **data, int64_t *status, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void rqs_reset_control(struct rqs_control_type *control, void **data, int32_t *status);
void rqs_reset_control_64(struct rqs_control_type_64 *control, void **data, int64_t *status);
void rqs_solve_problem(void **data, int32_t *status, int32_t n, double power, double weight, double f, double *c, int32_t H_ne, double *H_val, double *x, int32_t M_ne, double *M_val, int32_t m, int32_t A_ne, double *A_val, double *y);
void rqs_solve_problem_64(void **data, int64_t *status, int64_t n, double power, double weight, double f, double *c, int64_t H_ne, double *H_val, double *x, int64_t M_ne, double *M_val, int64_t m, int64_t A_ne, double *A_val, double *y);
void rqs_information(void **data, struct rqs_inform_type *inform, int32_t *status);
void rqs_information_64(void **data, struct rqs_inform_type_64 *inform, int64_t *status);
void rqs_terminate(void **data, struct rqs_control_type *control, struct rqs_inform_type *inform);
void rqs_terminate_64(void **data, struct rqs_control_type_64 *control, struct rqs_inform_type_64 *inform);

// C interface for DPS
struct dps_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t problem;
    int32_t print_level;
    int32_t new_h;
    int32_t taylor_max_degree;
    double eigen_min;
    double lower;
    double upper;
    double stop_normal;
    double stop_absolute_normal;
    bool goldfarb;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type sls_control;
};

struct dps_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t problem;
    int64_t print_level;
    int64_t new_h;
    int64_t taylor_max_degree;
    double eigen_min;
    double lower;
    double upper;
    double stop_normal;
    double stop_absolute_normal;
    bool goldfarb;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_64 sls_control;
};

struct dps_time_type {
    double total;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct dps_inform_type {
    int32_t status;
    int32_t alloc_status;
    int32_t mod_1by1;
    int32_t mod_2by2;
    double obj;
    double obj_regularized;
    double x_norm;
    double multiplier;
    double pole;
    bool hard_case;
    char bad_alloc[81];
    struct dps_time_type time;
    struct sls_inform_type sls_inform;
};

struct dps_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t mod_1by1;
    int64_t mod_2by2;
    double obj;
    double obj_regularized;
    double x_norm;
    double multiplier;
    double pole;
    bool hard_case;
    char bad_alloc[81];
    struct dps_time_type time;
    struct sls_inform_type_64 sls_inform;
};

void dps_initialize(void **data, struct dps_control_type *control, int32_t *status);
void dps_initialize_64(void **data, struct dps_control_type_64 *control, int64_t *status);
void dps_read_specfile(struct dps_control_type *control, char *specfile);
void dps_read_specfile_64(struct dps_control_type_64 *control, char *specfile);
void dps_import(struct dps_control_type *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void dps_import_64(struct dps_control_type_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void dps_reset_control(struct dps_control_type *control, void **data, int32_t *status);
void dps_reset_control_64(struct dps_control_type_64 *control, void **data, int64_t *status);
void dps_solve_tr_problem(void **data, int32_t *status, int32_t n, int32_t ne, double *H_val, double *c, double f, double radius, double *x);
void dps_solve_tr_problem_64(void **data, int64_t *status, int64_t n, int64_t ne, double *H_val, double *c, double f, double radius, double *x);
void dps_solve_rq_problem(void **data, int32_t *status, int32_t n, int32_t ne, double *H_val, double *c, double f, double power, double weight, double *x);
void dps_solve_rq_problem_64(void **data, int64_t *status, int64_t n, int64_t ne, double *H_val, double *c, double f, double power, double weight, double *x);
void dps_resolve_tr_problem(void **data, int32_t *status, int32_t n, double *c, double f, double radius, double *x);
void dps_resolve_tr_problem_64(void **data, int64_t *status, int64_t n, double *c, double f, double radius, double *x);
void dps_resolve_rq_problem(void **data, int32_t *status, int32_t n, double *c, double f, double power, double weight, double *x);
void dps_resolve_rq_problem_64(void **data, int64_t *status, int64_t n, double *c, double f, double power, double weight, double *x);
void dps_information(void **data, struct dps_inform_type *inform, int32_t *status);
void dps_information_64(void **data, struct dps_inform_type_64 *inform, int64_t *status);
void dps_terminate(void **data, struct dps_control_type *control, struct dps_inform_type *inform);
void dps_terminate_64(void **data, struct dps_control_type_64 *control, struct dps_inform_type_64 *inform);

// C interface for PSLS
struct psls_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t preconditioner;
    int32_t semi_bandwidth;
    int32_t scaling;
    int32_t ordering;
    int32_t max_col;
    int32_t icfs_vectors;
    int32_t mi28_lsize;
    int32_t mi28_rsize;
    double min_diagonal;
    bool new_structure;
    bool get_semi_bandwidth;
    bool get_norm_residual;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type sls_control;
    struct mi28_control mi28_control;
};

struct psls_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t preconditioner;
    int64_t semi_bandwidth;
    int64_t scaling;
    int64_t ordering;
    int64_t max_col;
    int64_t icfs_vectors;
    int64_t mi28_lsize;
    int64_t mi28_rsize;
    double min_diagonal;
    bool new_structure;
    bool get_semi_bandwidth;
    bool get_norm_residual;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_64 sls_control;
    struct mi28_control_64 mi28_control;
};

struct psls_time_type {
    float total;
    float assemble;
    float analyse;
    float factorize;
    float solve;
    float update;
    double clock_total;
    double clock_assemble;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
    double clock_update;
};

struct psls_inform_type {
    int32_t status;
    int32_t alloc_status;
    int32_t analyse_status;
    int32_t factorize_status;
    int32_t solve_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t preconditioner;
    int32_t semi_bandwidth;
    int32_t reordered_semi_bandwidth;
    int32_t out_of_range;
    int32_t duplicates;
    int32_t upper;
    int32_t missing_diagonals;
    int32_t semi_bandwidth_used;
    int32_t neg1;
    int32_t neg2;
    bool perturbed;
    double fill_in_ratio;
    double norm_residual;
    char bad_alloc[81];
    int32_t mc61_info[10];
    double mc61_rinfo[15];
    struct psls_time_type time;
    struct sls_inform_type sls_inform;
    struct mi28_info mi28_info;
};

struct psls_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t analyse_status;
    int64_t factorize_status;
    int64_t solve_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t preconditioner;
    int64_t semi_bandwidth;
    int64_t reordered_semi_bandwidth;
    int64_t out_of_range;
    int64_t duplicates;
    int64_t upper;
    int64_t missing_diagonals;
    int64_t semi_bandwidth_used;
    int64_t neg1;
    int64_t neg2;
    bool perturbed;
    double fill_in_ratio;
    double norm_residual;
    char bad_alloc[81];
    int64_t mc61_info[10];
    double mc61_rinfo[15];
    struct psls_time_type time;
    struct sls_inform_type_64 sls_inform;
    struct mi28_info_64 mi28_info;
};

void psls_initialize(void **data, struct psls_control_type *control, int32_t *status);
void psls_initialize_64(void **data, struct psls_control_type_64 *control, int64_t *status);
void psls_read_specfile(struct psls_control_type *control, char *specfile);
void psls_read_specfile_64(struct psls_control_type_64 *control, char *specfile);
void psls_import(struct psls_control_type *control, void **data, int32_t *status, int32_t n, char *type, int32_t ne, int32_t *row, int32_t *col, int32_t *ptr);
void psls_import_64(struct psls_control_type_64 *control, void **data, int64_t *status, int64_t n, char *type, int64_t ne, int64_t *row, int64_t *col, int64_t *ptr);
void psls_reset_control(struct psls_control_type *control, void **data, int32_t *status);
void psls_reset_control_64(struct psls_control_type_64 *control, void **data, int64_t *status);
void psls_form_preconditioner(void **data, int32_t *status, int32_t ne, double *val);
void psls_form_preconditioner_64(void **data, int64_t *status, int64_t ne, double *val);
void psls_form_subset_preconditioner(void **data, int32_t *status, int32_t ne, double *val, int32_t n_sub, int32_t *sub);
void psls_form_subset_preconditioner_64(void **data, int64_t *status, int64_t ne, double *val, int64_t n_sub, int64_t *sub);
void psls_update_preconditioner(void **data, int32_t *status, int32_t ne, double *val, int32_t n_del, int32_t *del);
void psls_update_preconditioner_64(void **data, int64_t *status, int64_t ne, double *val, int64_t n_del, int64_t *del);
void psls_apply_preconditioner(void **data, int32_t *status, int32_t n, double *sol);
void psls_apply_preconditioner_64(void **data, int64_t *status, int64_t n, double *sol);
void psls_information(void **data, struct psls_inform_type *inform, int32_t *status);
void psls_information_64(void **data, struct psls_inform_type_64 *inform, int64_t *status);
void psls_terminate(void **data, struct psls_control_type *control, struct psls_inform_type *inform);
void psls_terminate_64(void **data, struct psls_control_type_64 *control, struct psls_inform_type_64 *inform);

// C interface for ARC
struct arc_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t non_monotone;
    int32_t model;
    int32_t norm;
    int32_t semi_bandwidth;
    int32_t lbfgs_vectors;
    int32_t max_dxg;
    int32_t icfs_vectors;
    int32_t mi28_lsize;
    int32_t mi28_rsize;
    int32_t advanced_start;
    double stop_g_absolute;
    double stop_g_relative;
    double stop_s;
    double initial_weight;
    double minimum_weight;
    double reduce_gap;
    double tiny_gap;
    double large_root;
    double eta_successful;
    double eta_very_successful;
    double eta_too_successful;
    double weight_decrease_min;
    double weight_decrease;
    double weight_increase;
    double weight_increase_max;
    double obj_unbounded;
    double cpu_time_limit;
    double clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool renormalize_weight;
    bool quadratic_ratio_test;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type rqs_control;
    struct glrt_control_type glrt_control;
    struct dps_control_type dps_control;
    struct psls_control_type psls_control;
    struct lms_control_type lms_control;
    struct lms_control_type lms_control_prec;
    struct sha_control_type sha_control;
};

struct arc_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t non_monotone;
    int64_t model;
    int64_t norm;
    int64_t semi_bandwidth;
    int64_t lbfgs_vectors;
    int64_t max_dxg;
    int64_t icfs_vectors;
    int64_t mi28_lsize;
    int64_t mi28_rsize;
    int64_t advanced_start;
    double stop_g_absolute;
    double stop_g_relative;
    double stop_s;
    double initial_weight;
    double minimum_weight;
    double reduce_gap;
    double tiny_gap;
    double large_root;
    double eta_successful;
    double eta_very_successful;
    double eta_too_successful;
    double weight_decrease_min;
    double weight_decrease;
    double weight_increase;
    double weight_increase_max;
    double obj_unbounded;
    double cpu_time_limit;
    double clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool renormalize_weight;
    bool quadratic_ratio_test;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_64 rqs_control;
    struct glrt_control_type_64 glrt_control;
    struct dps_control_type_64 dps_control;
    struct psls_control_type_64 psls_control;
    struct lms_control_type_64 lms_control;
    struct lms_control_type_64 lms_control_prec;
    struct sha_control_type_64 sha_control;
};

struct arc_time_type {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    double clock_total;
    double clock_preprocess;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct arc_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    int32_t factorization_max;
    int32_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    double factorization_average;
    double obj;
    double norm_g;
    double weight;
    struct arc_time_type time;
    struct rqs_inform_type rqs_inform;
    struct glrt_inform_type glrt_inform;
    struct dps_inform_type dps_inform;
    struct psls_inform_type psls_inform;
    struct lms_inform_type lms_inform;
    struct lms_inform_type lms_inform_prec;
    struct sha_inform_type sha_inform;
};

struct arc_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    int64_t factorization_max;
    int64_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    double factorization_average;
    double obj;
    double norm_g;
    double weight;
    struct arc_time_type time;
    struct rqs_inform_type_64 rqs_inform;
    struct glrt_inform_type_64 glrt_inform;
    struct dps_inform_type_64 dps_inform;
    struct psls_inform_type_64 psls_inform;
    struct lms_inform_type_64 lms_inform;
    struct lms_inform_type_64 lms_inform_prec;
    struct sha_inform_type_64 sha_inform;
};

void arc_initialize(void **data, struct arc_control_type *control, int32_t *status);
void arc_initialize_64(void **data, struct arc_control_type_64 *control, int64_t *status);
void arc_read_specfile(struct arc_control_type *control, char *specfile);
void arc_read_specfile_64(struct arc_control_type_64 *control, char *specfile);
void arc_import(struct arc_control_type *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void arc_import_64(struct arc_control_type_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void arc_reset_control(struct arc_control_type *control, void **data, int32_t *status);
void arc_reset_control_64(struct arc_control_type_64 *control, void **data, int64_t *status);
void arc_solve_with_mat(void **data, void *userdata, int32_t *status, int32_t n, double *x, double *g, int32_t ne, galahad_f *eval_f, galahad_g *eval_g, galahad_h *eval_h, galahad_prec *eval_prec);
void arc_solve_with_mat_64(void **data, void *userdata, int64_t *status, int64_t n, double *x, double *g, int64_t ne, galahad_f_64 *eval_f, galahad_g_64 *eval_g, galahad_h_64 *eval_h, galahad_prec_64 *eval_prec);
void arc_solve_without_mat(void **data, void *userdata, int32_t *status, int32_t n, double *x, double *g, galahad_f *eval_f, galahad_g *eval_g, galahad_hprod *eval_hprod, galahad_prec *eval_prec);
void arc_solve_without_mat_64(void **data, void *userdata, int64_t *status, int64_t n, double *x, double *g, galahad_f_64 *eval_f, galahad_g_64 *eval_g, galahad_hprod_64 *eval_hprod, galahad_prec_64 *eval_prec);
void arc_solve_reverse_with_mat(void **data, int32_t *status, int32_t *eval_status, int32_t n, double *x, double f, double *g, int32_t ne, double *H_val, double *u, double *v);
void arc_solve_reverse_with_mat_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, double *x, double f, double *g, int64_t ne, double *H_val, double *u, double *v);
void arc_solve_reverse_without_mat(void **data, int32_t *status, int32_t *eval_status, int32_t n, double *x, double f, double *g, double *u, double *v);
void arc_solve_reverse_without_mat_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, double *x, double f, double *g, double *u, double *v);
void arc_information(void **data, struct arc_inform_type *inform, int32_t *status);
void arc_information_64(void **data, struct arc_inform_type_64 *inform, int64_t *status);
void arc_terminate(void **data, struct arc_control_type *control, struct arc_inform_type *inform);
void arc_terminate_64(void **data, struct arc_control_type_64 *control, struct arc_inform_type_64 *inform);

// C interface for TRS
struct trs_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t problem;
    int32_t print_level;
    int32_t dense_factorization;
    int32_t new_h;
    int32_t new_m;
    int32_t new_a;
    int32_t max_factorizations;
    int32_t inverse_itmax;
    int32_t taylor_max_degree;
    double initial_multiplier;
    double lower;
    double upper;
    double stop_normal;
    double stop_absolute_normal;
    double stop_hard;
    double start_invit_tol;
    double start_invitmax_tol;
    bool equality_problem;
    bool use_initial_multiplier;
    bool initialize_approx_eigenvector;
    bool force_Newton;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type sls_control;
    struct ir_control_type ir_control;
};

struct trs_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t problem;
    int64_t print_level;
    int64_t dense_factorization;
    int64_t new_h;
    int64_t new_m;
    int64_t new_a;
    int64_t max_factorizations;
    int64_t inverse_itmax;
    int64_t taylor_max_degree;
    double initial_multiplier;
    double lower;
    double upper;
    double stop_normal;
    double stop_absolute_normal;
    double stop_hard;
    double start_invit_tol;
    double start_invitmax_tol;
    bool equality_problem;
    bool use_initial_multiplier;
    bool initialize_approx_eigenvector;
    bool force_Newton;
    bool space_critical;
    bool deallocate_error_fatal;
    char problem_file[31];
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char prefix[31];
    struct sls_control_type_64 sls_control;
    struct ir_control_type_64 ir_control;
};

struct trs_time_type {
    double total;
    double assemble;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_assemble;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct trs_history_type {
    double lambda;
    double x_norm;
};

struct trs_inform_type {
    int32_t status;
    int32_t alloc_status;
    int32_t factorizations;
    int64_t max_entries_factors;
    int32_t len_history;
    double obj;
    double x_norm;
    double multiplier;
    double pole;
    bool dense_factorization;
    bool hard_case;
    char bad_alloc[81];
    struct trs_time_type time;
    struct trs_history_type history[100];
    struct sls_inform_type sls_inform;
    struct ir_inform_type ir_inform;
};

struct trs_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorizations;
    int64_t max_entries_factors;
    int64_t len_history;
    double obj;
    double x_norm;
    double multiplier;
    double pole;
    bool dense_factorization;
    bool hard_case;
    char bad_alloc[81];
    struct trs_time_type time;
    struct trs_history_type history[100];
    struct sls_inform_type_64 sls_inform;
    struct ir_inform_type_64 ir_inform;
};

void trs_initialize(void **data, struct trs_control_type *control, int32_t *status);
void trs_initialize_64(void **data, struct trs_control_type_64 *control, int64_t *status);
void trs_read_specfile(struct trs_control_type *control, char *specfile);
void trs_read_specfile_64(struct trs_control_type_64 *control, char *specfile);
void trs_import(struct trs_control_type *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void trs_import_64(struct trs_control_type_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void trs_import_m(void **data, int32_t *status, int32_t n, char *M_type, int32_t M_ne, int32_t *M_row, int32_t *M_col, int32_t *M_ptr);
void trs_import_m_64(void **data, int64_t *status, int64_t n, char *M_type, int64_t M_ne, int64_t *M_row, int64_t *M_col, int64_t *M_ptr);
void trs_import_a(void **data, int32_t *status, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void trs_import_a_64(void **data, int64_t *status, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void trs_reset_control(struct trs_control_type *control, void **data, int32_t *status);
void trs_reset_control_64(struct trs_control_type_64 *control, void **data, int64_t *status);
void trs_solve_problem(void **data, int32_t *status, int32_t n, double radius, double f, double *c, int32_t H_ne, double *H_val, double *x, int32_t M_ne, double *M_val, int32_t m, int32_t A_ne, double *A_val, double *y);
void trs_solve_problem_64(void **data, int64_t *status, int64_t n, double radius, double f, double *c, int64_t H_ne, double *H_val, double *x, int64_t M_ne, double *M_val, int64_t m, int64_t A_ne, double *A_val, double *y);
void trs_information(void **data, struct trs_inform_type *inform, int32_t *status);
void trs_information_64(void **data, struct trs_inform_type_64 *inform, int64_t *status);
void trs_terminate(void **data, struct trs_control_type *control, struct trs_inform_type *inform);
void trs_terminate_64(void **data, struct trs_control_type_64 *control, struct trs_inform_type_64 *inform);

// C interface for TRB
struct trb_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t more_toraldo;
    int32_t non_monotone;
    int32_t model;
    int32_t norm;
    int32_t semi_bandwidth;
    int32_t lbfgs_vectors;
    int32_t max_dxg;
    int32_t icfs_vectors;
    int32_t mi28_lsize;
    int32_t mi28_rsize;
    int32_t advanced_start;
    double infinity;
    double stop_pg_absolute;
    double stop_pg_relative;
    double stop_s;
    double initial_radius;
    double maximum_radius;
    double stop_rel_cg;
    double eta_successful;
    double eta_very_successful;
    double eta_too_successful;
    double radius_increase;
    double radius_reduce;
    double radius_reduce_max;
    double obj_unbounded;
    double cpu_time_limit;
    double clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool retrospective_trust_region;
    bool renormalize_radius;
    bool two_norm_tr;
    bool exact_gcp;
    bool accurate_bqp;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct trs_control_type trs_control;
    struct gltr_control_type gltr_control;
    struct psls_control_type psls_control;
    struct lms_control_type lms_control;
    struct lms_control_type lms_control_prec;
    struct sha_control_type sha_control;
};

struct trb_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t more_toraldo;
    int64_t non_monotone;
    int64_t model;
    int64_t norm;
    int64_t semi_bandwidth;
    int64_t lbfgs_vectors;
    int64_t max_dxg;
    int64_t icfs_vectors;
    int64_t mi28_lsize;
    int64_t mi28_rsize;
    int64_t advanced_start;
    double infinity;
    double stop_pg_absolute;
    double stop_pg_relative;
    double stop_s;
    double initial_radius;
    double maximum_radius;
    double stop_rel_cg;
    double eta_successful;
    double eta_very_successful;
    double eta_too_successful;
    double radius_increase;
    double radius_reduce;
    double radius_reduce_max;
    double obj_unbounded;
    double cpu_time_limit;
    double clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool retrospective_trust_region;
    bool renormalize_radius;
    bool two_norm_tr;
    bool exact_gcp;
    bool accurate_bqp;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct trs_control_type_64 trs_control;
    struct gltr_control_type_64 gltr_control;
    struct psls_control_type_64 psls_control;
    struct lms_control_type_64 lms_control;
    struct lms_control_type_64 lms_control_prec;
    struct sha_control_type_64 sha_control;
};

struct trb_time_type {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    double clock_total;
    double clock_preprocess;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct trb_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t cg_maxit;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    int32_t n_free;
    int32_t factorization_status;
    int32_t factorization_max;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    double obj;
    double norm_pg;
    double radius;
    struct trb_time_type time;
    struct trs_inform_type trs_inform;
    struct gltr_inform_type gltr_inform;
    struct psls_inform_type psls_inform;
    struct lms_inform_type lms_inform;
    struct lms_inform_type lms_inform_prec;
    struct sha_inform_type sha_inform;
};

struct trb_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t cg_maxit;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    int64_t n_free;
    int64_t factorization_status;
    int64_t factorization_max;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    double obj;
    double norm_pg;
    double radius;
    struct trb_time_type time;
    struct trs_inform_type_64 trs_inform;
    struct gltr_inform_type_64 gltr_inform;
    struct psls_inform_type_64 psls_inform;
    struct lms_inform_type_64 lms_inform;
    struct lms_inform_type_64 lms_inform_prec;
    struct sha_inform_type_64 sha_inform;
};

void trb_initialize(void **data, struct trb_control_type *control, int32_t *status);
void trb_initialize_64(void **data, struct trb_control_type_64 *control, int64_t *status);
void trb_read_specfile(struct trb_control_type *control, char *specfile);
void trb_read_specfile_64(struct trb_control_type_64 *control, char *specfile);
void trb_import(struct trb_control_type *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void trb_import_64(struct trb_control_type_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void trb_reset_control(struct trb_control_type *control, void **data, int32_t *status);
void trb_reset_control_64(struct trb_control_type_64 *control, void **data, int64_t *status);
void trb_solve_with_mat(void **data, void *userdata, int32_t *status, int32_t n, double *x_l, double *x_u, double *x, double *g, int32_t ne, galahad_f *eval_f, galahad_g *eval_g, galahad_h *eval_h, galahad_prec *eval_prec);
void trb_solve_with_mat_64(void **data, void *userdata, int64_t *status, int64_t n, double *x_l, double *x_u, double *x, double *g, int64_t ne, galahad_f_64 *eval_f, galahad_g_64 *eval_g, galahad_h_64 *eval_h, galahad_prec_64 *eval_prec);
void trb_solve_without_mat(void **data, void *userdata, int32_t *status, int32_t n, double *x_l, double *x_u, double *x, double *g, galahad_f *eval_f, galahad_g *eval_g, galahad_hprod *eval_hprod, galahad_shprod *eval_shprod, galahad_prec *eval_prec);
void trb_solve_without_mat_64(void **data, void *userdata, int64_t *status, int64_t n, double *x_l, double *x_u, double *x, double *g, galahad_f_64 *eval_f, galahad_g_64 *eval_g, galahad_hprod_64 *eval_hprod, galahad_shprod_64 *eval_shprod, galahad_prec_64 *eval_prec);
void trb_solve_reverse_with_mat(void **data, int32_t *status, int32_t *eval_status, int32_t n, double *x_l, double *x_u, double *x, double f, double *g, int32_t ne, double *H_val, double *u, double *v);
void trb_solve_reverse_with_mat_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, double *x_l, double *x_u, double *x, double f, double *g, int64_t ne, double *H_val, double *u, double *v);
void trb_solve_reverse_without_mat(void **data, int32_t *status, int32_t *eval_status, int32_t n, double *x_l, double *x_u, double *x, double f, double *g, double *u, double *v, int32_t *index_nz_v, int32_t *nnz_v, int32_t *index_nz_u, int32_t nnz_u);
void trb_solve_reverse_without_mat_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, double *x_l, double *x_u, double *x, double f, double *g, double *u, double *v, int64_t *index_nz_v, int64_t *nnz_v, int64_t *index_nz_u, int64_t nnz_u);
void trb_information(void **data, struct trb_inform_type *inform, int32_t *status);
void trb_information_64(void **data, struct trb_inform_type_64 *inform, int64_t *status);
void trb_terminate(void **data, struct trb_control_type *control, struct trb_inform_type *inform);
void trb_terminate_64(void **data, struct trb_control_type_64 *control, struct trb_inform_type_64 *inform);

// C interface for BGO
struct bgo_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t attempts_max;
    int32_t max_evals;
    int32_t sampling_strategy;
    int32_t hypercube_discretization;
    int32_t alive_unit;
    char alive_file[31];
    double infinity;
    double obj_unbounded;
    double cpu_time_limit;
    double clock_time_limit;
    bool random_multistart;
    bool hessian_available;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct ugo_control_type ugo_control;
    struct lhs_control_type lhs_control;
    struct trb_control_type trb_control;
};

struct bgo_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t attempts_max;
    int64_t max_evals;
    int64_t sampling_strategy;
    int64_t hypercube_discretization;
    int64_t alive_unit;
    char alive_file[31];
    double infinity;
    double obj_unbounded;
    double cpu_time_limit;
    double clock_time_limit;
    bool random_multistart;
    bool hessian_available;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct ugo_control_type_64 ugo_control;
    struct lhs_control_type_64 lhs_control;
    struct trb_control_type_64 trb_control;
};

struct bgo_time_type {
    float total;
    float univariate_global;
    float multivariate_local;
    double clock_total;
    double clock_univariate_global;
    double clock_multivariate_local;
};

struct bgo_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    double obj;
    double norm_pg;
    struct bgo_time_type time;
    struct ugo_inform_type ugo_inform;
    struct lhs_inform_type lhs_inform;
    struct trb_inform_type trb_inform;
};

struct bgo_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    double obj;
    double norm_pg;
    struct bgo_time_type time;
    struct ugo_inform_type_64 ugo_inform;
    struct lhs_inform_type_64 lhs_inform;
    struct trb_inform_type_64 trb_inform;
};

void bgo_initialize(void **data, struct bgo_control_type *control, int32_t *status);
void bgo_initialize_64(void **data, struct bgo_control_type_64 *control, int64_t *status);
void bgo_read_specfile(struct bgo_control_type *control, char *specfile);
void bgo_read_specfile_64(struct bgo_control_type_64 *control, char *specfile);
void bgo_import(struct bgo_control_type *control, void **data, int32_t *status, int32_t n, double *x_l, double *x_u, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void bgo_import_64(struct bgo_control_type_64 *control, void **data, int64_t *status, int64_t n, double *x_l, double *x_u, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void bgo_reset_control(struct bgo_control_type *control, void **data, int32_t *status);
void bgo_reset_control_64(struct bgo_control_type_64 *control, void **data, int64_t *status);
void bgo_solve_with_mat(void **data, void *userdata, int32_t *status, int32_t n, double *x, double *g, int32_t ne, galahad_f *eval_f, galahad_g *eval_g, galahad_h *eval_h, galahad_hprod *eval_hprod, galahad_prec *eval_prec);
void bgo_solve_with_mat_64(void **data, void *userdata, int64_t *status, int64_t n, double *x, double *g, int64_t ne, galahad_f_64 *eval_f, galahad_g_64 *eval_g, galahad_h_64 *eval_h, galahad_hprod_64 *eval_hprod, galahad_prec_64 *eval_prec);
void bgo_solve_without_mat(void **data, void *userdata, int32_t *status, int32_t n, double *x, double *g, galahad_f *eval_f, galahad_g *eval_g, galahad_hprod *eval_hprod, galahad_shprod *eval_shprod, galahad_prec *eval_prec);
void bgo_solve_without_mat_64(void **data, void *userdata, int64_t *status, int64_t n, double *x, double *g, galahad_f_64 *eval_f, galahad_g_64 *eval_g, galahad_hprod_64 *eval_hprod, galahad_shprod_64 *eval_shprod, galahad_prec_64 *eval_prec);
void bgo_solve_reverse_with_mat(void **data, int32_t *status, int32_t *eval_status, int32_t n, double *x, double f, double *g, int32_t ne, double *H_val, double *u, double *v);
void bgo_solve_reverse_with_mat_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, double *x, double f, double *g, int64_t ne, double *H_val, double *u, double *v);
void bgo_solve_reverse_without_mat(void **data, int32_t *status, int32_t *eval_status, int32_t n, double *x, double f, double *g, double *u, double *v, int32_t *index_nz_v, int32_t *nnz_v, int32_t *index_nz_u, int32_t nnz_u);
void bgo_solve_reverse_without_mat_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, double *x, double f, double *g, double *u, double *v, int64_t *index_nz_v, int64_t *nnz_v, int64_t *index_nz_u, int64_t nnz_u);
void bgo_information(void **data, struct bgo_inform_type *inform, int32_t *status);
void bgo_information_64(void **data, struct bgo_inform_type_64 *inform, int64_t *status);
void bgo_terminate(void **data, struct bgo_control_type *control, struct bgo_inform_type *inform);
void bgo_terminate_64(void **data, struct bgo_control_type_64 *control, struct bgo_inform_type_64 *inform);

// C interface for ULS
struct uls_control_type {
    bool f_indexing;
    int32_t error;
    int32_t warning;
    int32_t out;
    int32_t print_level;
    int32_t print_level_solver;
    int32_t initial_fill_in_factor;
    int32_t min_real_factor_size;
    int32_t min_integer_factor_size;
    int64_t max_factor_size;
    int32_t blas_block_size_factorize;
    int32_t blas_block_size_solve;
    int32_t pivot_control;
    int32_t pivot_search_limit;
    int32_t minimum_size_for_btf;
    int32_t max_iterative_refinements;
    bool stop_if_singular;
    double array_increase_factor;
    double switch_to_full_code_density;
    double array_decrease_factor;
    double relative_pivot_tolerance;
    double absolute_pivot_tolerance;
    double zero_tolerance;
    double acceptable_residual_relative;
    double acceptable_residual_absolute;
    char prefix[31];
};

struct uls_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t warning;
    int64_t out;
    int64_t print_level;
    int64_t print_level_solver;
    int64_t initial_fill_in_factor;
    int64_t min_real_factor_size;
    int64_t min_integer_factor_size;
    int64_t max_factor_size;
    int64_t blas_block_size_factorize;
    int64_t blas_block_size_solve;
    int64_t pivot_control;
    int64_t pivot_search_limit;
    int64_t minimum_size_for_btf;
    int64_t max_iterative_refinements;
    bool stop_if_singular;
    double array_increase_factor;
    double switch_to_full_code_density;
    double array_decrease_factor;
    double relative_pivot_tolerance;
    double absolute_pivot_tolerance;
    double zero_tolerance;
    double acceptable_residual_relative;
    double acceptable_residual_absolute;
    char prefix[31];
};

struct uls_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t more_info;
    int64_t out_of_range;
    int64_t duplicates;
    int64_t entries_dropped;
    int64_t workspace_factors;
    int32_t compresses;
    int64_t entries_in_factors;
    int32_t rank;
    int32_t structural_rank;
    int32_t pivot_control;
    int32_t iterative_refinements;
    bool alternative;
    char solver[21];
    struct gls_ainfo_type gls_ainfo;
    struct gls_finfo_type gls_finfo;
    struct gls_sinfo_type gls_sinfo;
    struct ma48_ainfo ma48_ainfo;
    struct ma48_finfo ma48_finfo;
    struct ma48_sinfo ma48_sinfo;
    int32_t lapack_error;
};

struct uls_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t more_info;
    int64_t out_of_range;
    int64_t duplicates;
    int64_t entries_dropped;
    int64_t workspace_factors;
    int64_t compresses;
    int64_t entries_in_factors;
    int64_t rank;
    int64_t structural_rank;
    int64_t pivot_control;
    int64_t iterative_refinements;
    bool alternative;
    char solver[21];
    struct gls_ainfo_type_64 gls_ainfo;
    struct gls_finfo_type_64 gls_finfo;
    struct gls_sinfo_type_64 gls_sinfo;
    struct ma48_ainfo_64 ma48_ainfo;
    struct ma48_finfo_64 ma48_finfo;
    struct ma48_sinfo_64 ma48_sinfo;
    int64_t lapack_error;
};

void uls_initialize(char *solver, void **data, struct uls_control_type *control, int32_t *status);
void uls_initialize_64(char *solver, void **data, struct uls_control_type_64 *control, int64_t *status);
void uls_read_specfile(struct uls_control_type *control, char *specfile);
void uls_read_specfile_64(struct uls_control_type_64 *control, char *specfile);
void uls_factorize_matrix(struct uls_control_type *control, void **data, int32_t *status, int32_t m, int32_t n, char *type, int32_t ne, double *val, int32_t *row, int32_t *col, int32_t *ptr);
void uls_factorize_matrix_64(struct uls_control_type_64 *control, void **data, int64_t *status, int64_t m, int64_t n, char *type, int64_t ne, double *val, int64_t *row, int64_t *col, int64_t *ptr);
void uls_reset_control(struct uls_control_type *control, void **data, int32_t *status);
void uls_reset_control_64(struct uls_control_type_64 *control, void **data, int64_t *status);
void uls_solve_system(void **data, int32_t *status, int32_t m, int32_t n, double *sol, bool trans);
void uls_solve_system_64(void **data, int64_t *status, int64_t m, int64_t n, double *sol, bool trans);
void uls_information(void **data, struct uls_inform_type *inform, int32_t *status);
void uls_information_64(void **data, struct uls_inform_type_64 *inform, int64_t *status);
void uls_terminate(void **data, struct uls_control_type *control, struct uls_inform_type *inform);
void uls_terminate_64(void **data, struct uls_control_type_64 *control, struct uls_inform_type_64 *inform);

// C interface for SBLS
struct sbls_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t indmin;
    int32_t valmin;
    int32_t len_ulsmin;
    int32_t itref_max;
    int32_t maxit_pcg;
    int32_t new_a;
    int32_t new_h;
    int32_t new_c;
    int32_t preconditioner;
    int32_t semi_bandwidth;
    int32_t factorization;
    int32_t max_col;
    int32_t scaling;
    int32_t ordering;
    double pivot_tol;
    double pivot_tol_for_basis;
    double zero_pivot;
    double static_tolerance;
    double static_level;
    double min_diagonal;
    double stop_absolute;
    double stop_relative;
    bool remove_dependencies;
    bool find_basis_by_transpose;
    bool affine;
    bool allow_singular;
    bool perturb_to_make_definite;
    bool get_norm_residual;
    bool check_basis;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type sls_control;
    struct uls_control_type uls_control;
};

struct sbls_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t indmin;
    int64_t valmin;
    int64_t len_ulsmin;
    int64_t itref_max;
    int64_t maxit_pcg;
    int64_t new_a;
    int64_t new_h;
    int64_t new_c;
    int64_t preconditioner;
    int64_t semi_bandwidth;
    int64_t factorization;
    int64_t max_col;
    int64_t scaling;
    int64_t ordering;
    double pivot_tol;
    double pivot_tol_for_basis;
    double zero_pivot;
    double static_tolerance;
    double static_level;
    double min_diagonal;
    double stop_absolute;
    double stop_relative;
    bool remove_dependencies;
    bool find_basis_by_transpose;
    bool affine;
    bool allow_singular;
    bool perturb_to_make_definite;
    bool get_norm_residual;
    bool check_basis;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_64 sls_control;
    struct uls_control_type_64 uls_control;
};

struct sbls_time_type {
    double total;
    double form;
    double factorize;
    double apply;
    double clock_total;
    double clock_form;
    double clock_factorize;
    double clock_apply;
};

struct sbls_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t sort_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t preconditioner;
    int32_t factorization;
    int32_t d_plus;
    int32_t rank;
    bool rank_def;
    bool perturbed;
    int32_t iter_pcg;
    double norm_residual;
    bool alternative;
    struct sbls_time_type time;
    struct sls_inform_type sls_inform;
    struct uls_inform_type uls_inform;
};

struct sbls_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t sort_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t preconditioner;
    int64_t factorization;
    int64_t d_plus;
    int64_t rank;
    bool rank_def;
    bool perturbed;
    int64_t iter_pcg;
    double norm_residual;
    bool alternative;
    struct sbls_time_type time;
    struct sls_inform_type_64 sls_inform;
    struct uls_inform_type_64 uls_inform;
};

void sbls_initialize(void **data, struct sbls_control_type *control, int32_t *status);
void sbls_initialize_64(void **data, struct sbls_control_type_64 *control, int64_t *status);
void sbls_read_specfile(struct sbls_control_type *control, char *specfile);
void sbls_read_specfile_64(struct sbls_control_type_64 *control, char *specfile);
void sbls_import(struct sbls_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr, char *C_type, int32_t C_ne, int32_t *C_row, int32_t *C_col, int32_t *C_ptr);
void sbls_import_64(struct sbls_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr, char *C_type, int64_t C_ne, int64_t *C_row, int64_t *C_col, int64_t *C_ptr);
void sbls_reset_control(struct sbls_control_type *control, void **data, int32_t *status);
void sbls_reset_control_64(struct sbls_control_type_64 *control, void **data, int64_t *status);
void sbls_factorize_matrix(void **data, int32_t *status, int32_t n, int32_t h_ne, double *H_val, int32_t a_ne, double *A_val, int32_t c_ne, double *C_val, double *D);
void sbls_factorize_matrix_64(void **data, int64_t *status, int64_t n, int64_t h_ne, double *H_val, int64_t a_ne, double *A_val, int64_t c_ne, double *C_val, double *D);
void sbls_solve_system(void **data, int32_t *status, int32_t n, int32_t m, double *sol);
void sbls_solve_system_64(void **data, int64_t *status, int64_t n, int64_t m, double *sol);
void sbls_information(void **data, struct sbls_inform_type *inform, int32_t *status);
void sbls_information_64(void **data, struct sbls_inform_type_64 *inform, int64_t *status);
void sbls_terminate(void **data, struct sbls_control_type *control, struct sbls_inform_type *inform);
void sbls_terminate_64(void **data, struct sbls_control_type_64 *control, struct sbls_inform_type_64 *inform);

// C interface for BLLS
struct blls_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t cold_start;
    int32_t preconditioner;
    int32_t ratio_cg_vs_sd;
    int32_t change_max;
    int32_t cg_maxit;
    int32_t arcsearch_max_steps;
    int32_t sif_file_device;
    double weight;
    double infinity;
    double stop_d;
    double identical_bounds_tol;
    double stop_cg_relative;
    double stop_cg_absolute;
    double alpha_max;
    double alpha_initial;
    double alpha_reduction;
    double arcsearch_acceptance_tol;
    double stabilisation_weight;
    double cpu_time_limit;
    bool direct_subproblem_solve;
    bool exact_arc_search;
    bool advance;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type sbls_control;
    struct convert_control_type convert_control;
};

struct blls_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t cold_start;
    int64_t preconditioner;
    int64_t ratio_cg_vs_sd;
    int64_t change_max;
    int64_t cg_maxit;
    int64_t arcsearch_max_steps;
    int64_t sif_file_device;
    double weight;
    double infinity;
    double stop_d;
    double identical_bounds_tol;
    double stop_cg_relative;
    double stop_cg_absolute;
    double alpha_max;
    double alpha_initial;
    double alpha_reduction;
    double arcsearch_acceptance_tol;
    double stabilisation_weight;
    double cpu_time_limit;
    bool direct_subproblem_solve;
    bool exact_arc_search;
    bool advance;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_64 sbls_control;
    struct convert_control_type_64 convert_control;
};

struct blls_time_type {
    double total;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct blls_inform_type {
    int32_t status;
    int32_t alloc_status;
    int32_t factorization_status;
    int32_t iter;
    int32_t cg_iter;
    double obj;
    double norm_pg;
    char bad_alloc[81];
    struct blls_time_type time;
    struct sbls_inform_type sbls_inform;
    struct convert_inform_type convert_inform;
};

struct blls_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorization_status;
    int64_t iter;
    int64_t cg_iter;
    double obj;
    double norm_pg;
    char bad_alloc[81];
    struct blls_time_type time;
    struct sbls_inform_type_64 sbls_inform;
    struct convert_inform_type_64 convert_inform;
};

void blls_initialize(void **data, struct blls_control_type *control, int32_t *status);
void blls_initialize_64(void **data, struct blls_control_type_64 *control, int64_t *status);
void blls_read_specfile(struct blls_control_type *control, char *specfile);
void blls_read_specfile_64(struct blls_control_type_64 *control, char *specfile);
void blls_import(struct blls_control_type *control, void **data, int32_t *status, int32_t n, int32_t o, char *Ao_type, int32_t Ao_ne, int32_t *Ao_row, int32_t *Ao_col, int32_t Ao_ptr_ne, int32_t *Ao_ptr);
void blls_import_64(struct blls_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t o, char *Ao_type, int64_t Ao_ne, int64_t *Ao_row, int64_t *Ao_col, int64_t Ao_ptr_ne, int64_t *Ao_ptr);
void blls_import_without_a(struct blls_control_type *control, void **data, int32_t *status, int32_t n, int32_t o);
void blls_import_without_a_64(struct blls_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t o);
void blls_reset_control(struct blls_control_type *control, void **data, int32_t *status);
void blls_reset_control_64(struct blls_control_type_64 *control, void **data, int64_t *status);
void blls_solve_given_a(void **data, void *userdata, int32_t *status, int32_t n, int32_t o, int32_t Ao_ne, double *Ao_val, double *b, double *x_l, double *x_u, double *x, double *z, double *r, double *g, int32_t *x_stat, double *w, galahad_constant_prec *eval_prec);
void blls_solve_given_a_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t o, int64_t Ao_ne, double *Ao_val, double *b, double *x_l, double *x_u, double *x, double *z, double *r, double *g, int64_t *x_stat, double *w, galahad_constant_prec_64 *eval_prec);
void blls_solve_reverse_a_prod(void **data, int32_t *status, int32_t *eval_status, int32_t n, int32_t o, double *b, double *x_l, double *x_u, double *x, double *z, double *r, double *g, int32_t *x_stat, double *v, double *p, int32_t *nz_v, int32_t *nz_v_start, int32_t *nz_v_end, int32_t *nz_p, int32_t nz_p_end, double *w);
void blls_solve_reverse_a_prod_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, int64_t o, double *b, double *x_l, double *x_u, double *x, double *z, double *r, double *g, int64_t *x_stat, double *v, double *p, int64_t *nz_v, int64_t *nz_v_start, int64_t *nz_v_end, int64_t *nz_p, int64_t nz_p_end, double *w);
void blls_information(void **data, struct blls_inform_type *inform, int32_t *status);
void blls_information_64(void **data, struct blls_inform_type_64 *inform, int64_t *status);
void blls_terminate(void **data, struct blls_control_type *control, struct blls_inform_type *inform);
void blls_terminate_64(void **data, struct blls_control_type_64 *control, struct blls_inform_type_64 *inform);

// C interface for BQP
struct bqp_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t cold_start;
    int32_t ratio_cg_vs_sd;
    int32_t change_max;
    int32_t cg_maxit;
    int32_t sif_file_device;
    double infinity;
    double stop_p;
    double stop_d;
    double stop_c;
    double identical_bounds_tol;
    double stop_cg_relative;
    double stop_cg_absolute;
    double zero_curvature;
    double cpu_time_limit;
    bool exact_arcsearch;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type sbls_control;
};

struct bqp_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t cold_start;
    int64_t ratio_cg_vs_sd;
    int64_t change_max;
    int64_t cg_maxit;
    int64_t sif_file_device;
    double infinity;
    double stop_p;
    double stop_d;
    double stop_c;
    double identical_bounds_tol;
    double stop_cg_relative;
    double stop_cg_absolute;
    double zero_curvature;
    double cpu_time_limit;
    bool exact_arcsearch;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_64 sbls_control;
};

struct bqp_inform_type {
    int32_t status;
    int32_t alloc_status;
    int32_t factorization_status;
    int32_t iter;
    int32_t cg_iter;
    double obj;
    double norm_pg;
    char bad_alloc[81];
    struct bqp_time_type time;
    struct sbls_inform_type sbls_inform;
};

struct bqp_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorization_status;
    int64_t iter;
    int64_t cg_iter;
    double obj;
    double norm_pg;
    char bad_alloc[81];
    struct bqp_time_type time;
    struct sbls_inform_type_64 sbls_inform;
};

void bqp_initialize(void **data, struct bqp_control_type *control, int32_t *status);
void bqp_initialize_64(void **data, struct bqp_control_type_64 *control, int64_t *status);
void bqp_read_specfile(struct bqp_control_type *control, char *specfile);
void bqp_read_specfile_64(struct bqp_control_type_64 *control, char *specfile);
void bqp_import(struct bqp_control_type *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void bqp_import_64(struct bqp_control_type_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void bqp_import_without_h(struct bqp_control_type *control, void **data, int32_t *status, int32_t n);
void bqp_import_without_h_64(struct bqp_control_type_64 *control, void **data, int64_t *status, int64_t n);
void bqp_reset_control(struct bqp_control_type *control, void **data, int32_t *status);
void bqp_reset_control_64(struct bqp_control_type_64 *control, void **data, int64_t *status);
void bqp_solve_given_h(void **data, int32_t *status, int32_t n, int32_t h_ne, double *H_val, double *g, double f, double *x_l, double *x_u, double *x, double *z, int32_t *x_stat);
void bqp_solve_given_h_64(void **data, int64_t *status, int64_t n, int64_t h_ne, double *H_val, double *g, double f, double *x_l, double *x_u, double *x, double *z, int64_t *x_stat);
void bqp_solve_reverse_h_prod(void **data, int32_t *status, int32_t n, double *g, double f, double *x_l, double *x_u, double *x, double *z, int32_t *x_stat, double *v, double *prod, int32_t *nz_v, int32_t *nz_v_start, int32_t *nz_v_end, int32_t *nz_prod, int32_t nz_prod_end);
void bqp_solve_reverse_h_prod_64(void **data, int64_t *status, int64_t n, double *g, double f, double *x_l, double *x_u, double *x, double *z, int64_t *x_stat, double *v, double *prod, int64_t *nz_v, int64_t *nz_v_start, int64_t *nz_v_end, int64_t *nz_prod, int64_t nz_prod_end);
void bqp_information(void **data, struct bqp_inform_type *inform, int32_t *status);
void bqp_information_64(void **data, struct bqp_inform_type_64 *inform, int64_t *status);
void bqp_terminate(void **data, struct bqp_control_type *control, struct bqp_inform_type *inform);
void bqp_terminate_64(void **data, struct bqp_control_type_64 *control, struct bqp_inform_type_64 *inform);

// C interface for FDC
struct fdc_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t indmin;
    int32_t valmin;
    double pivot_tol;
    double zero_pivot;
    double max_infeas;
    bool use_sls;
    bool scale;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type sls_control;
    struct uls_control_type uls_control;
};

struct fdc_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t indmin;
    int64_t valmin;
    double pivot_tol;
    double zero_pivot;
    double max_infeas;
    bool use_sls;
    bool scale;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_64 sls_control;
    struct uls_control_type_64 uls_control;
};

struct fdc_time_type {
    double total;
    double analyse;
    double factorize;
    double clock_total;
    double clock_analyse;
    double clock_factorize;
};

struct fdc_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    double non_negligible_pivot;
    struct fdc_time_type time;
    struct sls_inform_type sls_inform;
    struct uls_inform_type uls_inform;
};

struct fdc_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    double non_negligible_pivot;
    struct fdc_time_type time;
    struct sls_inform_type_64 sls_inform;
    struct uls_inform_type_64 uls_inform;
};

void fdc_initialize(void **data, struct fdc_control_type *control, int32_t *status);
void fdc_initialize_64(void **data, struct fdc_control_type_64 *control, int64_t *status);
void fdc_read_specfile(struct fdc_control_type *control, char *specfile);
void fdc_read_specfile_64(struct fdc_control_type_64 *control, char *specfile);
void fdc_find_dependent_rows(struct fdc_control_type *control, void **data, struct fdc_inform_type *inform, int32_t *status, int32_t m, int32_t n, int32_t A_ne, int32_t *A_col, int32_t *A_ptr, double *A_val, double *b, int32_t *n_depen, int32_t *depen);
void fdc_find_dependent_rows_64(struct fdc_control_type_64 *control, void **data, struct fdc_inform_type_64 *inform, int64_t *status, int64_t m, int64_t n, int64_t A_ne, int64_t *A_col, int64_t *A_ptr, double *A_val, double *b, int64_t *n_depen, int64_t *depen);
void fdc_terminate(void **data, struct fdc_control_type *control, struct fdc_inform_type *inform);
void fdc_terminate_64(void **data, struct fdc_control_type_64 *control, struct fdc_inform_type_64 *inform);

// C interface for CRO
struct cro_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t max_schur_complement;
    double infinity;
    double feasibility_tolerance;
    bool check_io;
    bool refine_solution;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type sls_control;
    struct sbls_control_type sbls_control;
    struct uls_control_type uls_control;
    struct ir_control_type ir_control;
};

struct cro_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t max_schur_complement;
    double infinity;
    double feasibility_tolerance;
    bool check_io;
    bool refine_solution;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_64 sls_control;
    struct sbls_control_type_64 sbls_control;
    struct uls_control_type_64 uls_control;
    struct ir_control_type_64 ir_control;
};

struct cro_time_type {
    float total;
    float analyse;
    float factorize;
    float solve;
    double clock_total;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct cro_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t dependent;
    struct cro_time_type time;
    struct sls_inform_type sls_inform;
    struct sbls_inform_type sbls_inform;
    struct uls_inform_type uls_inform;
    int32_t scu_status;
    struct scu_inform_type scu_inform;
    struct ir_inform_type ir_inform;
};

struct cro_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t dependent;
    struct cro_time_type time;
    struct sls_inform_type_64 sls_inform;
    struct sbls_inform_type_64 sbls_inform;
    struct uls_inform_type_64 uls_inform;
    int64_t scu_status;
    struct scu_inform_type_64 scu_inform;
    struct ir_inform_type_64 ir_inform;
};

void cro_initialize(void **data, struct cro_control_type *control, int32_t *status);
void cro_initialize_64(void **data, struct cro_control_type_64 *control, int64_t *status);
void cro_read_specfile(struct cro_control_type *control, char *specfile);
void cro_read_specfile_64(struct cro_control_type_64 *control, char *specfile);
void cro_crossover_solution(void **data, struct cro_control_type *control, struct cro_inform_type *inform, int32_t n, int32_t m, int32_t m_equal, int32_t h_ne, double *H_val, int32_t *H_col, int32_t *H_ptr, int32_t a_ne, double *A_val, int32_t *A_col, int32_t *A_ptr, double *g, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat);
void cro_crossover_solution_64(void **data, struct cro_control_type_64 *control, struct cro_inform_type_64 *inform, int64_t n, int64_t m, int64_t m_equal, int64_t h_ne, double *H_val, int64_t *H_col, int64_t *H_ptr, int64_t a_ne, double *A_val, int64_t *A_col, int64_t *A_ptr, double *g, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat);
void cro_terminate(void **data, struct cro_control_type *control, struct cro_inform_type *inform);
void cro_terminate_64(void **data, struct cro_control_type_64 *control, struct cro_inform_type_64 *inform);

// C interface for BQPB
struct bqpb_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double perturb_h;
    double prfeas;
    double dufeas;
    double muzero;
    double tau;
    double gamma_c;
    double gamma_f;
    double reduce_infeas;
    double obj_unbounded;
    double potential_unbounded;
    double identical_bounds_tol;
    double mu_pounce;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type fdc_control;
    struct sbls_control_type sbls_control;
    struct fit_control_type fit_control;
    struct roots_control_type roots_control;
    struct cro_control_type cro_control;
};

struct bqpb_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double perturb_h;
    double prfeas;
    double dufeas;
    double muzero;
    double tau;
    double gamma_c;
    double gamma_f;
    double reduce_infeas;
    double obj_unbounded;
    double potential_unbounded;
    double identical_bounds_tol;
    double mu_pounce;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_64 fdc_control;
    struct sbls_control_type_64 sbls_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_64 roots_control;
    struct cro_control_type_64 cro_control;
};

struct bqpb_time_type {
    double total;
    double preprocess;
    double find_dependent;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_preprocess;
    double clock_find_dependent;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct bqpb_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    double init_primal_infeasibility;
    double init_dual_infeasibility;
    double init_complementary_slackness;
    double potential;
    double non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    double checkpointsTime[16];
    struct bqpb_time_type time;
    struct fdc_inform_type fdc_inform;
    struct sbls_inform_type sbls_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct bqpb_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    double init_primal_infeasibility;
    double init_dual_infeasibility;
    double init_complementary_slackness;
    double potential;
    double non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    double checkpointsTime[16];
    struct bqpb_time_type time;
    struct fdc_inform_type_64 fdc_inform;
    struct sbls_inform_type_64 sbls_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void bqpb_initialize(void **data, struct bqpb_control_type *control, int32_t *status);
void bqpb_initialize_64(void **data, struct bqpb_control_type_64 *control, int64_t *status);
void bqpb_read_specfile(struct bqpb_control_type *control, char *specfile);
void bqpb_read_specfile_64(struct bqpb_control_type_64 *control, char *specfile);
void bqpb_import(struct bqpb_control_type *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void bqpb_import_64(struct bqpb_control_type_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void bqpb_reset_control(struct bqpb_control_type *control, void **data, int32_t *status);
void bqpb_reset_control_64(struct bqpb_control_type_64 *control, void **data, int64_t *status);
void bqpb_solve_qp(void **data, int32_t *status, int32_t n, int32_t h_ne, double *H_val, double *g, double f, double *x_l, double *x_u, double *x, double *z, int32_t *x_stat);
void bqpb_solve_qp_64(void **data, int64_t *status, int64_t n, int64_t h_ne, double *H_val, double *g, double f, double *x_l, double *x_u, double *x, double *z, int64_t *x_stat);
void bqpb_solve_sldqp(void **data, int32_t *status, int32_t n, double *w, double *x0, double *g, double f, double *x_l, double *x_u, double *x, double *z, int32_t *x_stat);
void bqpb_solve_sldqp_64(void **data, int64_t *status, int64_t n, double *w, double *x0, double *g, double f, double *x_l, double *x_u, double *x, double *z, int64_t *x_stat);
void bqpb_information(void **data, struct bqpb_inform_type *inform, int32_t *status);
void bqpb_information_64(void **data, struct bqpb_inform_type_64 *inform, int64_t *status);
void bqpb_terminate(void **data, struct bqpb_control_type *control, struct bqpb_inform_type *inform);
void bqpb_terminate_64(void **data, struct bqpb_control_type_64 *control, struct bqpb_inform_type_64 *inform);

// C interface for CCQP
struct ccqp_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double perturb_h;
    double prfeas;
    double dufeas;
    double muzero;
    double tau;
    double gamma_c;
    double gamma_f;
    double reduce_infeas;
    double obj_unbounded;
    double potential_unbounded;
    double identical_bounds_tol;
    double mu_pounce;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type fdc_control;
    struct sbls_control_type sbls_control;
    struct sbls_control_type sbls_pounce_control;
    struct fit_control_type fit_control;
    struct roots_control_type roots_control;
    struct cro_control_type cro_control;
};

struct ccqp_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double perturb_h;
    double prfeas;
    double dufeas;
    double muzero;
    double tau;
    double gamma_c;
    double gamma_f;
    double reduce_infeas;
    double obj_unbounded;
    double potential_unbounded;
    double identical_bounds_tol;
    double mu_pounce;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_64 fdc_control;
    struct sbls_control_type_64 sbls_control;
    struct sbls_control_type_64 sbls_pounce_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_64 roots_control;
    struct cro_control_type_64 cro_control;
};

struct ccqp_time_type {
    double total;
    double preprocess;
    double find_dependent;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_preprocess;
    double clock_find_dependent;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct ccqp_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    double init_primal_infeasibility;
    double init_dual_infeasibility;
    double init_complementary_slackness;
    double potential;
    double non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    double checkpointsTime[16];
    struct ccqp_time_type time;
    struct fdc_inform_type fdc_inform;
    struct sbls_inform_type sbls_inform;
    struct sbls_inform_type sbls_pounce_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct ccqp_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    double init_primal_infeasibility;
    double init_dual_infeasibility;
    double init_complementary_slackness;
    double potential;
    double non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    double checkpointsTime[16];
    struct ccqp_time_type time;
    struct fdc_inform_type_64 fdc_inform;
    struct sbls_inform_type_64 sbls_inform;
    struct sbls_inform_type_64 sbls_pounce_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void ccqp_initialize(void **data, struct ccqp_control_type *control, int32_t *status);
void ccqp_initialize_64(void **data, struct ccqp_control_type_64 *control, int64_t *status);
void ccqp_read_specfile(struct ccqp_control_type *control, char *specfile);
void ccqp_read_specfile_64(struct ccqp_control_type_64 *control, char *specfile);
void ccqp_import(struct ccqp_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void ccqp_import_64(struct ccqp_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void ccqp_reset_control(struct ccqp_control_type *control, void **data, int32_t *status);
void ccqp_reset_control_64(struct ccqp_control_type_64 *control, void **data, int64_t *status);
void ccqp_solve_qp(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, double *H_val, double *g, double f, int32_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat);
void ccqp_solve_qp_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, double *H_val, double *g, double f, int64_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat);
void ccqp_solve_sldqp(void **data, int32_t *status, int32_t n, int32_t m, double *w, double *x0, double *g, double f, int32_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat);
void ccqp_solve_sldqp_64(void **data, int64_t *status, int64_t n, int64_t m, double *w, double *x0, double *g, double f, int64_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat);
void ccqp_information(void **data, struct ccqp_inform_type *inform, int32_t *status);
void ccqp_information_64(void **data, struct ccqp_inform_type_64 *inform, int64_t *status);
void ccqp_terminate(void **data, struct ccqp_control_type *control, struct ccqp_inform_type *inform);
void ccqp_terminate_64(void **data, struct ccqp_control_type_64 *control, struct ccqp_inform_type_64 *inform);

// C interface for CQP
struct cqp_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double perturb_h;
    double prfeas;
    double dufeas;
    double muzero;
    double tau;
    double gamma_c;
    double gamma_f;
    double reduce_infeas;
    double obj_unbounded;
    double potential_unbounded;
    double identical_bounds_tol;
    double mu_pounce;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type fdc_control;
    struct sbls_control_type sbls_control;
    struct fit_control_type fit_control;
    struct roots_control_type roots_control;
    struct cro_control_type cro_control;
};

struct cqp_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double perturb_h;
    double prfeas;
    double dufeas;
    double muzero;
    double tau;
    double gamma_c;
    double gamma_f;
    double reduce_infeas;
    double obj_unbounded;
    double potential_unbounded;
    double identical_bounds_tol;
    double mu_pounce;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_64 fdc_control;
    struct sbls_control_type_64 sbls_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_64 roots_control;
    struct cro_control_type_64 cro_control;
};

struct cqp_time_type {
    double total;
    double preprocess;
    double find_dependent;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_preprocess;
    double clock_find_dependent;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct cqp_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    double init_primal_infeasibility;
    double init_dual_infeasibility;
    double init_complementary_slackness;
    double potential;
    double non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    double checkpointsTime[16];
    struct cqp_time_type time;
    struct fdc_inform_type fdc_inform;
    struct sbls_inform_type sbls_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct cqp_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    double init_primal_infeasibility;
    double init_dual_infeasibility;
    double init_complementary_slackness;
    double potential;
    double non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    double checkpointsTime[16];
    struct cqp_time_type time;
    struct fdc_inform_type_64 fdc_inform;
    struct sbls_inform_type_64 sbls_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void cqp_initialize(void **data, struct cqp_control_type *control, int32_t *status);
void cqp_initialize_64(void **data, struct cqp_control_type_64 *control, int64_t *status);
void cqp_read_specfile(struct cqp_control_type *control, char *specfile);
void cqp_read_specfile_64(struct cqp_control_type_64 *control, char *specfile);
void cqp_import(struct cqp_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void cqp_import_64(struct cqp_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void cqp_reset_control(struct cqp_control_type *control, void **data, int32_t *status);
void cqp_reset_control_64(struct cqp_control_type_64 *control, void **data, int64_t *status);
void cqp_solve_qp(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, double *H_val, double *g, double f, int32_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat);
void cqp_solve_qp_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, double *H_val, double *g, double f, int64_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat);
void cqp_solve_sldqp(void **data, int32_t *status, int32_t n, int32_t m, double *w, double *x0, double *g, double f, int32_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat);
void cqp_solve_sldqp_64(void **data, int64_t *status, int64_t n, int64_t m, double *w, double *x0, double *g, double f, int64_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat);
void cqp_information(void **data, struct cqp_inform_type *inform, int32_t *status);
void cqp_information_64(void **data, struct cqp_inform_type_64 *inform, int64_t *status);
void cqp_terminate(void **data, struct cqp_control_type *control, struct cqp_inform_type *inform);
void cqp_terminate_64(void **data, struct cqp_control_type_64 *control, struct cqp_inform_type_64 *inform);

// C interface for CLLS
struct clls_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double prfeas;
    double dufeas;
    double muzero;
    double tau;
    double gamma_c;
    double gamma_f;
    double reduce_infeas;
    double identical_bounds_tol;
    double mu_pounce;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type fdc_control;
    struct sls_control_type sls_control;
    struct sls_control_type sls_pounce_control;
    struct fit_control_type fit_control;
    struct roots_control_type roots_control;
    struct cro_control_type cro_control;
};

struct clls_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double prfeas;
    double dufeas;
    double muzero;
    double tau;
    double gamma_c;
    double gamma_f;
    double reduce_infeas;
    double identical_bounds_tol;
    double mu_pounce;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_64 fdc_control;
    struct sls_control_type_64 sls_control;
    struct sls_control_type_64 sls_pounce_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_64 roots_control;
    struct cro_control_type_64 cro_control;
};

struct clls_time_type {
    double total;
    double preprocess;
    double find_dependent;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_preprocess;
    double clock_find_dependent;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct clls_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    double non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    double checkpointsTime[16];
    struct clls_time_type time;
    struct fdc_inform_type fdc_inform;
    struct sls_inform_type sls_inform;
    struct sls_inform_type sls_pounce_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct clls_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    double non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    double checkpointsTime[16];
    struct clls_time_type time;
    struct fdc_inform_type_64 fdc_inform;
    struct sls_inform_type_64 sls_inform;
    struct sls_inform_type_64 sls_pounce_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void clls_initialize(void **data, struct clls_control_type *control, int32_t *status);
void clls_initialize_64(void **data, struct clls_control_type_64 *control, int64_t *status);
void clls_read_specfile(struct clls_control_type *control, char *specfile);
void clls_read_specfile_64(struct clls_control_type_64 *control, char *specfile);
void clls_import(struct clls_control_type *control, void **data, int32_t *status, int32_t n, int32_t o, int32_t m, char *Ao_type, int32_t Ao_ne, int32_t *Ao_row, int32_t *Ao_col, int32_t Ao_ptr_ne, int32_t *Ao_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t A_ptr_ne, int32_t *A_ptr);
void clls_import_64(struct clls_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t o, int64_t m, char *Ao_type, int64_t Ao_ne, int64_t *Ao_row, int64_t *Ao_col, int64_t Ao_ptr_ne, int64_t *Ao_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t A_ptr_ne, int64_t *A_ptr);
void clls_reset_control(struct clls_control_type *control, void **data, int32_t *status);
void clls_reset_control_64(struct clls_control_type_64 *control, void **data, int64_t *status);
void clls_solve_clls(void **data, int32_t *status, int32_t n, int32_t o, int32_t m, int32_t Ao_ne, double *Ao_val, double *b, double regularization_weight, int32_t A_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *r, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat, double *w);
void clls_solve_clls_64(void **data, int64_t *status, int64_t n, int64_t o, int64_t m, int64_t Ao_ne, double *Ao_val, double *b, double regularization_weight, int64_t A_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *r, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat, double *w);
void clls_information(void **data, struct clls_inform_type *inform, int32_t *status);
void clls_information_64(void **data, struct clls_inform_type_64 *inform, int64_t *status);
void clls_terminate(void **data, struct clls_control_type *control, struct clls_inform_type *inform);
void clls_terminate_64(void **data, struct clls_control_type_64 *control, struct clls_inform_type_64 *inform);

// C interface for DGO
struct dgo_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t max_evals;
    int32_t dictionary_size;
    int32_t alive_unit;
    char alive_file[31];
    double infinity;
    double lipschitz_lower_bound;
    double lipschitz_reliability;
    double lipschitz_control;
    double stop_length;
    double stop_f;
    double obj_unbounded;
    double cpu_time_limit;
    double clock_time_limit;
    bool hessian_available;
    bool prune;
    bool perform_local_optimization;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct hash_control_type hash_control;
    struct ugo_control_type ugo_control;
    struct trb_control_type trb_control;
};

struct dgo_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t max_evals;
    int64_t dictionary_size;
    int64_t alive_unit;
    char alive_file[31];
    double infinity;
    double lipschitz_lower_bound;
    double lipschitz_reliability;
    double lipschitz_control;
    double stop_length;
    double stop_f;
    double obj_unbounded;
    double cpu_time_limit;
    double clock_time_limit;
    bool hessian_available;
    bool prune;
    bool perform_local_optimization;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct hash_control_type_64 hash_control;
    struct ugo_control_type_64 ugo_control;
    struct trb_control_type_64 trb_control;
};

struct dgo_time_type {
    float total;
    float univariate_global;
    float multivariate_local;
    double clock_total;
    double clock_univariate_global;
    double clock_multivariate_local;
};

struct dgo_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    double obj;
    double norm_pg;
    double length_ratio;
    double f_gap;
    char why_stop[2];
    struct dgo_time_type time;
    struct hash_inform_type hash_inform;
    struct ugo_inform_type ugo_inform;
    struct trb_inform_type trb_inform;
};

struct dgo_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    double obj;
    double norm_pg;
    double length_ratio;
    double f_gap;
    char why_stop[2];
    struct dgo_time_type time;
    struct hash_inform_type_64 hash_inform;
    struct ugo_inform_type_64 ugo_inform;
    struct trb_inform_type_64 trb_inform;
};

void dgo_initialize(void **data, struct dgo_control_type *control, int32_t *status);
void dgo_initialize_64(void **data, struct dgo_control_type_64 *control, int64_t *status);
void dgo_read_specfile(struct dgo_control_type *control, char *specfile);
void dgo_read_specfile_64(struct dgo_control_type_64 *control, char *specfile);
void dgo_import(struct dgo_control_type *control, void **data, int32_t *status, int32_t n, double *x_l, double *x_u, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void dgo_import_64(struct dgo_control_type_64 *control, void **data, int64_t *status, int64_t n, double *x_l, double *x_u, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void dgo_reset_control(struct dgo_control_type *control, void **data, int32_t *status);
void dgo_reset_control_64(struct dgo_control_type_64 *control, void **data, int64_t *status);
void dgo_solve_with_mat(void **data, void *userdata, int32_t *status, int32_t n, double *x, double *g, int32_t ne, galahad_f *eval_f, galahad_g *eval_g, galahad_h *eval_h, galahad_hprod *eval_hprod, galahad_prec *eval_prec);
void dgo_solve_with_mat_64(void **data, void *userdata, int64_t *status, int64_t n, double *x, double *g, int64_t ne, galahad_f_64 *eval_f, galahad_g_64 *eval_g, galahad_h_64 *eval_h, galahad_hprod_64 *eval_hprod, galahad_prec_64 *eval_prec);
void dgo_solve_without_mat(void **data, void *userdata, int32_t *status, int32_t n, double *x, double *g, galahad_f *eval_f, galahad_g *eval_g, galahad_hprod *eval_hprod, galahad_shprod *eval_shprod, galahad_prec *eval_prec);
void dgo_solve_without_mat_64(void **data, void *userdata, int64_t *status, int64_t n, double *x, double *g, galahad_f_64 *eval_f, galahad_g_64 *eval_g, galahad_hprod_64 *eval_hprod, galahad_shprod_64 *eval_shprod, galahad_prec_64 *eval_prec);
void dgo_solve_reverse_with_mat(void **data, int32_t *status, int32_t *eval_status, int32_t n, double *x, double f, double *g, int32_t ne, double *H_val, double *u, double *v);
void dgo_solve_reverse_with_mat_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, double *x, double f, double *g, int64_t ne, double *H_val, double *u, double *v);
void dgo_solve_reverse_without_mat(void **data, int32_t *status, int32_t *eval_status, int32_t n, double *x, double f, double *g, double *u, double *v, int32_t *index_nz_v, int32_t *nnz_v, int32_t *index_nz_u, int32_t nnz_u);
void dgo_solve_reverse_without_mat_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, double *x, double f, double *g, double *u, double *v, int64_t *index_nz_v, int64_t *nnz_v, int64_t *index_nz_u, int64_t nnz_u);
void dgo_information(void **data, struct dgo_inform_type *inform, int32_t *status);
void dgo_information_64(void **data, struct dgo_inform_type_64 *inform, int64_t *status);
void dgo_terminate(void **data, struct dgo_control_type *control, struct dgo_inform_type *inform);
void dgo_terminate_64(void **data, struct dgo_control_type_64 *control, struct dgo_inform_type_64 *inform);

// C interface for DQP
struct dqp_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t dual_starting_point;
    int32_t maxit;
    int32_t max_sc;
    int32_t cauchy_only;
    int32_t arc_search_maxit;
    int32_t cg_maxit;
    int32_t explore_optimal_subspace;
    int32_t restore_problem;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    double rho;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double stop_cg_relative;
    double stop_cg_absolute;
    double cg_zero_curvature;
    double max_growth;
    double identical_bounds_tol;
    double cpu_time_limit;
    double clock_time_limit;
    double initial_perturbation;
    double perturbation_reduction;
    double final_perturbation;
    bool factor_optimal_matrix;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool exact_arc_search;
    bool subspace_direct;
    bool subspace_alternate;
    bool subspace_arc_search;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type fdc_control;
    struct sls_control_type sls_control;
    struct sbls_control_type sbls_control;
    struct gltr_control_type gltr_control;
};

struct dqp_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t dual_starting_point;
    int64_t maxit;
    int64_t max_sc;
    int64_t cauchy_only;
    int64_t arc_search_maxit;
    int64_t cg_maxit;
    int64_t explore_optimal_subspace;
    int64_t restore_problem;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    double rho;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double stop_cg_relative;
    double stop_cg_absolute;
    double cg_zero_curvature;
    double max_growth;
    double identical_bounds_tol;
    double cpu_time_limit;
    double clock_time_limit;
    double initial_perturbation;
    double perturbation_reduction;
    double final_perturbation;
    bool factor_optimal_matrix;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool exact_arc_search;
    bool subspace_direct;
    bool subspace_alternate;
    bool subspace_arc_search;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char definite_linear_solver[31];
    char unsymmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_64 fdc_control;
    struct sls_control_type_64 sls_control;
    struct sbls_control_type_64 sbls_control;
    struct gltr_control_type_64 gltr_control;
};

struct dqp_time_type {
    double total;
    double preprocess;
    double find_dependent;
    double analyse;
    double factorize;
    double solve;
    double search;
    double clock_total;
    double clock_preprocess;
    double clock_find_dependent;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
    double clock_search;
};

struct dqp_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t threads;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    double non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    double checkpointsTime[16];
    struct dqp_time_type time;
    struct fdc_inform_type fdc_inform;
    struct sls_inform_type sls_inform;
    struct sbls_inform_type sbls_inform;
    struct gltr_inform_type gltr_inform;
    int32_t scu_status;
    struct scu_inform_type scu_inform;
    struct rpd_inform_type rpd_inform;
};

struct dqp_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t threads;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    double non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    double checkpointsTime[16];
    struct dqp_time_type time;
    struct fdc_inform_type_64 fdc_inform;
    struct sls_inform_type_64 sls_inform;
    struct sbls_inform_type_64 sbls_inform;
    struct gltr_inform_type_64 gltr_inform;
    int64_t scu_status;
    struct scu_inform_type_64 scu_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void dqp_initialize(void **data, struct dqp_control_type *control, int32_t *status);
void dqp_initialize_64(void **data, struct dqp_control_type_64 *control, int64_t *status);
void dqp_read_specfile(struct dqp_control_type *control, char *specfile);
void dqp_read_specfile_64(struct dqp_control_type_64 *control, char *specfile);
void dqp_import(struct dqp_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void dqp_import_64(struct dqp_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void dqp_reset_control(struct dqp_control_type *control, void **data, int32_t *status);
void dqp_reset_control_64(struct dqp_control_type_64 *control, void **data, int64_t *status);
void dqp_solve_qp(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, double *H_val, double *g, double f, int32_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat);
void dqp_solve_qp_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, double *H_val, double *g, double f, int64_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat);
void dqp_solve_sldqp(void **data, int32_t *status, int32_t n, int32_t m, double *w, double *x0, double *g, double f, int32_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat);
void dqp_solve_sldqp_64(void **data, int64_t *status, int64_t n, int64_t m, double *w, double *x0, double *g, double f, int64_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat);
void dqp_information(void **data, struct dqp_inform_type *inform, int32_t *status);
void dqp_information_64(void **data, struct dqp_inform_type_64 *inform, int64_t *status);
void dqp_terminate(void **data, struct dqp_control_type *control, struct dqp_inform_type *inform);
void dqp_terminate_64(void **data, struct dqp_control_type_64 *control, struct dqp_inform_type_64 *inform);

// C interface for EQP
struct eqp_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t factorization;
    int32_t max_col;
    int32_t indmin;
    int32_t valmin;
    int32_t len_ulsmin;
    int32_t itref_max;
    int32_t cg_maxit;
    int32_t preconditioner;
    int32_t semi_bandwidth;
    int32_t new_a;
    int32_t new_h;
    int32_t sif_file_device;
    double pivot_tol;
    double pivot_tol_for_basis;
    double zero_pivot;
    double inner_fraction_opt;
    double radius;
    double min_diagonal;
    double max_infeasibility_relative;
    double max_infeasibility_absolute;
    double inner_stop_relative;
    double inner_stop_absolute;
    double inner_stop_inter;
    bool find_basis_by_transpose;
    bool remove_dependencies;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct fdc_control_type fdc_control;
    struct sbls_control_type sbls_control;
    struct gltr_control_type gltr_control;
};

struct eqp_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t factorization;
    int64_t max_col;
    int64_t indmin;
    int64_t valmin;
    int64_t len_ulsmin;
    int64_t itref_max;
    int64_t cg_maxit;
    int64_t preconditioner;
    int64_t semi_bandwidth;
    int64_t new_a;
    int64_t new_h;
    int64_t sif_file_device;
    double pivot_tol;
    double pivot_tol_for_basis;
    double zero_pivot;
    double inner_fraction_opt;
    double radius;
    double min_diagonal;
    double max_infeasibility_relative;
    double max_infeasibility_absolute;
    double inner_stop_relative;
    double inner_stop_absolute;
    double inner_stop_inter;
    bool find_basis_by_transpose;
    bool remove_dependencies;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct fdc_control_type_64 fdc_control;
    struct sbls_control_type_64 sbls_control;
    struct gltr_control_type_64 gltr_control;
};

struct eqp_time_type {
    double total;
    double find_dependent;
    double factorize;
    double solve;
    double solve_inter;
    double clock_total;
    double clock_find_dependent;
    double clock_factorize;
    double clock_solve;
};

struct eqp_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t cg_iter;
    int32_t cg_iter_inter;
    int64_t factorization_integer;
    int64_t factorization_real;
    double obj;
    struct eqp_time_type time;
    struct fdc_inform_type fdc_inform;
    struct sbls_inform_type sbls_inform;
    struct gltr_inform_type gltr_inform;
};

struct eqp_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t cg_iter;
    int64_t cg_iter_inter;
    int64_t factorization_integer;
    int64_t factorization_real;
    double obj;
    struct eqp_time_type time;
    struct fdc_inform_type_64 fdc_inform;
    struct sbls_inform_type_64 sbls_inform;
    struct gltr_inform_type_64 gltr_inform;
};

void eqp_initialize(void **data, struct eqp_control_type *control, int32_t *status);
void eqp_initialize_64(void **data, struct eqp_control_type_64 *control, int64_t *status);
void eqp_read_specfile(struct eqp_control_type *control, char *specfile);
void eqp_read_specfile_64(struct eqp_control_type_64 *control, char *specfile);
void eqp_import(struct eqp_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void eqp_import_64(struct eqp_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void eqp_reset_control(struct eqp_control_type *control, void **data, int32_t *status);
void eqp_reset_control_64(struct eqp_control_type_64 *control, void **data, int64_t *status);
void eqp_solve_qp(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, double *H_val, double *g, double f, int32_t a_ne, double *A_val, double *c, double *x, double *y);
void eqp_solve_qp_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, double *H_val, double *g, double f, int64_t a_ne, double *A_val, double *c, double *x, double *y);
void eqp_solve_sldqp(void **data, int32_t *status, int32_t n, int32_t m, double *w, double *x0, double *g, double f, int32_t a_ne, double *A_val, double *c, double *x, double *y);
void eqp_solve_sldqp_64(void **data, int64_t *status, int64_t n, int64_t m, double *w, double *x0, double *g, double f, int64_t a_ne, double *A_val, double *c, double *x, double *y);
void eqp_resolve_qp(void **data, int32_t *status, int32_t n, int32_t m, double *g, double f, double *c, double *x, double *y);
void eqp_resolve_qp_64(void **data, int64_t *status, int64_t n, int64_t m, double *g, double f, double *c, double *x, double *y);
void eqp_information(void **data, struct eqp_inform_type *inform, int32_t *status);
void eqp_information_64(void **data, struct eqp_inform_type_64 *inform, int64_t *status);
void eqp_terminate(void **data, struct eqp_control_type *control, struct eqp_inform_type *inform);
void eqp_terminate_64(void **data, struct eqp_control_type_64 *control, struct eqp_inform_type_64 *inform);

// C interface for LPA
struct lpa_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t max_iterative_refinements;
    int32_t min_real_factor_size;
    int32_t min_integer_factor_size;
    int32_t random_number_seed;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    double infinity;
    double tol_data;
    double feas_tol;
    double relative_pivot_tolerance;
    double growth_limit;
    double zero_tolerance;
    double change_tolerance;
    double identical_bounds_tol;
    double cpu_time_limit;
    double clock_time_limit;
    bool scale;
    bool dual;
    bool warm_start;
    bool steepest_edge;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
};

struct lpa_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t max_iterative_refinements;
    int64_t min_real_factor_size;
    int64_t min_integer_factor_size;
    int64_t random_number_seed;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    double infinity;
    double tol_data;
    double feas_tol;
    double relative_pivot_tolerance;
    double growth_limit;
    double zero_tolerance;
    double change_tolerance;
    double identical_bounds_tol;
    double cpu_time_limit;
    double clock_time_limit;
    bool scale;
    bool dual;
    bool warm_start;
    bool steepest_edge;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
};

struct lpa_time_type {
    double total;
    double preprocess;
    double clock_total;
    double clock_preprocess;
};

struct lpa_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t la04_job;
    int32_t la04_job_info;
    double obj;
    double primal_infeasibility;
    bool feasible;
    double RINFO[40];
    struct lpa_time_type time;
    struct rpd_inform_type rpd_inform;
};

struct lpa_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t la04_job;
    int64_t la04_job_info;
    double obj;
    double primal_infeasibility;
    bool feasible;
    double RINFO[40];
    struct lpa_time_type time;
    struct rpd_inform_type_64 rpd_inform;
};

void lpa_initialize(void **data, struct lpa_control_type *control, int32_t *status);
void lpa_initialize_64(void **data, struct lpa_control_type_64 *control, int64_t *status);
void lpa_read_specfile(struct lpa_control_type *control, char *specfile);
void lpa_read_specfile_64(struct lpa_control_type_64 *control, char *specfile);
void lpa_import(struct lpa_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void lpa_import_64(struct lpa_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void lpa_reset_control(struct lpa_control_type *control, void **data, int32_t *status);
void lpa_reset_control_64(struct lpa_control_type_64 *control, void **data, int64_t *status);
void lpa_solve_lp(void **data, int32_t *status, int32_t n, int32_t m, double *g, double f, int32_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat);
void lpa_solve_lp_64(void **data, int64_t *status, int64_t n, int64_t m, double *g, double f, int64_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat);
void lpa_information(void **data, struct lpa_inform_type *inform, int32_t *status);
void lpa_information_64(void **data, struct lpa_inform_type_64 *inform, int64_t *status);
void lpa_terminate(void **data, struct lpa_control_type *control, struct lpa_inform_type *inform);
void lpa_terminate_64(void **data, struct lpa_control_type_64 *control, struct lpa_inform_type_64 *inform);

// C interface for LPB
struct lpb_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double prfeas;
    double dufeas;
    double muzero;
    double tau;
    double gamma_c;
    double gamma_f;
    double reduce_infeas;
    double obj_unbounded;
    double potential_unbounded;
    double identical_bounds_tol;
    double mu_pounce;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type fdc_control;
    struct sbls_control_type sbls_control;
    struct fit_control_type fit_control;
    struct roots_control_type roots_control;
    struct cro_control_type cro_control;
};

struct lpb_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double prfeas;
    double dufeas;
    double muzero;
    double tau;
    double gamma_c;
    double gamma_f;
    double reduce_infeas;
    double obj_unbounded;
    double potential_unbounded;
    double identical_bounds_tol;
    double mu_pounce;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_64 fdc_control;
    struct sbls_control_type_64 sbls_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_64 roots_control;
    struct cro_control_type_64 cro_control;
};

struct lpb_time_type {
    double total;
    double preprocess;
    double find_dependent;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_preprocess;
    double clock_find_dependent;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct lpb_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    double init_primal_infeasibility;
    double init_dual_infeasibility;
    double init_complementary_slackness;
    double potential;
    double non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    double checkpointsTime[16];
    struct lpb_time_type time;
    struct fdc_inform_type fdc_inform;
    struct sbls_inform_type sbls_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct lpb_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    double init_primal_infeasibility;
    double init_dual_infeasibility;
    double init_complementary_slackness;
    double potential;
    double non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    double checkpointsTime[16];
    struct lpb_time_type time;
    struct fdc_inform_type_64 fdc_inform;
    struct sbls_inform_type_64 sbls_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void lpb_initialize(void **data, struct lpb_control_type *control, int32_t *status);
void lpb_initialize_64(void **data, struct lpb_control_type_64 *control, int64_t *status);
void lpb_read_specfile(struct lpb_control_type *control, char *specfile);
void lpb_read_specfile_64(struct lpb_control_type_64 *control, char *specfile);
void lpb_import(struct lpb_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void lpb_import_64(struct lpb_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void lpb_reset_control(struct lpb_control_type *control, void **data, int32_t *status);
void lpb_reset_control_64(struct lpb_control_type_64 *control, void **data, int64_t *status);
void lpb_solve_lp(void **data, int32_t *status, int32_t n, int32_t m, double *g, double f, int32_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat);
void lpb_solve_lp_64(void **data, int64_t *status, int64_t n, int64_t m, double *g, double f, int64_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat);
void lpb_information(void **data, struct lpb_inform_type *inform, int32_t *status);
void lpb_information_64(void **data, struct lpb_inform_type_64 *inform, int64_t *status);
void lpb_terminate(void **data, struct lpb_control_type *control, struct lpb_inform_type *inform);
void lpb_terminate_64(void **data, struct lpb_control_type_64 *control, struct lpb_inform_type_64 *inform);

// C interface for LSQP
struct lsqp_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t factor;
    int32_t max_col;
    int32_t indmin;
    int32_t valmin;
    int32_t itref_max;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t extrapolate;
    int32_t path_history;
    int32_t path_derivatives;
    int32_t fit_order;
    int32_t sif_file_device;
    double infinity;
    double stop_p;
    double stop_d;
    double stop_c;
    double prfeas;
    double dufeas;
    double muzero;
    double reduce_infeas;
    double potential_unbounded;
    double pivot_tol;
    double pivot_tol_for_dependencies;
    double zero_pivot;
    double identical_bounds_tol;
    double mu_min;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool feasol;
    bool balance_initial_complentarity;
    bool use_corrector;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct fdc_control_type fdc_control;
    struct sbls_control_type sbls_control;
};

struct lsqp_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t factor;
    int64_t max_col;
    int64_t indmin;
    int64_t valmin;
    int64_t itref_max;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t extrapolate;
    int64_t path_history;
    int64_t path_derivatives;
    int64_t fit_order;
    int64_t sif_file_device;
    double infinity;
    double stop_p;
    double stop_d;
    double stop_c;
    double prfeas;
    double dufeas;
    double muzero;
    double reduce_infeas;
    double potential_unbounded;
    double pivot_tol;
    double pivot_tol_for_dependencies;
    double zero_pivot;
    double identical_bounds_tol;
    double mu_min;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool feasol;
    bool balance_initial_complentarity;
    bool use_corrector;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct fdc_control_type_64 fdc_control;
    struct sbls_control_type_64 sbls_control;
};

struct lsqp_time_type {
    double total;
    double preprocess;
    double find_dependent;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_preprocess;
    double clock_find_dependent;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct lsqp_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    double obj;
    double potential;
    double non_negligible_pivot;
    bool feasible;
    struct lsqp_time_type time;
    struct fdc_inform_type fdc_inform;
    struct sbls_inform_type sbls_inform;
};

struct lsqp_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    double obj;
    double potential;
    double non_negligible_pivot;
    bool feasible;
    struct lsqp_time_type time;
    struct fdc_inform_type_64 fdc_inform;
    struct sbls_inform_type_64 sbls_inform;
};

void lsqp_initialize(void **data, struct lsqp_control_type *control, int32_t *status);
void lsqp_initialize_64(void **data, struct lsqp_control_type_64 *control, int64_t *status);
void lsqp_read_specfile(struct lsqp_control_type *control, char *specfile);
void lsqp_read_specfile_64(struct lsqp_control_type_64 *control, char *specfile);
void lsqp_import(struct lsqp_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void lsqp_import_64(struct lsqp_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void lsqp_reset_control(struct lsqp_control_type *control, void **data, int32_t *status);
void lsqp_reset_control_64(struct lsqp_control_type_64 *control, void **data, int64_t *status);
void lsqp_solve_qp(void **data, int32_t *status, int32_t n, int32_t m, double *w, double *x0, double *g, double f, int32_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat);
void lsqp_solve_qp_64(void **data, int64_t *status, int64_t n, int64_t m, double *w, double *x0, double *g, double f, int64_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat);
void lsqp_information(void **data, struct lsqp_inform_type *inform, int32_t *status);
void lsqp_information_64(void **data, struct lsqp_inform_type_64 *inform, int64_t *status);
void lsqp_terminate(void **data, struct lsqp_control_type *control, struct lsqp_inform_type *inform);
void lsqp_terminate_64(void **data, struct lsqp_control_type_64 *control, struct lsqp_inform_type_64 *inform);

// C interface for NLS
struct nls_subproblem_control_type {
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t jacobian_available;
    int32_t hessian_available;
    int32_t model;
    int32_t norm;
    int32_t non_monotone;
    int32_t weight_update_strategy;
    double stop_c_absolute;
    double stop_c_relative;
    double stop_g_absolute;
    double stop_g_relative;
    double stop_s;
    double power;
    double initial_weight;
    double minimum_weight;
    double initial_inner_weight;
    double eta_successful;
    double eta_very_successful;
    double eta_too_successful;
    double weight_decrease_min;
    double weight_decrease;
    double weight_increase;
    double weight_increase_max;
    double reduce_gap;
    double tiny_gap;
    double large_root;
    double switch_to_newton;
    double cpu_time_limit;
    double clock_time_limit;
    bool subproblem_direct;
    bool renormalize_weight;
    bool magic_step;
    bool print_obj;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type rqs_control;
    struct glrt_control_type glrt_control;
    struct psls_control_type psls_control;
    struct bsc_control_type bsc_control;
    struct roots_control_type roots_control;
};

struct nls_subproblem_control_type_64 {
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t jacobian_available;
    int64_t hessian_available;
    int64_t model;
    int64_t norm;
    int64_t non_monotone;
    int64_t weight_update_strategy;
    double stop_c_absolute;
    double stop_c_relative;
    double stop_g_absolute;
    double stop_g_relative;
    double stop_s;
    double power;
    double initial_weight;
    double minimum_weight;
    double initial_inner_weight;
    double eta_successful;
    double eta_very_successful;
    double eta_too_successful;
    double weight_decrease_min;
    double weight_decrease;
    double weight_increase;
    double weight_increase_max;
    double reduce_gap;
    double tiny_gap;
    double large_root;
    double switch_to_newton;
    double cpu_time_limit;
    double clock_time_limit;
    bool subproblem_direct;
    bool renormalize_weight;
    bool magic_step;
    bool print_obj;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_64 rqs_control;
    struct glrt_control_type_64 glrt_control;
    struct psls_control_type_64 psls_control;
    struct bsc_control_type_64 bsc_control;
    struct roots_control_type_64 roots_control;
};

struct nls_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t jacobian_available;
    int32_t hessian_available;
    int32_t model;
    int32_t norm;
    int32_t non_monotone;
    int32_t weight_update_strategy;
    double stop_c_absolute;
    double stop_c_relative;
    double stop_g_absolute;
    double stop_g_relative;
    double stop_s;
    double power;
    double initial_weight;
    double minimum_weight;
    double initial_inner_weight;
    double eta_successful;
    double eta_very_successful;
    double eta_too_successful;
    double weight_decrease_min;
    double weight_decrease;
    double weight_increase;
    double weight_increase_max;
    double reduce_gap;
    double tiny_gap;
    double large_root;
    double switch_to_newton;
    double cpu_time_limit;
    double clock_time_limit;
    bool subproblem_direct;
    bool renormalize_weight;
    bool magic_step;
    bool print_obj;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type rqs_control;
    struct glrt_control_type glrt_control;
    struct psls_control_type psls_control;
    struct bsc_control_type bsc_control;
    struct roots_control_type roots_control;
    struct nls_subproblem_control_type subproblem_control;
};

struct nls_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t jacobian_available;
    int64_t hessian_available;
    int64_t model;
    int64_t norm;
    int64_t non_monotone;
    int64_t weight_update_strategy;
    double stop_c_absolute;
    double stop_c_relative;
    double stop_g_absolute;
    double stop_g_relative;
    double stop_s;
    double power;
    double initial_weight;
    double minimum_weight;
    double initial_inner_weight;
    double eta_successful;
    double eta_very_successful;
    double eta_too_successful;
    double weight_decrease_min;
    double weight_decrease;
    double weight_increase;
    double weight_increase_max;
    double reduce_gap;
    double tiny_gap;
    double large_root;
    double switch_to_newton;
    double cpu_time_limit;
    double clock_time_limit;
    bool subproblem_direct;
    bool renormalize_weight;
    bool magic_step;
    bool print_obj;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct rqs_control_type_64 rqs_control;
    struct glrt_control_type_64 glrt_control;
    struct psls_control_type_64 psls_control;
    struct bsc_control_type_64 bsc_control;
    struct roots_control_type_64 roots_control;
    struct nls_subproblem_control_type_64 subproblem_control;
};

struct nls_time_type {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    double clock_total;
    double clock_preprocess;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct nls_subproblem_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int32_t iter;
    int32_t cg_iter;
    int32_t c_eval;
    int32_t j_eval;
    int32_t h_eval;
    int32_t factorization_max;
    int32_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    double factorization_average;
    double obj;
    double norm_c;
    double norm_g;
    double weight;
    struct nls_time_type time;
    struct rqs_inform_type rqs_inform;
    struct glrt_inform_type glrt_inform;
    struct psls_inform_type psls_inform;
    struct bsc_inform_type bsc_inform;
    struct roots_inform_type roots_inform;
};

struct nls_subproblem_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int64_t iter;
    int64_t cg_iter;
    int64_t c_eval;
    int64_t j_eval;
    int64_t h_eval;
    int64_t factorization_max;
    int64_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    double factorization_average;
    double obj;
    double norm_c;
    double norm_g;
    double weight;
    struct nls_time_type time;
    struct rqs_inform_type_64 rqs_inform;
    struct glrt_inform_type_64 glrt_inform;
    struct psls_inform_type_64 psls_inform;
    struct bsc_inform_type_64 bsc_inform;
    struct roots_inform_type_64 roots_inform;
};

struct nls_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int32_t iter;
    int32_t cg_iter;
    int32_t c_eval;
    int32_t j_eval;
    int32_t h_eval;
    int32_t factorization_max;
    int32_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    double factorization_average;
    double obj;
    double norm_c;
    double norm_g;
    double weight;
    struct nls_time_type time;
    struct rqs_inform_type rqs_inform;
    struct glrt_inform_type glrt_inform;
    struct psls_inform_type psls_inform;
    struct bsc_inform_type bsc_inform;
    struct roots_inform_type roots_inform;
    struct nls_subproblem_inform_type subproblem_inform;
};

struct nls_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int64_t iter;
    int64_t cg_iter;
    int64_t c_eval;
    int64_t j_eval;
    int64_t h_eval;
    int64_t factorization_max;
    int64_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    double factorization_average;
    double obj;
    double norm_c;
    double norm_g;
    double weight;
    struct nls_time_type time;
    struct rqs_inform_type_64 rqs_inform;
    struct glrt_inform_type_64 glrt_inform;
    struct psls_inform_type_64 psls_inform;
    struct bsc_inform_type_64 bsc_inform;
    struct roots_inform_type_64 roots_inform;
    struct nls_subproblem_inform_type_64 subproblem_inform;
};

void nls_initialize(void **data, struct nls_control_type *control, struct nls_inform_type *inform);
void nls_initialize_64(void **data, struct nls_control_type_64 *control, struct nls_inform_type_64 *inform);
void nls_read_specfile(struct nls_control_type *control, char *specfile);
void nls_read_specfile_64(struct nls_control_type_64 *control, char *specfile);
void nls_import(struct nls_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *J_type, int32_t J_ne, int32_t *J_row, int32_t *J_col, int32_t *J_ptr, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *P_type, int32_t P_ne, int32_t *P_row, int32_t *P_col, int32_t *P_ptr, double *w);
void nls_import_64(struct nls_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *J_type, int64_t J_ne, int64_t *J_row, int64_t *J_col, int64_t *J_ptr, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *P_type, int64_t P_ne, int64_t *P_row, int64_t *P_col, int64_t *P_ptr, double *w);
void nls_reset_control(struct nls_control_type *control, void **data, int32_t *status);
void nls_reset_control_64(struct nls_control_type_64 *control, void **data, int64_t *status);
void nls_solve_with_mat(void **data, void *userdata, int32_t *status, int32_t n, int32_t m, double *x, double *c, double *g, galahad_r *eval_r, int32_t j_ne, galahad_jr *eval_jr, int32_t h_ne, galahad_hr *eval_hr, int32_t p_ne, galahad_shrprod *eval_shrprod);
void nls_solve_with_mat_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t m, double *x, double *c, double *g, galahad_r_64 *eval_r, int64_t j_ne, galahad_jr_64 *eval_jr, int64_t h_ne, galahad_hr_64 *eval_hr, int64_t p_ne, galahad_shrprod_64 *eval_shrprod);
void nls_solve_without_mat(void **data, void *userdata, int32_t *status, int32_t n, int32_t m, double *x, double *c, double *g, galahad_r *eval_r, galahad_jrprod *eval_jrprod, galahad_hrprod *eval_hrprod, int32_t p_ne, galahad_shrprod *eval_shrprod);
void nls_solve_without_mat_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t m, double *x, double *c, double *g, galahad_r_64 *eval_r, galahad_jrprod_64 *eval_jrprod, galahad_hrprod_64 *eval_hrprod, int64_t p_ne, galahad_shrprod_64 *eval_shrprod);
void nls_solve_reverse_with_mat(void **data, int32_t *status, int32_t *eval_status, int32_t n, int32_t m, double *x, double *c, double *g, int32_t j_ne, double *J_val, double *y, int32_t h_ne, double *H_val, double *v, int32_t p_ne, double *P_val);
void nls_solve_reverse_with_mat_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, int64_t m, double *x, double *c, double *g, int64_t j_ne, double *J_val, double *y, int64_t h_ne, double *H_val, double *v, int64_t p_ne, double *P_val);
void nls_solve_reverse_without_mat(void **data, int32_t *status, int32_t *eval_status, int32_t n, int32_t m, double *x, double *c, double *g, bool *transpose, double *u, double *v, double *y, int32_t p_ne, double *P_val);
void nls_solve_reverse_without_mat_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, int64_t m, double *x, double *c, double *g, bool *transpose, double *u, double *v, double *y, int64_t p_ne, double *P_val);
void nls_information(void **data, struct nls_inform_type *inform, int32_t *status);
void nls_information_64(void **data, struct nls_inform_type_64 *inform, int64_t *status);
void nls_terminate(void **data, struct nls_control_type *control, struct nls_inform_type *inform);
void nls_terminate_64(void **data, struct nls_control_type_64 *control, struct nls_inform_type_64 *inform);

// C interface for QPA
struct qpa_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t factor;
    int32_t max_col;
    int32_t max_sc;
    int32_t indmin;
    int32_t valmin;
    int32_t itref_max;
    int32_t infeas_check_interval;
    int32_t cg_maxit;
    int32_t precon;
    int32_t nsemib;
    int32_t full_max_fill;
    int32_t deletion_strategy;
    int32_t restore_problem;
    int32_t monitor_residuals;
    int32_t cold_start;
    int32_t sif_file_device;
    double infinity;
    double feas_tol;
    double obj_unbounded;
    double increase_rho_g_factor;
    double infeas_g_improved_by_factor;
    double increase_rho_b_factor;
    double infeas_b_improved_by_factor;
    double pivot_tol;
    double pivot_tol_for_dependencies;
    double zero_pivot;
    double inner_stop_relative;
    double inner_stop_absolute;
    double multiplier_tol;
    double cpu_time_limit;
    double clock_time_limit;
    bool treat_zero_bounds_as_general;
    bool solve_qp;
    bool solve_within_bounds;
    bool randomize;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char prefix[31];
    bool each_interval;
    struct sls_control_type sls_control;
};

struct qpa_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t factor;
    int64_t max_col;
    int64_t max_sc;
    int64_t indmin;
    int64_t valmin;
    int64_t itref_max;
    int64_t infeas_check_interval;
    int64_t cg_maxit;
    int64_t precon;
    int64_t nsemib;
    int64_t full_max_fill;
    int64_t deletion_strategy;
    int64_t restore_problem;
    int64_t monitor_residuals;
    int64_t cold_start;
    int64_t sif_file_device;
    double infinity;
    double feas_tol;
    double obj_unbounded;
    double increase_rho_g_factor;
    double infeas_g_improved_by_factor;
    double increase_rho_b_factor;
    double infeas_b_improved_by_factor;
    double pivot_tol;
    double pivot_tol_for_dependencies;
    double zero_pivot;
    double inner_stop_relative;
    double inner_stop_absolute;
    double multiplier_tol;
    double cpu_time_limit;
    double clock_time_limit;
    bool treat_zero_bounds_as_general;
    bool solve_qp;
    bool solve_within_bounds;
    bool randomize;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char prefix[31];
    bool each_interval;
    struct sls_control_type_64 sls_control;
};

struct qpa_time_type {
    double total;
    double preprocess;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_preprocess;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct qpa_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t major_iter;
    int32_t iter;
    int32_t cg_iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nmods;
    int32_t num_g_infeas;
    int32_t num_b_infeas;
    double obj;
    double infeas_g;
    double infeas_b;
    double merit;
    struct qpa_time_type time;
    struct sls_inform_type sls_inform;
};

struct qpa_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t major_iter;
    int64_t iter;
    int64_t cg_iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nmods;
    int64_t num_g_infeas;
    int64_t num_b_infeas;
    double obj;
    double infeas_g;
    double infeas_b;
    double merit;
    struct qpa_time_type time;
    struct sls_inform_type_64 sls_inform;
};

void qpa_initialize(void **data, struct qpa_control_type *control, int32_t *status);
void qpa_initialize_64(void **data, struct qpa_control_type_64 *control, int64_t *status);
void qpa_read_specfile(struct qpa_control_type *control, char *specfile);
void qpa_read_specfile_64(struct qpa_control_type_64 *control, char *specfile);
void qpa_import(struct qpa_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void qpa_import_64(struct qpa_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void qpa_reset_control(struct qpa_control_type *control, void **data, int32_t *status);
void qpa_reset_control_64(struct qpa_control_type_64 *control, void **data, int64_t *status);
void qpa_solve_qp(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, double *H_val, double *g, double f, int32_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat);
void qpa_solve_qp_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, double *H_val, double *g, double f, int64_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat);
void qpa_solve_l1qp(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, double *H_val, double *g, double f, double rho_g, double rho_b, int32_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat);
void qpa_solve_l1qp_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, double *H_val, double *g, double f, double rho_g, double rho_b, int64_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat);
void qpa_solve_bcl1qp(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, double *H_val, double *g, double f, double rho_g, int32_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat);
void qpa_solve_bcl1qp_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, double *H_val, double *g, double f, double rho_g, int64_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat);
void qpa_information(void **data, struct qpa_inform_type *inform, int32_t *status);
void qpa_information_64(void **data, struct qpa_inform_type_64 *inform, int64_t *status);
void qpa_terminate(void **data, struct qpa_control_type *control, struct qpa_inform_type *inform);
void qpa_terminate_64(void **data, struct qpa_control_type_64 *control, struct qpa_inform_type_64 *inform);

// C interface for QPB
struct qpb_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t itref_max;
    int32_t cg_maxit;
    int32_t indicator_type;
    int32_t restore_problem;
    int32_t extrapolate;
    int32_t path_history;
    int32_t factor;
    int32_t max_col;
    int32_t indmin;
    int32_t valmin;
    int32_t infeas_max;
    int32_t precon;
    int32_t nsemib;
    int32_t path_derivatives;
    int32_t fit_order;
    int32_t sif_file_device;
    double infinity;
    double stop_p;
    double stop_d;
    double stop_c;
    double theta_d;
    double theta_c;
    double beta;
    double prfeas;
    double dufeas;
    double muzero;
    double reduce_infeas;
    double obj_unbounded;
    double pivot_tol;
    double pivot_tol_for_dependencies;
    double zero_pivot;
    double identical_bounds_tol;
    double inner_stop_relative;
    double inner_stop_absolute;
    double initial_radius;
    double mu_min;
    double inner_fraction_opt;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool center;
    bool primal;
    bool puiseux;
    bool feasol;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct lsqp_control_type lsqp_control;
    struct fdc_control_type fdc_control;
    struct sbls_control_type sbls_control;
    struct gltr_control_type gltr_control;
    struct fit_control_type fit_control;
};

struct qpb_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t itref_max;
    int64_t cg_maxit;
    int64_t indicator_type;
    int64_t restore_problem;
    int64_t extrapolate;
    int64_t path_history;
    int64_t factor;
    int64_t max_col;
    int64_t indmin;
    int64_t valmin;
    int64_t infeas_max;
    int64_t precon;
    int64_t nsemib;
    int64_t path_derivatives;
    int64_t fit_order;
    int64_t sif_file_device;
    double infinity;
    double stop_p;
    double stop_d;
    double stop_c;
    double theta_d;
    double theta_c;
    double beta;
    double prfeas;
    double dufeas;
    double muzero;
    double reduce_infeas;
    double obj_unbounded;
    double pivot_tol;
    double pivot_tol_for_dependencies;
    double zero_pivot;
    double identical_bounds_tol;
    double inner_stop_relative;
    double inner_stop_absolute;
    double initial_radius;
    double mu_min;
    double inner_fraction_opt;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool center;
    bool primal;
    bool puiseux;
    bool feasol;
    bool array_syntax_worse_than_do_loop;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct lsqp_control_type_64 lsqp_control;
    struct fdc_control_type_64 fdc_control;
    struct sbls_control_type_64 sbls_control;
    struct gltr_control_type_64 gltr_control;
    struct fit_control_type_64 fit_control;
};

struct qpb_time_type {
    double total;
    double preprocess;
    double find_dependent;
    double analyse;
    double factorize;
    double solve;
    double phase1_total;
    double phase1_analyse;
    double phase1_factorize;
    double phase1_solve;
    double clock_total;
    double clock_preprocess;
    double clock_find_dependent;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
    double clock_phase1_total;
    double clock_phase1_analyse;
    double clock_phase1_factorize;
    double clock_phase1_solve;
};

struct qpb_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t nmods;
    double obj;
    double non_negligible_pivot;
    bool feasible;
    struct qpb_time_type time;
    struct lsqp_inform_type lsqp_inform;
    struct fdc_inform_type fdc_inform;
    struct sbls_inform_type sbls_inform;
    struct gltr_inform_type gltr_inform;
    struct fit_inform_type fit_inform;
};

struct qpb_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t nmods;
    double obj;
    double non_negligible_pivot;
    bool feasible;
    struct qpb_time_type time;
    struct lsqp_inform_type_64 lsqp_inform;
    struct fdc_inform_type_64 fdc_inform;
    struct sbls_inform_type_64 sbls_inform;
    struct gltr_inform_type_64 gltr_inform;
    struct fit_inform_type_64 fit_inform;
};

void qpb_initialize(void **data, struct qpb_control_type *control, int32_t *status);
void qpb_initialize_64(void **data, struct qpb_control_type_64 *control, int64_t *status);
void qpb_read_specfile(struct qpb_control_type *control, char *specfile);
void qpb_read_specfile_64(struct qpb_control_type_64 *control, char *specfile);
void qpb_import(struct qpb_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void qpb_import_64(struct qpb_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void qpb_reset_control(struct qpb_control_type *control, void **data, int32_t *status);
void qpb_reset_control_64(struct qpb_control_type_64 *control, void **data, int64_t *status);
void qpb_solve_qp(void **data, int32_t *status, int32_t n, int32_t m, int32_t h_ne, double *H_val, double *g, double f, int32_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int32_t *x_stat, int32_t *c_stat);
void qpb_solve_qp_64(void **data, int64_t *status, int64_t n, int64_t m, int64_t h_ne, double *H_val, double *g, double f, int64_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y, double *z, int64_t *x_stat, int64_t *c_stat);
void qpb_information(void **data, struct qpb_inform_type *inform, int32_t *status);
void qpb_information_64(void **data, struct qpb_inform_type_64 *inform, int64_t *status);
void qpb_terminate(void **data, struct qpb_control_type *control, struct qpb_inform_type *inform);
void qpb_terminate_64(void **data, struct qpb_control_type_64 *control, struct qpb_inform_type_64 *inform);

// C interface for SLLS
struct slls_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t cold_start;
    int32_t preconditioner;
    int32_t ratio_cg_vs_sd;
    int32_t change_max;
    int32_t cg_maxit;
    int32_t arcsearch_max_steps;
    int32_t sif_file_device;
    double weight;
    double stop_d;
    double stop_cg_relative;
    double stop_cg_absolute;
    double alpha_max;
    double alpha_initial;
    double alpha_reduction;
    double arcsearch_acceptance_tol;
    double stabilisation_weight;
    double cpu_time_limit;
    bool direct_subproblem_solve;
    bool exact_arc_search;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type sbls_control;
    struct convert_control_type convert_control;
};

struct slls_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t cold_start;
    int64_t preconditioner;
    int64_t ratio_cg_vs_sd;
    int64_t change_max;
    int64_t cg_maxit;
    int64_t arcsearch_max_steps;
    int64_t sif_file_device;
    double weight;
    double stop_d;
    double stop_cg_relative;
    double stop_cg_absolute;
    double alpha_max;
    double alpha_initial;
    double alpha_reduction;
    double arcsearch_acceptance_tol;
    double stabilisation_weight;
    double cpu_time_limit;
    bool direct_subproblem_solve;
    bool exact_arc_search;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    char sif_file_name[31];
    char prefix[31];
    struct sbls_control_type_64 sbls_control;
    struct convert_control_type_64 convert_control;
};

struct slls_inform_type {
    int32_t status;
    int32_t alloc_status;
    int32_t factorization_status;
    int32_t iter;
    int32_t cg_iter;
    double obj;
    double norm_pg;
    char bad_alloc[81];
    struct slls_time_type time;
    struct sbls_inform_type sbls_inform;
    struct convert_inform_type convert_inform;
};

struct slls_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorization_status;
    int64_t iter;
    int64_t cg_iter;
    double obj;
    double norm_pg;
    char bad_alloc[81];
    struct slls_time_type time;
    struct sbls_inform_type_64 sbls_inform;
    struct convert_inform_type_64 convert_inform;
};

void slls_initialize(void **data, struct slls_control_type *control, int32_t *status);
void slls_initialize_64(void **data, struct slls_control_type_64 *control, int64_t *status);
void slls_read_specfile(struct slls_control_type *control, char *specfile);
void slls_read_specfile_64(struct slls_control_type_64 *control, char *specfile);
void slls_import(struct slls_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *Ao_type, int32_t Ao_ne, int32_t *Ao_row, int32_t *Ao_col, int32_t Ao_ptr_ne, int32_t *Ao_ptr);
void slls_import_64(struct slls_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *Ao_type, int64_t Ao_ne, int64_t *Ao_row, int64_t *Ao_col, int64_t Ao_ptr_ne, int64_t *Ao_ptr);
void slls_import_without_a(struct slls_control_type *control, void **data, int32_t *status, int32_t n, int32_t o);
void slls_import_without_a_64(struct slls_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t o);
void slls_reset_control(struct slls_control_type *control, void **data, int32_t *status);
void slls_reset_control_64(struct slls_control_type_64 *control, void **data, int64_t *status);
void slls_solve_given_a(void **data, void *userdata, int32_t *status, int32_t n, int32_t o, int32_t Ao_ne, double *Ao_val, double *b, double *x, double *z, double *r, double *g, int32_t *x_stat, galahad_constant_prec *eval_prec);
void slls_solve_given_a_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t o, int64_t Ao_ne, double *Ao_val, double *b, double *x, double *z, double *r, double *g, int64_t *x_stat, galahad_constant_prec_64 *eval_prec);
void slls_solve_reverse_a_prod(void **data, int32_t *status, int32_t *eval_status, int32_t n, int32_t o, double *b, double *x, double *z, double *r, double *g, int32_t *x_stat, double *v, double *p, int32_t *nz_v, int32_t *nz_v_start, int32_t *nz_v_end, int32_t *nz_p, int32_t nz_p_end);
void slls_solve_reverse_a_prod_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, int64_t o, double *b, double *x, double *z, double *r, double *g, int64_t *x_stat, double *v, double *p, int64_t *nz_v, int64_t *nz_v_start, int64_t *nz_v_end, int64_t *nz_p, int64_t nz_p_end);
void slls_information(void **data, struct slls_inform_type *inform, int32_t *status);
void slls_information_64(void **data, struct slls_inform_type_64 *inform, int64_t *status);
void slls_terminate(void **data, struct slls_control_type *control, struct slls_inform_type *inform);
void slls_terminate_64(void **data, struct slls_control_type_64 *control, struct slls_inform_type_64 *inform);

// C interface for TRU
struct tru_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t maxit;
    int32_t alive_unit;
    char alive_file[31];
    int32_t non_monotone;
    int32_t model;
    int32_t norm;
    int32_t semi_bandwidth;
    int32_t lbfgs_vectors;
    int32_t max_dxg;
    int32_t icfs_vectors;
    int32_t mi28_lsize;
    int32_t mi28_rsize;
    int32_t advanced_start;
    double stop_g_absolute;
    double stop_g_relative;
    double stop_s;
    double initial_radius;
    double maximum_radius;
    double eta_successful;
    double eta_very_successful;
    double eta_too_successful;
    double radius_increase;
    double radius_reduce;
    double radius_reduce_max;
    double obj_unbounded;
    double cpu_time_limit;
    double clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool retrospective_trust_region;
    bool renormalize_radius;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct trs_control_type trs_control;
    struct gltr_control_type gltr_control;
    struct dps_control_type dps_control;
    struct psls_control_type psls_control;
    struct lms_control_type lms_control;
    struct lms_control_type lms_control_prec;
    struct sec_control_type sec_control;
    struct sha_control_type sha_control;
};

struct tru_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t maxit;
    int64_t alive_unit;
    char alive_file[31];
    int64_t non_monotone;
    int64_t model;
    int64_t norm;
    int64_t semi_bandwidth;
    int64_t lbfgs_vectors;
    int64_t max_dxg;
    int64_t icfs_vectors;
    int64_t mi28_lsize;
    int64_t mi28_rsize;
    int64_t advanced_start;
    double stop_g_absolute;
    double stop_g_relative;
    double stop_s;
    double initial_radius;
    double maximum_radius;
    double eta_successful;
    double eta_very_successful;
    double eta_too_successful;
    double radius_increase;
    double radius_reduce;
    double radius_reduce_max;
    double obj_unbounded;
    double cpu_time_limit;
    double clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool retrospective_trust_region;
    bool renormalize_radius;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct trs_control_type_64 trs_control;
    struct gltr_control_type_64 gltr_control;
    struct dps_control_type_64 dps_control;
    struct psls_control_type_64 psls_control;
    struct lms_control_type_64 lms_control;
    struct lms_control_type_64 lms_control_prec;
    struct sec_control_type_64 sec_control;
    struct sha_control_type_64 sha_control;
};

struct tru_time_type {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    double clock_total;
    double clock_preprocess;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct tru_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t cg_iter;
    int32_t f_eval;
    int32_t g_eval;
    int32_t h_eval;
    int32_t factorization_max;
    int32_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    double factorization_average;
    double obj;
    double norm_g;
    double radius;
    struct tru_time_type time;
    struct trs_inform_type trs_inform;
    struct gltr_inform_type gltr_inform;
    struct dps_inform_type dps_inform;
    struct psls_inform_type psls_inform;
    struct lms_inform_type lms_inform;
    struct lms_inform_type lms_inform_prec;
    struct sec_inform_type sec_inform;
    struct sha_inform_type sha_inform;
};

struct tru_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t cg_iter;
    int64_t f_eval;
    int64_t g_eval;
    int64_t h_eval;
    int64_t factorization_max;
    int64_t factorization_status;
    int64_t max_entries_factors;
    int64_t factorization_integer;
    int64_t factorization_real;
    double factorization_average;
    double obj;
    double norm_g;
    double radius;
    struct tru_time_type time;
    struct trs_inform_type_64 trs_inform;
    struct gltr_inform_type_64 gltr_inform;
    struct dps_inform_type_64 dps_inform;
    struct psls_inform_type_64 psls_inform;
    struct lms_inform_type_64 lms_inform;
    struct lms_inform_type_64 lms_inform_prec;
    struct sec_inform_type_64 sec_inform;
    struct sha_inform_type_64 sha_inform;
};

void tru_initialize(void **data, struct tru_control_type *control, int32_t *status);
void tru_initialize_64(void **data, struct tru_control_type_64 *control, int64_t *status);
void tru_read_specfile(struct tru_control_type *control, char *specfile);
void tru_read_specfile_64(struct tru_control_type_64 *control, char *specfile);
void tru_import(struct tru_control_type *control, void **data, int32_t *status, int32_t n, char *H_type, int32_t ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void tru_import_64(struct tru_control_type_64 *control, void **data, int64_t *status, int64_t n, char *H_type, int64_t ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void tru_reset_control(struct tru_control_type *control, void **data, int32_t *status);
void tru_reset_control_64(struct tru_control_type_64 *control, void **data, int64_t *status);
void tru_solve_with_mat(void **data, void *userdata, int32_t *status, int32_t n, double *x, double *g, int32_t ne, galahad_f *eval_f, galahad_g *eval_g, galahad_h *eval_h, galahad_prec *eval_prec);
void tru_solve_with_mat_64(void **data, void *userdata, int64_t *status, int64_t n, double *x, double *g, int64_t ne, galahad_f_64 *eval_f, galahad_g_64 *eval_g, galahad_h_64 *eval_h, galahad_prec_64 *eval_prec);
void tru_solve_without_mat(void **data, void *userdata, int32_t *status, int32_t n, double *x, double *g, galahad_f *eval_f, galahad_g *eval_g, galahad_hprod *eval_hprod, galahad_prec *eval_prec);
void tru_solve_without_mat_64(void **data, void *userdata, int64_t *status, int64_t n, double *x, double *g, galahad_f_64 *eval_f, galahad_g_64 *eval_g, galahad_hprod_64 *eval_hprod, galahad_prec_64 *eval_prec);
void tru_solve_reverse_with_mat(void **data, int32_t *status, int32_t *eval_status, int32_t n, double *x, double f, double *g, int32_t ne, double *H_val, double *u, double *v);
void tru_solve_reverse_with_mat_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, double *x, double f, double *g, int64_t ne, double *H_val, double *u, double *v);
void tru_solve_reverse_without_mat(void **data, int32_t *status, int32_t *eval_status, int32_t n, double *x, double f, double *g, double *u, double *v);
void tru_solve_reverse_without_mat_64(void **data, int64_t *status, int64_t *eval_status, int64_t n, double *x, double f, double *g, double *u, double *v);
void tru_information(void **data, struct tru_inform_type *inform, int32_t *status);
void tru_information_64(void **data, struct tru_inform_type_64 *inform, int64_t *status);
void tru_terminate(void **data, struct tru_control_type *control, struct tru_inform_type *inform);
void tru_terminate_64(void **data, struct tru_control_type_64 *control, struct tru_inform_type_64 *inform);

// C interface for WCP
struct wcp_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t initial_point;
    int32_t factor;
    int32_t max_col;
    int32_t indmin;
    int32_t valmin;
    int32_t itref_max;
    int32_t infeas_max;
    int32_t perturbation_strategy;
    int32_t restore_problem;
    double infinity;
    double stop_p;
    double stop_d;
    double stop_c;
    double prfeas;
    double dufeas;
    double mu_target;
    double mu_accept_fraction;
    double mu_increase_factor;
    double required_infeas_reduction;
    double implicit_tol;
    double pivot_tol;
    double pivot_tol_for_dependencies;
    double zero_pivot;
    double perturb_start;
    double alpha_scale;
    double identical_bounds_tol;
    double reduce_perturb_factor;
    double reduce_perturb_multiplier;
    double insufficiently_feasible;
    double perturbation_small;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool balance_initial_complementarity;
    bool use_corrector;
    bool space_critical;
    bool deallocate_error_fatal;
    bool record_x_status;
    bool record_c_status;
    char prefix[31];
    struct fdc_control_type fdc_control;
    struct sbls_control_type sbls_control;
};

struct wcp_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t initial_point;
    int64_t factor;
    int64_t max_col;
    int64_t indmin;
    int64_t valmin;
    int64_t itref_max;
    int64_t infeas_max;
    int64_t perturbation_strategy;
    int64_t restore_problem;
    double infinity;
    double stop_p;
    double stop_d;
    double stop_c;
    double prfeas;
    double dufeas;
    double mu_target;
    double mu_accept_fraction;
    double mu_increase_factor;
    double required_infeas_reduction;
    double implicit_tol;
    double pivot_tol;
    double pivot_tol_for_dependencies;
    double zero_pivot;
    double perturb_start;
    double alpha_scale;
    double identical_bounds_tol;
    double reduce_perturb_factor;
    double reduce_perturb_multiplier;
    double insufficiently_feasible;
    double perturbation_small;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool just_feasible;
    bool balance_initial_complementarity;
    bool use_corrector;
    bool space_critical;
    bool deallocate_error_fatal;
    bool record_x_status;
    bool record_c_status;
    char prefix[31];
    struct fdc_control_type_64 fdc_control;
    struct sbls_control_type_64 sbls_control;
};

struct wcp_time_type {
    double total;
    double preprocess;
    double find_dependent;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_preprocess;
    double clock_find_dependent;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct wcp_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t c_implicit;
    int32_t x_implicit;
    int32_t y_implicit;
    int32_t z_implicit;
    double obj;
    double mu_final_target_max;
    double non_negligible_pivot;
    bool feasible;
    struct wcp_time_type time;
    struct fdc_inform_type fdc_inform;
    struct sbls_inform_type sbls_inform;
};

struct wcp_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t c_implicit;
    int64_t x_implicit;
    int64_t y_implicit;
    int64_t z_implicit;
    double obj;
    double mu_final_target_max;
    double non_negligible_pivot;
    bool feasible;
    struct wcp_time_type time;
    struct fdc_inform_type_64 fdc_inform;
    struct sbls_inform_type_64 sbls_inform;
};

void wcp_initialize(void **data, struct wcp_control_type *control, int32_t *status);
void wcp_initialize_64(void **data, struct wcp_control_type_64 *control, int64_t *status);
void wcp_read_specfile(struct wcp_control_type *control, char *specfile);
void wcp_read_specfile_64(struct wcp_control_type_64 *control, char *specfile);
void wcp_import(struct wcp_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void wcp_import_64(struct wcp_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void wcp_reset_control(struct wcp_control_type *control, void **data, int32_t *status);
void wcp_reset_control_64(struct wcp_control_type_64 *control, void **data, int64_t *status);
void wcp_find_wcp(void **data, int32_t *status, int32_t n, int32_t m, double *g, int32_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y_l, double *y_u, double *z_l, double *z_u, int32_t *x_stat, int32_t *c_stat);
void wcp_find_wcp_64(void **data, int64_t *status, int64_t n, int64_t m, double *g, int64_t a_ne, double *A_val, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *c, double *y_l, double *y_u, double *z_l, double *z_u, int64_t *x_stat, int64_t *c_stat);
void wcp_information(void **data, struct wcp_inform_type *inform, int32_t *status);
void wcp_information_64(void **data, struct wcp_inform_type_64 *inform, int64_t *status);
void wcp_terminate(void **data, struct wcp_control_type *control, struct wcp_inform_type *inform);
void wcp_terminate_64(void **data, struct wcp_control_type_64 *control, struct wcp_inform_type_64 *inform);

// C interface for LLSR
struct llsr_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t new_a;
    int32_t new_s;
    int32_t max_factorizations;
    int32_t taylor_max_degree;
    double initial_multiplier;
    double lower;
    double upper;
    double stop_normal;
    bool use_initial_multiplier;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sbls_control_type sbls_control;
    struct sls_control_type sls_control;
    struct ir_control_type ir_control;
};

struct llsr_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t new_a;
    int64_t new_s;
    int64_t max_factorizations;
    int64_t taylor_max_degree;
    double initial_multiplier;
    double lower;
    double upper;
    double stop_normal;
    bool use_initial_multiplier;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sbls_control_type_64 sbls_control;
    struct sls_control_type_64 sls_control;
    struct ir_control_type_64 ir_control;
};

struct llsr_time_type {
    double total;
    double assemble;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_assemble;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct llsr_history_type {
    double lambda;
    double x_norm;
    double r_norm;
};

struct llsr_inform_type {
    int32_t status;
    int32_t alloc_status;
    int32_t factorizations;
    int32_t len_history;
    double r_norm;
    double x_norm;
    double multiplier;
    char bad_alloc[81];
    struct llsr_time_type time;
    struct llsr_history_type history[100];
    struct sbls_inform_type sbls_inform;
    struct sls_inform_type sls_inform;
    struct ir_inform_type ir_inform;
};

struct llsr_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorizations;
    int64_t len_history;
    double r_norm;
    double x_norm;
    double multiplier;
    char bad_alloc[81];
    struct llsr_time_type time;
    struct llsr_history_type history[100];
    struct sbls_inform_type_64 sbls_inform;
    struct sls_inform_type_64 sls_inform;
    struct ir_inform_type_64 ir_inform;
};

void llsr_initialize(void **data, struct llsr_control_type *control, int32_t *status);
void llsr_initialize_64(void **data, struct llsr_control_type_64 *control, int64_t *status);
void llsr_read_specfile(struct llsr_control_type *control, char *specfile);
void llsr_read_specfile_64(struct llsr_control_type_64 *control, char *specfile);
void llsr_import(struct llsr_control_type *control, void **data, int32_t *status, int32_t m, int32_t n, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void llsr_import_64(struct llsr_control_type_64 *control, void **data, int64_t *status, int64_t m, int64_t n, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void llsr_import_scaling(struct llsr_control_type *control, void **data, int32_t *status, int32_t n, char *S_type, int32_t S_ne, int32_t *S_row, int32_t *S_col, int32_t *S_ptr);
void llsr_import_scaling_64(struct llsr_control_type_64 *control, void **data, int64_t *status, int64_t n, char *S_type, int64_t S_ne, int64_t *S_row, int64_t *S_col, int64_t *S_ptr);
void llsr_reset_control(struct llsr_control_type *control, void **data, int32_t *status);
void llsr_reset_control_64(struct llsr_control_type_64 *control, void **data, int64_t *status);
void llsr_solve_problem(void **data, int32_t *status, int32_t m, int32_t n, double power, double weight, int32_t A_ne, double *A_val, double *b, double *x, int32_t S_ne, double *S_val);
void llsr_solve_problem_64(void **data, int64_t *status, int64_t m, int64_t n, double power, double weight, int64_t A_ne, double *A_val, double *b, double *x, int64_t S_ne, double *S_val);
void llsr_information(void **data, struct llsr_inform_type *inform, int32_t *status);
void llsr_information_64(void **data, struct llsr_inform_type_64 *inform, int64_t *status);
void llsr_terminate(void **data, struct llsr_control_type *control, struct llsr_inform_type *inform);
void llsr_terminate_64(void **data, struct llsr_control_type_64 *control, struct llsr_inform_type_64 *inform);

// C interface for LLST
struct llst_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t new_a;
    int32_t new_s;
    int32_t max_factorizations;
    int32_t taylor_max_degree;
    double initial_multiplier;
    double lower;
    double upper;
    double stop_normal;
    bool equality_problem;
    bool use_initial_multiplier;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sbls_control_type sbls_control;
    struct sls_control_type sls_control;
    struct ir_control_type ir_control;
};

struct llst_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t new_a;
    int64_t new_s;
    int64_t max_factorizations;
    int64_t taylor_max_degree;
    double initial_multiplier;
    double lower;
    double upper;
    double stop_normal;
    bool equality_problem;
    bool use_initial_multiplier;
    bool space_critical;
    bool deallocate_error_fatal;
    char definite_linear_solver[31];
    char prefix[31];
    struct sbls_control_type_64 sbls_control;
    struct sls_control_type_64 sls_control;
    struct ir_control_type_64 ir_control;
};

struct llst_time_type {
    double total;
    double assemble;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_assemble;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct llst_history_type {
    double lambda;
    double x_norm;
    double r_norm;
};

struct llst_inform_type {
    int32_t status;
    int32_t alloc_status;
    int32_t factorizations;
    int32_t len_history;
    double r_norm;
    double x_norm;
    double multiplier;
    char bad_alloc[81];
    struct llst_time_type time;
    struct llst_history_type history[100];
    struct sbls_inform_type sbls_inform;
    struct sls_inform_type sls_inform;
    struct ir_inform_type ir_inform;
};

struct llst_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    int64_t factorizations;
    int64_t len_history;
    double r_norm;
    double x_norm;
    double multiplier;
    char bad_alloc[81];
    struct llst_time_type time;
    struct llst_history_type history[100];
    struct sbls_inform_type_64 sbls_inform;
    struct sls_inform_type_64 sls_inform;
    struct ir_inform_type_64 ir_inform;
};

void llst_initialize(void **data, struct llst_control_type *control, int32_t *status);
void llst_initialize_64(void **data, struct llst_control_type_64 *control, int64_t *status);
void llst_read_specfile(struct llst_control_type *control, char *specfile);
void llst_read_specfile_64(struct llst_control_type_64 *control, char *specfile);
void llst_import(struct llst_control_type *control, void **data, int32_t *status, int32_t m, int32_t n, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr);
void llst_import_64(struct llst_control_type_64 *control, void **data, int64_t *status, int64_t m, int64_t n, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr);
void llst_import_scaling(struct llst_control_type *control, void **data, int32_t *status, int32_t n, char *S_type, int32_t S_ne, int32_t *S_row, int32_t *S_col, int32_t *S_ptr);
void llst_import_scaling_64(struct llst_control_type_64 *control, void **data, int64_t *status, int64_t n, char *S_type, int64_t S_ne, int64_t *S_row, int64_t *S_col, int64_t *S_ptr);
void llst_reset_control(struct llst_control_type *control, void **data, int32_t *status);
void llst_reset_control_64(struct llst_control_type_64 *control, void **data, int64_t *status);
void llst_solve_problem(void **data, int32_t *status, int32_t m, int32_t n, double radius, int32_t A_ne, double *A_val, double *b, double *x, int32_t S_ne, double *S_val);
void llst_solve_problem_64(void **data, int64_t *status, int64_t m, int64_t n, double radius, int64_t A_ne, double *A_val, double *b, double *x, int64_t S_ne, double *S_val);
void llst_information(void **data, struct llst_inform_type *inform, int32_t *status);
void llst_information_64(void **data, struct llst_inform_type_64 *inform, int64_t *status);
void llst_terminate(void **data, struct llst_control_type *control, struct llst_inform_type *inform);
void llst_terminate_64(void **data, struct llst_control_type_64 *control, struct llst_inform_type_64 *inform);

// C interface for BLLSB
struct bllsb_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t maxit;
    int32_t infeas_max;
    int32_t muzero_fixed;
    int32_t restore_problem;
    int32_t indicator_type;
    int32_t arc;
    int32_t series_order;
    int32_t sif_file_device;
    int32_t qplib_file_device;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double prfeas;
    double dufeas;
    double muzero;
    double tau;
    double gamma_c;
    double gamma_f;
    double reduce_infeas;
    double identical_bounds_tol;
    double mu_pounce;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type fdc_control;
    struct sls_control_type sls_control;
    struct sls_control_type sls_pounce_control;
    struct fit_control_type fit_control;
    struct roots_control_type roots_control;
    struct cro_control_type cro_control;
};

struct bllsb_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t maxit;
    int64_t infeas_max;
    int64_t muzero_fixed;
    int64_t restore_problem;
    int64_t indicator_type;
    int64_t arc;
    int64_t series_order;
    int64_t sif_file_device;
    int64_t qplib_file_device;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double prfeas;
    double dufeas;
    double muzero;
    double tau;
    double gamma_c;
    double gamma_f;
    double reduce_infeas;
    double identical_bounds_tol;
    double mu_pounce;
    double indicator_tol_p;
    double indicator_tol_pd;
    double indicator_tol_tapia;
    double cpu_time_limit;
    double clock_time_limit;
    bool remove_dependencies;
    bool treat_zero_bounds_as_general;
    bool treat_separable_as_general;
    bool just_feasible;
    bool getdua;
    bool puiseux;
    bool every_order;
    bool feasol;
    bool balance_initial_complentarity;
    bool crossover;
    bool reduced_pounce_system;
    bool space_critical;
    bool deallocate_error_fatal;
    bool generate_sif_file;
    bool generate_qplib_file;
    char symmetric_linear_solver[31];
    char sif_file_name[31];
    char qplib_file_name[31];
    char prefix[31];
    struct fdc_control_type_64 fdc_control;
    struct sls_control_type_64 sls_control;
    struct sls_control_type_64 sls_pounce_control;
    struct fit_control_type_64 fit_control;
    struct roots_control_type_64 roots_control;
    struct cro_control_type_64 cro_control;
};

struct bllsb_time_type {
    double total;
    double preprocess;
    double find_dependent;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_preprocess;
    double clock_find_dependent;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct bllsb_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int32_t iter;
    int32_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t nfacts;
    int32_t nbacts;
    int32_t threads;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    double non_negligible_pivot;
    bool feasible;
    int32_t checkpointsIter[16];
    double checkpointsTime[16];
    struct bllsb_time_type time;
    struct fdc_inform_type fdc_inform;
    struct sls_inform_type sls_inform;
    struct sls_inform_type sls_pounce_inform;
    struct fit_inform_type fit_inform;
    struct roots_inform_type roots_inform;
    struct cro_inform_type cro_inform;
    struct rpd_inform_type rpd_inform;
};

struct bllsb_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t iter;
    int64_t factorization_status;
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t nfacts;
    int64_t nbacts;
    int64_t threads;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    double non_negligible_pivot;
    bool feasible;
    int64_t checkpointsIter[16];
    double checkpointsTime[16];
    struct bllsb_time_type time;
    struct fdc_inform_type_64 fdc_inform;
    struct sls_inform_type_64 sls_inform;
    struct sls_inform_type_64 sls_pounce_inform;
    struct fit_inform_type_64 fit_inform;
    struct roots_inform_type_64 roots_inform;
    struct cro_inform_type_64 cro_inform;
    struct rpd_inform_type_64 rpd_inform;
};

void bllsb_initialize(void **data, struct bllsb_control_type *control, int32_t *status);
void bllsb_initialize_64(void **data, struct bllsb_control_type_64 *control, int64_t *status);
void bllsb_read_specfile(struct bllsb_control_type *control, char *specfile);
void bllsb_read_specfile_64(struct bllsb_control_type_64 *control, char *specfile);
void bllsb_import(struct bllsb_control_type *control, void **data, int32_t *status, int32_t n, int32_t o, char *Ao_type, int32_t Ao_ne, int32_t *Ao_row, int32_t *Ao_col, int32_t Ao_ptr_ne, int32_t *Ao_ptr);
void bllsb_import_64(struct bllsb_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t o, char *Ao_type, int64_t Ao_ne, int64_t *Ao_row, int64_t *Ao_col, int64_t Ao_ptr_ne, int64_t *Ao_ptr);
void bllsb_reset_control(struct bllsb_control_type *control, void **data, int32_t *status);
void bllsb_reset_control_64(struct bllsb_control_type_64 *control, void **data, int64_t *status);
void bllsb_solve_blls(void **data, int32_t *status, int32_t n, int32_t o, int32_t Ao_ne, double *Ao_val, double *b, double regularization_weight, double *x_l, double *x_u, double *x, double *r, double *z, int32_t *x_stat, double *w);
void bllsb_solve_blls_64(void **data, int64_t *status, int64_t n, int64_t o, int64_t Ao_ne, double *Ao_val, double *b, double regularization_weight, double *x_l, double *x_u, double *x, double *r, double *z, int64_t *x_stat, double *w);
void bllsb_information(void **data, struct bllsb_inform_type *inform, int32_t *status);
void bllsb_information_64(void **data, struct bllsb_inform_type_64 *inform, int64_t *status);
void bllsb_terminate(void **data, struct bllsb_control_type *control, struct bllsb_inform_type *inform);
void bllsb_terminate_64(void **data, struct bllsb_control_type_64 *control, struct bllsb_inform_type_64 *inform);

// C interface for SSLS
struct ssls_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type sls_control;
};

struct ssls_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    bool space_critical;
    bool deallocate_error_fatal;
    char symmetric_linear_solver[31];
    char prefix[31];
    struct sls_control_type_64 sls_control;
};

struct ssls_time_type {
    double total;
    double analyse;
    double factorize;
    double solve;
    double clock_total;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct ssls_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    int64_t factorization_integer;
    int64_t factorization_real;
    int32_t rank;
    bool rank_def;
    struct ssls_time_type time;
    struct sls_inform_type sls_inform;
};

struct ssls_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    int64_t factorization_integer;
    int64_t factorization_real;
    int64_t rank;
    bool rank_def;
    struct ssls_time_type time;
    struct sls_inform_type_64 sls_inform;
};

void ssls_initialize(void **data, struct ssls_control_type *control, int32_t *status);
void ssls_initialize_64(void **data, struct ssls_control_type_64 *control, int64_t *status);
void ssls_read_specfile(struct ssls_control_type *control, char *specfile);
void ssls_read_specfile_64(struct ssls_control_type_64 *control, char *specfile);
void ssls_import(struct ssls_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr, char *A_type, int32_t A_ne, int32_t *A_row, int32_t *A_col, int32_t *A_ptr, char *C_type, int32_t C_ne, int32_t *C_row, int32_t *C_col, int32_t *C_ptr);
void ssls_import_64(struct ssls_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr, char *A_type, int64_t A_ne, int64_t *A_row, int64_t *A_col, int64_t *A_ptr, char *C_type, int64_t C_ne, int64_t *C_row, int64_t *C_col, int64_t *C_ptr);
void ssls_reset_control(struct ssls_control_type *control, void **data, int32_t *status);
void ssls_reset_control_64(struct ssls_control_type_64 *control, void **data, int64_t *status);
void ssls_factorize_matrix(void **data, int32_t *status, int32_t h_ne, double *H_val, int32_t a_ne, double *A_val, int32_t c_ne, double *C_val);
void ssls_factorize_matrix_64(void **data, int64_t *status, int64_t h_ne, double *H_val, int64_t a_ne, double *A_val, int64_t c_ne, double *C_val);
void ssls_solve_system(void **data, int32_t *status, int32_t n, int32_t m, double *sol);
void ssls_solve_system_64(void **data, int64_t *status, int64_t n, int64_t m, double *sol);
void ssls_information(void **data, struct ssls_inform_type *inform, int32_t *status);
void ssls_information_64(void **data, struct ssls_inform_type_64 *inform, int64_t *status);
void ssls_terminate(void **data, struct ssls_control_type *control, struct ssls_inform_type *inform);
void ssls_terminate_64(void **data, struct ssls_control_type_64 *control, struct ssls_inform_type_64 *inform);

// C interface for EXPO
struct expo_control_type {
    bool f_indexing;
    int32_t error;
    int32_t out;
    int32_t print_level;
    int32_t start_print;
    int32_t stop_print;
    int32_t print_gap;
    int32_t max_it;
    int32_t max_eval;
    int32_t alive_unit;
    char alive_file[31];
    int32_t update_multipliers_itmin;
    double update_multipliers_tol;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double stop_s;
    double stop_subproblem_rel;
    double initial_mu;
    double mu_reduce;
    double obj_unbounded;
    double try_advanced_start;
    double try_sqp_start;
    double stop_advanced_start;
    double cpu_time_limit;
    double clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct bsc_control_type bsc_control;
    struct tru_control_type tru_control;
    struct ssls_control_type ssls_control;
};

struct expo_control_type_64 {
    bool f_indexing;
    int64_t error;
    int64_t out;
    int64_t print_level;
    int64_t start_print;
    int64_t stop_print;
    int64_t print_gap;
    int64_t max_it;
    int64_t max_eval;
    int64_t alive_unit;
    char alive_file[31];
    int64_t update_multipliers_itmin;
    double update_multipliers_tol;
    double infinity;
    double stop_abs_p;
    double stop_rel_p;
    double stop_abs_d;
    double stop_rel_d;
    double stop_abs_c;
    double stop_rel_c;
    double stop_s;
    double stop_subproblem_rel;
    double initial_mu;
    double mu_reduce;
    double obj_unbounded;
    double try_advanced_start;
    double try_sqp_start;
    double stop_advanced_start;
    double cpu_time_limit;
    double clock_time_limit;
    bool hessian_available;
    bool subproblem_direct;
    bool space_critical;
    bool deallocate_error_fatal;
    char prefix[31];
    struct bsc_control_type_64 bsc_control;
    struct tru_control_type_64 tru_control;
    struct ssls_control_type_64 ssls_control;
};

struct expo_time_type {
    float total;
    float preprocess;
    float analyse;
    float factorize;
    float solve;
    double clock_total;
    double clock_preprocess;
    double clock_analyse;
    double clock_factorize;
    double clock_solve;
};

struct expo_inform_type {
    int32_t status;
    int32_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int32_t iter;
    int32_t fc_eval;
    int32_t gj_eval;
    int32_t hl_eval;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    struct expo_time_type time;
    struct bsc_inform_type bsc_inform;
    struct tru_inform_type tru_inform;
    struct ssls_inform_type ssls_inform;
};

struct expo_inform_type_64 {
    int64_t status;
    int64_t alloc_status;
    char bad_alloc[81];
    char bad_eval[13];
    int64_t iter;
    int64_t fc_eval;
    int64_t gj_eval;
    int64_t hl_eval;
    double obj;
    double primal_infeasibility;
    double dual_infeasibility;
    double complementary_slackness;
    struct expo_time_type time;
    struct bsc_inform_type_64 bsc_inform;
    struct tru_inform_type_64 tru_inform;
    struct ssls_inform_type_64 ssls_inform;
};

void expo_initialize(void **data, struct expo_control_type *control, struct expo_inform_type *inform);
void expo_initialize_64(void **data, struct expo_control_type_64 *control, struct expo_inform_type_64 *inform);
void expo_read_specfile(struct expo_control_type *control, char *specfile);
void expo_read_specfile_64(struct expo_control_type_64 *control, char *specfile);
void expo_import(struct expo_control_type *control, void **data, int32_t *status, int32_t n, int32_t m, char *J_type, int32_t J_ne, int32_t *J_row, int32_t *J_col, int32_t *J_ptr, char *H_type, int32_t H_ne, int32_t *H_row, int32_t *H_col, int32_t *H_ptr);
void expo_import_64(struct expo_control_type_64 *control, void **data, int64_t *status, int64_t n, int64_t m, char *J_type, int64_t J_ne, int64_t *J_row, int64_t *J_col, int64_t *J_ptr, char *H_type, int64_t H_ne, int64_t *H_row, int64_t *H_col, int64_t *H_ptr);
void expo_reset_control(struct expo_control_type *control, void **data, int32_t *status);
void expo_reset_control_64(struct expo_control_type_64 *control, void **data, int64_t *status);
void expo_solve_hessian_direct(void **data, void *userdata, int32_t *status, int32_t n, int32_t m, int32_t J_ne, int32_t H_ne, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *y, double *z, double *c, double *gl, galahad_fc *eval_fc, galahad_gj *eval_gj, galahad_hl *eval_hl);
void expo_solve_hessian_direct_64(void **data, void *userdata, int64_t *status, int64_t n, int64_t m, int64_t J_ne, int64_t H_ne, double *c_l, double *c_u, double *x_l, double *x_u, double *x, double *y, double *z, double *c, double *gl, galahad_fc_64 *eval_fc, galahad_gj_64 *eval_gj, galahad_hl_64 *eval_hl);
void expo_information(void **data, struct expo_inform_type *inform, int32_t *status);
void expo_information_64(void **data, struct expo_inform_type_64 *inform, int64_t *status);
void expo_terminate(void **data, struct expo_control_type *control, struct expo_inform_type *inform);
void expo_terminate_64(void **data, struct expo_control_type_64 *control, struct expo_inform_type_64 *inform);

// end include guard
#endif

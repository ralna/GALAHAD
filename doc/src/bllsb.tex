\documentclass{galahad}

% set the package name

\newcommand{\package}{bllsb}
\newcommand{\packagename}{BLLSB}
\newcommand{\fullpackagename}{\libraryname\_\packagename}
\newcommand{\solver}{{\tt \fullpackagename\_solve}}

\begin{document}

\galheader

%%%%%%%%%%%%%%%%%%%%%% SUMMARY %%%%%%%%%%%%%%%%%%%%%%%%

\galsummary
This package uses a primal-dual interior-point method to solve the
{\bf bound-constrained regularized linear least-squares problem}
\eqn{qp}{\mbox{minimize}\;\; \half \| \bmA_o \bmx - \bmb\|_W^2
 + \half \sigma \| \bmx \|_2^2}
subject to the simple bound constraints
\disp{x_{j}^{l}  \leq  x_{j}^{ } \leq  x_{j}^{u} , \;\;\; j = 1, \ldots , n,}
where the $o$ by $n$ real matrix $\bmA_o$, the vectors 
$\bmb$, $\bmx^{l}$, $\bmx^{u}$ and the non-negative weights $\bmw > 0$ and 
$\sigma \geq 0$ are given, and where the Euclidean and weighted-Euclidean norms
satisfy $\|\bmv\|_2^2 = \bmv^T \bmv$ and $\|\bmv\|_W^2 = \bmv^T \bmW \bmv$,
respectively, with $\bmW = \mbox{diag}(\bmw)$.
Any of the constraint bounds $x_{j}^{l}$ and $x_{j}^{u}$ may be infinite.
Full advantage is taken of any zero coefficients in the matrix $\bmA_o$.

%%%%%%%%%%%%%%%%%%%%%% attributes %%%%%%%%%%%%%%%%%%%%%%%%

\galattributes
\galversions{\tt  \fullpackagename\_single, \fullpackagename\_double}.
\galuses
{\tt GALAHAD\_CLOCK},
{\tt GALAHAD\_SY\-M\-BOLS},
{\tt GALAHAD\-\_SPACE},
{\tt GALAHAD\_SPECFILE},
{\tt GALAHAD\_SMT},
{\tt GALAHAD\_QPT},
{\tt GALAHAD\_LSP},
{\tt GALAHAD\_\-QPD},
{\tt GALAHAD\_\-CQP},
{\tt GALAHAD\_\-CLLS},
{\tt GALAHAD\_\-FIT},
{\tt GALAHAD\_\-ROOTS},
{\tt GALAHAD\_\-NORMS},
{\tt GALAHAD\_\-SLS},
{\tt GALAHAD\_\-CRO},
{\tt GALAHAD\_FDC}.
\galdate December 2023.
\galorigin N. I. M. Gould.
\gallanguage Fortran~95 + TR 15581 or Fortran~2003.
\galparallelism Some options may use OpenMP and its runtime library.

%%%%%%%%%%%%%%%%%%%%%% HOW TO USE %%%%%%%%%%%%%%%%%%%%%%%%

\galhowto

%\subsection{Calling sequences}

The package is available using both single and double precision reals, 
and either 32-bit or 64-bit integers. Access to the 32-bit integer,
single precision version requires the {\tt USE} statement
\medskip

\hspace{8mm} {\tt USE \fullpackagename\_single}

\medskip
\noindent
with the obvious substitution {\tt \fullpackagename\_double},
{\tt \fullpackagename\_single\_64} and 
{\tt \fullpackagename\_double\_64} for the other variants.

\noindent
If it is required to use more than one of the modules at the same time, 
the derived types
{\tt SMT\_type},
{\tt QPT\_problem\_type},
{\tt NLPT\_userdata\-\_type},
{\tt \packagename\_time\_type},
{\tt \packagename\_control\_type},
{\tt \packagename\_inform\_type}
and
{\tt \packagename\_data\_type}
(Section~\ref{galtypes})
and the subroutines
{\tt \packagename\_initialize},
{\tt \packagename\_\-solve},
{\tt \packagename\_terminate},
(Section~\ref{galarguments})
and
{\tt \packagename\_read\_specfile}
(Section~\ref{galfeatures})
must be renamed on one of the {\tt USE} statements.

%%%%%%%%%%%%%%%%%%%%%% matrix formats %%%%%%%%%%%%%%%%%%%%%%%%

\galmatrix
An $m$ by $n$ matrix $\bmA$ (in our case $\bmA_o$)
may be stored in a variety of input formats.

\subsubsection{Dense row-wise storage format}\label{dense}
The matrix $\bmA$ is stored as a compact
dense matrix by rows, that is, the values of the entries of each row in turn are
stored in order within an appropriate real one-dimensional array.
Component $n \ast (i-1) + j$ of the storage array {\tt A\%val} will hold the
value $a_{ij}$ for $i = 1, \ldots , m$, $j = 1, \ldots , n$.

\subsubsection{Dense column-wise storage format}\label{densecolumnwise}
The matrix $\bmA$ is stored as a compact
dense matrix by columns, that is, the values of the entries of each column
in turn are stored in order within an appropriate real one-dimensional array.
Component $m \ast (j-1) + i$ of the storage array {\tt A\%val} will hold the
value $a_{ij}$ for $i = 1, \ldots , m$, $j = 1, \ldots , n$.

\subsubsection{Sparse co-ordinate storage format}\label{coordinate}
Only the nonzero entries of the matrices are stored. For the
$l$-th entry of $\bmA$, its row index $i$, column index $j$
and value $a_{ij}$
are stored in the $l$-th components of the integer arrays {\tt A\%row},
{\tt A\%col} and real array {\tt A\%val}, respectively.
The order is unimportant, but the total
number of entries {\tt A\%ne} is also required.

\subsubsection{Sparse row-wise storage format}\label{rowwise}
Again only the nonzero entries are stored, but this time
they are ordered so that those in row $i$ appear directly before those
in row $i+1$. For the $i$-th row of $\bmA$, the $i$-th component of a
integer array {\tt A\%ptr} holds the position of the first entry in this row,
while {\tt A\%ptr} $(m+1)$ holds the total number of entries plus one.
The column indices $j$ and values $a_{ij}$ of the entries in the $i$-th row
are stored in components
$l =$ {\tt A\%ptr}$(i)$, \ldots ,{\tt A\%ptr} $(i+1)-1$ of the
integer array {\tt A\%col}, and real array {\tt A\%val}, respectively.

\subsubsection{Sparse column-wise storage format}\label{columnwise}
Once again only the nonzero entries are stored, but this time
they are ordered so that those in column $j$ appear directly before those
in column $j+1$. For the $j$-th column of $\bmA$, the $j$-th component of a
integer array {\tt A\%ptr} holds the position of the first entry in this column,
while {\tt A\%ptr} $(n+1)$ holds the total number of entries plus one.
The row indices $i$ and values $a_{ij}$ of the entries in the $j$-th column
are stored in components
$l =$ {\tt A\%ptr}$(j)$, \ldots ,{\tt A\%ptr} $(j+1)-1$ of the
integer array {\tt A\%row}, and real array {\tt A\%val}, respectively.

For sparse matrices, the latter pair schemes almost always require less
storage than the co-ordinate one.

%%%%%%%%%%%%%%%%%%%%%% kinds %%%%%%%%%%%%%%%%%%%%%%

\input{kinds}

%%%%%%%%%%%%%%%%%%%%%% parallel usage %%%%%%%%%%%%%%%%%%%%%%%%

\input{parallel}

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\galtypes
Ten derived data types are accessible from the package.

%%%%%%%%%%% matrix data type %%%%%%%%%%%

\subsubsection{The derived data type for holding matrices}\label{typesmt}
The derived data type {\tt SMT\_TYPE} is used to hold an $m$ by $n$ 
matrix $\bmA$. The components of {\tt SMT\_TYPE} used here are:

\begin{description}

\ittf{m} is a scalar component of type \integer,
that holds the number of rows in the matrix.

\ittf{n} is a scalar component of type \integer,
that holds the number of columns in the matrix.

\ittf{ne} is a scalar variable of type \integer, that
holds the number of matrix entries.

\ittf{type} is a rank-one allocatable array of type default \character, that
is used to indicate the matrix storage scheme used. Its precise length and
content depends on the type of matrix to be stored (see \S\ref{typeprob}).

\ittf{val} is a rank-one allocatable array of type \realdp\,
and dimension at least {\tt ne}, that holds the values of the entries.

\ittf{row} is a rank-one allocatable array of type \integer,
and dimension at least {\tt ne}, that may hold the row indices of the entries.
(see \S\ref{coordinate} \& \ref{columnwise}).

\ittf{col} is a rank-one allocatable array of type \integer,
and dimension at least {\tt ne}, that may the column indices of the entries
(see \S\ref{coordinate}--\ref{rowwise}).

\ittf{ptr} is a rank-one allocatable array of type \integer,
and dimension at least {\tt m + 1}, that may hold the pointers to
the first entry in each row (see \S\ref{rowwise}),
or dimension at least {\tt n + 1}, that may hold the pointers to
the first entry in each column (see \S\ref{columnwise}),

\end{description}

%%%%%%%%%%% problem type %%%%%%%%%%%

\subsubsection{The derived data type for holding the problem}\label{typeprob}
The derived data type {\tt QPT\_problem\_type} is used to hold
the problem. The components of
{\tt QPT\_problem\_type}
are:

\begin{description}

\ittf{n} is a scalar variable of type \integer,
 that holds the number of optimization variables, $n$.

\ittf{o} is a scalar variable of type \integer,
 that holds the number of observations, $o$.

\ittf{Ao} is scalar variable of type {\tt SMT\_TYPE}
that holds the objective design matrix $\bmA_o$.
The following components are used:

\begin{description}

\itt{Ao\%type} is an allocatable array of rank one and type default \character,
that is used to indicate the storage scheme used.
If the dense row-wise storage scheme (see Section~\ref{dense}) is used,
the first five components of {\tt Ao\%type} must contain the
string {\tt DENSE}.
By contrast, if the dense column-wise storage scheme
(see Section~\ref{densecolumnwise}) is used,
the first fifteen components of {\tt Ao\%type} must contain the
string {\tt DENSE\_BY\_COLUMNS}.
For the sparse co-ordinate scheme (see Section~\ref{coordinate}),
the first ten components of {\tt Ao\%type} must contain the
string {\tt COORDINATE}, while
for the sparse row-wise storage scheme (see Section~\ref{rowwise}),
the first fourteen components of {\tt Ao\%type} must contain the
string {\tt SPARSE\_BY\_ROWS},
and for the sparse column-wise storage scheme (see Section~\ref{columnwise}),
the first seventeen components of {\tt Ao\%type} must contain the
string {\tt SPARSE\_BY\_COLUMNS},

The procedure {\tt SMT\_put} may be used to allocate sufficient space and
insert the required keyword into {\tt Ao\%type}. For example,
if {\tt prob} is of derived type {\tt \packagename\_problem\_type}
and involves an objective design matrix we wish to store using the co-ordinate
storage scheme, we may simply
%\vspace*{-2mm}
{\tt
\begin{verbatim}
        CALL SMT_put( prob%Ao%type, 'COORDINATE', istat )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent

\itt{Ao\%ne} is a scalar variable of type \integer, that
holds the number of entries in $\bmA_o$
in the sparse co-ordinate storage scheme (see Section~\ref{coordinate}).
It need not be set for any of the other appropriate schemes.

\itt{Ao\%val} is a rank-one allocatable array of type \realdp, that
holds the values of the entries of the design matrix $\bmA_o$ in any of the
appropriate storage schemes discussed in Section~\ref{galmatrix}.

\itt{Ao\%row} is a rank-one allocatable array of type \integer,
that holds the row indices of $\bmA_o$ in the sparse co-ordinate storage
or sparse column-wise schemes
(see Sections~\ref{coordinate} and \ref{columnwise}).
It need not be allocated for any of the other schemes.

\itt{Ao\%col} is a rank-one allocatable array variable of type \integer,
that holds the column indices of $\bmA_o$ in either the sparse co-ordinate
(see Section~\ref{coordinate}), or the sparse row-wise
(see Section~\ref{rowwise}) storage scheme.
It need not be allocated for any of the other schemes.

\itt{Ao\%ptr} is a rank-one allocatable array of dimension {\tt o+1} and type
\integer, that holds the starting position of each row of $\bmA_o$,
as well as the total number of entries plus one,
in the sparse row-wise storage scheme (see Section~\ref{rowwise}).
By contrast, for the sparse column-wise storage scheme
(see Section~\ref{columnwise}), it should be of dimension {\tt n+1}
and holds the starting position of each column of $\bmA_o$,
as well as the total number of entries plus one,
It need not be allocated when the other appropriate schemes are used.

\end{description}

\ittf{B} is a rank-one allocatable array type \realdp, that
should be allocated to have length {\tt o}, and its $i$-th component
filled with the value $b_{i}$ for $i = 1, \ldots , o$.

\ittf{X\_l} is a rank-one allocatable array of dimension {\tt n} and type
\realdp, that holds
the vector of lower bounds $\bmx^{l}$ on the the variables.
The $j$-th component of {\tt X\_l}, $j = 1, \ldots , n$,
contains $\bmx_{j}^{l}$.
Infinite bounds are allowed by setting the corresponding
components of {\tt X\_l} to any value smaller than {\tt -infinity},
where {\tt infinity} is a component of the control array {\tt control}
(see Section~\ref{typecontrol}).

\ittf{X\_u} is a rank-one allocatable array of dimension {\tt n} and type
\realdp, that holds
the vector of upper bounds $\bmx^{u}$ on the variables.
The $j$-th component of {\tt X\_u}, $j = 1, \ldots , n$,
contains $\bmx_{j}^{u}$.
Infinite bounds are allowed by setting the corresponding
components of {\tt X\_u} to any value larger than that {\tt infinity},
where {\tt infinity} is a component of the control array {\tt control}
(see Section~\ref{typecontrol}).

\ittf{X} is a rank-one allocatable array of dimension {\tt n} and type
\realdp,
that holds the values $\bmx$ of the optimization variables.
The $j$-th component of {\tt X}, $j = 1,  \ldots , n$, contains $x_{j}$.

\ittf{R} is a rank-one allocatable array of dimension {\tt o} and type default
\realdp, that holds the values $\bmr = \bmA_o \bmx - \bmb$ of the residuals.
The $i$-th component of {\tt R}, $i = 1,  \ldots , o$, contains $\bmr_{i}$.

\ittf{Z} is a rank-one allocatable array of dimension {\tt n} and type default
\realdp, that holds
the values $\bmz$ of estimates  of the dual variables
corresponding to the simple bound constraints (see Section~\ref{galmethod}).
The $j$-th component of {\tt Z}, $j = 1,  \ldots ,  n$, contains $z_{j}$.

\itt{X\_status} is a rank-one allocatable array argument of dimension {\tt n}
and type \integer, that indicates which of the simple bound
constraints are in the current active set. Possible values for
{\tt X\_status(j)}, {\tt j}$=1, \ldots ,$ {\tt n}, and their meanings are
\begin{description}
\itt{<0} the $j$-th simple bound constraint
is in the active set, on its lower bound,
\itt{>0} the $j$-th simple bound constraint
is in the active set, on its upper bound, and
\itt{0}  the $j$-th simple bound constraint is not in the active set.
\end{description}
When {\tt control\%crossover} is \true, more specific values are
\begin{description}
\itt{-1} the $j$-th simple bound constraint
is both independent and active on its lower bound,
\itt{-2} the $j$-th simple bound constraint
is on its lower bound but linearly dependent on others,
\itt{1} the $j$-th simple bound constraint
is both independent and active on its upper bound,
\itt{2} the $j$-th simple bound constraint
is on its upper bound but linearly dependent on others, and
\itt{0} the $j$-th simple bound constraint is not in the active set.
\end{description}

\end{description}

%%%%%%%%%%% control type %%%%%%%%%%%

\subsubsection{The derived data type for holding control
 parameters}\label{typecontrol}
The derived data type
{\tt \packagename\_control\_type}
is used to hold controlling data. Default values may be obtained by calling
{\tt \packagename\_initialize}
(see Section~\ref{subinit}),
while components may also be changed by calling
{\tt \packagename\_read\-\_specfile}
(see Section~\ref{readspec}).
The components of
{\tt \packagename\_control\_type}
are:

\begin{description}

\itt{error} is a scalar variable of type \integer, that holds the
stream number for error messages. Printing of error messages in
{\tt \packagename\_solve} and {\tt \packagename\_terminate} is suppressed if
{\tt error} $\leq 0$.
The default is {\tt error = 6}.

\ittf{out} is a scalar variable of type \integer, that holds the
stream number for informational messages. Printing of informational messages in
{\tt \packagename\_solve} is suppressed if {\tt out} $< 0$.
The default is {\tt out = 6}.

\itt{print\_level} is a scalar variable of type \integer, that is used
to control the amount of informational output which is required. No
informational output will occur if {\tt print\_level} $\leq 0$. If
{\tt print\_level} $= 1$, a single line of output will be produced for each
iteration of the process. If {\tt print\_level} $\geq 2$, this output will be
increased to provide significant detail of each iteration.
The default is {\tt print\_level = 0}.

\itt{maxit} is a scalar variable of type \integer, that holds the
maximum number of iterations which will be allowed in {\tt \packagename\_solve}.
The default is {\tt maxit = 1000}.

\itt{start\_print} is a scalar variable of type \integer, that specifies
the first iteration for which printing will occur in {\tt \packagename\_solve}.
If {\tt start\_print} is negative, printing will occur from the outset.
The default is {\tt start\_print = -1}.

\itt{stop\_print} is a scalar variable of type \integer, that specifies
the last iteration for which printing will occur in  {\tt \packagename\_solve}.
If {\tt stop\_print} is negative, printing will occur once it has been
started by {\tt start\_print}.
The default is {\tt stop\_print = -1}.

\itt{infeas\_max} is a scalar variable of type \integer, that specifies
the number of iterations for which the overall infeasibility
of the problem is not reduced by at least a factor {\tt reduce\_infeas
before} the problem is flagged as infeasible (see {\tt reduce\_infeas}).
The default is {\tt infeas\_max = 200}.
%The default is {\tt infeas\_max = 10}.

\itt{muzero\_fixed} is a scalar variable of type \integer,
that specifies
the number of iterations before the initial barrier parameter
(see {\tt muzero}) may be altered.
The default is {\tt muzero\_fixed = 1}.

\ifthenelse{\equal{\package}{bllsb}}{
\itt{restore\_problem} is a scalar variable of type \integer, that
specifies how much of the input problem is to be restored on output.
Possible values are:
\begin{description}
\itt{0} nothing is restored.
\itt{1} the vector data $\bmw$, $\bmb$,
   $\bmx^{l}$, and $\bmx^{u}$
   will be restored to their input values.
\itt{2} the entire problem, that is the above vector data along with
the matrix $\bmA_o$ will be restored.
\end{description}
The default is {\tt restore\_problem = 2}.
}{}

\itt{indicator\_type} is a scalar variable of type \integer,
that specifies the type of indicator used to assess when a bounds on
a variable is active.
Possible values are:

\begin{description}
\itt{1} a bound is active if and only if the distance
to its nearest bound is no larger than {\tt indicator\-\_tol\_p} (see below).
\itt{2} a bound is active if and only if the distance
to its nearest bound is no larger than {\tt indicator\-\_tol\_pd}
(see below) times the magnitude of its corresponding dual variable.
\itt{3} a bound is active if and only if the distance
to its neaerest bound is no larger than {\tt indicator\-\_tol\_tapia}
(see below) times the distance to the same bound at the previous iteration.
\end{description}
The default is {\tt indicator\_type = 3}.

\itt{arc} is a scalar variable of type \integer,
that specifies the type of residual trajectory used to define the path
to the solution.
Possible values are:

\begin{description}
\itt{1} the residual trajectory proposed by Zhang will be used.
\itt{2} the residual trajectory proposed by Zhao and Sun will be used; note
this trajectory does not necessarily ensure convergence, so should be used
with caution.
\itt{3} a combination in which Zhang's trajectory is used until the
method determines that Zhou and Sun's will be better.
\itt{4} a mixed linear-quadratic variant of Zhang's proposal will be used.
\end{description}
The default is {\tt arc = 1}.

\itt{series\_order} is a scalar variable of type \integer, that
specifies the order of (Puiseux or Taylor) series to approximate the
residual trajectory. The default is {\tt series\_order = 2}.

\itt{infinity} is a scalar variable of type \realdp, that is used to
specify which constraint bounds are infinite.
Any bound larger than {\tt infinity} in modulus will be regarded as infinite.
The default is {\tt infinity =} $10^{19}$.

\itt{stop\_abs\_p} and {\tt stop\_rel\_p}
are scalar variables of type \realdp, that hold the
required absolute and relative accuracy for the primal infeasibility
(see Section~\ref{galmethod}).
The absolute value of each component of the primal infeasibility
on exit is required to be smaller than the larger of {\tt stop\_abs\_p} and
{\tt stop\_rel\_p} times a ``typical value'' for this component.
The defaults are {\tt stop\_abs\_p =} {\tt stop\_rel\_p =} $u^{1/3}$,
where $u$ is {\tt EPSILON(1.0)} ({\tt EPSILON(1.0D0)} in
{\tt \fullpackagename\_double}).

\itt{stop\_abs\_d} and {\tt stop\_rel\_d}
are scalar variables of type \realdp, that hold the
required absolute and relative accuracy for the dual infeasibility
(see Section~\ref{galmethod}).
The absolute value of each component of the dual infeasibility
on exit is required to be smaller than the larger of {\tt stop\_abs\_p} and
{\tt stop\_rel\_p} times a ``typical value'' for this component.
The defaults are {\tt stop\_abs\_d =} {\tt stop\_rel\_d =} $u^{1/3}$,
where $u$ is {\tt EPSILON(1.0)} ({\tt EPSILON(1.0D0)} in
{\tt \fullpackagename\_double}).

\itt{stop\_abs\_c} and {\tt stop\_rel\_c}
are scalar variables of type \realdp, that hold the
required absolute and relative accuracy
for the violation of complementary slackness
(see Section~\ref{galmethod}).
The absolute value of each component of the complementary slackness
on exit is required to be smaller than the larger of {\tt stop\_abs\_p} and
{\tt stop\_rel\_p} times a ``typical value'' for this component.
The defaults are {\tt stop\_abs\_c =} {\tt stop\_rel\_c =} $u^{1/3}$,
where $u$ is {\tt EPSILON(1.0)} ({\tt EPSILON(1.0D0)} in
{\tt \fullpackagename\_double}).

\itt{prfeas} is a scalar variable of type \realdp, that aims to specify
the closest that any initial variable may be to infeasibility. Any variable
closer to infeasibility than {\tt prfeas} will be moved to {\tt prfeas} from
the offending bound. However, if a variable is range bounded, and its bounds
are closer than {\tt prfeas} apart, it will be moved to the mid-point of the
two bounds.
The default is {\tt prfeas = $10^4$}.

\itt{dufeas} is a scalar variable of type \realdp, that aims to specify
the closest that any initial dual variable or Lagrange multiplier may be to
infeasibility. Any variable closer to infeasibility than {\tt prfeas} will be
moved to {\tt dufeas} from the offending bound. However, if a dual variable
is range bounded, and its bounds are closer than {\tt dufeas} apart, it will
be moved to the mid-point of the two bounds.
The default is {\tt dufeas = $10^4$}.

\itt{muzero}  is a scalar variable of type \realdp, that holds the
initial value of the barrier parameter. If {\tt muzero} is
not positive, it will be reset automatically to an appropriate value.
The default is {\tt muzero = -1.0}.

\itt{tau}  is a scalar variable of type \realdp, that holds the
weight attached to primal-dual infeasibility compared to complementarity
when assessing step acceptance.
The default is {\tt tau = 1.0}.

\itt{gamma\_c}  is a scalar variable of type \realdp, that holds the
smallest value that individual complementarity pairs are allowed
to be relative to the average as the iteration proceeds.
The default is {\tt gamma\_c = $10^{-5}$}.

\itt{gamma\_f}  is a scalar variable of type \realdp, that holds the
smallest value the average complementarity is allowed
to be relative to the primal-dual infeasibility as the iteration proceeds.
The default is {\tt gamma\_c = $10^{-5}$}.

\itt{reduce\_infeas}  is a scalar variable of type default
\realdp, that specifies the
least factor by which the overall infeasibility of the problem must be reduced,
over {\tt infeas\_max} consecutive iterations,
for it not be declared infeasible (see {\tt infeas\_max)}.
The default is {\tt reduce\_infeas = 0.99}.

\itt{identical\_bounds\_tol}
is a scalar variable of type \realdp.
Every pair of constraint bounds
$(c_{i}^{l}, c_{i}^{u})$ or $(x_{j}^{l}, x_{j}^{u})$
that is closer than {\tt identical\_bounds\_tol}
will be reset to the average of their values,
$\half (c_{i}^{l} + c_{i}^{u})$ or $\half (x_{j}^{l} + x_{j}^{u})$
respectively.
The default is {\tt identical\_bounds\_tol =} $u$,
where $u$ is {\tt EPSILON(1.0)} ({\tt EPSILON(1.0D0)} in
{\tt \fullpackagename\_double}).

\itt{mu\_pounce}
is a scalar variable of type \realdp that specifies
the value of the barrier parameter that must be attained before an 
extrapolating ``pounce'' may be attempted.
The default is {\tt mu\_pounce =} $10^{-5}$.

\itt{indicator\_tol\_p}
is a scalar variable of type \realdp that
provides the indicator tolerance associated with the test
{\tt indicator\_type = 1}.
The default is {\tt indicator\_tol\_p =} $u^{1/3}$,
where $u$ is {\tt EPSILON(1.0)} ({\tt EPSILON(1.0D0)} in
{\tt \fullpackagename\_double}).

\itt{indicator\_tol\_pd}
is a scalar variable of type \realdp that
provides the indicator tolerance associated with the test
{\tt indicator\_type = 2}.
The default is {\tt indicator\_tol\_pd =} 1.0.

\itt{indicator\_tol\_tapia}
is a scalar variable of type \realdp that
provides the indicator tolerance associated with the test
{\tt indicator\_type = 3}.
The default is {\tt indicator\_tol\-\_tapia =} 0.9.

\itt{cpu\_time\_limit} is a scalar variable of type \realdp,
that is used to specify the maximum permitted CPU time. Any negative
value indicates no limit will be imposed. The default is
{\tt cpu\_time\_limit = - 1.0}.

\itt{clock\_time\_limit} is a scalar variable of type \realdp,
that is used to specify the maximum permitted elapsed system clock time.
Any negative value indicates no limit will be imposed. The default is
{\tt clock\_time\_limit = - 1.0}.

\itt{remove\_dependencies} is a scalar variable of type
default \logical, that must be set \true\ if the algorithm
is to attempt to remove any linearly dependent constraints before
solving the problem, and \false\ otherwise.
We recommend removing linearly dependencies.
The default is {\tt remove\_dependencies = .TRUE.}.

\itt{treat\_zero\_bounds\_as\_general} is a scalar variable of type
default \logical.
If it is set to \false, variables which
are only bounded on one side, and whose bound is zero,
will be recognised as non-negativities/non-positivities rather than simply as
lower- or upper-bounded variables.
If it is set to \true, any variable bound
$x_{j}^{l}$ or $x_{j}^{u}$ which has the value 0.0 will be
treated as if it had a general value.
Setting {\tt treat\_zero\_bounds\_as\_general} to \true\ has the advantage
that if a sequence of problems are reordered, then bounds which are
``accidentally'' zero will be considered to have the same structure as
those which are nonzero. However, {\tt \fullpackagename} is
able to take special advantage of non-negativities/non-positivities, so
if a single problem, or if a sequence of problems whose
bound structure is known not to change, is/are to be solved,
it will pay to set the variable to \false.
The default is {\tt treat\_zero\_bounds\_as\_general = .FALSE.}.

\itt{just\_feasible} is a scalar variable of type default \logical, that
must be set \true\ if the algorithm should stop as soon as a feasible point
of the constraint set is found, and \false\ otherwise.
%We recommend using the analytic center.
The default is {\tt just\_feasible = .FALSE.}.

\itt{getdua} is a scalar variable of type default \logical, that
must be set \true\ if the user-provided estimates of the dual variables
should be replaced by estimates whose aim is to try to balance the
requirements of dual feasibility and complementary slackness,
and \false\ if users estimates are to be used.
The default is {\tt getdua = .FALSE.}.

\itt{puiseux} is a scalar variable of type default \logical, that
must be set \true\
if a Puiseux series will be used when extrapolating along the central path
and \false\ if a Taylor series is preferred.
We recommend using the Puiseux series unless the solution is known
to be non-degenerate.
The default is {\tt puiseux = .TRUE.}.

\itt{every\_order} is a scalar variable of type default \logical, that
must be set \true\
if every order of approximation up to {\tt series\_order} will be tried
and the best taken,
and \false\ if only the exact order specified by  {\tt series\_order}
will be used.
The default is {\tt every\_order = .TRUE.}.

\itt{feasol} is a scalar variable of type default \logical, that
should be set \true\
if the final solution obtained will be perturbed
so that variables close to their bounds are moved onto these bounds,
and \false\ otherwise.
The default is {\tt feasol = .FALSE.}.
%The default is {\tt feasol = .TRUE.}.

\itt{balance\_initial\_complentarity} is a scalar variable of type 
default \logical, that should be set \true\
if the initial complementarity is required to be balanced,
and \false\ otherwise.
The default is {\tt balance\_initial\_complentarity = .FALSE.}.

\itt{crossover} is a scalar variable of type default \logical,
that must be set \true\ if the solution is to be defined in terms
of linearly-independent constraints,
and  \false\ otherwise.
The default is {\tt crossover = .TRUE.}.

\itt{reduced\_pounce\_system} is a scalar variable of type 
default \logical, that should be set \true\
if fixed variables will be eliminated when solving the linear system 
required by attempted pounces to the solution, and \false\ otherwise.
The default is {\tt reduced\_pounce\_system = .TRUE.}.

\itt{space\_critical} is a scalar variable of type default \logical,
that must be set \true\ if space is critical when allocating arrays
and  \false\ otherwise. The package may run faster if
{\tt space\_critical} is \false\ but at the possible expense of a larger
storage requirement. The default is {\tt space\_critical = .FALSE.}.

\itt{deallocate\_error\_fatal} is a scalar variable of type default \logical,
that must be set \true\ if the user wishes to terminate execution if
a deallocation  fails, and \false\ if an attempt to continue
will be made. The default is {\tt deallocate\_error\_fatal = .FALSE.}.

\itt{symmetric\_linear\_solver} is a scalar variable of type default \character\
and length 30, that specifies the external package to be used to
solve any symmetric linear system that might arise. Current possible
choices are {\tt 'sils'}, {\tt 'ma27'}, {\tt 'ma57'}, {\tt 'ma77'},
{\tt 'ma86'}, {\tt 'ma97'}, {\tt ssids}, {\tt 'pardiso'}
and {\tt 'wsmp'},
although only {\tt 'sils'} and, for OMP 4.0-compliant compilers,
{\tt 'ssids'} are installed by default.
See the documentation for the \galahad\ package {\tt SLS} for further details.
The default is {\tt symmetric\_linear\_solver = 'sils'}.

\itt{prefix} is a scalar variable of type default \character\
and length 30, that may be used to provide a user-selected
character string to preface every line of printed output.
Specifically, each line of output will be prefaced by the string
{\tt prefix(2:LEN(TRIM(prefix))-1)},
thus ignoring the first and last non-null components of the
supplied string. If the user does not want to preface lines by such
a string, they may use the default {\tt prefix = ""}.

\itt{FDC\_control} is a scalar variable of type
{\tt FDC\_control\_type}
whose components are used to control any detection of linear dependencies
performed by the package
{\tt \libraryname\_FDC}.
See the specification sheet for the package
{\tt \libraryname\_FDC}
for details, and appropriate default values.

\itt{SLS\_control} and {SLS\_pounce\_control}
are scalar variables of type
{\tt SLS\_control\_type}
whose components are used to control factorizations
performed by the package
{\tt \libraryname\_SLS} for generic and pounce-specific factorizations.
See the specification sheet for the package
{\tt \libraryname\_SLS}
for details, and appropriate default values.

\itt{FIT\_control} is a scalar variable of type
{\tt FIT\_control\_type}
whose components are used to control fitting of data to polynomials
performed by the package
{\tt \libraryname\_FIT}.
See the specification sheet for the package
{\tt \libraryname\_FIT}
for details, and appropriate default values.

\itt{ROOTS\_control} is a scalar variable of type
{\tt ROOTS\_control\_type}
whose components are used to control the polynomial root finding
performed by the package
{\tt \libraryname\_ROOTS}.
See the specification sheet for the package
{\tt \libraryname\_ROOTS}
for details, and appropriate default values.

\itt{CRO\_control} is a scalar variable of type
{\tt CRO\_control\_type}
whose components are used to control crossover
performed by the package
{\tt \libraryname\_CRO}.
See the specification sheet for the package
{\tt \libraryname\_CRO}
for details, and appropriate default values.

\end{description}

%%%%%%%%%%% time type %%%%%%%%%%%

\subsubsection{The derived data type for holding timing
 information}\label{typetime}
The derived data type
{\tt \packagename\_time\_type}
is used to hold elapsed CPU and system clock times for the various parts of
the calculation. The components of
{\tt \packagename\_time\_type}
are:
\begin{description}
\itt{total} is a scalar variable of type \realdp, that gives
 the total CPU time spent in the package.

\itt{preprocess} is a scalar variable of type \realdp, that gives
 the CPU time spent preprocess the problem prior to solution.

\itt{find\_dependent} is a scalar variable of type \realdp, that gives
 the CPU time spent detecting and removing dependent constraints prior
to solution.

\itt{analyse} is a scalar variable of type \realdp, that gives
 the CPU time spent analysing the required matrices prior to factorization.

\itt{factorize} is a scalar variable of type \realdp, that gives
 the CPU time spent factorizing the required matrices.

\itt{solve} is a scalar variable of type \realdp, that gives
 the CPU time spent computing the search direction.

\itt{clock\_total} is a scalar variable of type \realdp, that gives
 the total elapsed system clock time spent in the package.

\itt{clock\_preprocess} is a scalar variable of type \realdp, that gives
 the elapsed system clock time spent preprocess the problem prior to solution.

\itt{clock\_find\_dependent} is a scalar variable of type \realdp,
that gives  the elapsed system clock time spent detecting and removing
dependent constraints prior to solution.

\itt{clock\_analyse} is a scalar variable of type \realdp, that gives
 the elapsed system clock time spent analysing the required matrices prior to
factorization.

\itt{clock\_factorize} is a scalar variable of type \realdp, that gives
 the elapsed system clock time spent factorizing the required matrices.

\itt{clock\_solve} is a scalar variable of type \realdp, that gives
 the elapsed system clock time spent computing the search direction.

\end{description}

%%%%%%%%%%% inform type %%%%%%%%%%%

\subsubsection{The derived data type for holding informational
 parameters}\label{typeinform}
The derived data type
{\tt \packagename\_inform\_type}
is used to hold parameters that give information about the progress and needs
of the algorithm. The components of
{\tt \packagename\_inform\_type}
are:

\begin{description}

\itt{status} is a scalar variable of type \integer, that gives the
exit status of the algorithm.
%See Sections~\ref{galerrors} and \ref{galinfo}
See Section~\ref{galerrors}
for details.

\itt{alloc\_status} is a scalar variable of type \integer, that gives
the status of the last attempted array allocation or deallocation.
This will be 0 if {\tt status = 0}.

\itt{bad\_alloc} is a scalar variable of type default \character\
and length 80, that  gives the name of the last internal array
for which there were allocation or deallocation errors.
This will be the null string if {\tt status = 0}.

\itt{factorization\_status} is a scalar variable of type \integer, that
gives the return status from the matrix factorization.

\itt{factorization\_integer} is a scalar variable of type long
\integer, that gives the amount of integer storage used for the matrix
factorization.

\itt{factorization\_real} is a scalar variable of type \longinteger,
that gives the amount of real storage used for the matrix factorization.

\itt{nfacts} is a scalar variable of type \integer, that gives the
total number of factorizations performed.

\itt{nbacts} is a scalar variable of type \integer, that gives the
total number of backtracks performed during the sequence of linesearches.

\itt{threads} is a scalar variable of type \integer, that gives the
total number of threads used for parallel execution.

\itt{iter} is a scalar variable of type \integer, that
gives the number of iterations performed.

\ittf{obj} is a scalar variable of type \realdp, that holds the
value of the objective function at the best estimate of the solution found.

\itt{primal\_infeasibility} is a scalar variable of type \realdp,
that holds the norm of the violation of primal optimality
(see Section~\ref{typetime}) at the best estimate of the solution found.

\itt{dual\_infeasibility} is a scalar variable of type \realdp,
that holds the norm of the violation of dual optimality
(see Section~\ref{typetime}) at the best estimate of the solution found.

\itt{complementary\_slackness}
is a scalar variable of type \realdp,
that holds the norm of the violation of complementary slackness
(see Section~\ref{typetime}) at the best estimate of the solution found.

\itt{non\_negligible\_pivot}
is a scalar variable of type \realdp,
that holds the value of the smallest pivot which was not judged to be 
zero when detecting linearly dependent constraints.

\itt{feasible} is a scalar variable of type default \logical, that has the
value \true\ if the output value of $\bmx$ satisfies the constraints,
and the value \false\ otherwise.

\ittf{time} is a scalar variable of type {\tt \packagename\_time\_type}
whose components are used to hold elapsed CPU and system clock times for the
various parts of the calculation (see Section~\ref{typetime}).

\itt{FDC\_inform} is a scalar variable of type
{\tt FDC\_inform\_type}
whose components are used to provide information about
any detection of linear dependencies
performed by the package
{\tt \libraryname\_FDC}.
See the specification sheet for the package
{\tt \libraryname\_FDC} for details.

\itt{SLS\_inform} and {SLS\_pounce\_inform}
are scalar variables of type {\tt SLS\_inform\_type}
whose components are used to provide information about
generic and pounce-specific factorizations performed by the package
{\tt \libraryname\_SLS}.
See the specification sheet for the package
{\tt \libraryname\_SLS} for details.

\itt{FIT\_inform} is a scalar variable of type
{\tt FIT\_inform\_type}
whose components are used to provide information about the fitting
of data to polynomials performed by the package
{\tt \libraryname\_FIT}.
See the specification sheet for the package
{\tt \libraryname\_FIT} for details.

\itt{ROOTS\_inform} is a scalar variable of type
{\tt ROOTS\_inform\_type}
whose components are used to provide information about the
polynomial root finding performed by the package
{\tt \libraryname\_ROOTS}.
See the specification sheet for the package
{\tt \libraryname\_ROOTS} for details.

\itt{CRO\_inform} is a scalar variable of type
{\tt CRO\_inform\_type}
whose components are used to provide information about the crossover
performed by the package
{\tt \libraryname\_CRO}.
See the specification sheet for the package
{\tt \libraryname\_CRO} for details.

\end{description}


%%%%%%%%%%% data type %%%%%%%%%%%

\subsubsection{The derived data type for holding problem data}\label{typedata}
The derived data type
{\tt \packagename\_data\_type}
is used to hold all the data for a particular problem,
or sequences of problems with the same structure, between calls of
{\tt \packagename} procedures.
This data should be preserved, untouched, from the initial call to
{\tt \packagename\_initialize}
to the final call to
{\tt \packagename\_terminate}.

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\galarguments
There are three procedures for user calls
(see Section~\ref{galfeatures} for further features):

\begin{enumerate}
\item The subroutine
      {\tt \packagename\_initialize}
      is used to set default values, and initialize private data,
      before solving one or more problems with the
      same sparsity and bound structure.
\item The subroutine
      {\tt \packagename\_solve}
      is called to solve the problem.
\item The subroutine
      {\tt \packagename\_terminate}
      is provided to allow the user to automatically deallocate array
       components of the private data, allocated by
       {\tt \packagename\_solve},
       at the end of the solution process.
\end{enumerate}
We use square brackets {\tt [ ]} to indicate \optional\ arguments.

%%%%%% initialization subroutine %%%%%%

\subsubsection{The initialization subroutine}\label{subinit}
 Default values are provided as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_initialize( data, control, inform )}

\vspace*{-3mm}
\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see Section~\ref{typedata}). It is used to hold data about the problem being
solved.

\itt{control} is a scalar \intentout\ argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}).
On exit, {\tt control} contains default values for the components as
described in Section~\ref{typecontrol}.
These values should only be changed after calling
{\tt \packagename\_initialize}.

\itt{inform} is a scalar \intentout\ argument of type
{\tt \packagename\_inform\_type}
(see Section~\ref{typeinform}). A successful call to
{\tt \packagename\_initialize}
is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\end{description}

%%%%%%%%% main solution subroutine %%%%%%

\subsubsection{The least-squares subroutine}\label{qps}
The constrained least-squares solution algorithm is called as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_solve( prob, data, control, inform[, regularization\_weight, w] )}

%\vspace*{-3mm}
\begin{description}
\ittf{prob} is a scalar \intentinout\ argument of type
{\tt QPT\_problem\_type}
(see Section~\ref{typeprob}).
It is used to hold data about the problem being solved.
The user must allocate all the array components,
and set values for all components.

The components {\tt prob\%X} and {\tt prob\%Z}
must be set to initial estimates of the primal variables, $\bmx$,
Lagrange multipliers, $\bmy$, for the general constraints
and dual variables for the bound constraints, $\bmz$, respectively.
Inappropriate initial values will be altered, so the user should
not be overly concerned if suitable values are not apparent, and may be
content with merely setting {\tt prob\%X=0.0}, {\tt prob\%Y=0.0}
and {\tt prob\%Z=0.0}.
%The component {\tt prob\%C} need not be set on entry.

On exit, the components {\tt prob\%X} , {\tt prob\%C}, {\tt prob\%Y},
and {\tt prob\%Z}
will contain the best estimates of the primal variables $\bmx$,
the linear constraints $\bmA \bmx$,
Lagrange multipliers, $\bmy$, for the general constraints
and dual variables for the bound constraints $\bmz$, respectively.
\restrictions {\tt prob\%n} $> 0$, {\tt prob\%m} $\geq 0$,
 {\tt prob\%Ao\_type} $\in \{${\tt 'DENSE'},
 {\tt 'DENSE\_BY\_COLUMNS'},
 {\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_\-ROWS'} $\}$,
 {\tt 'SPARSE\_BY\_\-COLUMNS'} $\}$.

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see Section~\ref{typedata}). It is used to hold data about the problem being
solved. It must not have been altered {\bf by the user} since the last call to
{\tt \packagename\_initialize}.

\itt{control} is a scalar \intentin\ argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}). Default values may be assigned by calling
{\tt \packagename\_initialize} prior to the first call to
{\tt \packagename\_solve}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see Section~\ref{typeinform}).
A successful call to
{\tt \packagename\_solve}
is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\ittf{regularization\_weight} is an \optional\ scalar variable of type
\realdp, that holds the regularization weight, $\sigma \geq 0$.
It need not be \present\ if $\sigma = 0$.

\ittf{W} is an \optional\ rank-one allocatable array of dimension {\tt o} and
type \realdp, that holds the positive residual weights, $w$. If it
is \present, its $i$-th component must contain the value $w_{i}$ for
$i = 1, \ldots , o$.
If all the weights are one, {\tt W} need not be \present.

\end{description}

%%%%%%% termination subroutine %%%%%%

\subsubsection{The  termination subroutine}
All previously allocated arrays are deallocated as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_terminate( data, control, inform )}

\vspace*{-3mm}
\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
exactly as for
{\tt \packagename\_solve},
which must not have been altered {\bf by the user} since the last call to
{\tt \packagename\_initialize}.
On exit, array components will have been deallocated.

\itt{control} is a scalar \intentin\ argument of type
{\tt \packagename\_control\_type}
exactly as for
{\tt \packagename\_solve}.

\itt{inform} is a scalar \intentout\ argument of type
{\tt \packagename\_inform\_type}
exactly as for
{\tt \packagename\_solve}.
Only the component {\tt status} will be set on exit, and a
successful call to
{\tt \packagename\_terminate}
is indicated when this  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\end{description}


%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\galerrors
A negative value of {\tt inform\%status} on exit from
{\tt \packagename\_solve}
or
{\tt \packagename\_terminate}
indicates that an error has occurred. No further calls should be made
until the error has been corrected. Possible values are:

\begin{description}

\itt{\galerrallocate.} An allocation error occurred. A message indicating
the offending
array is written on unit {\tt control\%error}, and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc} respectively.

\itt{\galerrdeallocate.} A deallocation error occurred.
A message indicating the offending
array is written on unit {\tt control\%error} and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc} respectively.

\itt{\galerrrestrictions.} One of the restrictions
 {\tt prob\%n} $> 0$ , {\tt prob\%o} $> 0$ $\geq 0$
    the requirement that {\tt prob\%Ao\_type} contain its relevant string
    {\tt 'DENSE'}, {\tt 'DENSE\_BY\_COLUMNS'}, {\tt 'COORDINATE'},
   {\tt 'SPARSE\_BY\_ROWS'} or {\tt 'SPARSE\_BY\_COLUMNS'},
    has been violated.

\itt{\galerrbadbounds.} The bound constraints are inconsistent.

\itt{\galerrprimalinfeasible.} The constraints appear to have no feasible point.

\itt{\galerrunbounded.} The objective function appears to be unbounded
  from below on the feasible set.

\itt{\galerranalysis.} The analysis phase of the factorization failed;
  the return status from the factorization
    package is given in the component {\tt inform\%fac\-t\-or\_status}.

\itt{\galerrfactorization.} The factorization failed; the return status
  from the factorization
    package is given in the component {\tt inform\%fac\-t\-or\_status}.

\itt{\galerrillconditioned.} The problem is so ill-conditioned that
 further progress is impossible.

\itt{\galerrtinystep.} The step is too small to make further impact.

\itt{\galerrmaxiterations.} Too many iterations have been performed.
   This may happen if
    {\tt control\%maxit} is too small, but may also be symptomatic of
    a badly scaled problem.

\itt{\galerrcpulimit.} The elapsed CPU or system clock time limit has been
    reached. This may happen if either {\tt control\%cpu\_time\_limit} or
    {\tt control\%clock\_time\_limit} is too small, but may also be symptomatic
    of a badly scaled problem.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Further features %%%%%%%%%%%%%%%%%%%%%%%%

\galfeatures
\noindent In this section, we describe an alternative means of setting
control parameters, that is components of the variable {\tt control} of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}),
by reading an appropriate data specification file using the
subroutine {\tt \packagename\_read\_specfile}. This facility
is useful as it allows a user to change  {\tt \packagename} control parameters
without editing and recompiling programs that call {\tt \packagename}.

A specification file, or specfile, is a data file containing a number of
"specification commands". Each command occurs on a separate line,
and comprises a "keyword",
which is a string (in a close-to-natural language) used to identify a
control parameter, and
an (optional) "value", which defines the value to be assigned to the given
control parameter. All keywords and values are case insensitive,
keywords may be preceded by one or more blanks but
values must not contain blanks, and
each value must be separated from its keyword by at least one blank.
Values must not contain more than 30 characters, and
each line of the specfile is limited to 80 characters,
including the blanks separating keyword and value.

The portion of the specification file used by
{\tt \packagename\_read\_specfile}
must start
with a "{\tt BEGIN \packagename}" command and end with an
"{\tt END}" command.  The syntax of the specfile is thus defined as follows:
\begin{verbatim}
  ( .. lines ignored by BLLSB_read_specfile .. )
    BEGIN BLLSB
       keyword    value
       .......    .....
       keyword    value
    END
  ( .. lines ignored by BLLSB_read_specfile .. )
\end{verbatim}
where keyword and value are two strings separated by (at least) one blank.
The ``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiter command lines
may contain additional (trailing) strings so long as such strings are
separated by one or more blanks, so that lines such as
\begin{verbatim}
    BEGIN BLLSB SPECIFICATION
\end{verbatim}
and
\begin{verbatim}
    END BLLSB SPECIFICATION
\end{verbatim}
are acceptable. Furthermore,
between the
``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiters,
specification commands may occur in any order.  Blank lines and
lines whose first non-blank character is {\tt !} or {\tt *} are ignored.
The content
of a line after a {\tt !} or {\tt *} character is also
ignored (as is the {\tt !} or {\tt *}
character itself). This provides an easy manner to "comment out" some
specification commands, or to comment specific values
of certain control parameters.

The value of a control parameters may be of three different types, namely
integer, logical or real.
Integer and real values may be expressed in any relevant Fortran integer and
floating-point formats (respectively). Permitted values for logical
parameters are "{\tt ON}", "{\tt TRUE}", "{\tt .TRUE.}", "{\tt T}",
"{\tt YES}", "{\tt Y}", or "{\tt OFF}", "{\tt NO}",
"{\tt N}", "{\tt FALSE}", "{\tt .FALSE.}" and "{\tt F}".
Empty values are also allowed for
logical control parameters, and are interpreted as "{\tt TRUE}".

The specification file must be open for
input when {\tt \packagename\_read\_specfile}
is called, and the associated device number
passed to the routine in device (see below).
Note that the corresponding
file is {\tt REWIND}ed, which makes it possible to combine the specifications
for more than one program/routine.  For the same reason, the file is not
closed by {\tt \packagename\_read\_specfile}.

\subsubsection{To read control parameters from a specification file}
\label{readspec}

Control parameters may be read from a file as follows:
\hskip0.5in

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
     CALL BLLSB_read_specfile( control, device )
\end{verbatim}
}
\def\baselinestretch{1.0}

\begin{description}
\itt{control} is a scalar \intentinout argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}).
Default values should have already been set, perhaps by calling
{\tt \packagename\_initialize}.
On exit, individual components of {\tt control} may have been changed
according to the commands found in the specfile. Specfile commands and
the component (see Section~\ref{typecontrol}) of {\tt control}
that each affects are given in Table~\ref{specfile}.

\bctable{|l|l|l|}
\hline
  command & component of {\tt control} & value type \\
\hline
  {\tt error-printout-device} & {\tt \%error} & integer \\
  {\tt printout-device} & {\tt \%out} & integer \\
  {\tt print-level} & {\tt \%print\_level} & integer \\
  {\tt maximum-number-of-iterations} & {\tt \%maxit} & integer \\
  {\tt start-print} & {\tt \%start\_print} & integer \\
  {\tt stop-print} & {\tt \%stop\_print} & integer \\
  {\tt indicator-type-used} & {\tt \%indicator\_type} & integer \\
  {\tt arc-used} & {\tt \%arc} & integer \\
  {\tt series-order} & {\tt \%series\_order} & integer \\
  {\tt infinity-value} & {\tt \%infinity} & real \\
  {\tt identical-bounds-tolerance} & {\tt \%identical\_bounds\_tol} & real \\
  {\tt absolute-primal-accuracy} & {\tt \%stop\_abs\_p} & real \\
  {\tt relative-primal-accuracy} & {\tt \%stop\_rel\_p} & real \\
  {\tt absolute-dual-accuracy} & {\tt \%stop\_abs\_d} & real \\
  {\tt relative-dual-accuracy} & {\tt \%stop\_rel\_d} & real \\
  {\tt absolute-complementary-slackness-accuracy} & {\tt \%stop\_abs\_c} & real \\
  {\tt relative-complementary-slackness-accuracy} & {\tt \%stop\_rel\_c} & real \\
  {\tt initial-barrier-parameter} & {\tt \%muzero} & real \\
  {\tt feasibility-vs-complementarity-weight} & {\tt \%tao} & real \\
  {\tt balance-complementarity-factor} & {\tt \%gamma\_c} & real \\
  {\tt balance-feasibility-factor} & {\tt \%gamma\_f} & real \\
  {\tt poor-iteration-tolerance} & {\tt \%reduce\_infeas} & real \\
  {\tt identical-bounds-tolerance} & {\tt \%identical\_bounds\_tol} & real \\
  {\tt required-barrier-value-before-pounce} & {\tt mu\_pounce} & real \\
  {\tt primal-indicator-tolerance} & {\tt \%indicator\_tol\_p} & real \\
  {\tt primal-dual-indicator-tolerance} & {\tt \%indicator\_tol\_pd} & real \\
  {\tt tapia-indicator-tolerance} & {\tt \%indicator\_tol\_tapia} & real \\
  {\tt maximum-cpu-time-limit} & {\tt \%cpu\_time\_limit} & real \\
  {\tt maximum-clock-time-limit} & {\tt \%clock\_time\_limit} & real \\
  {\tt remove-linear-dependencies} & {\tt \%remove\_dependencies} & logical \\
  {\tt treat-zero-bounds-as-general} & {\tt \%treat\_zero\_bounds\_as\_general} & logical \\
  {\tt just-find-feasible-point} & {\tt \%just\_feasible} & logical \\
  {\tt puiseux-series} & {\tt \%puiseux} & logical \\
  {\tt try-every-order-of-series} & {\tt \%every\_order} & logical \\
  {\tt cross-over-solution}   & {\tt \%crossover} & logical \\
  {\tt solve-reduced-pounce-system} & {\tt \%reduced\_pounce\_system} & logical \\
  {\tt space-critical}   & {\tt \%space\_critical} & logical \\
  {\tt deallocate-error-fatal}   & {\tt \%deallocate\_error\_fatal} & logical \\
  {\tt symmetric-linear-equation-solver} & {\tt \%symmetric\_linear\_solver} & character \\
  {\tt output-line-prefix} & {\tt \%prefix} & character \\
\hline

\ectable{\label{specfile}Specfile commands and associated
components of {\tt control}.}

\itt{device} is a scalar \intentin argument of type \integer,
that must be set to the unit number on which the specfile
has been opened. If {\tt device} is not open, {\tt control} will
not be altered and execution will continue, but an error message
will be printed on unit {\tt control\%error}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Information printed %%%%%%%%%%%%%%%%%%%%%%%%

\galinfo
If {\tt control\%print\_level} is positive, information about the progress
of the algorithm will be printed on unit {\tt control\-\%out}.
If {\tt control\%print\_level} $= 1$, a single line of output will be produced
for each iteration of the process.
For the initial-feasible-point phase,
this will include values of the current primal and dual infeasibility, and
violation of complementary slackness, the feasibility-phase objective value,
the current steplength, the value of the barrier parameter, the
number of backtracks in the linesearch and the elapsed CPU time in seconds.
Once a suitable feasible point has been found, the iteration is divided
into major iterations, at which the barrier parameter is reduced, and
minor iterations, and which the barrier function is approximately minimized
for the current value of the barrier parameter. For the major iterations,
the value of the barrier parameter, the required values of
dual feasibility and violation of complementary slackness, and the current
constraint infeasibility are reported. Each minor iteration of the
optimality phase results in a line giving
the current dual feasibility and violation of complementary slackness, the
objective function value, the ratio of predicted to achieved reduction
of the objective function, the trust-region radius, the
number of backtracks in the linesearch, the number of conjugate-gradient
iterations taken, and the elapsed CPU time in seconds.

If {\tt control\%print\_level} $\geq 2$ this
output will be increased to provide significant detail of each iteration.
This extra output includes residuals of the linear systems solved, and,
for larger values of {\tt control\%print\_level}, values of the primal and dual
variables and Lagrange multipliers.

%%%%%%%%%%%%%%%%%%%%%% GENERAL INFORMATION %%%%%%%%%%%%%%%%%%%%%%%%

\galgeneral

\galcommon None.
\galworkspace Provided automatically by the module.
\galroutines None.
\galmodules {\tt \packagename\_solve} calls the \galahad\ packages
{\tt GALAHAD\_CLOCK},
{\tt GALAHAD\_SY\-M\-BOLS},
{\tt GALA\-HAD\_SPACE},
{\tt GAL\-AHAD\_TOOLS},
{\tt GALAHAD\_SPECFILE},
{\tt GALAHAD\_SMT},
{\tt GALAHAD\_QPT},
{\tt GALAHAD\_LSP},
{\tt GALAHAD\_QPD},
{\tt GALAHAD\_\-CQP},
{\tt GALAHAD\_\-CLLS},
{\tt GALAHAD\_FIT},
{\tt GALAHAD\_ROOTS},
{\tt GALAHAD\_NORMS},
{\tt GALAHAD\_SLS},
{\tt GALAHAD\_CRO}
and
{\tt GAL\-AHAD\_FDC}.
\galio Output is under control of the arguments
 {\tt control\%error}, {\tt control\%out} and {\tt control\%print\_level}.
\galrestrictions {\tt prob\%n} $> 0$, , {\tt prob\%o} $> 0$,
{\tt prob\%m} $\geq  0$,
{\tt prob\%Ao\_type} and {\tt prob\%A\_type} $\in \{${\tt 'DENSE'},
 {\tt 'DENSE\_BY\_COLUMNS'},  {\tt 'COORDINATE'},
{\tt 'SPARSE\_BY\_\-ROWS'}, {\tt 'SPARSE\_BY\_\-COLUMNS'},
$\}$.
\galportability ISO Fortran~95 + TR 15581 or Fortran~2003.
The package is thread-safe.

%%%%%%%%%%%%%%%%%%%%%% METHOD %%%%%%%%%%%%%%%%%%%%%%%%

\galmethod
The required solution $\bmx$ necessarily satisfies
the primal optimality conditions
\eqn{4.1}{\bmx^{l} \leq \bmx \leq \bmx^{u},}
the dual optimality conditions
\eqn{4.2a}{
 \bmA_o^T W ( \bmA_o \bmx - \bmb) + \sigma \bmx = \bmz,}
where
\eqn{4.2b}{
 \bmz = \bmz^{l} + \bmz^{u}, \,\,
 \bmz^{l} \geq 0 \;\; \mbox{and} \;\;
 \bmz^{u} \leq 0 ,}
and the complementary slackness conditions
\eqn{4.3}{
(\bmx -\bmx^{l} )^{T} \bmz^{l} = 0   \tim{and}
(\bmx -\bmx^{u} )^{T} \bmz^{u} = 0 ,}
where the diagonal matrix $\bmW$ has diagonal entries $w_i$,
$i = 1, \ldots , o$, where the components of the vector $\bmz$ are
known as the dual variables for the bounds,
and where the vector inequalities hold component-wise.

Primal-dual interior point methods iterate towards a point
that satisfies these conditions by ultimately aiming to satisfy
\req{4.2a} and \req{4.3}, while ensuring that
\req{4.1} and \req{4.2b} are
satisfied as strict inequalities at each stage.
Appropriate norms of the amounts by
which \req{4.2a} and \req{4.3} fail to be satisfied are known as the
primal and dual infeasibility, and the violation of complementary slackness,
respectively. The fact that \req{4.1} and \req{4.2b} are satisfied as strict
inequalities gives such methods their other title, namely
interior-point methods.

The method aims at each stage to reduce the
overall violation of \req{4.2a} and \req{4.3},
rather than reducing each of the terms individually. Given an estimate
$\bmv = (\bmx, \; \bmz, \; \bmz^{l}, \; \bmz^{u})$
of the primal-dual variables, a correction
$\Delta \bmv = \Delta (\bmx, \;\bmz,\;\bmz^{l} ,\;\bmz^{u} )$
is obtained by solving a suitable linear system of Newton equations for the
nonlinear systems \req{4.2a} and a parameterized ``residual
trajectory'' perturbation of \req{4.3}; residual trajectories
proposed by Zhang (1994) and Zhao and Sun (1999) are possibilities.
An improved estimate $\bmv + \alpha \Delta \bmv$
is then used, where the step-size $\alpha$
is chosen as close to 1.0 as possible while ensuring both that
\req{4.1} and \req{4.2b} continue to hold and that the individual components
which make up the complementary slackness
\req{4.3} do not deviate too significantly
from their average value. The parameter that controls the perturbation
of \req{4.3} is ultimately driven to zero.

If the algorithm believes that it is close to the solution, it may take a
speculative ``pounce'' extrapolation, based on an estimate of the ultimate 
active set, to avoid further costly iterations. If the pounce is unsuccessful, 
the iteration continues, but further pounces may be attempted later.

The Newton equations are solved  by applying the
\galahad\ matrix factorization package
{\tt GALAHAD\_SLS}.
Optionally, the problem may be pre-processed temporarily to eliminate dependent
constraints using the package {\tt GALAHAD\_FDC}. This may improve the
performance of the subsequent iteration.

\vspace*{1mm}

\galreferences
\vspace*{1mm}

\noindent
The basic algorithm is a generalisation of those of
\vspace*{1mm}

\noindent
Y.\ Zhang (1994).
On the convergence of a class of infeasible interior-point methods for the
horizontal linear complementarity problem.
SIAM J. Optimization {\bf 4} (1) 208-227,
\vspace*{1mm}

\noindent
and

\noindent
G.\ Zhao and J.\ Sun (1999).
On the rate of local convergence of high-order
infeasible path-following algorithms for $P_*$ linear complementarity
problems.
Computational Optimization and Applications {\bf 14} (1) 293-307,
\vspace*{1mm}

\noindent
with many enhancements described by
\vspace*{1mm}

\noindent
N.\ I.\ M.\ Gould, D.\ Orban and D.\ P.\ Robinson (2013).
Trajectory-following methods for
large-scale  degenerate convex quadratic programming,
{\em Mathematical Programming Computation} {\bf 5(2)} 113-142.

%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\galexample
Suppose we wish to minimize
\disp{\half \left\| \vect{ x_1 + x_2 - 2 \\ x_2 + x_3 - 2 \\
 x_1 + x_3 - 3 \\ \sqrt{2} ( x_2 - 1 ) } \right\|^2}
subject to the simple bounds
$-1  \leq  x_{1}  \leq  1$ and $x_{3}  \leq  2$.
Then, on writing the data for this problem as
\disp{\bmA_o = \mat{ccc}{1 & 1 & \\ & 1 & 1 \\ 1 &  & 1  \\ & 1 & }, \;\;
\bmb = \vect{ 2 \\ 2 \\ 3 \\ 1 }, \;\;
\bmw = \vect{ 1 \\ 1 \\ 1 \\ 2 }, \;\;
\bmx^{l} = \vect{ -1 \\ - \infty \\ - \infty }, \;\;
\bmx^{u} = \vect{ 1 \\ \infty \\ 2 } }
in sparse co-ordinate format, we may use the following code:

{\tt \small
\VerbatimInput{\packageexample}
}
\noindent
This produces the following output:
{\tt \small
\VerbatimInput{\packageresults}
}
\noindent
The same problem may be solved holding the data in
a sparse row-wise storage format by replacing the relevant lines in
{\tt \small
\begin{verbatim}
!  sparse co-ordinate storage format
...
! problem data complete
\end{verbatim}
}
\noindent
by
{\tt \small
\begin{verbatim}
! sparse row-wise storage format
   CALL SMT_put( p%Ao%type, 'SPARSE_BY_ROWS', s ) ! Specify sparse row
   ALLOCATE( p%Ao%col( ao_ne ), p%Ao%ptr( o + 1 ), p%Ao%val( ao_ne ) )
   p%Ao%col = (/ 1, 2, 2, 3, 1, 3, 2 /)  ! design matrix Ao
   p%Ao%ptr = (/ 1, 3, 5, 7, 8 /)
   p%Ao%val = (/ 1.0_wp, 1.0_wp, 1.0_wp, 1.0_wp, 1.0_wp, 1.0_wp, 1.0_wp /)
! problem data complete
\end{verbatim}
}
\noindent
or using a dense storage format with the replacement lines
{\tt \small
\begin{verbatim}
!  dense storage format
   CALL SMT_put( p%Ao%type, 'DENSE', s ) ! Specify dense
   ALLOCATE( p%Ao%val( o * n ), p%A%val( n * m ) )
   p%Ao%val = (/ 1.0_wp, 1.0_wp, 0.0_wp, 0.0_wp, 1.0_wp, 1.0_wp,  &
                 1.0_wp, 0.0_wp, 1.0_wp, 0.0_wp, 1.0_wp, 0.0_wp /) ! Ao
! problem data complete
\end{verbatim}
}
\noindent
respectively.

\end{document}

\documentclass{galahad}

% set the package name

\newcommand{\package}{psls}
\newcommand{\packagename}{PSLS}
\newcommand{\fullpackagename}{\libraryname\_\-\packagename}

\begin{document}

\galheader

%%%%%%%%%%%%%%%%%%%%%% SUMMARY %%%%%%%%%%%%%%%%%%%%%%%%

\galsummary

Given a sparse symmetric matrix $\bmA = \{ a_{ij} \}_{n \times n}$, this package
{\bf builds a suitable symmetric, positive definite---or 
diagonally dominant---preconditioner $\bmP$} of $\bmA$ or a symmetric 
sub-matrix thereof. The matrix $\bmA$ need not be definite. Facilities
are provided to apply the preconditioner to a given vector, and to
remove rows and columns (symmetrically) from the initial preconditioner
without a full re-factorization.

%%%%%%%%%%%%%%%%%%%%%% attributes %%%%%%%%%%%%%%%%%%%%%%%%

\galattributes
\galversions{\tt  \fullpackagename\_single, \fullpackagename\_double}.
\galcalls
{\tt GALAHAD\_CLOCK},
{\tt GALAHAD\-\_SYMBOLS},
{\tt GALAHAD\_SPACE},
{\tt GALAHAD\_\-SORT},
{\tt GALAHAD\_SPECFILE},
{\tt GALAHAD\_SMT},
{\tt GALAHAD\_QPT},
{\tt GALAHAD\_SLS},
{\tt GALA\-HAD\_SCU},
{\tt GALAHAD\_EXTEND},
{\tt GALAHAD\_NORMS},
{\tt LANCELOT\_BAND}
and optionally
{\tt MC61},
{\tt HSL\_\-MI28} and
{\tt ICFS},
\galdate April 2008.
\galorigin N. I. M. Gould, Rutherford Appleton Laboratory.
\gallanguage Fortran~95 + TR 15581 or Fortran~2003.
\galparallelism GALAHAD\_SLS may use OpenMP, MPI and their runtime libraries.

%%%%%%%%%%%%%%%%%%%%%% HOW TO USE %%%%%%%%%%%%%%%%%%%%%%%%

\galhowto

\subsection{Calling sequences}

Access to the package requires a {\tt USE} statement such as

\medskip\noindent{\em Single precision version}

\hskip0.5in {\tt USE \fullpackagename\_single}

\medskip\noindent{\em Double precision version}

\hskip0.5in {\tt USE  \fullpackagename\_double}

\medskip

If it is required to use both modules at the same time, the derived types
{\tt SMT\_type},
{\tt \packagename\_control\_type},
{\tt \packagename\_time\-\_type},
{\tt \packagename\_data\-\_type}, and
{\tt \packagename\_inform\_type}
(\S\ref{galtypes}),
and the subroutines
{\tt \packagename\_initialize},
{\tt \packagename\-\_form\_and\_fact\-orize},
{\tt \packagename\-\_update\_factors},
{\tt \packagename\_apply},
{\tt \packagename\_terminate}
(\S\ref{galarguments}),
must be renamed on one of the {\tt USE} statements.

\noindent There are five principal subroutines for user calls (see
\S\ref{galfeatures} for further features):

\begin{description}
\item[] {\tt \packagename\_initialize} must be called to
set default values for solver-specific components of the control structure.
If non-default values are
wanted for any of the control components, the corresponding components
should be altered after the call to {\tt \packagename\_initialize}.

\item[] {\tt \packagename\_form\_and\_factorize} accepts the pattern of $\bmA$,
 removes any unwanted rows and columns, sets up necessary data structures
 and then forms and factorizes the required preconditioner, $\bmP$.

\item[] {\tt \packagename\_update\_factors} modifies the preconditioner and
 its factorization if further rows and columns are removed.

\item[] {\tt \packagename\_apply} uses the factors generated by
  {\tt \packagename\_factorize} to
  solve a system of equations $\bmP \bmx = \bmb$.

\item[] {\tt \packagename\_terminate} deallocates the arrays held inside the
  structure for the factors. It should be called
  when all the systems involving its matrix have been solved
  or before another external solver is to be used.
\end{description}

\subsection{Supported external solvers}

In Table~\ref{solvers} we summarize key features of
the external solvers supported by \packagename, and used
by some preconditioning options. Further details
are provided in the references cited in \S\ref{galmethod} of the
documentation to the \libraryname\ package {\tt SLS}. Note that many
of the solvers {\bf are not part of the package, and must be obtained
separately.}

\bctable{|l|l|l|l|l|}
\hline
 solver & factorization & indefinite $\bmA$ & out-of-core & parallelised \\
\hline
{\tt SILS/MA27} & multifrontal & yes & no & no \\
{\tt HSL\_MA57} & multifrontal & yes & no & no \\
{\tt HSL\_MA77} & multifrontal & yes & yes & OpenMP core \\
{\tt HSL\_MA86} & left-looking & yes & no & OpenMP fully \\
{\tt HSL\_MA87} & left-looking & no & no & OpenMP fully \\
{\tt HSL\_MA97} & multifrontal & yes & no & OpenMP core \\
{\tt SSIDS} & multifrontal & yes & no & CUDA core \\
{\tt PARDISO} & left-right-looking & yes & no & OpenMP fully \\
{\tt MKL\_PARDISO} & left-right-looking & yes & optionally & OpenMP fully \\
{\tt WSMP} & left-right-looking & yes & no & OpenMP fully \\
{\tt POTR} & dense & no & no & with parallel LAPACK \\
{\tt SYTR} & dense & yes & no & with parallel LAPACK \\
{\tt PBTR} & dense band & no & no & with parallel LAPACK \\
\hline

\ectable{\label{solvers}External solver characteristics.}
%\vspace*{-8mm}
%%%%%%%%%%%%%%%%%%%%%% matrix formats %%%%%%%%%%%%%%%%%%%%%%%%

\galmatrix
The matrix $\bmA$ may be stored in a variety of input formats.

\subsubsection{Sparse co-ordinate storage format}\label{coordinate}
Only the nonzero entries of the lower-triangular part of $\bmA$ are stored.
For the $l$-th entry of the lower-triangular portion of $\bmA$,
its row index $i$, column index $j$ and value $a_{ij}$
are stored in the $l$-th components of the integer arrays {\tt row},
{\tt col} and real array {\tt val}, respectively.
The order is unimportant, but the total number of entries
{\tt ne} is also required.

\subsubsection{Sparse row-wise storage format}\label{rowwise}
Again only the nonzero entries of the lower-triangular part are stored,
but this time they are ordered so that those in row $i$ appear directly
before those in row $i+1$. For the $i$-th row of $\bmA$, the $i$-th component
of an integer array {\tt ptr} holds the position of the first entry in this row,
while {\tt ptr} $(m+1)$ holds the total number of entries plus one.
The column indices $j$ and values $a_{ij}$ of the entries in the $i$-th row
are stored in components
$l =$ {\tt ptr}$(i)$, \ldots ,{\tt ptr} $(i+1)-1$ of the
integer array {\tt col}, and real array {\tt val}, respectively.

For sparse matrices, this scheme almost always requires less storage than
its predecessor.

\subsubsection{Dense storage format}\label{dense}
The matrix $\bmA$ is stored as a compact
dense matrix by rows, that is, the values of the entries of each row in turn are
stored in order within an appropriate real one-dimensional array.
Since $\bmA$ is symmetric, only the lower triangular part (that is the part
$a_{ij}$ for $1 \leq j \leq i \leq n$) need be held, and this part will be
stored by rows, that is component
$i \ast (i-1)/2 + j$ of the storage array {\tt val}
will hold the value $a_{ij}$ (and, by symmetry, $a_{ji}$)
for $1 \leq j \leq i \leq n$.

%\subsubsection{Diagonal storage format}\label{diagonal}
%If $\bmA$ is diagonal (i.e., $a_{ij} = 0$ for all $1 \leq i \neq j \leq n$)
%only the diagonals entries $a_{ii}$, $1 \leq i \leq n$,  need be stored,
%and the first $n$ components of the array {\tt A\%val} may be used for
%the purpose.

%%%%%%%%%%%%%%%%%%%%%% long integers %%%%%%%%%%%%%%%%%%%%%%

\subsection{Integer kinds}\label{Integer kinds}
We use the term
long \integer\ to denote {\tt INTEGER\-(kind=long)}, where
{\tt long = selected\_int\_kind(18))}.

%%%%%%%%%%%%%%%%%%%%%% parallel usage %%%%%%%%%%%%%%%%%%%%%%%%

\input{parallel}

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\galtypes
Five derived data types are used by the package.

%%%%%%%%%%% problem type %%%%%%%%%%%

\subsubsection{The derived data type for holding the matrix}\label{typeprob}
The derived data type {\tt SMT\_type} is used to hold the matrix $\bmA$.
The components of {\tt SMT\_type} used are:

\begin{description}

\ittf{n} is a scalar variable of type default \integer, that holds
the order $n$ of the matrix  $\bmA$.
\restriction {\tt n} $\geq$ {\tt 1}.

\itt{type} is an allocatable array of rank one and type default \character, that
indicates the storage scheme used. If the
sparse co-ordinate scheme (see \S\ref{coordinate}) is used
the first ten components of {\tt type} must contain the
string {\tt COORDINATE}.
For the sparse row-wise storage scheme (see \S\ref{rowwise}),
the first fourteen components of {\tt type} must contain the
string {\tt SPARSE\_BY\_ROWS}, and
for dense storage scheme (see \S\ref{dense})
the first five components of {\tt type} must contain the
string {\tt DENSE}.
%and for the diagonal storage scheme (see \S\ref{diagonal}),
%the first eight components of {\tt type} must contain the
%string {\tt DIAGONAL}.

For convenience, the procedure {\tt SMT\_put}
may be used to allocate sufficient space and insert the required keyword
into {\tt type}.
For example, if $\bmA$ is to be stored in the structure {\tt A}
of derived type {\tt SMT\_type} and we wish to use
the co-ordinate scheme, we may simply
%\vspace*{-2mm}
{\tt
\begin{verbatim}
        CALL SMT_put( A%type, 'COORDINATE', istat )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent
See the documentation for the \galahad\ package {\tt SMT}
for further details on the use of {\tt SMT\_put}.

\itt{ne} is a scalar variable of type default \integer, that
holds the number of entries in the {\bf lower triangular} part of $\bmA$
in the sparse co-ordinate storage scheme (see \S\ref{coordinate}).
It need not be set for any of the other three schemes.

\itt{val} is a rank-one allocatable array of type default \realdp, that holds
the values of the entries of the {\bf lower triangular} part
of the matrix $\bmA$ for each of the
storage schemes discussed in \S\ref{galmatrix}.
Any duplicated entries that appear in the sparse
co-ordinate or row-wise schemes will be summed.

\itt{row} is a rank-one allocatable array of type default \integer,
that holds the row indices of the {\bf lower triangular} part of $\bmA$
in the sparse co-ordinate storage
scheme (see \S\ref{coordinate}).
It need not be allocated for any of the other schemes.
Any entry whose row index lies out of the range $[$1,n$]$ will be ignored.

\itt{col} is a rank-one allocatable array variable of type default \integer,
that holds the column indices of the {\bf lower triangular} part of
$\bmA$ in either the sparse co-ordinate
(see \S\ref{coordinate}), or the sparse row-wise
(see \S\ref{rowwise}) storage scheme.
It need not be allocated when the dense
%or diagonal storage schemes are used.
storage scheme is used.
Any entry whose column index lies out of the range $[$1,n$]$ will be ignored,
while the row and column indices of any entry from the
{\bf strict upper triangle} will implicitly be swapped.

\itt{ptr} is a rank-one allocatable array of size {\tt n+1} and type
default \integer, that holds the starting position of
each row of the {\bf lower triangular} part of $\bmA$, as well
as the total number of entries plus one, in the sparse row-wise storage
scheme (see \S\ref{rowwise}). It need not be allocated for the
other schemes.

\end{description}

%%%%%%%%%%% control type %%%%%%%%%%%

\subsubsection{The derived data type for holding control
 parameters}\label{typecontrol}
The derived data type
{\tt \packagename\_control\_type}
is used to hold controlling data.
Default values specifically for the desired solver
may be obtained by calling
{\tt \packagename\_initialize}
(see \S\ref{subinit}),
%Default values are assigned,
while components may be changed at run time by calling
{\tt \packagename\_read\-\_specfile}
(see \S\ref{readspec}).
The components of
{\tt \packagename\_control\_type}
are:

\begin{description}

\itt{error} is a scalar variable of type default \integer, that holds the
unit number for error messages.
Printing of error messages is suppressed if ${\tt error} < {\tt 0}$.
The default is {\tt error = 6}.

\ittf{out} is a scalar variable of type default \integer, that holds the
unit number for informational messages.
6Printing of informational messages is suppressed if ${\tt out} < {\tt 0}$.
The default is {\tt out = 6}.

\itt{print\_level} is a scalar variable of type default \integer,
that is used
to control the amount of informational output that is required. No
informational output will occur if ${\tt print\_level} \leq {\tt 0}$. 
Every increasing values produce more information.
The default is {\tt print\_level = 0}.

\itt{preconditioner} is a scalar variable of type default \integer, that 
indicates the preconditioner required. Possible values are
\begin{description}
\itt{<0} no preconditioning occurs, $\bmP = \bmI$
\itt{0}  the preconditioner is chosen automatically (forthcoming,
         and currently defaults to {\tt 1}).
\itt{1}  $\bmA$ is replaced by the diagonal, 
         $\bmP$ = diag( max( $\bmA$, {\tt min\_diagonal} ) ) (see below).
\itt{2}  $\bmA$ is replaced by the band 
         $\bmP$ = band( $\bmA$ ) with semi-bandwidth {\tt semi\_bandwidth}
         (see below).
\itt{3}  $\bmA$ is replaced by the reordered band 
         $\bmP$ = band( order( $\bmA$ ) ) with semi-bandwidth 
         {\tt semi\_bandwidth}, where order is chosen by the HSL package
         {\tt MC61} (see \S\ref{galmethod}) to move entries closer to 
         the diagonal.
\itt{4}  $\bmP$ is a full factorization of $\bmA$ using Schnabel-Eskow 
         modifications, in which small or negative diagonals are
         made sensibly positive during the factorization.
\itt{5}  $\bmP$ is a full factorization of $\bmA$  due to Gill, Murray, 
         Poncel\'{e}on and Saunders, in which an indefinite factorization 
         is altered to give a positive definite one.
\itt{6}  $\bmP$ is an incomplete Cholesky factorization of $\bmA$ using the 
         package {\tt ICFS} due to Lin and Mor\'{e} (see \S\ref{galmethod}).
\itt{7}  $\bmP$ is an incomplete factorization of $\bmA$ implemented 
         as {\tt HSL\_MI28} from HSL (see \S\ref{galmethod}).
\itt{8}  $\bmP$ is an incomplete factorization of $\bmA$ due 
         to Munskgaard (forthcoming).
\itt{>8} treated as {\tt 0}.
\end{description}
{\bf N.B.} Options 3--8 may require additional external software that 
is not part of the package, and that must be obtained separately.
The default is {\tt preconditioner = 0}.

\itt{semi\_bandwidth} is a scalar variable of type default \integer, that holds
the semi-bandwidth used if a band preconditioner ({\tt \%preconditioner = 2,3})
is selected. Any negative value will be regarded as {\tt 0}.
The default is {\tt semi\_bandwidth = 5}.

%\itt{scaling} is a scalar variable of type default \integer, that holds
%The default is {\tt scaling = 0}.

%\itt{ordering} is a scalar variable of type default \integer, that holds
%The default is {\tt ordering = 0}.

\itt{max\_col} is a scalar variable of type default \integer, that holds
the maximum number of nonzeros in a column of $\bmA$ that are allowed
for a Schur-complement factorization, rather than a refactorization, 
to accommodate newly deleted columns.
The default is {\tt max\_col = 100}.

\itt{icfs\_vectors} is a scalar variable of type default \integer, that holds
the number of extra vectors of length $n$ required by the Lin--Mor\'{e} 
incomplete Cholesky preconditioner ({\tt \%preconditioner = 6}).
Usually, the larger the number, the
better the preconditioner, but the more space and effort required to
use it. Any negative value will be regarded as {\tt 0}.
The default is {\tt icfs\_vectors = 10}.

\itt{mi28\_lsize} is a scalar variable of type default \integer, that holds
the maximum number of fill entries within each column of the incomplete
factor $\bmL$ computed by {\tt HSL\_MI28} ({\tt \%preconditioner = 7}).
In general, increasing {\tt mi28\_lsize} improves
the quality of the preconditioner but increases the time to compute
and then apply the preconditioner. Values less than 0 are treated as 0.
The default is {\tt mi28\_lsize = 10}.

\itt{mi28\_rsize} is a scalar variable of type default \integer, that holds
the maximum number of entries within each column of the strictly lower
triangular matrix $\bmR$ used in the computation of the preconditioner by
{\tt HSL\_MI28} ({\tt \%preconditioner = 7)}.
Rank-1 arrays of size {\tt mi28\_rsize} times $n$ are allocated internally
to hold $\bmR$. Thus the amount of memory used, as well as the amount of work
involved in computing the preconditioner, depends on {\tt mi28\_rsize}. 
Setting {\tt mi28\_rsize} $>$ 0 generally leads to a higher quality 
preconditioner than using {\tt mi28\_rsize = 0}, and choosing 
{\tt mi28\_rsize} $\geq$  {\tt mi28\_lsize} is generally recommended.
The default is {\tt mi28\_rsize = 10}.

\itt{max\_col} is a scalar variable of type default \integer, that specifies
Any non-positive value will be regarded as {\tt 1}.
The default is {\tt max\_col = 100}.
\itt{prefix} is a scalar variable of type default \character\
and length 30, that may be used to provide a user-selected
character string to preface every line of printed output.
Specifically, each line of output will be prefaced by the string
{\tt prefix(2:LEN(TRIM(prefix))-1)},
thus ignoring the first and last non-null components of the
supplied string. If the user does not want to preface lines by such
a string, the default {\tt prefix = ""} should be used.

\itt{min\_diagonal} is a scalar variable of type default \realdp,
that specifies the smallest permitted diagonal in $\bmP$ for some
of the preconditioners provided. See {\tt preconditioner} above.
The default is {\tt min\_diagonal = 0.00001}.

\itt{new\_structure} is a scalar variable of type default \logical,
that must be set \true\ if the storage structure for the input matrix has
changed, and \false\ if only the values have changed.
The default is {\tt new\_structure = .TRUE.}.

\itt{get\_semi\_bandwidth} is a scalar variable of type default \logical,
that must be set \true\ if the user wishes the package to calculate
the semi-bandwidth of the preconditioner, $\bmP$
and  \false\ otherwise.
The default is {\tt get\_semi\_bandwidth = .TRUE.}.

\itt{get\_norm\_residual} is a scalar variable of type default \logical,
that must be set \true\ if the user wishes the package to return
the value of the norm of the residuals for the computed solution
when applying the preconditioner and  \false\ otherwise.
The default is {\tt get\_norm\_residual = .FALSE.}.

\itt{space\_critical} is a scalar variable of type default \logical,
that must be set \true\ if space is critical when allocating arrays
and  \false\ otherwise. The package may run faster if
{\tt space\_critical} is \false\ but at the possible expense of a larger
storage requirement. The default is {\tt space\_critical = .FALSE.}.

\itt{deallocate\_error\_fatal} is a scalar variable of type default \logical,
that must be set \true\ if the user wishes to terminate execution if
a deallocation  fails, and \false\ if an attempt to continue
will be made. The default is {\tt deallocate\_error\_fatal = .FALSE.}.

\itt{definite\_linear\_solver} is a scalar variable of type default \character\
and length 30, that specifies the external package to be used to
solve any symmetric positive-definite linear system that might arise
when {\tt \%precondit\-ioner = 4,5}. Possible choices are
{\tt 'sils'},
{\tt 'ma27'},
{\tt 'ma57'},
{\tt 'ma77'},
{\tt 'ma86'},
{\tt 'ma87'},
{\tt 'ma97'},
{\tt 'ssids'},
{\tt 'pardiso'}
{\tt 'mkl\_pardiso'},
{\tt 'wsmp'},
{\tt 'potr'} and
{\tt 'pbtr'},
although only {\tt 'sils'}, {\tt 'potr'}, {\tt 'pbtr'}
and, for OMP 4.0-compliant compilers,
{\tt 'ssids'} are installed by default.
See Table~\ref{solvers} and
the documentation for the \galahad\ package {\tt SLS} for further details.
The default is {\tt definite\_linear\_solver = 'sils'}.

\itt{prefix} is a scalar variable of type default \character\
and length 30, that may be used to provide a user-selected
character string to preface every line of printed output.
Specifically, each line of output will be prefaced by the string
{\tt prefix(2:LEN(TRIM(prefix))-1)},
thus ignoring the first and last non-null components of the
supplied string. If the user does not want to preface lines by such
a string, they may use the default {\tt prefix = ""}.

\end{description}

%%%%%%%%%%% time type %%%%%%%%%%%

\subsubsection{The derived data type for holding timing
 information}\label{typetime}
The derived data type
{\tt \packagename\_time\_type}
is used to hold elapsed CPU and system clock times for the various parts
of the calculation. The components of
{\tt \packagename\_time\_type}
are:
\begin{description}
\itt{total} is a scalar variable of type default \realdp, that gives
 the total CPU time (in seconds) spent in the package.

\itt{analyse} is a scalar variable of type default \realdp, that gives
 the CPU time spent analysing the matrix structure prior to building and
 factorizing the preconditioner.

\itt{factorize} is a scalar variable of type default \realdp, that gives
 the CPU time spent building and factorizing the preconditioner.

\itt{solve} is a scalar variable of type default \realdp, that gives
 the CPU time spent applying the preconditioner.

\itt{update} is a scalar variable of type default \realdp, that gives
 the CPU time spent updating existing factorizations.

\itt{clock\_total} is a scalar variable of type default \realdp, that gives
 the total elapsed system clock time (in seconds) spent in the package.

\itt{clock\_analyse} is a scalar variable of type default \realdp, that gives
 the elapsed system clock time spent analysing the matrix structure prior to 
 building and factorizing the preconditioner.

\itt{clock\_factorize} is a scalar variable of type default \realdp, that gives
 the elapsed system clock time spent building and factorizing the 
 preconditioner.

\itt{clock\_solve} is a scalar variable of type default \realdp, that gives
 the elapsed system clock time spent applying the preconditioner.

\itt{clock\_update} is a scalar variable of type default \realdp,
 that gives  the elapsed system clock time spent updating existing 
 factorizations.

\end{description}

%%%%%%%%%%% inform type %%%%%%%%%%%

\subsubsection{The derived data type for holding informational
 parameters}\label{typeinform}
The derived data type
{\tt \packagename\_inform\_type}
is used to hold parameters that give information about the progress and needs
of the algorithm. The components of
{\tt \packagename\_inform\_type}
are as follows---any component that is not relevant to the solver being used
will have the value {\tt -1} or {\tt -1.0} as appropriate:

\begin{description}

\itt{status} is a scalar variable of type default \integer, that gives the
exit status of the algorithm.
%See Sections~\ref{galerrors} and \ref{galinfo}
See \S\ref{galerrors}
for details.

\itt{alloc\_status} is a scalar variable of type default \integer, that gives
the status of the last attempted array allocation or deallocation.

\itt{bad\_alloc} is a scalar variable of type default \character\
and length 80, that  gives the name of the last internal array
for which there were allocation or deallocation errors.
This will be the null string if there have been no
allocation or deallocation errors.

\itt{preconditioner} is a scalar variable of type default \integer,
that indicates the preconditioner method used. The range of values returned
corresponds to those requested in {\tt control\%preconditioner},
excepting that the requested value may have been altered to a more
appropriate one during the factorization. In particular, if the automatic
choice {\tt control\%preconditioner = 0} is requested,
{\tt preconditioner} reports the actual choice made.

\itt{semi\_bandwidth} is a scalar variable of type default \integer,
that indicates the actual semi-bandwith.

\itt{reordered\_semi\_bandwidth} is a scalar variable of type default \integer,
that indicates the semi-bandwith used after reordering.

\itt{semi\_bandwidth\_used} is a scalar variable of type default \integer,
that indicates the actual semi-bandwith used.

\itt{out\_of\_range} is a scalar variable of type default \integer,
that is set to the number of
entries of $\bmA$ supplied with one or both indices out of range.

\itt{duplicates} is a scalar variable of type default \integer,
that is set to the number of duplicate off-diagonal entries of $\bmA$ supplied.

\itt{upper} is a scalar variable of type default \integer,
that is set to the number of input entries from the strict upper triangle
of $\bmA$.

\itt{missing\_diagonals} is a scalar variable of type default \integer,
that gives the number of diagonal entries entries missing for an
allegedly-definite matrix $\bmA$.

\itt{neg1} is a scalar variable of type default \integer,
that gives the number of 1 by 1 pivots present in the factorization
of $\bmA$.

\itt{neg2} is a scalar variable of type default \integer,
that gives the number of 2 by 2 pivots present in the factorization
of $\bmA$.

\itt{perturbed} is a scalar variable of type default \logical,
that is /true/ if the factorization has been perturbed when building the
preconditioner.

\itt{fill\_in\_ratio} is a scalar variable of type \realdp,
that gives the ratio of the fill-ins during factorization to the
original numbers of non-zeros of $\bmA$.

\itt{norm\_residual} is a scalar variable of type \realdp,
that gives the norm of the residual $\|\bmP \bmx - \bmb\|$
when solving $\bmP \bmx = \bmb$.

\itt{mc61\_info} is an array of size 10 and type \integer,
that corresponds to the output array {\tt INFO}
from {\tt MC61}. See the HSL documentation for {\tt MC61} for further
details.

\itt{mc61\_rinfo} is an array of size 15 and type \realdp,
that corresponds to the output array {\tt RINFO}
from {\tt MC61}. See the HSL documentation for {\tt MC61} for further
details.

\ittf{time} is a scalar variable of type {\tt \packagename\_time\_type}
whose components are used to hold elapsed CPU and system clock times
(in seconds) for the various parts of the calculation
(see Section~\ref{typetime}).

\itt{sls\_inform} is a scalar variable of type {\tt sls\_inform\_type},
that corresponds to the output value {\tt sls\_inform} from the \libraryname\ 
package {\tt SLS}. See the documentation for {\tt SLS} for further details.

\itt{mi28\_info} is a scalar variable of type {\tt mi28\_info},
that corresponds to the output value {\tt mi28\_info}
from {\tt HSL\_MI28}. See the documentation for {\tt HSL\_MI28} for further
details.

\end{description}


%%%%%%%%%%% data type %%%%%%%%%%%

\subsubsection{The derived data type for holding problem data}\label{typedata}
The derived data type
{\tt \packagename\_data\_type}
is used to hold all the data for a particular problem,
or sequences of problems with the same structure, between calls to
{\tt \packagename} procedures.
%This data should be preserved, untouched, from the initial call to
%{\tt \packagename\_initialize}
%to the final call to
%{\tt \packagename\_terminate}.
All components are private.

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\galarguments
We use square brackets {\tt [ ]} to indicate \optional\ arguments.

%%%%%% initialization subroutine %%%%%%

\subsubsection{The initialization subroutine}\label{subinit}
The initialization subroutine must be called for each solver used
to initialize data and solver-specific control parameters.

\hskip0.5in
{\tt CALL \packagename\_initialize( data, control, inform )}
\begin{description}

\itt{data} is a scalar \intentout argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold data about the problem being
solved.

\itt{control} is a scalar \intentout argument of type
{\tt \packagename\_control\_type}
(see \S\ref{typecontrol}).
On exit, {\tt control} contains solver-specific default values for the
components as described in \S\ref{typecontrol}.
These values should only be changed after calling
{\tt \packagename\_initialize}.

\itt{inform} is a scalar \intentout argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\end{description}

%%%%%%%%% form and factorization subroutine %%%%%%

\subsubsection{The subroutine for constructing the preconditioner}
This subroutine assembles and factorizes the required preconditioner
from the input matrix $\bmA$ as follows:

\hskip0.5in
{\tt CALL \packagename\_form\_and\_factorize( matrix, data, control, inform[, SUB] )}

\begin{description}
\itt{matrix} is scalar \intentin\ argument of type {\tt SMT\_type}
that is used to specify $\bmA$.
The user must set all of the relevant components of {\tt matrix} according
to the storage scheme desired (see \S\ref{typeprob}).
Incorrectly-set components will result in errors
flagged in {\tt inform\%status}, see \S\ref{galerrors}.

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors of the preconditioner 
and other data concerning the matrix used.
It must have been initialized by a call to
{\tt \packagename\_ini\-tialize}.

\itt{control} is scalar \intentin\ argument of type
{\tt \packagename\_control\_type}. Its components control the action
of the analysis phase, as explained in
\S\ref{typecontrol}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\itt{SUB} is an \optional\ \intentin\ rank-one default assumed-size 
\integer\ argument that may be used to provide a set of distinct indices
that specify the rows (and, by symmetry, columns) of $\bmA$ that are 
to be considered. Each component of {\tt SUB} must lie between 1 and {\tt n},
and they should be input in increasing order.
If {\tt SUB} is not supplied, all indices $1 \leq i \leq n$ will be used. 
\end{description}

%%%%%%%%% update factors subroutine %%%%%%

\subsubsection{The subroutine for updating the preconditioner}
This subroutine updates the factorization of the preconditioner
when a subset of the rows (and, by symmetry, columns) are removed.

\hskip0.5in
{\tt CALL \packagename\_update\_factors( DEL, data, control, inform )}

\begin{description}
\itt{DEL} is an \intentin\ rank-one default assumed-size 
\integer\ argument whose indices are those of rows (and columns) of $\bmA$
that are to be deleted. Each component of {\tt DEL} must lie between 1 and 
{\tt n}.

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors of the 
updated preconditioner and other data concerning the matrix used.
It must have been previously set by a call to
{\tt \packagename\_form\_and\_factorize}.

\itt{control} is scalar \intentin\ argument of type
{\tt \packagename\_control\_type}. Its components control the action
of the analysis phase, as explained in
\S\ref{typecontrol}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\end{description}

%%%%%%%%% solve subroutine %%%%%%

\subsubsection{The subroutine for applying the preconditioner}
\label{solve}
Given the preconditioner $\bmP$, a set of equations 
$\bmP \bmx = \bmb$ may be solved as follows:

\hskip0.5in
{\tt CALL \packagename\_apply( X, data, control, inform )}

\begin{description}

\ittf{X} is an \intentinout\ assumed-shape array argument of rank 1
and of type \realdp.  On entry, {\tt X} must be set
to the vector $\bmb$, and on successful return it holds
the solution $\bmx$. The {\tt i}-th component of $\bmb$ and the resulting
{\tt i}-th component of the solution $\bmx$
occupy the {\tt i}-th component of {\tt X}. 
Any component corresponding to rows/columns not in the initial subset
recorded by {\tt  \packagename\_form\_and\_factorize},
or in those subsequently deleted
by {\tt \packagename\_update\_factors}, will not be altered.

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors and other
data about the problem being solved.
It must have been initialized by a call to
{\tt \packagename\_ini\-tialize} and not altered by the user in the interim.

\itt{control} is scalar \intentin\ argument of type
{\tt \packagename\_control\_type}. Its components control the action
of the solve phase, as explained in
\S\ref{typecontrol}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\end{description}

%%%%%%% termination subroutine %%%%%%

\subsubsection{The termination subroutine}
All previously allocated internal arrays are deallocated and OpenMP locks
destroyed as follows:

\hskip0.5in
{\tt CALL \packagename\_terminate( data, control, inform )}

\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors and other
data about the problem being solved.
It must have been initialized by a call to
{\tt \packagename\_ini\-tialize} and not altered by the user in the interim.
On exit, its allocatable array components will have been deallocated.

\itt{control} is scalar \intentin\ argument of type
{\tt \packagename\_control\_type}. Its components control the action
of the termination phase, as explained in
\S\ref{typecontrol}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\galerrors
A negative value of {\tt inform\%status} on exit from the subroutines
indicates that an error has occurred. No further calls should be made
until the error has been corrected. Possible values are:

\begin{description}

\itt{\galerrallocate} An allocation error occurred. A message indicating
the offending
array is written on unit {\tt control\%error}, and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc} respectively.

\itt{\galerrdeallocate} A deallocation error occurred.
A message indicating the offending
array is written on unit {\tt control\%error} and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc} respectively.

\itt{\galerrrestrictions} One of the restrictions
 {\tt matrix\%n} $> 0$ or
 {\tt matrix\%ne} $< 0$, for co-ordinate entry,
  or requirements that {\tt matrix\%type}
  contain its relevant string
{\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_ROWS'} or   {\tt 'DENSE'}
  has been violated.

\itt{\galerranalysis} The solver required by {\tt SLS} reported an
  error during its analysis phase. 
  See {\tt inform\%SLS\_inform\%status} for more details.

\itt{\galerrfactorization} The solver required by {\tt SLS} reported an
  error during its factorization phase. 
  See {\tt inform\%SLS\_inform\%status} for more details.

\itt{\galerrinertia} The matrix is not positive definite while the solver
  used expected it to be.

\itt{\galunknownsolver} The requested factorization solver is not available.

\itt{\galerrunavailable} A specified option is not available with this solver.

\itt{\galerrunknownprecond} The requested preconditioner is not available.
     
\itt{\galerrmitwentyeight} An error occurred when calling {\tt HSL\_MI28}. See
  {\tt inform\%mi28\_info\%stat} for more details.


\end{description}

%%%%%%%%%%%%%%%%%%%%%% Further control features %%%%%%%%%%%%%%%%%%%%%%%%

\galfeatures
\noindent In this section, we describe an alternative means of setting
control parameters, that is components of the variable {\tt control} of type
{\tt \packagename\_control\_type}
(see \S\ref{typecontrol}),
by reading an appropriate data specification file using the
subroutine {\tt \packagename\_read\_specfile}. This facility
is useful as it allows a user to change  {\tt \packagename} control parameters
without editing and recompiling programs that call {\tt \packagename}.

A specification file, or specfile, is a data file containing a number of
``specification commands''. Each command occurs on a separate line,
and comprises a ``keyword'',
that is a string (in a close-to-natural language) used to identify a
control parameter, and
an (optional) "value", which defines the value to be assigned to the given
control parameter. All keywords and values are case insensitive,
keywords may be preceded by one or more blanks but
values must not contain blanks, and
each value must be separated from its keyword by at least one blank.
Values must not contain more than 30 characters, and
each line of the specification file is limited to 80 characters,
including the blanks separating keyword and value.

The portion of the specification file used by
{\tt \packagename\_read\_specfile}
must start
with a ``{\tt BEGIN \packagename}'' command and end with an
``{\tt END}'' command.  The syntax of the specfile is thus defined as follows:
\begin{verbatim}
  ( .. lines ignored by PSLS_read_specfile .. )
    BEGIN PSLS
       keyword    value
       .......    .....
       keyword    value
    END
  ( .. lines ignored by PSLS_read_specfile .. )
\end{verbatim}
where keyword and value are two strings separated by (at least) one blank.
The ``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiter command lines
may contain additional (trailing) strings so long as such strings are
separated by one or more blanks, so that lines such as
\begin{verbatim}
    BEGIN PSLS SPECIFICATION
\end{verbatim}
and
\begin{verbatim}
    END PSLS SPECIFICATION
\end{verbatim}
are acceptable. Furthermore,
between the
``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiters,
specification commands may occur in any order.  Blank lines and
lines whose first non-blank character is {\tt !} or {\tt *} are ignored.
The content
of a line after a {\tt !} or {\tt *} character is also
ignored (as is the {\tt !} or {\tt *}
character itself). This provides an easy way to ``comment out'' some
specification commands, or to comment specific values
of certain control parameters.

The value of a control parameter may be of three different types, namely
integer, character or real.
Integer and real values may be expressed in any relevant Fortran integer and
floating-point formats (respectively).
%Permitted values for logical
%parameters are "{\tt ON}", "{\tt TRUE}", "{\tt .TRUE.}", "{\tt T}",
%"{\tt YES}", "{\tt Y}", or "{\tt OFF}", "{\tt NO}",
%"{\tt N}", "{\tt FALSE}", "{\tt .FALSE.}" and "{\tt F}".
%Empty values are also allowed for
%logical control parameters, and are interpreted as "{\tt TRUE}".

The specification file must be open for
input when {\tt \packagename\_read\_specfile}
is called, and the associated unit number
passed to the routine in {\tt device} (see below).
Note that the corresponding
file is rewound, which makes it possible to combine the specifications
for more than one program/routine.  For the same reason, the file is not
closed by {\tt \packagename\_read\_specfile}.

\subsubsection{To read control parameters from a specification file}
\label{readspec}

Control parameters may be read from a file as follows:
\hskip0.5in

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
     CALL PSLS_read_specfile( control, device )
\end{verbatim}
}
\def\baselinestretch{1.0}

\begin{description}
\itt{control} is a scalar \intentinout\ argument of type
{\tt \packagename\_control\_type}
(see \S\ref{typecontrol}).
Default values should have already been set, perhaps by calling
{\tt \packagename\_initialize}.
On exit, individual components of {\tt control} may have been changed
according to the commands found in the specfile. Specfile commands and
the component (see \S\ref{typecontrol}) of {\tt control}
that each affects are given in Table~\ref{specfile}.

\pctable{|l|l|l|}
\hline
  command & component of {\tt control} & value type \\
\hline
{\tt error-printout-device} & {\tt \%error} & {\tt integer} \\
{\tt printout-device} & {\tt \%out} & {\tt integer} \\
{\tt print-level} & {\tt \%print\_level} & {\tt integer} \\
{\tt preconditioner-used} & {\tt \%preconditioner} & {\tt integer} \\
{\tt semi-bandwidth-for-band-preconditioner} & {\tt \%semi\_bandwidth} & {\tt integer} \\
%  {\tt ordering-used}  & {\tt \%ordering} & {\tt integer} \\
%  {\tt scaling-used}   & {\tt \%scaling} & {\tt integer} \\
{\tt maximum-column-nonzeros-in-schur-complement}  & {\tt \%max\_col} & {\tt integer} \\
{\tt number-of-lin-more-vectors} & {\tt \%icfs\_vectors} & {\tt integer} \\
{\tt mi28-l-fill-size} & {\tt \%mi28\_lsize } & {\tt integer} \\
{\tt mi28-r-entry-size} & {\tt \%mi28\_rsize } & {\tt integer} \\
{\tt minimum-diagonal}  & {\tt \%min\_diagonal} & {\tt real} \\
{\tt new-structure}   & {\tt \%new\_structure} & {\tt logical} \\
{\tt get-semi-bandwidth}   & {\tt \%get\_semi\_bandwidth} & logical \\
{\tt get-norm-residual}   & {\tt \%get\_norm\_residual} & {\tt logical} \\
{\tt space-critical}   & {\tt \%space\_critical} & {\tt logical} \\
{\tt deallocate-error-fatal}   & {\tt \%deallocate\_error\_fatal} & {\tt logical} \\
{\tt definite-linear-equation-solver} & {\tt \%definite\_linear\_solver} & {\tt character} \\
{\tt output-line-prefix} & {\tt \%prefix} & character \\
\hline

\ectable{\label{specfile}Specfile commands and associated
components of {\tt control}.}

\itt{device} is a scalar \intentin\ argument of type default \integer,
that must be set to the unit number on which the specification file
has been opened. If {\tt device} is not open, {\tt control} will
not be altered and execution will continue, but an error message
will be printed on unit {\tt control\%error}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% GENERAL INFORMATION %%%%%%%%%%%%%%%%%%%%%%%%

\galgeneral

%\galcommon None.
\galworkspace Provided automatically by the module.
\galmodules {\tt GALAHAD\_CLOCK},
{\tt GALAHAD\-\_SYMBOLS},
{\tt GALAHAD\_SPACE\_single/double},
{\tt GALAHAD\_\-SORT\-\_single/double},
{\tt GALAHAD\_SPECFILE\_single/double},
{\tt GALAHAD\_SMT\_single/double},
{\tt GALAHAD\_QPT\-\_single\-/double},
{\tt GALAHAD\_SLS\_single/double},
{\tt GALA\-HAD\_SCU\_single/double},
{\tt GALAHAD\_EXTEND\_single/double},
{\tt GALAHAD\_NORMS\_single/double},
{\tt LANCELOT\_BAND\_single/double}.
\galroutines Optionally {\tt MC61}, {\tt HSL\_MI28} and {\tt ICFS},
plus those called by {\tt GALAHAD\_SLS}.
\galio Output is under control of the arguments
{\tt control\%error},
and {\tt control\%out}.
\galrestrictions {\tt matrix\%n} $\geq$ {\tt 1},
{\tt matrix\%ne} $\geq$ {\tt 0} if {\tt matrix\%type = 'COORDINATE'},
and {\tt matrix\%type} is one of
{\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_ROWS'} or   {\tt 'DENSE'}.
% or {\tt 'DIAGONAL'}.
\galportability ISO Fortran~95 + TR 15581 or Fortran~2003 and optionally OpenMP.
The package is thread-safe.

%%%%%%%%%%%%%%%%%%%%%% METHOD %%%%%%%%%%%%%%%%%%%%%%%%

\galmethod

\noindent
The basic preconditioners are described in detail in Section 3.3.10 of
\vspace*{1mm}

\noindent
%\begin{center}
A. R. Conn, N. I. M. Gould and Ph. L. Toint (1992).
LANCELOT. A fortran package for large-scale nonlinear optimization
(release A). Springer Verlag Series in Computational Mathematics 17,
Berlin,
%\end{center}

\noindent
along with the more modern versions implements in {\tt ICFS} due to
\vspace*{1mm}

\noindent
%\begin{center}
C.-J. Lin and J. J. Mor\'{e} (1999).
Incomplete Cholesky factorizations with limited memory.
SIAM Journal on Scientific Computing {\bf 21} 21-45,
%\end{center}

\noindent
and in {\tt HSL\_MI28} described by
\vspace*{1mm}

\noindent
J. A. Scott and M. T\.{u}ma (2013). HSL MI28: an efficient and robust 
limited-memory incomplete Cholesky factorization code. 
ACM Transactions on Mathematical Software {\bf 40(4)} (2014), Article 24.

%\noindent
The factorization methods used by the \libraryname\ package {\tt SLS} in
conjunction with some preconditioners
are described in the documentation to that package. Orderings to reduce the
bandwidth, as implemented in HSL's MC61, are due to
\vspace*{1mm}

\noindent
J. K. Reid and J. A. Scott (1999)
Ordering symmetric sparse matrices for small profile and wavefront
International Journal for Numerical Methods in Engineering {\bf 45} 1737-1755.

If a subset of the rows and columns are specified, the remaining rows/columns
are removed before processing. Any subsequent removal of rows and columns
is achieved using the \libraryname\ Schur-complement updating package {\tt SCU}
unless a complete re-factorization is likely more efficient.

%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\galexample
We illustrate the use of the package on the (indefinite) sparse matrix
\disp{\mat{ccccc}{ 2 & 3 &   &   &   \\
                   3 &   & 4 &   & 6 \\
                     & 4 & 1 & 5 &   \\
                     &   & 5 &   &   \\
                     & 6 & &     & 1 }}
(Note that this example does not illustrate all the facilities).
Then, choosing the solver {\tt SILS}, we may use the following code
to find a tridiagonal (banded, with a semi-bandwidth of 1) preconditioner 
and apply it to a given vector:

{\tt \small
\VerbatimInput{\packageexample}
}
\noindent
%with the following data
%{\tt \small
%\VerbatimInput{\packagedata}
%}
%\noindent
This produces the following output:
{\tt \small
\VerbatimInput{\packageresults}
}
\noindent
The same problem may be solved holding the data in
a sparse row-wise storage format by replacing the lines
{\tt \small
\begin{verbatim}
! allocate and set lower triangle of matrix in co-ordinate form
...
! problem setup complete
\end{verbatim}
}
\noindent
by
{\tt \small
\begin{verbatim}
! allocate and set lower triangle of matrix in spares row form
     CALL SMT_put( matrix%type, 'SPARSE_BY_ROWS', s )
     matrix%n = n 
     ALLOCATE( matrix%val( ne ), matrix%col( ne ), matrix%ptr( n + 1 ) )
     matrix%ptr = (/ 1, 2, 3, 5, 6, 8 /)
     matrix%col = (/ 1, 1, 2, 3, 3, 2, 5 /)
     matrix%val = (/ 2.0_wp, 3.0_wp, 4.0_wp, 1.0_wp, 5.0_wp, 6.0_wp, 1.0_wp /)
! problem setup complete
\end{verbatim}
}
\noindent
or using a dense storage format with the replacement lines
{\tt \small
\begin{verbatim}
! allocate and set lower triangle of matrix in dense form
     CALL SMT_put( matrix%type, 'DENSE', s )
     matrix%n = n 
     ALLOCATE( matrix%val( n * ( n + 1 ) / 2 ) )
     matrix%val = (/ 2.0_wp, 3.0_wp, 0.0_wp, 0.0_wp, 4.0_wp, 1.0_wp,           &
                     0.0_wp, 0.0_wp, 5.0_wp, 0.0_wp, 0.0_wp, 6.0_wp,           &
                     0.0_wp, 0.0_wp, 1.0_wp /)
! problem setup complete
\end{verbatim}
}
\noindent
respectively.
\end{document}

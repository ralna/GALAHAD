\documentclass{galahad}

% set the package name

\newcommand{\package}{lpa}
\newcommand{\packagename}{LPA}
\newcommand{\fullpackagename}{\libraryname\_\packagename}
\newcommand{\solver}{{\tt \fullpackagename\_solve}}

\begin{document}

\galheader

%%%%%%%%%%%%%%%%%%%%%% SUMMARY %%%%%%%%%%%%%%%%%%%%%%%%

\galsummary
This package uses the {\bf simplex method}
to solve the {\bf linear programming problem}
\eqn{qp}{\mbox{minimize}\;\; \ell(\bmx) = \bmg^T \bmx + f}
subject to the general linear constraints
\disp{c_{i}^{l}  \leq  \bma_{i}^{T}\bmx  \leq  c_{i}^{u}, \;\;\;
 i = 1, \ldots , m,}
and the simple bound constraints
\disp{x_{j}^{l}  \leq  x_{j}^{ } \leq  x_{j}^{u} , \;\;\; j = 1, \ldots , n,}
where the vectors $\bmg$, $\bma_{i}$, $\bmc^{l}$, $\bmc^{u}$, $\bmx^{l}$,
$\bmx^{u}$ and the scalar $f$ are given.
Any of the constraint bounds $c_{i}^{l}$, $c_{i}^{u}$,
$x_{j}^{l}$ and $x_{j}^{u}$ may be infinite.
Full advantage is taken of any zero coefficients in
the matrix $\bmA$ of vectors $\bma_{i}$.

\noindent
{\bf N.B.} The package is simply a sophisticated interface to the HSL package
  {\tt LA04}, and requires that a user has obtained the latter.
  {\bf {LA04} is not included in \galahad,}
  but is available without charge to recognised academics, see
  {\tt http://www.hsl.rl.ac.uk/catalogue/la04.html}. If {\tt LA04}
  is unavailable, the \galahad\ interior-point linear programming
  package {\tt LPB} is an alternative.

%%%%%%%%%%%%%%%%%%%%%% attributes %%%%%%%%%%%%%%%%%%%%%%%%

\galattributes
\galversions{\tt  \fullpackagename\_single, \fullpackagename\_double}.
\galuses
{\tt GALAHAD\_CLOCK},
{\tt GALAHAD\_SY\-M\-BOLS},
{\tt GALAHAD\-\_SPACE},
{\tt GALAHAD\_TOOLS},
{\tt GALAHAD\_SPECFILE},
{\tt GALAHAD\_SMT},
{\tt GALAHAD\_QPT},
{\tt GALAHAD\_\-QPD}.
\galdate October 2018.
\galorigin N. I. M. Gould and J. K. Reid, Rutherford Appleton Laboratory.
\gallanguage Fortran~95 + TR 15581 or Fortran~2003.
%\galparallelism Some options may use OpenMP and its runtime library.

%%%%%%%%%%%%%%%%%%%%%% HOW TO USE %%%%%%%%%%%%%%%%%%%%%%%%

\galhowto

The package is available using both single and double precision reals, 
and either 32-bit or 64-bit integers. Access to the 32-bit integer,
single precision version requires the {\tt USE} statement
\medskip

\hspace{8mm} {\tt USE \fullpackagename\_single}

\medskip
\noindent
with the obvious substitution {\tt \fullpackagename\_double},
{\tt \fullpackagename\_single\_64} and 
{\tt \fullpackagename\_double\_64} for the other variants.

\noindent
If it is required to use more than one of the modules at the same time, 
the derived types
{\tt SMT\_type},
{\tt QPT\_problem\_type},
%{\tt NLPT\_userdata\-\_type},
{\tt \packagename\_time\_type},
{\tt \packagename\_control\_type},
{\tt \packagename\_inform\_type}
and
{\tt \packagename\_data\_type}
(Section~\ref{galtypes})
and the subroutines
{\tt \packagename\_initialize},
{\tt \packagename\_\-solve},
{\tt \packagename\_terminate},
(Section~\ref{galarguments})
and
{\tt \packagename\_read\_specfile}
(Section~\ref{galfeatures})
must be renamed on one of the {\tt USE} statements.

%%%%%%%%%%%%%%%%%%%%%% matrix formats %%%%%%%%%%%%%%%%%%%%%%%%

\galmatrix
%When its is explicitly available,
The constraint Jacobian $\bmA$, the matrix
whose rows are the vectors $\bma_{i}^{T}$, $i = 1, \ldots , m$,
may be stored in a variety of input formats.

\subsubsection{Dense storage format}\label{dense}
The matrix $\bmA$ is stored as a compact
dense matrix by rows, that is, the values of the entries of each row in turn
are stored in order within an appropriate real one-dimensional array.
Component $n \ast (i-1) + j$ of the storage array {\tt A\%val} will hold the
value $a_{ij}$ for $i = 1, \ldots , m$, $j = 1, \ldots , n$.

\subsubsection{Sparse co-ordinate storage format}\label{coordinate}
Only the nonzero entries of the matrices are stored. For the
$l$-th entry of $\bmA$, its row index $i$, column index $j$
and value $a_{ij}$
are stored in the $l$-th components of the integer arrays {\tt A\%row},
{\tt A\%col} and real array {\tt A\%val}, respectively.
The order is unimportant, but the total
number of entries {\tt A\%ne} is also required.

\subsubsection{Sparse row-wise storage format}\label{rowwise}
Again only the nonzero entries are stored, but this time
they are ordered so that those in row $i$ appear directly before those
in row $i+1$. For the $i$-th row of $\bmA$, the $i$-th component of a
integer array {\tt A\%ptr} holds the position of the first entry in this row,
while {\tt A\%ptr} $(m+1)$ holds the total number of entries plus one.
The column indices $j$ and values $a_{ij}$ of the entries in the $i$-th row
are stored in components
$l =$ {\tt A\%ptr}$(i)$, \ldots ,{\tt A\%ptr} $(i+1)-1$ of the
integer array {\tt A\%col}, and real array {\tt A\%val}, respectively.

For sparse matrices, this scheme almost always requires less storage than
its predecessor.

%%%%%%%%%%%%%%%%%%%%%%%%%%% kinds %%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{kinds}

%%%%%%%%%%%%%%%%%%%%%% parallel usage %%%%%%%%%%%%%%%%%%%%%%%%

%\input{parallel}

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\galtypes
Ten derived data types are accessible from the package.

%%%%%%%%%%% matrix data type %%%%%%%%%%%

\subsubsection{The derived data type for holding matrices}\label{typesmt}
The derived data type {\tt SMT\_TYPE} is used to hold the matrix $\bmA$.
The components of {\tt SMT\_TYPE} used here are:

\begin{description}

\ittf{m} is a scalar component of type \integer,
that holds the number of rows in the matrix.

\ittf{n} is a scalar component of type \integer,
that holds the number of columns in the matrix.

\ittf{ne} is a scalar variable of type \integer, that
holds the number of matrix entries.

\ittf{type} is a rank-one allocatable array of type default \character, that
is used to indicate the matrix storage scheme used. Its precise length and
content depends on the type of matrix to be stored (see \S\ref{typeprob}).

\ittf{val} is a rank-one allocatable array of type \realdp\,
and dimension at least {\tt ne}, that holds the values of the entries
(see \S\ref{dense}--\ref{rowwise}).
Any duplicated entries that appear in the sparse
co-ordinate or row-wise schemes will be summed.

\ittf{row} is a rank-one allocatable array of type \integer,
and dimension at least {\tt ne}, that may hold the row indices of the entries.
(see \S\ref{coordinate}).

\ittf{col} is a rank-one allocatable array of type \integer,
and dimension at least {\tt ne}, that may the column indices of the entries
(see \S\ref{coordinate}--\ref{rowwise}).

\ittf{ptr} is a rank-one allocatable array of type \integer,
and dimension at least {\tt m + 1}, that may hold the pointers to
the first entry in each row (see \S\ref{rowwise}).

\end{description}

%%%%%%%%%%% problem type %%%%%%%%%%%

\subsubsection{The derived data type for holding the problem}\label{typeprob}
The derived data type {\tt QPT\_problem\_type} is used to hold
the problem. The components of
{\tt QPT\_problem\_type}
are:

\begin{description}

\ittf{n} is a scalar variable of type \integer,
 that holds the number of optimization variables, $n$.

\ittf{m} is a scalar variable of type \integer,
 that holds the number of general linear constraints, $m$.

\itt{gradient\_kind} is a scalar variable of type \integer,
that is used to indicate whether the components of the gradient $\bmg$
have special or general values. Possible values for {\tt gradient\_kind} are:
\begin{description}
\itt{0}  In this case, $\bmg = 0$.

\itt{1} In this case, $g_{j} = 1$ for $j = 1, \ldots , n$.

\itt{$\neq$ 0,1} In this case, general values of $\bmg$ will be used,
     and will be provided in the component {\tt G} (see below).
\end{description}

\ittf{G} is a rank-one allocatable array type \realdp, that
should be allocated to have length {\tt n}, and its $j$-th component
filled with the value $g_{j}$ for $j = 1, \ldots , n$,
whenever {\tt gradient\_kind} $\neq$ 0,1.
If {\tt gradient\_kind} {= 0, 1}, {\tt G} need not be allocated.

\ittf{f} is a scalar variable of type
\realdp, that holds
the constant term, $f$, in the objective function.

\ittf{A} is scalar variable of type {\tt SMT\_TYPE}
that holds the Jacobian matrix $\bmA$ when it is available explicitly.
The following components are used:

\begin{description}

\itt{A\%type} is an allocatable array of rank one and type default \character,
that is used to indicate the storage scheme used. If the dense storage scheme
(see Section~\ref{dense}) is used,
the first five components of {\tt A\%type} must contain the
string {\tt DENSE}.
For the sparse co-ordinate scheme (see Section~\ref{coordinate}),
the first ten components of {\tt A\%type} must contain the
string {\tt COORDINATE}, while
for the sparse row-wise storage scheme (see Section~\ref{rowwise}),
the first fourteen components of {\tt A\%type} must contain the
string {\tt SPARSE\_BY\_ROWS}.

Just as for {\tt H\%type} above, the procedure {\tt SMT\_put}
may be used to allocate sufficient space and insert the required keyword
into {\tt A\%type}.
Once again, if {\tt prob} is of derived type {\tt \packagename\_problem\_type}
and involves a Jacobian we wish to store using the sparse row-wise
storage scheme, we may simply
%\vspace*{-2mm}
{\tt
\begin{verbatim}
        CALL SMT_put( prob%A%type, 'SPARSE_BY_ROWS', istat )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent

\itt{A\%ne} is a scalar variable of type \integer, that
holds the number of entries in $\bmA$
in the sparse co-ordinate storage scheme (see Section~\ref{coordinate}).
It need not be set for either of the other two appropriate schemes.

\itt{A\%val} is a rank-one allocatable array of type \realdp, that holds
the values of the entries of the Jacobian matrix $\bmA$ in any of the
appropriate storage schemes discussed in Section~\ref{galmatrix}.

\itt{A\%row} is a rank-one allocatable array of type \integer,
that holds the row indices of $\bmA$ in the sparse co-ordinate storage
scheme (see Section~\ref{coordinate}).
It need not be allocated for either of the other two appropriate schemes.

\itt{A\%col} is a rank-one allocatable array variable of type \integer,
that holds the column indices of $\bmA$ in either the sparse co-ordinate
(see Section~\ref{coordinate}), or the sparse row-wise
(see Section~\ref{rowwise}) storage scheme.
It need not be allocated when the dense storage scheme is used.

\itt{A\%ptr} is a rank-one allocatable array of dimension {\tt m+1} and type
\integer, that holds the
starting position of each row of $\bmA$, as well
as the total number of entries plus one, in the sparse row-wise storage
scheme (see Section~\ref{rowwise}). It need not be allocated when the
other appropriate schemes are used.

\end{description}

\ittf{C\_l} is a rank-one allocatable array of dimension {\tt m} and type
\realdp, that holds the vector of lower bounds $\bmc^{l}$
on the general constraints. The $i$-th component of
{\tt C\_l}, $i = 1, \ldots , m$, contains $\bmc_{i}^{l}$.
Infinite bounds are allowed by setting the corresponding
components of {\tt C\_l} to any value smaller than {\tt -infinity},
where {\tt infinity} is a component of the control array {\tt control}
(see Section~\ref{typecontrol}).

\ittf{C\_u} is a rank-one allocatable array of dimension {\tt m} and type
\realdp, that holds the vector of upper bounds $\bmc^{u}$
on the general constraints. The $i$-th component of
{\tt C\_u}, $i = 1,  \ldots ,  m$, contains $\bmc_{i}^{u}$.
Infinite bounds are allowed by setting the corresponding
components of {\tt C\_u} to any value larger than {\tt infinity},
where {\tt infinity} is a component of the control array {\tt control}
(see Section~\ref{typecontrol}).

\ittf{X\_l} is a rank-one allocatable array of dimension {\tt n} and type
\realdp, that holds
the vector of lower bounds $\bmx^{l}$ on the the variables.
The $j$-th component of {\tt X\_l}, $j = 1, \ldots , n$,
contains $\bmx_{j}^{l}$.
Infinite bounds are allowed by setting the corresponding
components of {\tt X\_l} to any value smaller than {\tt -infinity},
where {\tt infinity} is a component of the control array {\tt control}
(see Section~\ref{typecontrol}).

\ittf{X\_u} is a rank-one allocatable array of dimension {\tt n} and type
\realdp, that holds
the vector of upper bounds $\bmx^{u}$ on the variables.
The $j$-th component of {\tt X\_u}, $j = 1, \ldots , n$,
contains $\bmx_{j}^{u}$.
Infinite bounds are allowed by setting the corresponding
components of {\tt X\_u} to any value larger than that {\tt infinity},
where {\tt infinity} is a component of the control array {\tt control}
(see Section~\ref{typecontrol}).

\ittf{X} is a rank-one allocatable array of dimension {\tt n} and type
\realdp,
that holds the values $\bmx$ of the optimization variables.
The $j$-th component of {\tt X}, $j = 1,  \ldots , n$, contains $x_{j}$.

\ittf{C} is a rank-one allocatable array of dimension {\tt m} and type default
\realdp, that holds
the values $\bmA \bmx$ of the constraints.
The $i$-th component of {\tt C}, $i = 1,  \ldots ,  m$, contains
$\bma_{i}^{T}\bmx \equiv (\bmA \bmx)_{i}$.

\ittf{Y} is a rank-one allocatable array of dimension {\tt m} and type
\realdp, that holds
the values $\bmy$ of estimates  of the Lagrange multipliers
corresponding to the general linear constraints (see Section~\ref{galmethod}).
The $i$-th component of {\tt Y}, $i = 1,  \ldots ,  m$, contains $y_{i}$.

\ittf{Z} is a rank-one allocatable array of dimension {\tt n} and type default
\realdp, that holds
the values $\bmz$ of estimates  of the dual variables
corresponding to the simple bound constraints (see Section~\ref{galmethod}).
The $j$-th component of {\tt Z}, $j = 1,  \ldots ,  n$, contains $z_{j}$.

\end{description}

%%%%%%%%%%% control type %%%%%%%%%%%

\subsubsection{The derived data type for holding control
 parameters}\label{typecontrol}
The derived data type
{\tt \packagename\_control\_type}
is used to hold controlling data. Default values may be obtained by calling
{\tt \packagename\_initialize}
(see Section~\ref{subinit}),
while components may also be changed by calling
{\tt \packagename\_read\-\_specfile}
(see Section~\ref{readspec}).
The components of
{\tt \packagename\_control\_type}
are:

\input{lpa_control}

%%%%%%%%%%% time type %%%%%%%%%%%

\subsubsection{The derived data type for holding timing
 information}\label{typetime}
The derived data type
{\tt \packagename\_time\_type}
is used to hold elapsed CPU and system clock times for the various parts of
the calculation. The components of
{\tt \packagename\_time\_type}
are:
\begin{description}
\itt{total} is a scalar variable of type \realdp, that gives
 the total CPU time spent in the package.

\itt{preprocess} is a scalar variable of type \realdp, that gives
 the CPU time spent preprocess the problem prior to solution.

\itt{clock\_total} is a scalar variable of type \realdp, that gives
 the total elapsed system clock time spent in the package.

\itt{clock\_preprocess} is a scalar variable of type \realdp, that gives
 the elapsed system clock time spent preprocess the problem prior to solution.

\itt{clock\_solve} is a scalar variable of type \realdp, that gives
 the elapsed system clock time spent computing the search direction.

\end{description}

%%%%%%%%%%% inform type %%%%%%%%%%%

\subsubsection{The derived data type for holding informational
 parameters}\label{typeinform}
The derived data type
{\tt \packagename\_inform\_type}
is used to hold parameters that give information about the progress and needs
of the algorithm. The components of
{\tt \packagename\_inform\_type}
are:

\input{lpa_inform}

%%%%%%%%%%% data type %%%%%%%%%%%

\subsubsection{The derived data type for holding problem data}\label{typedata}
The derived data type
{\tt \packagename\_data\_type}
is used to hold all the data for a particular problem,
or sequences of problems with the same structure, between calls of
{\tt \packagename} procedures.
This data should be preserved, untouched, from the initial call to
{\tt \packagename\_initialize}
to the final call to
{\tt \packagename\_terminate}.

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\galarguments
There are three procedures for user calls
(see Section~\ref{galfeatures} for further features):

\begin{enumerate}
\item The subroutine
      {\tt \packagename\_initialize}
      is used to set default values, and initialize private data,
      before solving one or more problems with the
      same sparsity and bound structure.
\item The subroutine
      {\tt \packagename\_solve}
      is called to solve the problem.
\item The subroutine
      {\tt \packagename\_terminate}
      is provided to allow the user to automatically deallocate array
       components of the private data, allocated by
       {\tt \packagename\_solve},
       at the end of the solution process.
\end{enumerate}
We use square brackets {\tt [ ]} to indicate \optional\ arguments.

%%%%%% initialization subroutine %%%%%%

\subsubsection{The initialization subroutine}\label{subinit}
 Default values are provided as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_initialize( data, control, inform )}

\vspace*{-3mm}
\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see Section~\ref{typedata}). It is used to hold data about the problem being
solved.

\itt{control} is a scalar \intentout\ argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}).
On exit, {\tt control} contains default values for the components as
described in Section~\ref{typecontrol}.
These values should only be changed after calling
{\tt \packagename\_initialize}.

\itt{inform} is a scalar \intentout\ argument of type
{\tt \packagename\_inform\_type}
(see Section~\ref{typeinform}). A successful call to
{\tt \packagename\_initialize}
is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\end{description}

%%%%%%%%% main solution subroutine %%%%%%

\subsubsection{The linear programming subroutine}\label{qps}
The linear programming solution algorithm is called as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_solve( prob, data, control, inform[, C\_stat, X\_stat] )}

%\vspace*{-3mm}
\begin{description}
\ittf{prob} is a scalar \intentinout\ argument of type
{\tt QPT\_problem\_type}
(see Section~\ref{typeprob}).
It is used to hold data about the problem being solved.
The user must allocate all the array components,
and set values for all components except {\tt prob\%X}, {\tt prob\%C},
{\tt prob\%Y} and {\tt prob\%Z}

On exit, the components {\tt prob\%X} , {\tt prob\%C}, {\tt prob\%Y},
and {\tt prob\%Z}
will contain the best estimates of the primal variables $\bmx$,
the linear constraints $\bmA \bmx$,
Lagrange multipliers, $\bmy$, for the general constraints
and dual variables for the bound constraints $\bmz$, respectively.
\restrictions {\tt prob\%n} $> 0$, {\tt prob\%m} $\geq 0$,
 {\tt prob\%A\_type} $\in \{${\tt 'DENSE'},
 {\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_\-ROWS'} $\}$.

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see Section~\ref{typedata}). It is used to hold data about the problem being
solved. It must not have been altered {\bf by the user} since the last call to
{\tt \packagename\_initialize}.

\itt{control} is a scalar \intentin\ argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}). Default values may be assigned by calling
{\tt \packagename\_initialize} prior to the first call to
{\tt \packagename\_solve}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see Section~\ref{typeinform}).
A successful call to
{\tt \packagename\_solve}
is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\itt{C\_stat} is an \optional\ rank-one \intentout\ array argument of
dimension {\tt p\%m}
and type \integer, that indicates which of the general linear
constraints are in the optimal active set. Possible values for
{\tt C\_stat(i)}, {\tt i}$=1, \ldots ,$ {\tt p\%m}, and their meanings are
\begin{description}
\itt{<0} the $i$-th general constraint
is in the active set, on its lower bound,
\itt{>0} the $i$-th general constraint
is in the active set, on its upper bound, and
\itt{0}  the $i$-th general constraint is not in the active set.
\end{description}
If a warm start is to be performed (see {\tt control\%wam\_start}),
{\tt C\_stat} must be provided and set as above.

\itt{X\_stat} is an \optional\ rank-one \intentout\ array argument of
dimension {\tt p\%n}
and type \integer, that indicates which of the simple bound
constraints are in the current active set. Possible values for
{\tt X\_stat(j)}, {\tt j}$=1, \ldots ,$ {\tt p\%n}, and their meanings are
\begin{description}
\itt{<0} the $j$-th simple bound constraint
is in the active set, on its lower bound,
\itt{>0} the $j$-th simple bound constraint
is in the active set, on its upper bound, and
\itt{0}  the $j$-th simple bound constraint is not in the active set.
\end{description}
If a warm start is to be performed (see {\tt control\%wam\_start}),
{\tt X\_stat} must be provided and set as above.

\end{description}

%%%%%%% termination subroutine %%%%%%

\subsubsection{The  termination subroutine}
All previously allocated arrays are deallocated as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_terminate( data, control, inform )}

\vspace*{-3mm}
\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
exactly as for
{\tt \packagename\_solve},
which must not have been altered {\bf by the user} since the last call to
{\tt \packagename\_initialize}.
On exit, array components will have been deallocated.

\itt{control} is a scalar \intentin\ argument of type
{\tt \packagename\_control\_type}
exactly as for
{\tt \packagename\_solve}.

\itt{inform} is a scalar \intentout\ argument of type
{\tt \packagename\_inform\_type}
exactly as for
{\tt \packagename\_solve}.
Only the component {\tt status} will be set on exit, and a
successful call to
{\tt \packagename\_terminate}
is indicated when this  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\end{description}


%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\galerrors
A negative value of {\tt inform\%status} on exit from
{\tt \packagename\_solve}
or
{\tt \packagename\_terminate}
indicates that an error has occurred. No further calls should be made
until the error has been corrected. Possible values are:

\begin{description}

\itt{\galerrallocate.} An allocation error occurred. A message indicating
the offending
array is written on unit {\tt control\%error}, and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc} respectively.

\itt{\galerrdeallocate.} A deallocation error occurred.
A message indicating the offending
array is written on unit {\tt control\%error} and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc} respectively.

\itt{\galerrrestrictions.} One of the restrictions
 {\tt prob\%n} $> 0$ ,  {\tt prob\%m} $\geq 0$ or
    the requirement that {\tt prob\%A\_type} contain its relevant string
    {\tt 'DENSE'}, {\tt 'COORDINATE'} or {\tt 'SPARSE\_BY\_ROWS'},
    has been violated.

\itt{\galerrbadbounds.} The bound constraints are inconsistent.

\itt{\galerrprimalinfeasible.} The constraints appear to have no feasible point.

\itt{\galerrunbounded.} The objective function appears to be unbounded
  from below on the feasible set.

%\itt{\galerranalysis.} The analysis phase of the factorization failed;
%  the return status from the factorization
%    package is given in the component {\tt inform\%fac\-t\-or\_status}.

%\itt{\galerrfactorization.} The factorization failed; the return status
%  from the factorization
%    package is given in the component {\tt inform\%fac\-t\-or\_status}.

\itt{\galerrillconditioned.} The problem is so ill-conditioned that
 further progress is impossible.

\itt{\galerrtinystep.} The step is too small to make further impact.

\itt{\galerrmaxiterations.} Too many iterations have been performed.
   This may happen if
    {\tt control\%maxit} is too small, but may also be symptomatic of
    a badly scaled problem.

\itt{\galerrcpulimit.} The elapsed CPU or system clock time limit has been
    reached. This may happen if either {\tt control\%cpu\_time\_limit} or
    {\tt control\%clock\_time\_limit} is too small, but may also be symptomatic
    of a badly scaled problem.

\itt{\galerrunavailable.} The HSL solver {\tt LA04} is unavailable.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Further features %%%%%%%%%%%%%%%%%%%%%%%%

\galfeatures
\noindent In this section, we describe an alternative means of setting
control parameters, that is components of the variable {\tt control} of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}),
by reading an appropriate data specification file using the
subroutine {\tt \packagename\_read\_specfile}. This facility
is useful as it allows a user to change  {\tt \packagename} control parameters
without editing and recompiling programs that call {\tt \packagename}.

A specification file, or specfile, is a data file containing a number of
"specification commands". Each command occurs on a separate line,
and comprises a "keyword",
which is a string (in a close-to-natural language) used to identify a
control parameter, and
an (optional) "value", which defines the value to be assigned to the given
control parameter. All keywords and values are case insensitive,
keywords may be preceded by one or more blanks but
values must not contain blanks, and
each value must be separated from its keyword by at least one blank.
Values must not contain more than 30 characters, and
each line of the specfile is limited to 80 characters,
including the blanks separating keyword and value.



The portion of the specification file used by
{\tt \packagename\_read\_specfile}
must start
with a "{\tt BEGIN \packagename}" command and end with an
"{\tt END}" command.  The syntax of the specfile is thus defined as follows:
\begin{verbatim}
  ( .. lines ignored by LPA_read_specfile .. )
    BEGIN LPA
       keyword    value
       .......    .....
       keyword    value
    END
  ( .. lines ignored by LPA_read_specfile .. )
\end{verbatim}
where keyword and value are two strings separated by (at least) one blank.
The ``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiter command lines
may contain additional (trailing) strings so long as such strings are
separated by one or more blanks, so that lines such as
\begin{verbatim}
    BEGIN LPA SPECIFICATION
\end{verbatim}
and
\begin{verbatim}
    END LPA SPECIFICATION
\end{verbatim}
are acceptable. Furthermore,
between the
``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiters,
specification commands may occur in any order.  Blank lines and
lines whose first non-blank character is {\tt !} or {\tt *} are ignored.
The content
of a line after a {\tt !} or {\tt *} character is also
ignored (as is the {\tt !} or {\tt *}
character itself). This provides an easy manner to "comment out" some
specification commands, or to comment specific values
of certain control parameters.

The value of a control parameters may be of three different types, namely
integer, logical or real.
Integer and real values may be expressed in any relevant Fortran integer and
floating-point formats (respectively). Permitted values for logical
parameters are "{\tt ON}", "{\tt TRUE}", "{\tt .TRUE.}", "{\tt T}",
"{\tt YES}", "{\tt Y}", or "{\tt OFF}", "{\tt NO}",
"{\tt N}", "{\tt FALSE}", "{\tt .FALSE.}" and "{\tt F}".
Empty values are also allowed for
logical control parameters, and are interpreted as "{\tt TRUE}".

The specification file must be open for
input when {\tt \packagename\_read\_specfile}
is called, and the associated device number
passed to the routine in device (see below).
Note that the corresponding
file is {\tt REWIND}ed, which makes it possible to combine the specifications
for more than one program/routine.  For the same reason, the file is not
closed by {\tt \packagename\_read\_specfile}.

\subsubsection{To read control parameters from a specification file}
\label{readspec}

Control parameters may be read from a file as follows:
\hskip0.5in

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
     CALL LPA_read_specfile( control, device )
\end{verbatim}
}
\def\baselinestretch{1.0}

\begin{description}
\itt{control} is a scalar \intentinout argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}).
Default values should have already been set, perhaps by calling
{\tt \packagename\_initialize}.
On exit, individual components of {\tt control} may have been changed
according to the commands found in the specfile. Specfile commands and
the component (see Section~\ref{typecontrol}) of {\tt control}
that each affects are given in Table~\ref{specfile}.

\bctable{|l|l|l|}
\hline
  command & component of {\tt control} & value type \\
\hline
  {\tt error-printout-device} & {\tt \%error} & integer \\
  {\tt printout-device} & {\tt \%out} & integer \\
  {\tt print-level} & {\tt \%print\_level} & integer \\
  {\tt start-print} & {\tt \%start\_print} & integer \\
  {\tt stop-print} & {\tt \%stop\_print} & integer \\
  {\tt maximum-number-of-iterations} & {\tt \%maxit} & integer \\
  {\tt max-iterative-refinements} & {\tt \%max\_iterative\_refinements} & integer \\
  {\tt minimum-real-factor-size} & {\tt \%min\_real\_factor\_size} & integer \\
  {\tt minimum-integer-factor-size} & {\tt \%min\_integer\_factor\_size} & integer \\
  {\tt random-number-seed} & {\tt \%random\_number\_seed} & integer \\
  {\tt infinity-value} & {\tt \%infinity} & real \\
  {\tt tolerable-relative-data-perturbation} & {\tt \% tol\_data} & real \\
  {\tt feasibility-tolerance} & {\tt \%feas\_tol} & real \\
  {\tt relative-pivot-tolerance} & {\tt \%relative\_pivot\_tolerance} & real \\
  {\tt growth-limit-tolerance} & {\tt \% growth\_limit} & real \\
  {\tt zero-basis-entry-tolerance} & {\tt \%zero\_tolerance} & real \\
  {\tt change-tolerance} & {\tt \%change\_tolerance} & real \\
  {\tt identical-bounds-tolerance} & {\tt \%identical\_bounds\_tol} & real \\
  {\tt maximum-cpu-time-limit} & {\tt \%cpu\_time\_limit} & real \\
  {\tt maximum-clock-time-limit} & {\tt \%clock\_time\_limit} & real \\
  {\tt scale-problem-data} & {\tt \%remove\_dependencies} & logical \\
  {\tt warm-startl} & {\tt \%warm\_start} & logical \\
  {\tt solve-dual} & {\tt \%dual} & logical \\
  {\tt space-critical}   & {\tt \%space\_critical} & logical \\
  {\tt deallocate-error-fatal}   & {\tt \%deallocate\_error\_fatal} & logical \\
  {\tt output-line-prefix} & {\tt \%prefix} & character \\
\hline

\ectable{\label{specfile}Specfile commands and associated
components of {\tt control}.}

\itt{device} is a scalar \intentin argument of type \integer,
that must be set to the unit number on which the specfile
has been opened. If {\tt device} is not open, {\tt control} will
not be altered and execution will continue, but an error message
will be printed on unit {\tt control\%error}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Information printed %%%%%%%%%%%%%%%%%%%%%%%%

\galinfo
If {\tt control\%print\_level = 1}, a summary of the return status
of the algorithm will be printed on unit {\tt control\-\%out}.
If {\tt control\%print\_level} $\geq 2$, information about the progress
of the algorithm will be given.
At each iteration two lines of output are produced showing :
\begin{enumerate}
\item[(i)] The iteration number.
\item[(ii)] The length {\tt LENL} of the $\bmL$ part of the factorization of
the basis matrix.
\item[(iii)] The length {\tt LENU} of the $\bmU$ part of the factorization of
the basis matrix.
\item[(iv)] The variable, {\tt JIN}, entering the basis.
\item[(v)] The variable, {\tt JOUT}, leaving the basis.
\item[(vi)] The number, {\tt NINF}, of infeasibilities.
\item[(vii)] The value of the objective function (or the sum
of the infeasibilities if the phase-one problem is being solved).
\item[(viii)] The growth parameter, {\tt G}.
\item[(ix)] The number, {\tt NCP}, of compresses performed when updating the factors of the
  basis matrix.
\item[(x)] The reduced cost, {\tt Z}, of the incoming variable.
\item[(xi)] The recurred approximation, {\tt APPROX Z},  to this reduced cost.
\item[(xii)] The steepest-edge weight {\tt GAMMA} used to choose the incoming
variable.
\item[(xiii)] The recurred approximation, {\tt APPROX GAMMA}, to this weight.
\item[(xiv)] The time taken so far.
\item[(xv)] The value of the pivot.
\end{enumerate}
When the run terminates, a message to this effect is printed and
the value of the objective function is output.
If {\tt control\%print\_level} $\geq 100$ this
output will be increased to provide detailed debuging information.

%%%%%%%%%%%%%%%%%%%%%% GENERAL INFORMATION %%%%%%%%%%%%%%%%%%%%%%%%

\galgeneral

\galcommon None.
\galworkspace Provided automatically by the module.
\galroutines None.
\galmodules {\tt \packagename\_solve} calls the \galahad\ packages
{\tt GALAHAD\_CLOCK},
{\tt GALAHAD\_SY\-M\-BOLS},
{\tt GALA\-HAD\_SPACE},
{\tt GALAHAD\_SPECFILE},
{\tt GALAHAD\_SMT},
{\tt GALAHAD\_QPT}
and
{\tt GALAHAD\_QPD},
and the HSL package {\tt LA04}.
\galio Output is under control of the arguments
 {\tt control\%error}, {\tt control\%out} and {\tt control\%print\_level}.
\galrestrictions {\tt prob\%n} $> 0$, {\tt prob\%m} $\geq  0$,
{\tt prob\%A\_type} and {\tt prob\%H\_type} $\in \{${\tt 'DENSE'},
 {\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_\-ROWS'}, {\tt 'DIAGONAL'} $\}$.
%(if $\bmH$ and $\bmA$ are explicit).
\galportability ISO Fortran~95 + TR 15581 or Fortran~2003.
The package is thread-safe.

%%%%%%%%%%%%%%%%%%%%%% METHOD %%%%%%%%%%%%%%%%%%%%%%%%

\galmethod
The required solution $\bmx$ necessarily satisfies
the primal optimality conditions
\eqn{4.1a}{\bmA \bmx = \bmc}
and
\eqn{4.1b}{
 \bmc^{l} \leq \bmc \leq \bmc^{u}, \;\;
\bmx^{l} \leq\bmx \leq\bmx^{u},}
the dual optimality conditions
\eqn{4.2a}{\bmg = \bmA^{T} \bmy + \bmz }
where
\eqn{4.2b}{
 \bmy = \bmy^{l} + \bmy^{u}, \;\;
 \bmz = \bmz^{l} + \bmz^{u}\,\,
 \bmy^{l} \geq 0 , \;\;
 \bmy^{u} \leq 0 , \;\;
 \bmz^{l} \geq 0 \;\; \mbox{and} \;\;
 \bmz^{u} \leq 0 ,}
and the complementary slackness conditions
\eqn{4.3}{
( \bmA \bmx - \bmc^{l} )^{T} \bmy^{l} = 0  ,\;\;
( \bmA \bmx - \bmc^{u} )^{T} \bmy^{u} = 0  ,\;\;
(\bmx -\bmx^{l} )^{T} \bmz^{l} = 0   \tim{and}
(\bmx -\bmx^{u} )^{T} \bmz^{u} = 0 ,}
where the vectors $\bmy$ and $\bmz$ are known as the Lagrange multipliers for
the general linear constraints, and the dual variables for the bounds,
respectively, and where the vector inequalities hold component-wise.

The so-called dual to this problem is another linear program
\disp{
  - \mbox{minimize} \;\; \bmc^{lT} \bmy^l + \bmc^{uT} \bmy^u +
  \bmx^{lT} \bmz^l + \bmx^{uT} \bmz^u + f
      \;\; \mbox{subject to the constraints \req{4.2a} and \req{4.2b}}}
that uses the same data. The solution to the two problems, it is exists,
is the same, but if one is infeasible, the other is unbounded. It can be
more efficient to solve the dual, particularly if $m$ is much larger than $n$.

The bulk of the work is peformed by the HSL package {\tt LA04}. The
main subbroutine from this package requires that the input problem
be transformed into the ``standard form''
\eqn{newlp}{
\begin{array}{rl}
  \mbox{minimize} & \bmg'^T \bmx' \\
  \mbox{subject to} & \bmA' \bmx' = \bmb \\
  & l_i \leq x'_i \leq u_i, \;\;  (i\leq k) \\
  \tim{and} & x'_l \geq 0, \;\; (i \geq l)
\end{array}
}
by introducing slack an surpulus variables, reordering and
removing fixed variables and free constraints. The resulting
problem involves $n'$ unknowns and $m'$ general constraints.
In order to deal with the possibility that the general constraints
are inconsistent or not of full rank,
{\tt LA04} introduces additional ``artifical'' variables $\bmv$, 
replaces the constraints of \req{newlp} by
\eqn{newcon}{\bmA' \bmx' + \bmv = \bmb}
and gradually encourages $\bmv$ to zero as a first solution phase.

Once a selection of $m'$ independent ({\em non-basic}) variables
is made, the constraints \req{newcon}  determine the remaining $m'$
dependent ({\em basic}) variables. The {\bf simplex method}
is a scheme for systematically adjusting the choice of basic
and non-basic variables until a set which defines an optimal
solution of \req{newlp} is obtained. Each
iteration of the simplex method requires the solution of a number
of sets of linear equations whose coefficient matrix is the
{\em basis} matrix $\bmB$, made up of the columns of $[\bmA' \;\; \bmI]$
corresponding to the
basic variables, or its transpose $\bmB^T$. As the basis matrices for
consecutive iterations are closely related, it is normally
advantageous to update (rather than recompute) their factorizations
as the computation proceeds.
If an initial basis is not provided by the user,
a set of basic variables which provide a (permuted)
triangular basis matrix is found by the simple crash algorithm of
Gould and Reid (1989), and initial steepest-edge weights are calculated.

Phases one (finding a feasible solution)
and two (solving \req{newlp}) of the simplex method are applied, as
appropriate, with the choice of entering variable as described
by Goldfarb and Reid (1977) and the
choice of leaving variable as proposed by Harris (1973).
Refactorizations of the basis matrix are performed whenever doing so
will reduce the average iteration time or there is insufficient memory
for its factors.
The reduced cost for the entering variable is computed afresh. If it
is found to be of a different sign from the recurred value or more than
10\% different in magnitude, a fresh computation of all the reduced
costs is performed.
Details of the factorization and updating procedures are given by
Reid (1982).
Iterative refinement is encouraged for the basic solution and for
the reduced costs after each factorization
of the basis matrix and when they are recomputed at the end of phase 1.

\vspace*{1mm}

\galreferences
\vspace*{1mm}

\noindent
D.\ Goldfarb and J.\ K.\ Reid (1977).
``A practicable steepest-edge simplex algorithm''.
Mathematical Programming {\bf 12} 361-371.
\vspace*{1mm}

\noindent
N.\ I.\ M.\ Gould and J.\ K.\ Reid (1989).
``New crash procedures for large systems of linear constraints''.
Mathematical Programming {\bf 45} 475-501.
\vspace*{1mm}

\noindent
P.\ M.\ J.\ Harris (1973).
``Pivot selection methods of the {D}evex {LP} code''.
Mathematical Programming {\bf 5} 1-28.
\vspace*{1mm}

\noindent
J.\ K.\ Reid (1982).
``A sparsity-exploiting variant of the {B}artels-{G}olub
decomposition for linear-programming bases''.
Mathematical Programming {\bf 24} 55-69.
\vspace*{1mm}

%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\galexample
Suppose we wish to minimize
$x_1 + 2 x_2 + 1$
subject to the the general linear constraints
$1 \leq  2 x_{1}  +  x_{2}  \leq  2$ and
$x_{2}  +  x_{3}  =  2$, and simple bounds
$-1  \leq  x_{1}  \leq  1$, $x_2 \geq 3$ and $x_{3}  \leq  2$.
Then, on writing the data for this problem as $f = 1$,
\disp{ \bmg = \vect{ 1 \\ 2 \\ 0 }, \;\;
\bmx^{l} = \vect{ -1 \\ 3 \\ - \infty } \tim{and}
\bmx^{u} = \vect{ 1 \\ \infty \\ 2 },}
and
\disp{
 \bmA = \mat{ccc}{ 2 & 1 & \\ & 1 & 1},\;\;
 \bmc^{l} = \vect{ 1 \\ 2 }, \tim{and}
 \bmc^{u} = \vect{ 2 \\ 2 }}
in sparse co-ordinate format,
we may use the following code:

{\tt \small
\VerbatimInput{\packageexample}
}
\noindent
This produces the following output:
{\tt \small
\VerbatimInput{\packageresults}
}
\noindent
The same problem may be solved holding the data in
a sparse row-wise storage format by replacing the lines
{\tt \small
\begin{verbatim}
!  sparse co-ordinate storage format
...
! problem data complete
\end{verbatim}
}
\noindent
by
{\tt \small
\begin{verbatim}
! sparse row-wise storage format
   CALL SMT_put( p%A%type, 'SPARSE_BY_ROWS' )  ! storage for A
   ALLOCATE( p%A%val( a_ne ), p%A%col( a_ne ), p%A%ptr( m + 1 ) )
   p%A%val = (/ 2.0_wp, 1.0_wp, 1.0_wp, 1.0_wp /) ! Jacobian A
   p%A%col = (/ 1, 2, 2, 3 /)
   p%A%ptr = (/ 1, 3, 5 /)                        ! Set row pointers
! problem data complete
\end{verbatim}
}
\noindent
or using a dense storage format with the replacement lines
{\tt \small
\begin{verbatim}
! dense storage format
   CALL SMT_put( p%A%type, 'DENSE' )  ! storage for A
   ALLOCATE( p%A%val( n * m ) )
   p%A%val = (/ 2.0_wp, 1.0_wp, 0.0_wp, 0.0_wp, 1.0_wp, 1.0_wp /) ! Jacobian
! problem data complete
\end{verbatim}
}
\noindent
respectively.

\end{document}

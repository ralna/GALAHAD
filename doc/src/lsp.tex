\documentclass{galahad}

% set the package name

\newcommand{\package}{lsp}
\newcommand{\packagename}{LSP}
\newcommand{\fullpackagename}{\libraryname\_\packagename}

\begin{document}

\galheader

%%%%%%%%%%%%%%%%%%%%%% SUMMARY %%%%%%%%%%%%%%%%%%%%%%%%

\galsummary
This package reorders to a standard form the variables and constraints
for the {\bf linearly-constrained linear least-squares problem}
\eqn{qp}{\mbox{minimize}\;\; \half \| \bmA_o \bmx - \bmb \|^2}
subject to the general linear constraints
\disp{c_{i}^{l}  \leq  \bma_{i}^{T}\bmx  \leq  c_{i}^{u}, \;\;\;
 i = 1, \ldots , m,}
and the simple bound constraints
\disp{x_{j}^{l}  \leq  x_{j}^{ } \leq  x_{j}^{u} , \;\;\; j = 1, \ldots , n,}
where the $o$ by $n$ matrix $\bmA_o$, and the 
vectors $\bmb$, $\bma_{i}$, $\bmc^{l}$, $\bmc^{u}$, $\bmx^{l}$, 
$\bmx^{u}$ are given.
Full advantage is taken of any zero coefficients in the matrix $\bmA_o$ or the
vectors $\bma_{i}$. 
Any of the constraint bounds $c_{i}^{l}$, $c_{i}^{u}$, 
$x_{j}^{l}$ and $x_{j}^{u}$ may be infinite.

The variables are rordered so that any
free variables (ie, those without bounds) occur first, followed
respectively by 
non-negativities (i.e., those for which the only
bounds are that $x_j \geq 0$),
lower-bounded variables (i.e., those for which the only
bounds are that $x_j \geq x_j^l \neq 0$),
range-bounded variables (i.e., those for which the 
bounds satisfy $- \infty < x_j^l < x_j^u < \infty$)
upper-bounded variables (i.e., those for which the only
bounds are that $x_j \leq x_j^u \neq 0$), and finally
non-positivities (i.e., those for which the only
bounds are that $x_j \leq 0$).
Fixed variables will be removed. 

The constraints are reordered so that equality constraints (i.e., those
for which $c_i^l = c_i^u$) occur first, followed 
respectively by those 
which are lower-bounded (i.e., those for which the only
bounds are that $\bma_i^T \bmx \geq c_i^l$),
those which have ranges (i.e., those for which the 
bounds satisfy 
$- \infty < c_j^l < c_j^u < \infty$), 
and finally those which are upper-bounded (i.e., those for which the only
bounds are that $\bma_i^T \bmx \leq c_i^u$).
Free constraints, that is those for which 
$c_i^l = - \infty$ and $c_i^u = \infty$, are removed.

Procedures are provided to detetmine the required ordering, to
reorder the problem to standard form, and
to recover the problem, or perhaps just the values of
the original variables, once it has been converted to standard form.

The derived type is also capable of supporting {\em parametric}
problems, in which an additional objective
term $\theta \delta \bmb$ is added to $\bmb$, and the trajectory of 
solution are required for all $0 \leq \theta \leq \theta_{\max}$ 
for which
\disp{
c_{i}^{l}  + \theta \delta c_{i}^{l}
\leq  \bma_{i}^{T}\bmx  \leq  c_{i}^{u} + \theta \delta c_{i}^{u}, \;\;\;
 i = 1, \ldots , m,}
and 
\disp{x_{j}^{l} + \theta x_{j}^{l} \leq x_{j}^{ } \leq 
x_{j}^{u} + \delta x_{j}^{u} , \;\;\; j = 1, \ldots , n.}

It is anticipated that this module will principally be used as a pre- and 
post-processing tool for other \galahad\ packages.

%%%%%%%%%%%%%%%%%%%%%% attributes %%%%%%%%%%%%%%%%%%%%%%%%

\galattributes
\galversions{\tt  \fullpackagename\_single, \fullpackagename\_double}.
\galuses
{\tt GALAHAD\_SY\-M\-BOLS}, 
{\tt GALAHAD\_SMT}, 
{\tt GALAHAD\_QPT},
{\tt GALAHAD\_SORT}.
\galdate August 2022.
\galorigin N. I. M. Gould, Rutherford Appleton Laboratory.
\gallanguage Fortran~95 + TR 15581 or Fortran~2003. 
The package is thread-safe.

%%%%%%%%%%%%%%%%%%%%%% HOW TO USE %%%%%%%%%%%%%%%%%%%%%%%%

\galhowto

The package is available using both single and double precision reals, 
and either 32-bit or 64-bit integers. Access to the 32-bit integer,
single precision version requires the {\tt USE} statement
\medskip

\hspace{8mm} {\tt USE \fullpackagename\_single}

\medskip
\noindent
with the obvious substitution {\tt \fullpackagename\_double},
{\tt \fullpackagename\_single\_64} and 
{\tt \fullpackagename\_double\_64} for the other variants.

\noindent
If it is required to use more than one of the modules at the same time, 
the derived types
{\tt SMT\_TYPE},
{\tt QPT\_problem\_type},
{\tt QPT\_dimensions\_type}, 
{\tt \packagename\_control\_type}, 
\sloppy
{\tt \packagename\_inform\_type} 
and
{\tt \packagename\_map\_type}
(Section~\ref{galtypes})
and the subroutines
{\tt \packagename\_initialize}, 
{\tt \packagename\_reorder},
{\tt \packagename\_apply}, 
{\tt \packagename\_get\_values}, 
{\tt \packagename\_restore}
and
{\tt \packagename\_terminate} 
(Section~\ref{galarguments})
must be renamed on one of the {\tt USE} statements.

%%%%%%%%%%%%%%%%%%%%%% matrix formats %%%%%%%%%%%%%%%%%%%%%%%%

\galmatrix

Both the objective Jacobian $\bmA_o$ and
the constraint Jacobian $\bmA$, the matrix 
whose rows are the vectors $\bma_{i}^{T}$, $i = 1, \ldots , m$, 
may be stored in a variety of input formats. Here we refer to $\bmA$, but
identical formats apply to $\bmA_o$ (with the index $o$ replacing $m$ as
necessary).

\subsubsection{Dense row-wise storage format}\label{dense}
The matrix $\bmA$ is stored as a compact 
dense matrix by rows, that is, the values of the entries of each row in turn are
stored in order within an appropriate real one-dimensional array.
Component $n \ast (i-1) + j$ of the storage array {\tt A\%val} will hold the 
value $a_{ij}$ for $i = 1, \ldots , m$, $j = 1, \ldots , n$.

\subsubsection{Dense row-wise storage format}\label{densecolwise}
The matrix $\bmA$ is stored as a compact 
dense matrix by columns, that is, the values of the entries of each column 
in turn are stored in order within an appropriate real one-dimensional array.
Component $m \ast (j-1) + i$ of the storage array {\tt A\%val} will hold the 
value $a_{ij}$ for $i = 1, \ldots , m$, $j = 1, \ldots , n$.

\subsubsection{Sparse co-ordinate storage format}\label{coordinate}
Only the nonzero entries of the matrices are stored. For the 
$l$-th entry of $\bmA$, its row index $i$, column index $j$ 
and value $a_{ij}$
are stored in the $l$-th components of the integer arrays {\tt A\%row}, 
{\tt A\%col} and real array {\tt A\%val}, respectively.
The order is unimportant, but the total
number of entries {\tt A\%ne} is also required. 

\subsubsection{Sparse row-wise storage format}\label{rowwise}
Again only the nonzero entries are stored, but this time
they are ordered so that those in row $i$ appear directly before those
in row $i+1$. For the $i$-th row of $\bmA$, the $i$-th component of a 
integer array {\tt A\%ptr} holds the position of the first entry in this row,
while {\tt A\%ptr} $(m+1)$ holds the total number of entries plus one.
The column indices $j$ and values $a_{ij}$ of the entries in the $i$-th row 
are stored in components 
$l =$ {\tt A\%ptr}$(i)$, \ldots ,{\tt A\%ptr} $(i+1)-1$ of the 
integer array {\tt A\%col}, and real array {\tt A\%val}, respectively. 

\subsubsection{Sparse column-wise storage format}\label{colwise}
Here only the nonzero entries are stored, but by contrast
they are ordered so that those in column $j$ appear directly before those
in column $j+1$. For the $j$-th column of $\bmA$, the $j$-th component of a 
integer array {\tt A\%ptr} holds the position of the first entry in this column,
while {\tt A\%ptr} $(n+1)$ holds the total number of entries plus one.
The row indices $i$ and values $a_{ij}$ of the entries in the $j$-th column
are stored in components 
$l =$ {\tt A\%ptr}$(j)$, \ldots ,{\tt A\%ptr} $(j+1)-1$ of the 
integer array {\tt A\%row}, and real array {\tt A\%val}, respectively. 

For sparse matrices, the later two schemes almost always requires less storage 
than its co-ordinate one.

%%%%%%%%%%%%%%%%%%%%%%%%%%% kinds %%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{kinds}

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\galtypes
Six derived data types are accessible from the package.

%%%%%%%%%%% matrix data type %%%%%%%%%%%

\subsubsection{The derived data type for holding matrices}\label{typesmt}
The derived data type {\tt SMT\_TYPE} is used to hold the matrices $\bmA_o$
and $\bmA$. The components of {\tt SMT\_TYPE} used here for $\bmA$
are:

\begin{description}

\ittf{m} is a scalar component of type \integer, 
that holds the number of rows in the matrix. 
 
\ittf{n} is a scalar component of type \integer, 
that holds the number of columns in the matrix. 
 
\ittf{ne} is a scalar variable of type \integer, that either 
holds the number of matrix entries or is used to flag the storage scheme
used. 

\ittf{type} is a rank-one allocatable array of type default \character, that
is used to indicate the matrix storage scheme used. Its precise length and
content depends on the type of matrix to be stored (see \S\ref{typeqp}).

\ittf{val} is a rank-one allocatable array of type \realdp\, 
and dimension at least {\tt ne}, that holds the values of the entries. 
Any duplicated entries that appear in the sparse 
co-ordinate, row-wise or column-wise schemes will be summed. 

\ittf{row} is a rank-one allocatable array of type \integer, 
and dimension at least {\tt ne}, that may hold the row indices of the entries. 
(see \S\ref{coordinate} and \ref{colwise}).

\ittf{col} is a rank-one allocatable array of type \integer, 
and dimension at least {\tt ne}, that may the column indices of the entries
(see \S\ref{coordinate} and \ref{rowwise}).

\ittf{ptr} is a rank-one allocatable array of type \integer, 
and dimension at least {\tt m + 1}, that may hold the pointers to
the first entry in each row in a row-wise scheme (see \S\ref{rowwise}). 
For a column-wise scheme (see \S\ref{colwise}) it must be of 
dimension at least {\tt m + 1}, that may hold the pointers to
the first entry in each column.

\end{description}
For the matrix $\bmA_o$, {\tt m} will hold the row dimension $o$, and
{\tt ptr} will be of length $o+1$ in a row-wise storage scheme.


%%%%%%%%%%% problem type %%%%%%%%%%%

\subsubsection{The derived data type for holding linearly-constrained linear least-squares problems}
\label{typeqp}

The derived data type 
{\tt QPT\_problem\_type}
is used to hold the data that defines the problem.
The components of 
{\tt QPT\_problem\_type} used here are:

\begin{description}

\ittf{n} is a scalar variable of type \integer, 
 that holds the number of optimization variables, $n$.  
              
\ittf{o} is a scalar variable of type \integer, 
 that holds the number of observations (and rows of $\bmA_o$), $o$.
              
\ittf{m} is a scalar variable of type \integer, 
 that holds the number of general linear constraints, $m$.
              
\ittf{Ao} is scalar variable of type {\tt SMT\_TYPE} 
that holds the Jacobian matrix $\bmA_o$. The following components are used:

\begin{description}

\itt{Ao\%type} is an allocatable array of rank one and type default \character, 
that is used to indicate the storage scheme used. If the dense row-wise 
storage scheme (see Section~\ref{dense}) is used, 
the first five components of {\tt Ao\%type} must contain the
string {\tt DENSE} or the first thirteen components must contain the
string {\tt DENSE\_BY\_ROWS}.

By contrast, if the dense column-wise storage scheme 
(see Section~\ref{densecolwise}) is used, 
the first sixteen components of {\tt Ao\%type} must contain the
the string {\tt DENSE\_BY\_COLUMNS}.
For the sparse co-ordinate scheme (see Section~\ref{coordinate}), 
the first ten components of {\tt Ao\%type} must contain the
string {\tt COORDINATE}, while 
for the sparse row-wise storage scheme (see Section~\ref{rowwise}),
the first fourteen components of {\tt Ao\%type} must contain the
string {\tt SPARSE\_BY\_ROWS},
and for the sparse column-wise storage scheme (see Section~\ref{colwise}),
the first seventeen components of {\tt Ao\%type} must contain the
string {\tt SPARSE\_BY\_COLUMNS}.
Just as for {\tt H\%type} above, the procedure {\tt SMT\_put} 
may be used to allocate sufficient space and insert the required keyword
into {\tt Ao\%type}.
If {\tt prob} is of derived type {\tt \packagename\_problem\_type}
and involves a Jacobian $\bmA_o$ we wish to store using the sparse column-wise 
storage scheme, we may simply
%\vspace*{-2mm}
{\tt 
\begin{verbatim}
        CALL SMT_put( prob%A%type, 'SPARSE_BY_COLUMNS' )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent

\itt{Ao\%ne} is a scalar variable of type \integer, that 
holds the number of entries in $\bmA_o$
in the sparse co-ordinate storage scheme (see Section~\ref{coordinate}). 
It need not be set for either of the other four schemes.

\itt{Ao\%val} is a rank-one allocatable array of type \realdp, that 
holds
the values of the entries of the Jacobian matrix $\bmA_o$ in any of the 
storage schemes discussed in Section~\ref{galmatrix}.

\itt{Ao\%row} is a rank-one allocatable array of type \integer,
that holds the row indices of $\bmA_o$ in the sparse co-ordinate 
or column-wise storage schemes (see \S\ref{coordinate} and \ref{colwise}).
It need not be allocated for the other three schemes.

\itt{Ao\%col} is a rank-one allocatable array variable of type \integer,
that holds the column indices of $\bmA_o$ in either the sparse co-ordinate 
(see Section~\ref{coordinate}), or the sparse row-wise 
(see \ref{rowwise}) storage scheme.
It need not be allocated for the other three schemes.

\itt{Ao\%ptr} is a rank-one allocatable array of dimension {\tt o+1} and type 
\integer, that holds the 
starting position of each row of $\bmA_o$, as well
as the total number of entries plus one, in the sparse row-wise storage
scheme (see Section~\ref{rowwise}). By contrast, if the spares column-wise 
scheme is used, it should be of length {\tt n+1}, and hold
starting position of each column of $\bmA_o$, as well
as the total number of entries plus one.
\end{description}

\ittf{B} is a rank-one allocatable array type \realdp, that 
should be allocated to have length {\tt o}, and its $j$-th component 
filled with the value $b_{i}$ for $i = 1, \ldots , o$, 

\ittf{DB} is a rank-one allocatable array of dimension {\tt o} and type 
\realdp, that may hold the perturbation $\delta \bmb$ 
of the observation vector $\bmb$.
The $j$-th component of 
{\tt DB}, $i = 1,  \ldots ,  o$, contains $\delta b_{i}$.

\ittf{A} is scalar variable of type {\tt SMT\_TYPE} that holds the constraint 
Jacobian matrix $\bmA$. The following components are used:

\begin{description}

\itt{A\%type} is an allocatable array of rank one and type default \character, 
that is used to indicate the storage scheme used. If the dense row-wise 
storage scheme (see Section~\ref{dense}) is used, 
the first five components of {\tt A\%type} must contain the
string {\tt DENSE} or the first thirteen components must contain the
string {\tt DENSE\_BY\_ROWS}.
By contrast, if the dense column-wise storage scheme 
(see Section~\ref{densecolwise}) is used, 
the first sixteen components of {\tt A\%type} must contain the
the string {\tt DENSE\_BY\_COLUMNS}.
For the sparse co-ordinate scheme (see Section~\ref{coordinate}), 
the first ten components of {\tt A\%type} must contain the
string {\tt COORDINATE}, while 
for the sparse row-wise storage scheme (see Section~\ref{rowwise}),
the first fourteen components of {\tt A\%type} must contain the
string {\tt SPARSE\_BY\_ROWS},
and for the sparse column-wise storage scheme (see Section~\ref{colwise}),
the first seventeen components of {\tt A\%type} must contain the
string {\tt SPARSE\_BY\_COLUMNS}.
The procedure {\tt SMT\_put} may be used to allocate sufficient space and 
insert the required keyword into {\tt A\%type}.
Once again, if {\tt prob} is of derived type {\tt \packagename\_problem\_type}
and involves a Jacobian $\bmA$ we wish to store using the sparse row-wise 
storage scheme, we may simply
%\vspace*{-2mm}
{\tt 
\begin{verbatim}
        CALL SMT_put( prob%L%type, 'SPARSE_BY_ROWS' )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent

\itt{A\%ne} is a scalar variable of type \integer, that 
holds the number of entries in $\bmA$
in the sparse co-ordinate storage scheme (see Section~\ref{coordinate}). 
It need not be set for either of the other four schemes.

\itt{A\%val} is a rank-one allocatable array of type \realdp, that holds
the values of the entries of the Jacobian matrix $\bmA$ in any of the 
storage schemes discussed in Section~\ref{galmatrix}.

\itt{A\%row} is a rank-one allocatable array of type \integer,
that holds the row indices of $\bmA$ in the sparse co-ordinate 
or column-wise storage schemes (see \S\ref{coordinate} and \ref{colwise}).
It need not be allocated for the other three schemes.

\itt{A\%col} is a rank-one allocatable array variable of type \integer,
that holds the column indices of $\bmA$ in either the sparse co-ordinate 
(see Section~\ref{coordinate}), or the sparse row-wise 
(see \ref{rowwise}) storage scheme.
It need not be allocated for the other three schemes.

\itt{A\%ptr} is a rank-one allocatable array of dimension {\tt m+1} and type 
\integer, that holds the 
starting position of each row of $\bmA$, as well
as the total number of entries plus one, in the sparse row-wise storage
scheme (see Section~\ref{rowwise}). By contrast, if the spares column-wise 
scheme is used, it should be of length {\tt n+1}, and hold
starting position of each column of $\bmA$, as well
as the total number of entries plus one.
\end{description}

\ittf{C\_l} is a rank-one allocatable array of dimension {\tt m} and type 
\realdp, that holds the vector of lower bounds $\bmc^{l}$ 
on the general constraints. The $i$-th component of 
{\tt C\_l}, $i = 1, \ldots , m$, contains $c_{i}^{l}$.
Infinite bounds are allowed by setting the corresponding 
components of {\tt C\_l} to any value smaller than {\tt -infinity}, 
where {\tt infinity} is a  solver-dependent value that will be recognised as
infinity.

\ittf{C\_u} is a rank-one allocatable array of dimension {\tt m} and type 
\realdp, that holds the vector of upper bounds $\bmc^{u}$ 
on the general constraints. The $i$-th component of 
{\tt C\_u}, $i = 1,  \ldots ,  m$, contains $c_{i}^{u}$.
Infinite bounds are allowed by setting the corresponding 
components of {\tt C\_u} to any value larger than {\tt infinity}, 
where {\tt infinity} is a  solver-dependent value that will be recognised as
infinity.

\ittf{DC\_l} is a rank-one allocatable array of dimension {\tt m} and type 
\realdp, that may hold the vector of parametric lower bounds 
$\delta \bmc^{l}$ on the general constraints. The $i$-th component of 
{\tt DC\_l}, $i = 1, \ldots , m$, contains $\delta c_{i}^{l}$.
Only components corresponding to finite lower bounds $c_{i}^{l}$
need be set.

\ittf{DC\_u} is a rank-one allocatable array of dimension {\tt m} and type 
\realdp, that may hold the vector of parametric upper bounds 
$\delta \bmc^{u}$  on the general constraints. The $i$-th component of 
{\tt DC\_u}, $i = 1,  \ldots ,  m$, contains $\delta c_{i}^{u}$.
Only components corresponding to finite upper bounds $c_{i}^{u}$
need be set.

\ittf{X\_l} is a rank-one allocatable array of dimension {\tt n} and type 
\realdp, that holds
the vector of lower bounds $\bmx^{l}$ on the variables.
The $j$-th component of {\tt X\_l}, $j = 1, \ldots , n$, 
contains $x_{j}^{l}$.
Infinite bounds are allowed by setting the corresponding 
components of {\tt X\_l} to any value smaller than {\tt -infinity}, 
where {\tt infinity} is a  solver-dependent value that will be recognised as
infinity.

\ittf{X\_u} is a rank-one allocatable array of dimension {\tt n} and type 
\realdp, that holds
the vector of upper bounds $\bmx^{u}$ on the variables.
The $j$-th component of {\tt X\_u}, $j = 1, \ldots , n$, 
contains $x_{j}^{u}$.
Infinite bounds are allowed by setting the corresponding 
components of {\tt X\_u} to any value larger than that {\tt infinity}, 
where {\tt infinity} is a  solver-dependent value that will be recognised as
infinity.

\ittf{DX\_l} is a rank-one allocatable array of dimension {\tt n} and type 
\realdp, that may hold the vector of parametric lower bounds 
$\delta \bmx^{l}$ on the variables. The $j$-th component of 
{\tt DX\_l}, $j = 1, \ldots , n$, contains $\delta x_{j}^{l}$.
Only components corresponding to finite lower bounds $x_{j}^{l}$
need be set.

\ittf{DX\_u} is a rank-one allocatable array of dimension {\tt n} and type 
\realdp, that may hold the vector of parametric upper bounds 
$\delta \bmx^{u}$  on the variables. The $j$-th component of 
{\tt DX\_u}, $j = 1,  \ldots ,  n$, contains $\delta x_{j}^{u}$.
Only components corresponding to finite upper bounds $x_{j}^{u}$
need be set.

\ittf{X} is a rank-one allocatable array of dimension {\tt n} and type 
\realdp, 
that holds the values $\bmx$ of the optimization variables.
The $j$-th component of {\tt X}, $j = 1,  \ldots , n$, contains $x_{j}$.  

\ittf{Z} is a rank-one allocatable array of dimension {\tt n} and type default 
\realdp, that holds
the values $\bmz$ of estimates  of the dual variables 
corresponding to the simple bound constraints (see Section~\ref{galmethod}).
The $j$-th component of {\tt Z}, $j = 1,  \ldots ,  n$, contains $z_{j}$.  

\ittf{Z\_l} is a rank-one allocatable array of dimension {\tt n} and type default 
\realdp, that holds
the values $\bmz^{l}$ of estimates  of the dual variables 
corresponding to the lower simple bound constraints $\bmx^{l} \leq \bmx$
(see Section~\ref{galmethod}).
The $j$-th component of {\tt Z\_l}, $j = 1,  \ldots ,  n$, 
contains $z_{j}^{l}$.  

\ittf{Z\_u} is a rank-one allocatable array of dimension {\tt n} and type default 
\realdp, that holds
the values $\bmz^{u}$ of estimates  of the dual variables 
corresponding to the upper simple bound constraints $\bmx \leq \bmx^{u}$
(see Section~\ref{galmethod}).
The $j$-th component of {\tt Z\_l}, $j = 1,  \ldots ,  n$, 
contains $z_{j}^{l}$.  

\ittf{C} is a rank-one allocatable array of dimension {\tt m} and type default 
\realdp, that holds
the values $\bmA \bmx$ of the constraints.
The $i$-th component of {\tt C}, $i = 1,  \ldots ,  m$, contains 
$\bmA_{i}^{T}\bmx \equiv (\bmA \bmx)_{i}$.  

\ittf{Y} is a rank-one allocatable array of dimension {\tt m} and type 
\realdp, that holds
the values $\bmy$ of estimates  of the Lagrange multipliers
corresponding to the general linear constraints (see Section~\ref{galmethod}).
The $i$-th component of {\tt Y}, $i = 1,  \ldots ,  m$, contains $y_{i}$.  

\ittf{Y\_l} is a rank-one allocatable array of dimension {\tt m} and 
type \realdp, that holds
the values $\bmy^{l}$ of estimates  of the Lagrange multipliers
corresponding to the lower general constraints $\bmc^{l} \leq \bmA \bmx$
(see Section~\ref{galmethod}).
The $i$-th component of {\tt Y\_l}, $i = 1,  \ldots ,  m$, 
contains $y_{i}^{l}$.  

\ittf{Y\_u} is a rank-one allocatable array of dimension {\tt m} and 
type \realdp, that holds
the values $\bmy^{u}$ of estimates  of the Lagrange multipliers
corresponding to the upper general constraints $\bmA \bmx \leq \bmc^{u}$
(see Section~\ref{galmethod}).
The $i$-th component of {\tt Y\_u}, $i = 1,  \ldots ,  m$, 
contains $y_{i}^{u}$.  

\end{description}


%%%%%%%%%%% problem type %%%%%%%%%%%

\subsubsection{The derived data type for holding the problem dimensions}
\label{typeprob}
The derived data type 
{\tt QPT\_dimensions\_type} 
is used to hold scalar data that defines the problem partitioning for the
reordered problem. 
The components of 
{\tt QPT\_dimensions\_type} 
are:

\begin{description}
\itt{x\_free} is a scalar variable of type \integer, that holds the 
number of free variables. 
    
\itt{x\_l\_start} is a scalar variable of type \integer, that holds the 
index of the first variable with a nonzero lower (or lower range) bound. 
    
\itt{x\_l\_end} is a scalar variable of type \integer, that holds the 
index of the last variable with a nonzero lower (or lower range) bound. 
    
\itt{x\_u\_start} is a scalar variable of type \integer, that holds the 
index of the first variable with a nonzero upper (or upper range) bound. 
    
\itt{x\_u\_end} is a scalar variable of type \integer, that holds the 
index of the last variable with a nonzero upper (or upper range) bound. 
    
\itt{c\_equality} is a scalar variable of type \integer, that holds the 
number of equality constraints. 
    
\itt{c\_l\_start} is a scalar variable of type \integer, that holds the 
index of the first inequality constraint with a lower (or lower range) bound. 
    
\itt{c\_l\_end} is a scalar variable of type \integer, that holds the 
index of the last inequality constraint with a lower (or lower range) bound. 
    
\itt{c\_u\_start} is a scalar variable of type \integer, that holds the 
index of the first inequality constraint with an upper (or upper range) bound. 
    
\itt{c\_u\_end} is a scalar variable of type \integer, that holds the 
index of the last inequality constraint with an upper (or upper range) bound. 
 
\end{description}

%%%%%%%%%%% control type %%%%%%%%%%%

\subsubsection{The derived data type for holding control 
 parameters}\label{typecontrol}
The derived data type 
{\tt \packagename\_control\_type} 
is used to hold controlling data. Default values may be obtained by calling 
{\tt \packagename\_initialize}
(see Section~\ref{subinit}). The components of 
{\tt \packagename\_control\_type} 
are:

\begin{description}

\itt{error} is a scalar variable of type \integer, that holds the
stream number for error messages. Printing of error messages in 
{\tt \packagename\_reorder} and {\tt \packagename\_terminate} 
is suppressed if {\tt error} $\leq 0$.
The default is {\tt error = 6}.

\itt{infinity} is a scalar variable of type \realdp, that is used to
specify which constraint bounds are infinite.
Any bound larger than {\tt infinity} in modulus will be regarded as infinite.
The default is {\tt infinity =} $10^{19}$.

\itt{treat\_zero\_bounds\_as\_general} is a scalar variable of type 
default \logical.
If it is set to \false, variables which 
are only bounded on one side, and whose bound is zero,
will be recognised as non-negativities/non-positivities rather than simply as
lower- or upper-bounded variables.
If it is set to \true, any variable bound 
$x_{j}^{l}$ or $x_{j}^{u}$ which has the value 0.0 will be
treated as if it had a general value.
Setting {\tt treat\_zero\_bounds\_as\_general} to \true\ has the advantage
that if a sequence of problems are reordered, then bounds which are
``accidentally'' zero will be considered to have the same structure as
those which are nonzero. However, {\tt \fullpackagename} is
able to take special advantage of non-negativities/non-positivities, so
if a single problem, or if a sequence of problems whose 
bound structure is known not to change, is/are to be solved, 
it will pay to set the variable to \false.
The default is {\tt treat\_zero\_bounds\_as\_general = .FALSE.}.

\end{description}

%%%%%%%%%%% info type %%%%%%%%%%%

\subsubsection{The derived data type for holding informational
 parameters}\label{typeinform}
The derived data type 
{\tt \packagename\_inform\_type} 
is used to hold parameters that give information about the progress and needs 
of the algorithm. The components of 
{\tt \packagename\_inform\_type} 
are:

\begin{description}

\itt{status} is a scalar variable of type \integer, that gives the
exit status of the algorithm. See Sections~\ref{galerrors} and \ref{galinfo}
for details.

\itt{alloc\_status} is a scalar variable of type \integer, that gives
the status of the last attempted array allocation or deallocation.

\end{description}

%%%%%%%%%%% map type %%%%%%%%%%%

\subsubsection{The derived data type for holding reordering data}\label{typemap}
The derived data type 
{\tt \packagename\_map\_type} 
is used to hold all the reordering and workspace data for a particular 
problem, or sequences of problems with the same structure, between calls of 
{\tt \packagename} procedures. 
This data should be preserved, untouched, from the initial call to 
{\tt \packagename\_initialize}
to the final call to
{\tt \packagename\_terminate}.

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\galarguments
There are six procedures for user calls:

\begin{enumerate}
\item The subroutine 
  {\tt \packagename\_initialize} 
  is used to set default 
  values, and initialize private data, before reordered one or more problems 
  with the same sparsity and bound structure. 
  Here, the term "structure" refers both to 
  the sparsity patterns of the Jacobian matrices $\bmA_o$  and $\bmA$ 
  involved 
  (but not their numerical values), to the zero/nonzero/infinity patterns 
  (a bound is either zero, $\pm$ infinity, or a finite but arbitrary 
  nonzero) of each of the constraint bounds, and to the variables and 
  constraints that are fixed (both bounds are the same) or free 
  (the lower and upper bounds are $\pm$ infinity, respectively). 
 
\item The subroutine 
  {\tt \packagename\_reorder} 
  is called to reorder a problem, or the first of a sequence of structurally 
  identical problems. 
 
\item The subroutine 
  {\tt \packagename\_apply} 
  may be called to reorder real data for subsequent structurally identical 
  problems. 
 
\item The subroutine 
  {\tt \packagename\_get\_values} 
  may be used to obtain the values of the original primal and dual variables 
  and Lagrange multipliers from those for the reordered problem. 
 
\item The subroutine {\tt \packagename\_restore} may be used to recover the 
  original problem from the data for the reordered one. 
 
\item The subroutine 
  {\tt \packagename\_terminate} 
  is provided to allow the user to automatically deallocate array components 
  of the private data,  allocated by 
  {\tt \packagename\_reorder}, 
  at the end of the reordering process. It is important to do this if the data 
  object is re-used for another problem {\bf with a different structure} 
  since {\tt \packagename\_initialize} cannot test for this situation, 
  and any existing associated targets will subsequently become unreachable. 
\end{enumerate}
We use square brackets {\tt [ ]} to indicate \optional\ arguments.

%%%%%% initialization subroutine %%%%%%

\subsubsection{The initialization subroutine}\label{subinit}
 Default values are provided as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_initialize( map, control )}

\vspace*{-2mm}
\begin{description}

\itt{map} is a scalar \intentout\ argument of type 
{\tt \packagename\_map\_type} (see Section~\ref{typemap}). 
It is used to hold all the reordering and workspace data for the problem. 

\itt{control} is a scalar \intentout\ argument of type 
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}). 
On exit, {\tt control} contains default values for the components as
described in Section~\ref{typecontrol}.
These values should only be changed after calling 
{\tt \packagename\_initialize}.

\end{description}

%%%%%%%%% initial reordering subroutine %%%%%%

\subsubsection{The initial reordering subroutine}
The initial reordering algorithm is applied as follows: 
\vspace*{-2mm}
{\tt 
\begin{verbatim}
        CALL LSP_reorder( map, control, info, dims, prob, &
                          get_x, get_y, get_z [, parametric ] )
\end{verbatim}
}
\vspace*{-4mm}
\begin{description}
\ittf{map} is a scalar \intentinout\ argument of type 
{\tt \packagename\_map\_type}. 
It is used to hold reordering and workspace data for the problem. 
It must not have been altered {\bf by the user} since the last call
to {\tt \packagename\_initialize}. 
 
\itt{control} is a scalar \intentin\ argument of type 
{\tt \packagename\_control\_type} 
(see Section~\ref{typecontrol}). 
Default values may be assigned by calling 
{\tt \packagename\_initialize} 
prior to the first call to {\tt \packagename\_reorder}. 
 
\itt{info} is a scalar \intentout\ argument of type 
{\tt \packagename\_inform\_type} 
(see Section~\ref{typeinform}). 
A successful call to {\tt \packagename\_reor\-der} is indicated 
when the component {\tt status} has the value 0. For other return values 
of {\tt status}, see Section~\ref{galerrors}. 
 
\itt{dims} is a scalar \intentout\ argument of type 
{\tt QPT\_dimensions\_type} that 
is used to hold scalar data that defines the reordered problem. 
On successful exit, all components will have been set to values 
that define the reordered problem (see Section~\ref{typeprob}). 
 
\itt{prob} is a scalar \intentinout\ argument of type 
{\tt QPT\_problem\_type} that 
is used to hold data that defines the original and reordered problem. 
On entry, components {\tt f}, {\tt gradient\_kind}, {\tt G},
{\tt A}, {\tt C\_l}, {\tt C\_u}, {\tt X\_l} and {\tt X\_u} 
must be appropriately allocated and set (see Section~\ref{typeqp}).
The same is true of component {\tt H} in the quadratic programming case
and components {\tt Hessian\_kind}, {\tt target\_kind}, 
{\tt WEIGHT} and {\tt X0} in the least-distance case. 
In addition, for parametric problems
{\tt DG}, {\tt DC\_l}, {\tt DC\_u}, {\tt DX\_l} and {\tt DX\_u}
must be allocated appropriately and set.
If the user wishes to provide suitable starting values for $\bmx$, $\bmy$ 
(or alternatively $\bmy^l$ and $\bmy^u$) and
$\bmz$ (or alternatively $\bmz^l$ and $\bmz^u$), 
they should be placed in {\tt X}, {\tt Y} (or {\tt Y\_l} and {\tt Y\_u})
and {\tt Z} (or {\tt Z\_l} and {\tt Z\_u}) respectively,
and the arguments {\tt get\_x}, {\tt get\_y} and {\tt get\_z}
set appropriately (see below). 

%Regardless of the storage schemes used to store $g$, $\bmA_o$ and $\bmH$, the
%components {\tt G}, {\tt H\%col}, {\tt H\%ptr}, {\tt Ao\%col} and {\tt Ao\%ptr}
%must be either explicitly disassociated (using a {\tt NULLIFY} statement) 
%or allocated.

On successful exit, all provided components will have been set to values 
that define the reordered problem (see Section 2.2.1). The reordered 
arrays $\bmA_o$ and $\bmA$ will be stored using the sparse column-wise and 
row-wise schemes, respectively. In addition the components
{\tt X}, {\tt Y}, {\tt Z} and {\tt C} will contain values of 
$\bmx$, $\bmy$, $\bmz$ and $\bmA \bmx$ for the reordered problem. 
The user should be aware that fixed variables and free constraints will have 
been removed, and thus that the components {\tt prob\%n} and {\tt prob\%m} 
may be smaller than their values on entry. 

\itt{get\_x} is a scalar \intentin\ argument of type default \logical, that 
must be set \false\ if the user wishes to provide suitable values for the 
primal variables in {\tt X}, and \true, if appropriate values should be 
calculated by the subroutine. 
 
\itt{get\_y} is a scalar \intentin\ argument of type default \logical, that 
must be set \false\ if the user wishes to provide suitable values for the 
Lagrange multiplies for the general linear constraints in {\tt Y}
(or alternatively in {\tt Y\_l} and {\tt Y\_u}), 
and \true, if appropriate values should be calculated by the subroutine. 
In the latter case, the array {\tt Y} (or the arrays {\tt Y\_l} and {\tt Y\_u})
must have been allocated.
 
\itt{get\_z} is a scalar \intentin\ argument of type default \logical, that 
must be set \false\ if the user wishes to provide suitable values for the 
dual variables for the simple bound constraints in {\tt Z}
(or alternatively in {\tt Z\_l} and {\tt Z\_u}), and \true, 
if appropriate values should be calculated by the subroutine. 
In the latter case, the array {\tt Z} (or the arrays {\tt Z\_l} and {\tt Z\_u})
must have been allocated.

\itt{parametric} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {parametric} is present, the problem will be assumed to include
parametric data $\delta \bmg$, $\delta \bmx_l$, $\delta \bmx_u$, 
$\delta \bmx_l$ and $\delta \bmx_u$ as part of {\tt prob},
and this data will be reordered. If 
If {parametric} is absent, no parametric data will be processed.
 
\end{description}

%%%%%%% subsequent reordering subroutine %%%%%%

\subsubsection{The subsequent reordering subroutine}
The reordering calculated by a previous call to {\tt \packagename\_reorder} 
may be applied to a structurally identical problem with different real data 
as follows:

\vspace*{-2mm}
{\tt 
\begin{verbatim}
     CALL LSP_apply( map, info, dims, prob [, get_all, get_all_parametric, &
                     get_g, get_dg, get_x, get_y, get_z,                   &
                     get_x_bounds, get_dx_bounds, get_c, get_c_bounds,     &
                     get_dc_bounds, get_Ao, get_A ] )
\end{verbatim}
}
\vspace*{-1mm}
\noindent
The arguments {\tt map}, and {\tt info} are exactly as for 
{\tt \packagename\_reorder}. The values of the integers 
{\tt prob\%n}, {\tt prob\%m}, {\tt prob\%o}, 
{\tt prob\%ao\%ne}, {\tt prob\%A\%ne},
integer arrays {\tt prob\%Ao\%row}, {\tt prob\%Ao\%ptr}, 
{\tt prob\%A\%col}, {\tt prob\%A\%ptr}, and the remaining (integer) 
components of {\tt dims} must 
have been preserved exactly as they were on exit from the most recent 
call to {\tt \packagename\_reorder} or {\tt \packagename\_restore}, 
and are not altered by the subroutine. 

New \realdp, values may be assigned to the arguments 
{\tt prob\%Ao\%val}, {\tt prob\%B}, {\tt prob\%A\%val}, {\tt prob\%C\_l}, 
{\tt prob\%C\_l}, {\tt prob\%X\_l}, {\tt prob\%X\_u}, {\tt prob\%X}, 
{\tt prob\%Y} 
(or alternatively {\tt prob\%Y\_l} and {\tt prob\%Y\_u}), 
and {\tt prob\%Z}
(or alternatively {\tt prob\%Z\_l} and {\tt prob\%Z\_u}), 
(and optionally 
{\tt prob\%DB}, {\tt prob\%DC}, {\tt prob\%DC\_l}, {\tt prob\%DC\_l}, 
{\tt prob\%DX\_l} and {\tt prob\%DX\_u} for parametric problems), 
but the components of these arrays 
must be in exactly the same order as originally presented to 
{\tt \packagename\_reorder}. 
The exit values of all of these real values depend on the following, 
remaining arguments: 

\begin{description}
\itt{get\_all} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_all} is present, the entire non-parametric problem 
input in {\tt prob} will be reordered according to the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
Any parametric data will be ignored.

\itt{get\_all\_parametric} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_all\_parametric} is present, the entire parametric problem 
input in {\tt prob} will be reordered according to the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
 
\itt{get\_f} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_f} is present, the constant objective term
$f$, input in {\tt prob\%f} 
will be adjusted for the the reordered problem according to the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
 
\itt{get\_g} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_g} is present, the gradient 
$\bmg$, input in {\tt prob\%G} 
will be adjusted for the the reordered problem according to the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
 
\itt{get\_dg} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_dg} is present, the parametric gradient $\delta \bmg$, input in 
{\tt prob\%DG}),
will be adjusted for the the reordered problem according to the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
 
\itt{get\_x} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_x} is present, the vector of primal variables $\bmx$, 
input in {\tt prob\%X}, will be 
adjusted for the the reordered problem according to the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
 
\itt{get\_y} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_y} is present, the 
Lagrange multipliers $\bmy$, input in {\tt prob\%Y}
(or alternatively in {\tt prob\%Y\_l} and {\tt prob\%Y\_u}), 
will be adjusted for the the reordered problem according to the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 

\itt{get\_z} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_z} is present, the vector of dual variables $\bmz$, input in 
{\tt prob\%Z} (or alternatively in {\tt prob\%Z\_l} and {\tt prob\%Z\_u}),
will be adjusted for the reordered problem according 
to the mappings generated by the last successful 
call to {\tt \packagename\_reorder}. 
 
\itt{get\_x\_bounds} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_x\_bounds} is present, 
the vectors of variable bounds $\bmx_l$ and 
$\bmx_u$, input in {\tt prob\%X\_l} and {\tt prob\%X\_u} respectively
will be reordered according to the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
 
\itt{get\_dx\_bounds} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_dx\_bounds} is present, 
the vectors of parametric variable bounds $\delta \bmx_l$ and 
$\delta \bmx_u$, input in {\tt prob\%DX\_l} and {\tt prob\%DX\_u} respectively,
will be reordered according to the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
 
\itt{get\_c} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_c} is present, the vector $\bmA \bmx$ for the reordered problem 
will be returned in {\tt prob\%C}. 
 
\itt{get\_c\_bounds} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_c\_bounds} is present, 
the vectors of constraint bounds $\bmc_l$ and 
$\bmc_u$, input in {\tt prob\%C\_l} and {\tt prob\%C\_u} respectively
will be reordered according to the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
 
\itt{get\_dc\_bounds} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_dc\_bounds} is present, 
the vectors of parametric constraint bounds $\delta \bmc_l$ and 
$\delta \bmc_u$, input in {\tt prob\%DC\_l} and {\tt prob\%DC\_u} respectively,
will be reordered according to the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
 
\itt{get\_A} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_A} is present, the entries of the 
matrix $\bmA_o$, input in {\tt prob\%Ao\%val}, will be reordered according 
to the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
 
\itt{get\_L} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_L} is present, the entries of the 
matrix $\bmA$, input in {\tt prob\%A\%val}, will be reordered according to the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
 
\end{description}

%%%%%%% variable recovery subroutine %%%%%%

\subsubsection{The  variable recovery reordering subroutine}
The values of minimization variables that have been determined for the 
reordered problem may be recovered for the original problem as follows: 
\vspace*{-2mm}
{\tt 
\begin{verbatim}
        CALL LSP_get_values( map, info, prob [, X_val, Y_val, Z_val ] )
\end{verbatim}
}
\vspace*{-1mm}
\noindent
The arguments {\tt map} and {\tt info} are exactly as for 
{\tt \packagename\_reorder}. 
The \intentin\ argument {\tt prob}
must contain reordered problem data from a previous call 
to {\tt LSP\_reorder} or {\tt LSP\_apply}.

\begin{description}
\itt{X\_val} is an \optional\ rank-one \intentout\ array argument of 
type \realdp. If 
present, it will be filled with the values of the primal variables $\bmx$ 
for the original problem, corresponding to those for the the reordered 
problem input in {\tt X}. 
 
\itt{Y\_val} is an \optional\ rank-one \intentout\ array argument of 
type \realdp. If present, 
it will be filled with the values of the Lagrange multipliers $\bmy$ 
for the original problem, corresponding to those for the the reordered 
problem input in {\tt Y} (or {\tt Y\_l + Y\_u}).
. 
 
\itt{Z\_val} is an \optional\ rank-one \intentout\ array argument of 
type \realdp. If 
present, it will be filled with the values of the primal variables $\bmz$ 
for the original problem, corresponding to those for the the reordered 
problem input in {\tt Z} (or {\tt Z\_l + Z\_u}).
\end{description}

%%%%%%%  problem restoration subroutine %%%%%%

\subsubsection{The  problem restoration subroutine}
The data for the original problem may be recovered from its reordered 
variant as follows:
\vspace*{-2mm}
{\tt 
\begin{verbatim}
     CALL LSP_restore( map, info, dims, prob [, get_all, get_all_parametric, &
                       get_g, get_dg, get_x, get_y, get_z,                   &
                       get_x_bounds, get_dx_bounds, get_c, get_c_bounds,     &
                       get_dc_bounds, get_Ao, get_A ] )
\end{verbatim}
}
\vspace*{-1mm}
\noindent
The arguments {\tt map}, {\tt info}, {\tt dims} and {\tt prob} are 
exactly as described as output from 
{\tt \packagename\_reorder} or {\tt \packagename\_apply},
and correspond to data for the reordered problem. 
They may be restored to data for the original problem by appropriate 
settings for the remaining arguments: 

\begin{description}
\itt{get\_all} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_all} is present, the entire non-parametric problem 
input in {\tt prob} and {\tt dims} will be restored using the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
Any parametric data will be ignored.

\itt{get\_all\_parametric} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_all\_parametric} is present, the entire parametric problem 
input in {\tt prob} and {\tt dims} will be recovered from the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
 
\itt{get\_g} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_g} is present, the gradient $\bmg$
will be recovered from  the reordered problem and placed in {\tt prob\%G} 
using the mappings generated by the last successful call to 
{\tt \packagename\_reorder}. 

will be recovered from  the reordered problem using the 
mappings generated by the last successful call to {\tt \packagename\_reorder}. 
 
\itt{get\_dg} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_dg} is present, the parametric gradient $\delta \bmg$
will be recovered from  the reordered problem and placed in {\tt prob\%DG} 
using the mappings generated by the last successful call to 
{\tt \packagename\_reorder}. 
 
\itt{get\_x} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_x} is present, the vector of primal variables $\bmx$
will be recovered from  the reordered problem and placed in {\tt prob\%X} 
using the mappings generated by the last successful call to 
{\tt \packagename\_reorder}. 
 
\itt{get\_y} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_y} is present and {\tt prob\%Y} is allocated, 
the Lagrange multipliers 
$\bmy$ will be recovered from  the reordered problem and placed in {\tt prob\%Y} 
using the mappings generated by the last successful call to 
{\tt \packagename\_reorder}. If {\tt prob\%Y\_l} and {\tt prob\%Y\_u} 
are allocated, the Lagrange multipliers 
$\bmy^l$ and $\bmy^u$ will be recovered from  the reordered problem and 
placed in {\tt prob\%Y\_l} and {\tt prob\%Y\_u} respectively.
 
\itt{get\_z} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_z} is present and {\tt prob\%Z} is allocated, 
the vector of dual variables $\bmz$
will be recovered from  the reordered problem and placed in {\tt prob\%Z} 
using the mappings generated by the last successful call to 
{\tt \packagename\_reorder}. If {\tt prob\%Z\_l} and {\tt prob\%Z\_u} 
are allocated, the dual variables
$\bmz^l$ and $\bmz^u$ will be recovered from  the reordered problem and 
placed in {\tt prob\%Z\_l} and {\tt prob\%Z\_u} respectively.
 
\itt{get\_x\_bounds} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_x\_bounds} is present, 
the vectors of variable bounds $\bmx_l$ and $\bmx_u$
will be recovered from  the reordered problem and placed in {\tt prob\%X\_l} 
and {\tt prob\%X\_u} using the mappings generated by the last successful 
call to {\tt \packagename\_reorder}. 
 
\itt{get\_dx\_bounds} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_dx\_bounds} is present, 
the vectors of parametric variable bounds $\delta \bmx_l$ and 
$\delta \bmx_u$
will be recovered from  the reordered problem and placed in {\tt prob\%DX\_l} 
and {\tt prob\%DX\_u} using the mappings generated by the last successful 
call to {\tt \packagename\_reorder}. 

\itt{get\_c} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_c} is present, the vector $\bmA \bmx$ 
will be recovered from  the reordered problem and placed in {\tt prob\%C} 
using the mappings generated by the last successful call to 
{\tt \packagename\_reorder}. 
 
\itt{get\_c\_bounds} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_c\_bounds} is present, 
the vectors of constraint bounds $\bmc_l$ and 
$\bmc_u$
will be recovered from  the reordered problem and placed in {\tt prob\%C\_l} 
and {\tt prob\%C\_u} using the mappings generated by the last successful 
call to {\tt \packagename\_reorder}. 
 
\itt{get\_dc\_bounds} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_dc\_bounds} is present, 
the vectors of parametric constraint bounds $\delta \bmc_l$ and $\delta \bmc_u$
will be recovered from  the reordered problem and placed in {\tt prob\%DC\_l} 
and {\tt prob\%DC\_u} using the mappings generated by the last successful 
call to {\tt \packagename\_reorder}. 
 
\itt{get\_Ao} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_Ao} is present, the matrix $\bmA_o$
will be recovered from the reordered problem and placed in {\tt prob\%Ao} 
using the mappings generated by the last successful call to 
{\tt \packagename\_reorder}. 
 
\itt{get\_A} 
is an \optional\ scalar \intentin\ argument of type default \logical. 
If {\tt get\_L} is present, the matrix $\bmA$
will be recovered from the reordered problem and placed in {\tt prob\%A} 
using the mappings generated by the last successful call to 
{\tt \packagename\_reorder}. 

\end{description}

%%%%%%% termination subroutine %%%%%%

\subsubsection{The  termination subroutine}
All previously allocated arrays are deallocated as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_terminate( map, control, info )}

\vspace*{-3mm}
\begin{description}

\itt{map} is a scalar \intentinout\ argument of type 
{\tt \packagename\_map\_type} 
exactly as for 
{\tt \packagename\_reorder}
which must not have been altered {\bf by the user} since the last call to 
{\tt \packagename\_initialize}.
On exit, array components will have been deallocated.

\itt{control} is a scalar \intentin\ argument of type 
{\tt \packagename\_control\_type}
exactly as for
{\tt \packagename\_reorder}.

\itt{info} is a scalar \intentout\ argument of type 
{\tt \packagename\_inform\_type}
exactly as for
{\tt \packagename\_reorder}.
Only the component {\tt status} will be set on exit, and a 
successful call to 
{\tt \packagename\_terminate}
is indicated when this  component {\tt status} has the value 0. 
For other return values of {\tt status}, see Section~\ref{galerrors}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\galerrors
A negative value of {\tt info\%status} on exit from 
{\tt \packagename\_solve}
or 
{\tt \packagename\_terminate}
indicates that an error has occurred. No further calls should be made
until the error has been corrected. Possible values are:

\begin{description}

\itt{\galerrallocate.} An allocation error occurred. 
A message indicating the offending 
 array is written on unit {\tt control\%error} and the returned allocation 
 status is given by the value {\tt inform\%alloc\_status}.

\itt{\galerrrestrictions.} One of the restrictions 
{\tt prob\%n} $> 0$, {\tt prob\%o} $\geq  0$ or {\tt prob\%m} $\geq  0$
    or requirements that {\tt prob\%Ao\%type} 
    and {\tt prob\%A\%type} contain its relevant string
    {\tt 'DENSE'}, {\tt 'DENSE\_BY\_ROWS'}, {\tt 'DENSE\_BY\_COLUMNS'}, 
   {\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_ROWS'} or {\tt 'SPARSE\_BY\_COLUMNS'} 
    has been violated.

%\itt{-3.} At least one of the arrays 
% {\tt prob\%Ao\_val}, {\tt prob\%Ao\_row}, {\tt prob\%Ao\_col},
% {\tt prob\%A\_val}, {\tt prob\%A\_row} or {\tt prob\%A\_col},
% is not large enough to hold the original, or reordered, matrices $\bmA_o$
% or $\bmA$.

\itt{\galerrprimalinfeasible.} The constraints are inconsistent.

\itt{-31.} An attempt to use 
{\tt \packagename\_apply}, {\tt \packagename\_get\_values} 
or {\tt \packagename\_restore} 
has been made before a successful call to {\tt \packagename\_reorder}. 
 
\itt{-52.} An attempt to change a matrix storage format has been made 
without first recalling {\tt \packagename\_reorder}. 
 
\itt{-53.} At least one of the matrices $\bmA_o$ or $\bmA$ has not been reordered,
while the current subroutine call requires it to have been. 

\itt{-54.} Neither the array {\tt prob\%Y} nor the pair {\tt prob\%Y\_l} and
{\tt prob\%Y\_u} have been allocated.

\itt{-55.} Neither the array {\tt prob\%Z} nor the pair {\tt prob\%Z\_l} and
{\tt prob\%Z\_u} have been allocated.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Information printed %%%%%%%%%%%%%%%%%%%%%%%%

\galinfo
The only information printed will be error messages, corresponding to 
nonzero values of {\tt info\%status}, on unit {\tt control\%error}. 

%%%%%%%%%%%%%%%%%%%%%% GENERAL INFORMATION %%%%%%%%%%%%%%%%%%%%%%%%

\galgeneral

\galcommon None.
\galworkspace Provided automatically by the module.
\galroutines None. 
\galmodules 
{\tt GALAHAD\_SY\-M\-BOLS}, 
{\tt GALAHAD\_SMT}, 
{\tt GALAHAD\_QPT},
and {\tt GALAHAD\_SORT}.
\galio Output is under control of the argument {\tt control\%error}.
\galrestrictions {\tt prob\%n} $> 0$, {\tt prob\%m} $\geq  0$, 
 {\tt prob\%o} $\geq  0$, 
 {\tt prob\%Ao\%type} and {\tt prob\%A\%type} $\in \{${\tt 'DENSE'}, 
 {\tt 'DENSE\_BY\_ROWS'},  {\tt 'DENSE\_BY\_COLUMNS'}, 
 {\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_ROWS'},
 {\tt 'SPARSE\_BY\_COLUMNS'}$\}$. 
\galportability ISO Fortran~95 + TR 15581 or Fortran~2003. 
The package is thread-safe.

%%%%%%%%%%%%%%%%%%%%%% METHOD %%%%%%%%%%%%%%%%%%%%%%%%

\galmethod
The required solution $\bmx$ necessarily satisfies 
the primal optimality conditions
\eqn{4.1a}{\bmA \bmx = \bmc,}
where
\eqn{4.1b}{
 \bmc^{l} \leq \bmc \leq \bmc^{u} \;\; \mbox{and} \;\;
\bmx^{l} \leq\bmx \leq\bmx^{u},}
the dual optimality conditions
\eqn{4.2a}{ \bmA_o^T ( \bmA_o \bmx - \bmb ) = \bmA^{T} \bmy + \bmz,}
where
\eqn{4.2b}{
 \bmy = \bmy^{l} + \bmy^{u}, \;\;
 \bmz = \bmz^{l} + \bmz^{u}, \;\;
 \bmy^{l} \geq 0 , \;\;
 \bmy^{u} \leq 0 , \;\;
 \bmz^{l} \geq 0 \;\; \mbox{and} \;\;
 \bmz^{u} \leq 0 ,}
and the complementary slackness conditions 
\eqn{4.3}{
( \bmA \bmx - \bmc^{l} )^{T} \bmy^{l} = 0  ,\;\;
( \bmA \bmx - \bmc^{u} )^{T} \bmy^{u} = 0  ,\;\;
(\bmx -\bmx^{l} )^{T} \bmz^{l} = 0   \tim{and}
(\bmx -\bmx^{u} )^{T} \bmz^{u} = 0 ,}
where the vectors $\bmy$ and $\bmz$ are 
known as the Lagrange multipliers for
the general linear constraints, and the dual variables for the bounds,
respectively, and where the vector inequalities hold componentwise.

Two passes are made through the sets of bounds on the variables. 
In the first, the number belonging to each of the required categories 
(free, non-negativities, lower-bounded, range-bounded, 
upper-bounded, non-positivities and fixed) is computed. On the second pass, a 
permutation of the variables to rearange them into the required standard form 
is obtained. A mapping array of the original Jacobian entries into their 
permuted form is then obtained, and the permutations applied in place 
(ie, without resorting to further storage) to $\bmA_o$, $\bmA$ $\bmx$, $\bmz$, 
$\bmb$, 
$\bmx^l$ and $\bmx^u$, suitable values of $\bmx$ and $\bmz$ 
satisfying \req{4.1b} and \req{4.2b} having optionally been computed. 
 
Next, two passes are made through the sets of constraint bounds. 
In the first, the number belonging to each of the required categories 
(equality, lower-bounded, range-bounded, 
upper-bounded, and free) is computed, while in the 
second the required permutation of the constraints 
into the required standard form is obtained. 
A mapping array of the original Jacobian entries into their 
permuted form is then obtained, and the permutations applied in place 
to $\bmA_o$, $\bmA$, $\bmb$, $\bmc$, $\bmy$, $\bmc^l$ and $\bmc^u$, 
suitable values of $\bmc$ and $\bmy$, satisfying \req{4.2b},
having, as before, optionally been computed. 
Both sets of permutations, and the matrix mapping arrays are saved for 
possible later use. 
 
Any fixed variables and free constraints are removed. Fixing variables 
results in changes to the values of $f$, $\bmg$, $\bmc^l$ and $\bmc^u$. 
Subsequent reorderings for structurally similar problems, or restorations 
of data from reordered problems, 
are easily obtained from the permuation and mapping arrays, and their inverses. 

%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\galexample
Suppose we wish to minimize
\disp{\half \left \| 
\vect{ x_1 - 1 \\ x_1 + 2x_2 - 2 \\ x_1 + x_2 + 3 x_3 - 3 \\ 
 x_1 + x_2 + x_3 + 4 x_4 - 4 \\ 5x_2 + x_3 + x_4 - 5 \\ 6 x_3 + x_4 - 6 \\
7 x_7 - 7} \right \|^2
}
subject to the general linear constraints 
$1 \leq 2 x_1 + x_2 \leq 2$, 
$x_2 + x_3 + x_4 = 2$, and simple bounds 
$-1 \leq x_1 \leq 1$, $x_3 = 1$ and $x_4 \leq 2$, but first wish to 
convert the problem to our standard form. 
Then, on writing the data for this problem as 
\disp{\bmA_o = \mat{cccc}{1 &   &   &   \\ 1 & 2 &   &   \\
1 & 1 & 3 &   \\ 1 & 1 & 1 & 4 \\   & 5 & 1 & 1 \\   &   & 6 & 1 \\
  &   &   & 7}, \;\; \bmb = \vect{ 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 \\ 7}, \;\;
\bmx^{l} = \vect{ -1 \\ - \infty \\ 1 \\ - \infty } \tim{and}
\bmx^{u} = \vect{ 1 \\ \infty \\ 1 \\ 2 },}
and
\disp{
 \bmA = \mat{cccc}{ 2 & 1 & & \\ & 1 & 1 & 1 },\;\;
 \bmc^{l} = \vect{ 1 \\ 2 }, \tim{and}
 \bmc^{u} = \vect{ 2 \\ 2 }}
we may use the following code:
{\tt \small
\VerbatimInput{\packageexample}
}
\noindent
This produces the following output:
{\tt \small
\VerbatimInput{\packageresults}
}
\noindent

The same problem may be solved holding the data in a sparse row-wise, a sparse 
column-wise, or a dense (row-wise) format by changing the parameter 
{\tt type} in the program above to {\tt 2}, {\tt 3} or {\tt 4}
respectively.
\end{document}

\documentclass{galahad}

% set the package name

\newcommand{\package}{dgo}
\newcommand{\packagename}{DGO}
\newcommand{\fullpackagename}{\libraryname\_\packagename}
\newcommand{\solver}{{\tt \fullpackagename\_solve}}

\begin{document}

\galheader

%%%%%%%%%%%%%%%%%%%%%% SUMMARY %%%%%%%%%%%%%%%%%%%%%%%%

\galsummary
This package uses a {\bf deterministic partition-and-bound trust-region 
method to find an approximation to the global minimizer of a differentiable 
objective function $f(\bmx)$ of $n$ variables $\bmx$, subject to a
finite set of simple bounds $\bmx^l \leq \bmx \leq \bmx^u$ on the variables.}
The method offers the choice of direct
and iterative solution of the key trust-region subproblems, and
is suitable for large problems. First derivatives are required,
and if second derivatives can be calculated, they will be exploited---if
the product of second derivatives with a vector may be found but
not the derivatives themselves, that may also be exploited.

Although there are theoretical guarantees, these may require a large
number of evaluations as the dimension and nonconvexity increase.
The alternative \libraryname\ package {\tt BGO} may sometimes be
preferred.

%%%%%%%%%%%%%%%%%%%%%% attributes %%%%%%%%%%%%%%%%%%%%%%%%

\galattributes
\galversions{\tt  \fullpackagename\_single, \fullpackagename\_double}.
\galuses
{\tt GALAHAD\_CLOCK},
{\tt GALAHAD\_SY\-M\-BOLS},
{\tt GALAHAD\_HASH},
{\tt GALAHAD\_NLPT},
{\tt GALAHAD\_USERDATA},
{\tt GALAHAD\_SPECFILE},
{\tt GALAHAD\_SPACE},
{\tt GALAHAD\_\-NORMS},
{\tt GALAHAD\_UGO}
and 
{\tt GALAHAD\_TRB}.
\galdate July 2021.
\galorigin J. Fowkes and N. I. M. Gould, Rutherford Appleton Laboratory.
\gallanguage Fortran~95 + TR 15581 or Fortran~2003.

%%%%%%%%%%%%%%%%%%%%%% HOW TO USE %%%%%%%%%%%%%%%%%%%%%%%%

\galhowto

%\subsection{Calling sequences}

The package is available using both single and double precision reals, 
and either 32-bit or 64-bit integers. Access to the 32-bit integer,
single precision version requires the {\tt USE} statement
\medskip

\hspace{8mm} {\tt USE \fullpackagename\_single}

\medskip
\noindent
with the obvious substitution {\tt \fullpackagename\_double},
{\tt \fullpackagename\_single\_64} and 
{\tt \fullpackagename\_double\_64} for the other variants.

\noindent
If it is required to use more than one of the modules at the same time, 
the derived types
{\tt SMT\_type},
{\tt GALAHAD\_userdata\_type},
{\tt \packagename\_time\_\-type},
{\tt \packagename\_control\_type},
{\tt \packagename\_inform\_type},
{\tt \packagename\_data\_type}
and
{\tt NLPT\_problem\_type},
(Section~\ref{galtypes})
and the subroutines
{\tt \packagename\_initialize},
{\tt \packagename\_\-solve},
{\tt \packagename\_terminate},
(Section~\ref{galarguments})
and
{\tt \packagename\_read\_specfile}
(Section~\ref{galfeatures})
must be renamed on one of the {\tt USE} statements.

%%%%%%%%%%%%%%%%%%%%%% matrix formats %%%%%%%%%%%%%%%%%%%%%%%%

\galmatrix
If available, the Hessian matrix $\bmH = \nabla_{xx} f(\bmx)$
may be stored in a variety of input formats.

\subsubsection{Dense storage format}\label{dense}
The matrix $\bmH$ is stored as a compact
dense matrix by rows, that is, the values of the entries of each row in turn are
stored in order within an appropriate real one-dimensional array.
Since $\bmH$ is symmetric, only the lower triangular part (that is the part
$h_{ij}$ for $1 \leq j \leq i \leq n$) need be held. In this case
the lower triangle should be stored by rows, that is
component $i \ast (i-1)/2 + j$ of the storage array {\tt H\%val}
will hold the value $h_{ij}$ (and, by symmetry, $h_{ji}$)
for $1 \leq j \leq i \leq n$.

\subsubsection{Sparse co-ordinate storage format}\label{coordinate}
Only the nonzero entries of the matrices are stored.
For the $l$-th entry, $1 \leq l \leq$ {\tt H\%ne}, of $\bmH$, 
its row index $i$, column index $j$ and value $h_{ij}$,
$1 \leq j \leq i \leq n$,
are stored in the $l$-th components of the integer arrays {\tt H\%row},
{\tt H\%col} and real array {\tt H\%val}, respectively.
Note that only the entries in the lower triangle should be stored.

\subsubsection{Sparse row-wise storage format}\label{rowwise}
Again only the nonzero entries are stored, but this time
they are ordered so that those in row $i$ appear directly before those
in row $i+1$. For the $i$-th row of $\bmH$, the $i$-th component of the
integer array {\tt H\%ptr} holds the position of the first entry in this row,
while {\tt H\%ptr} $(n+1)$ holds the total number of entries plus one.
The column indices $j$, $1 \leq j \leq i$, and values $h_{ij}$ of the
entries in the $i$-th row are stored in components
$l =$ {\tt H\%ptr}$(i)$, \ldots ,{\tt H\%ptr} $(i+1)-1$ of the
integer array {\tt H\%col}, and real array {\tt H\%val}, respectively.
Note that as before only the entries in the lower triangle should be stored.
For sparse matrices, this scheme almost always requires less storage than
its predecessor.

\subsubsection{Diagonal storage format}\label{diagonal}
If $\bmH$ is diagonal (i.e., $h_{ij} = 0$ for all $1 \leq i \neq j \leq n$)
only the diagonals entries $h_{ii}$, $1 \leq i \leq n$,  need be stored,
and the first $n$ components of the array {\tt H\%val} may be used for
the purpose.

%%%%%%%%%%%%%%%%%%%%%%%%%%% kinds %%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{kinds}

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\galtypes
Seven derived data types are accessible from the package.

%%%%%%%%%%% matrix data type %%%%%%%%%%%

\subsubsection{The derived data type for holding matrices}\label{typesmt}
The derived data type {\tt SMT\_TYPE} is used to hold the Hessian matrix $\bmH$
if this is available. The components of {\tt SMT\_TYPE} used here are:

\begin{description}

\ittf{n} is a scalar component of type \integer,
that holds the dimension of the matrix.

\ittf{ne} is a scalar variable of type \integer, that
holds the number of matrix entries.

\ittf{type} is a rank-one allocatable array of type default \character, that
is used to indicate the matrix storage scheme used. Its precise length and
content depends on the type of matrix to be stored (see \S\ref{typeprob}).

\ittf{val} is a rank-one allocatable array of type \realdp\,
and dimension at least {\tt ne}, that holds the values of the entries.
Each pair of off-diagonal entries $h_{ij} = h_{ji}$ of the {\em symmetric}
matrix $\bmH$ is represented as a single entry
(see \S\ref{dense}--\ref{rowwise}).
Any duplicated entries that appear in the sparse
co-ordinate or row-wise schemes will be summed.

\ittf{row} is a rank-one allocatable array of type \integer,
and dimension at least {\tt ne}, that may hold the row indices of the entries.
(see \S\ref{coordinate}).

\ittf{col} is a rank-one allocatable array of type \integer,
and dimension at least {\tt ne}, that may hold the column indices of the entries
(see \S\ref{coordinate}--\ref{rowwise}).

\ittf{ptr} is a rank-one allocatable array of type \integer,
and dimension at least {\tt n + 1}, that may hold the pointers to
the first entry in each row (see \S\ref{rowwise}).

\end{description}

%%%%%%%%%%% problem type %%%%%%%%%%%

\subsubsection{The derived data type for holding the problem}\label{typeprob}
The derived data type {\tt NLPT\_problem\_type} is used to hold
the problem. The relevant components of
{\tt NLPT\_problem\_type}
are:

\begin{description}

\ittf{n} is a scalar variable of type \integer,
 that holds the number of optimization variables, $n$.

\ittf{H} is scalar variable of type {\tt SMT\_TYPE}
that holds the Hessian matrix $\bmH$. The following components
are used here:

\begin{description}

\itt{H\%type} is an allocatable array of rank one and type default
\character, that
is used to indicate the storage scheme used. If the dense storage scheme
(see Section~\ref{dense}) is used,
the first five components of {\tt H\%type} must contain the
string {\tt DENSE}.
For the sparse co-ordinate scheme (see Section~\ref{coordinate}),
the first ten components of {\tt H\%type} must contain the
string {\tt COORDINATE},
for the sparse row-wise storage scheme (see Section~\ref{rowwise}),
the first fourteen components of {\tt H\%type} must contain the
string {\tt SPARSE\_BY\_ROWS},
and for the diagonal storage scheme (see Section~\ref{diagonal}),
the first eight components of {\tt H\%type} must contain the
string {\tt DIAGONAL}.

For convenience, the procedure {\tt SMT\_put}
may be used to allocate sufficient space and insert the required keyword
into {\tt H\%type}.
For example, if {\tt nlp} is of derived type {\tt \packagename\_problem\_type}
and involves a Hessian we wish to store using the co-ordinate scheme,
we may simply
%\vspace*{-2mm}
{\tt
\begin{verbatim}
        CALL SMT_put( nlp%H%type, 'COORDINATE' )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent
See the documentation for the \galahad\ package {\tt SMT}
for further details on the use of {\tt SMT\_put}.

\itt{H\%ne} is a scalar variable of type \integer, that
holds the number of entries in the {\bf lower triangular} part of $\bmH$
in the sparse co-ordinate storage scheme (see Section~\ref{coordinate}).
It need not be set for any of the other three schemes.

\itt{H\%val} is a rank-one allocatable array of type \realdp, that holds
the values of the entries of the {\bf lower triangular} part
of the Hessian matrix $\bmH$ in any of the
storage schemes discussed in Section~\ref{galmatrix}.

\itt{H\%row} is a rank-one allocatable array of type \integer,
that holds the row indices of the {\bf lower triangular} part of $\bmH$
in the sparse co-ordinate storage
scheme (see Section~\ref{coordinate}).
It need not be allocated for any of the other three schemes.

\itt{H\%col} is a rank-one allocatable array variable of type \integer,
that holds the column indices of the {\bf lower triangular} part of
$\bmH$ in either the sparse co-ordinate
(see Section~\ref{coordinate}), or the sparse row-wise
(see Section~\ref{rowwise}) storage scheme.
It need not be allocated when the dense or diagonal storage schemes are used.

\itt{H\%ptr} is a rank-one allocatable array of dimension {\tt n+1} and type
\integer, that holds the starting position of
each row of the {\bf lower triangular} part of $\bmH$, as well
as the total number of entries plus one, in the sparse row-wise storage
scheme (see Section~\ref{rowwise}). It need not be allocated when the
other schemes are used.

\end{description}

\ittf{G} is a rank-one allocatable array of dimension {\tt n} and type
\realdp, that holds the gradient $\bmg$
of the objective function.
The $j$-th component of
{\tt G}, $j = 1,  \ldots ,  n$, contains $\bmg_{j}$.
These are equivalently the values $\bmz$ of estimates  of the dual variables
corresponding to the simple bound constraints (see Section~\ref{galmethod}).

\ittf{f} is a scalar variable of type
\realdp, that holds the value of the objective function.

\ittf{X\_l} is a rank-one allocatable array of dimension {\tt n} and type
\realdp, that holds
the vector of lower bounds $\bmx^{l}$ on the the variables.
The $j$-th component of {\tt X\_l}, $j = 1, \ldots , n$,
contains $\bmx_{j}^{l}$.
Infinite bounds are allowed by setting the corresponding
components of {\tt X\_l} to any value smaller than {\tt -infinity},
where {\tt infinity} is a component of the control array {\tt control}
(see Section~\ref{typecontrol}).

\ittf{X\_u} is a rank-one allocatable array of dimension {\tt n} and type
\realdp, that holds
the vector of upper bounds $\bmx^{u}$ on the variables.
The $j$-th component of {\tt X\_u}, $j = 1, \ldots , n$,
contains $\bmx_{j}^{u}$.
Infinite bounds are allowed by setting the corresponding
components of {\tt X\_u} to any value larger than that {\tt infinity},
where {\tt infinity} is a component of the control array {\tt control}
(see Section~\ref{typecontrol}).

\ittf{X} is a rank-one allocatable array of dimension {\tt n} and type
\realdp,
that holds the values $\bmx$ of the optimization variables.
The $j$-th component of {\tt X}, $j = 1,  \ldots , n$, contains $x_{j}$.

\itt{pname} is a scalar variable of type
default \character\ and length 10, which contains the
``name'' of the problem for printing. The default ``empty'' string is
provided.

\itt{VNAMES} is a rank-one allocatable array of dimension {\tt n} and type
default \character\ and length 10, whose $j$-th entry contains the
``name'' of the $j$-th variable for printing. This is only used
if ``debug''printing {\tt control\%print\_level > 4}) is requested,
and will be ignored if the array is not allocated.

\end{description}

%%%%%%%%%%% control type %%%%%%%%%%%

\subsubsection{The derived data type for holding control
 parameters}\label{typecontrol}
The derived data type
{\tt \packagename\_control\_type}
is used to hold controlling data. Default values may be obtained by calling
{\tt \packagename\_initialize}
(see Section~\ref{subinit}),
while components may also be changed by calling
{\tt \fullpackagename\_read\-\_spec}
(see Section~\ref{readspec}).
The components of
{\tt \packagename\_control\_type}
are:


\begin{description}

\itt{error} is a scalar variable of type \integer, that holds the
stream number for error messages. Printing of error messages in
{\tt \packagename\_solve} and {\tt \packagename\_terminate}
is suppressed if {\tt error} $\leq 0$.
The default is {\tt error = 6}.

\ittf{out} is a scalar variable of type \integer, that holds the
stream number for informational messages. Printing of informational messages in
{\tt \packagename\_solve} is suppressed if {\tt out} $< 0$.
The default is {\tt out = 6}.

\itt{print\_level} is a scalar variable of type \integer, that is used
to control the amount of informational output which is required. No
informational output will occur if {\tt print\_level} $\leq 0$. If
{\tt print\_level} $= 1$, a single line of output will be produced for each
iteration of the process. If {\tt print\_level} $\geq 2$, this output will be
increased to provide significant detail of each iteration.
The default is {\tt print\_level = 0}.

\itt{start\_print} is a scalar variable of type \integer, that specifies
the first iteration for which printing will occur in {\tt \packagename\_solve}.
If {\tt start\_print} is negative, printing will occur from the outset.
The default is {\tt start\_print = -1}.

\itt{stop\_print} is a scalar variable of type \integer, that specifies
the last iteration for which printing will occur in  {\tt \packagename\_solve}.
If {\tt stop\_print} is negative, printing will occur once it has been
started by {\tt start\_print}.
The default is {\tt stop\_print = -1}.

\itt{print\_gap} is a scalar variable of type \integer.
Once printing has been started, output will occur once every
{\tt print\_gap} iterations. If {\tt print\_gap} is no larger than 1,
printing will be permitted on every iteration.
The default is {\tt print\_gap = 1}.

\itt{maxit} is a scalar variable of type \integer, that holds the
maximum number of iterations which will be allowed in {\tt \packagename\_solve}.
The default is {\tt maxit = 1000}.

\itt{max\_evals} is a scalar variable of type \integer, that gives
the maximum number of function evaluations that are allowed.
The default is {\tt max\_evals = 10000}.

\itt{dictionary\_size} is a scalar variable of type \integer, that 
gives the size of the initial hash dictionary.
The default is {\tt dictionary\_size = 100000}.

\itt{alive\_unit} is a scalar variable of type \integer.
If {\tt alive\_unit} $>$ 0, a temporary file named {\tt alive\_file} (see below)
will be created on stream number {\tt alive\_unit} on initial entry to
\solver, and execution of \solver\ will continue so
long as this file continues to exist. Thus, a user may terminate execution
simply by removing the temporary file from this unit.
If {\tt alive\_unit} $\leq$ 0, no temporary file will be created, and
execution cannot be terminated in this way.
The default is {\tt alive\_unit} $=$ 60.

\itt{infinity} is a scalar variable of type \realdp, that is used to
specify which constraint bounds are infinite.
Any bound larger than {\tt infinity} in modulus will be regarded as infinite.
The default is {\tt infinity =} $10^{19}$.

\itt{lipschitz\_lower\_bound} is a scalar variable of type \realdp, 
that provides a lower bound on the Lipschitz constant for the gradient.
This must be non-negative (and not zero unless the function is constant).
The default is {\tt lipschitz\_lower\_bound =} $10^{-6}$.

\itt{lipschitz\_reliability} and {\tt lipschitz\_control} are scalar variables 
of type \realdp, that are used to provide a reliable estimate of 
the Lipschitz constant in the current sub-box. 
Specifically, the Lipschitz constant used will be
{\tt lipschitz\_reliability} + max( 1, n - 1 ) * {\tt lipschitz\_control} 
/ iteration counter times the largest value observed.
The defaults are {\tt lipschitz\_reliab\-ility =} $2.0$ and
{\tt lipschitz\_control =} $50$.

\itt{stop\_length} is a scalar variable of type \realdp, that is 
used to stop the iteration. This will happen if the length of the ``diagonal''
in the sub-box with the smallest-found objective function is smaller than 
{\tt stop\_length} times that of the original bound box.
The default is {\tt stop\_length =} $10^{-4}$.

\itt{stop\_f} is a scalar variable of type \realdp, that is used to
stop the iteration. This will happen if the gap between the best objective 
value found and the smallest lower bound is smaller than {\tt stop\_f}.
The default is {\tt stop\_f =} $10^{-4}$.

\itt{obj\_unbounded}  is a scalar variable of type default
\realdp, that specifies smallest
value of the objective function that will be tolerated before the problem
is declared to be unbounded from below.
The default is {\tt potential\_u\-nbounded =} $-u^{-2}$,
where $u$ is {\tt EPSILON(1.0)} ({\tt EPSILON(1.0D0)} in
{\tt \fullpackagename\_double}).

\itt{cpu\_time\_limit} is a scalar variable of type \realdp,
that is used to specify the maximum permitted CPU time. Any negative
value indicates no limit will be imposed. The default is
{\tt cpu\_time\_limit = - 1.0}.

\itt{clock\_time\_limit} is a scalar variable of type \realdp,
that is used to specify the maximum permitted elapsed system clock time.
Any negative value indicates no limit will be imposed. The default is
{\tt clock\_time\_limit = - 1.0}.

\itt{hessian\_available}
is a scalar variable of type default \logical,
that should be set \true\ if the user will provide second derivatives
(either by providing an appropriate evaluation routine to the solver
or by reverse communication, see Section~\ref{reverse}), and
\false\ if the second derivatives are not explicitly available.
The default is {\tt hessian\_available = .TRUE.}.

\itt{prune}
is a scalar variable of type default \logical,
that should be set \true\ if sub-boxes that cannot contain the global 
minimizer be pruned (i.e.,  removed from further consideration),
and \false\ if a no local pruning is required.
The default is {\tt prune = .TRUE.}.

\itt{perform\_local\_optimization}
is a scalar variable of type default \logical,
that should be set \true\ if approximate minimizers are to 
be improved by judicious local minimization, 
and \false\ if a no local improvement is required.
The default is {\tt perform\_local\_optimization = .TRUE.}.

\itt{space\_critical} is a scalar variable of type default \logical,
that must be set \true\ if space is critical when allocating arrays
and  \false\ otherwise. The package may run faster if
{\tt space\_critical} is \false\ but at the possible expense of a larger
storage requirement. The default is {\tt space\_critical = .FALSE.}.

\itt{deallocate\_error\_fatal} is a scalar variable of type default \logical,
that must be set \true\ if the user wishes to terminate execution if
a deallocation  fails, and \false\ if an attempt to continue
will be made. The default is {\tt deallocate\_error\_fatal = .FALSE.}.

\itt{alive\_file} is a scalar variable of type default \character\ and length
30, that gives the name of the temporary file whose removal from stream number
{\tt alive\_unit} terminates execution of \solver.
The default is {\tt alive\_unit} $=$ {\tt ALIVE.d}.

\itt{prefix} is a scalar variable of type default \character\
and length 30, that may be used to provide a user-selected
character string to preface every line of printed output.
Specifically, each line of output will be prefaced by the string
{\tt prefix(2:LEN(TRIM( prefix ))-1)},
thus ignoreing the first and last non-null components of the
supplied string. If the user does not want to preface lines by such
a string, they may use the default {\tt prefix = ""}.

\itt{HASH\_control} is a scalar variable of type
{\tt HASH\_control\_type}
whose components are used to control the the hash table used to store
the dictionary of vertices of the sub-boxes maintained by the package
{\tt \libraryname\_HASH}.
See the specification sheet for the package
{\tt \libraryname\_HASH}
for details, and appropriate default values.

\itt{TRB\_control} is a scalar variable of type
{\tt TRB\_control\_type}
whose components are used to control the local multivariate
optimization aspects of the calculation, as performed by the package
{\tt \libraryname\_TRB}.
See the specification sheet for the package
{\tt \libraryname\_TRB}
for details, and appropriate default values.

\itt{UGO\_control} is a scalar variable of type
{\tt UGO\_control\_type}
whose components are used to control the
univariate global optimization calculation (if any),
performed by the package
{\tt \libraryname\_UGO}.
See the specification sheet for the package
{\tt \libraryname\_UGO}
for details, and appropriate default values.

\end{description}

%%%%%%%%%%% time type %%%%%%%%%%%

\subsubsection{The derived data type for holding timing
 information}\label{typetime}
The derived data type
{\tt \packagename\_time\_type}
is used to hold elapsed CPU and system clock times for the various parts
of the calculation. The components of
{\tt \packagename\_time\_type}
are:
\begin{description}
\itt{total} is a scalar variable of type default \real, that gives
 the CPU total time spent in the package.

\itt{univariate\_global} is a scalar variable of type \realdp, that 
gives the CPU time spent performing univariate global optimization.

\itt{multivariate\_local} is a scalar variable of type \realdp, that 
gives the CPU time spent performing multivariate local optimization.

\itt{clock\_total} is a scalar variable of type default \real, that gives
 the total elapsed system clock time spent in the package.

\itt{clock\_univariate\_global} is a scalar variable of type \realdp, 
that gives the elapsed system clock time spent performing univariate global 
optimization.

\itt{clock\_multivariate\_local} is a scalar variable of type \realdp, 
that gives the  elapsed system clock time spent performing multivariate local 
optimization.

\end{description}

%%%%%%%%%%% inform type %%%%%%%%%%%

\subsubsection{The derived data type for holding informational
 parameters}\label{typeinform}
The derived data type
{\tt \packagename\_inform\_type}
is used to hold parameters that give information about the progress and needs
of the algorithm. The components of
{\tt \packagename\_inform\_type}
are:

\begin{description}
\itt{status} is a scalar variable of type \integer, that gives the
exit status of the algorithm.
%See Sections~\ref{galerrors} and \ref{galinfo}
See Sections~\ref{reverse} and \ref{galerrors}
for details.

\itt{alloc\_status} is a scalar variable of type \integer, that gives
the status of the last attempted array allocation or deallocation.
This will be 0 if {\tt status = 0}.

\itt{bad\_alloc} is a scalar variable of type default \character\
and length 80, that  gives the name of the last internal array
for which there were allocation or deallocation errors.
This will be the null string if {\tt status = 0}.

\itt{f\_eval} is a scalar variable of type \integer, that gives the
total number of objective function evaluations performed.

\itt{g\_eval} is a scalar variable of type \integer, that gives the
total number of objective function gradient evaluations performed.

\itt{h\_eval} is a scalar variable of type \integer, that gives the
total number of objective function Hessian evaluations performed.

\ittf{obj} is a scalar variable of type \realdp, that holds the
value of the objective function at the best estimate of the solution found.

\itt{norm\_pg} is a scalar variable of type \realdp, that holds the
value of the norm of the projected gradient of the objective function 
at the best estimate of the solution found.

\itt{length\_ratio} is a scalar variable of type \realdp, that holds 
the ratio of the final to the initial box lengths.

\itt{f\_gap} is a scalar variable of type \realdp, that holds the
gap  between the best objective value found and the lowest bound.

\itt{why\_stop} is a scalar variable of type default \character\
and length 1 that summarises why the iteration stopped. It will be 
'D' if the box length is small enough, 
'F' if the objective gap is small enough, and ' ' otherwise.

\ittf{time} is a scalar variable of type {\tt \packagename\_time\_type}
whose components are used to hold elapsed elapsed CPU and system clock
times for the various parts of the calculation (see Section~\ref{typetime}).

\itt{HASH\_inform} is a scalar variable of type
{\tt HASH\_inform\_type}
whose components give information about the hash table used to store
the dictionary of vertices of the sub-boxes maintained by the package
{\tt \libraryname\_HASH}.
See the specification sheet for the package
{\tt \libraryname\_HASH}
for details.

\itt{TRB\_inform} is a scalar variable of type
{\tt TRB\_inform\_type}
whose components give information about the progress and needs of the local
multivariate optimization stages of the algorithm performed by the package
{\tt \libraryname\_TRB}.
See the specification sheet for the package
{\tt \libraryname\_TRB}
for details.

\itt{UGO\_inform} is a scalar variable of type
{\tt UGO\_inform\_type}
whose components give information about the progress and needs of the 
univariate global optimization stages of the algorithm performed by the package
{\tt \libraryname\_UGO}.
See the specification sheet for the package
{\tt \libraryname\_UGO}
for details.

\end{description}

%%%%%%%%%%% data type %%%%%%%%%%%

\subsubsection{The derived data type for holding problem data}\label{typedata}
The derived data type
{\tt \packagename\_data\_type}
is used to hold all the data for a particular problem,
or sequences of problems with the same structure, between calls of
{\tt \packagename} procedures.
This data should be preserved, untouched (except as directed on
return from \solver\ with positive values of {\tt inform\%status}, see
Section~\ref{reverse}),
from the initial call to
{\tt \packagename\_initialize}
to the final call to
{\tt \packagename\_terminate}.

%%%%%%%%%%% userdata type %%%%%%%%%%%

\input{userdata_type}

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\galarguments
There are three procedures for user calls
(see Section~\ref{galfeatures} for further features):

\begin{enumerate}
\item The subroutine
      {\tt \packagename\_initialize}
      is used to set default values, and initialize private data,
      before solving one or more problems with the
      same sparsity and bound structure.
\item The subroutine
      {\tt \packagename\_solve}
      is called to solve the problem.
\item The subroutine
      {\tt \packagename\_terminate}
      is provided to allow the user to automatically deallocate array
       components of the private data, allocated by
       {\tt \packagename\_solve},
       at the end of the solution process.
       It is important to do this if the data object is re-used for another
       problem {\bf with a different structure}
       since {\tt \packagename\_initialize} cannot test for this situation,
       and any existing associated targets will subsequently become unreachable.
\end{enumerate}
We use square brackets {\tt [ ]} to indicate \optional\ arguments.

%%%%%% initialization subroutine %%%%%%

\subsubsection{The initialization subroutine}\label{subinit}
 Default values are provided as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_initialize( data, control, inform )}

\vspace*{-2mm}
\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see Section~\ref{typedata}). It is used to hold data about the problem being
solved.

\itt{control} is a scalar \intentout\ argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}).
On exit, {\tt control} contains default values for the components as
described in Section~\ref{typecontrol}.
These values should only be changed after calling
{\tt \packagename\_initialize}.

\itt{inform} is a scalar \intentout\ argument of type
{\tt \packagename\_inform\_type}
(see Section~\ref{typeinform}). A successful call to
{\tt \packagename\_initialize}
is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\end{description}

%%%%%%%%% main solution subroutine %%%%%%

\subsubsection{The minimization subroutine}
The minimization algorithm is called as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_solve( nlp, control, inform, data, userdata[, eval\_F,
eval\_G, \hspace{8mm}                  \&}
\vspace*{-1mm}

\hspace{37mm}
{\tt
eval\_H,  eval\_HPROD, eval\_SHPROD, eval\_PREC] )}

\vspace*{-2mm}
\begin{description}
\ittf{nlp} is a scalar \intentinout\ argument of type
{\tt NLPT\_problem\_type}
(see Section~\ref{typeprob}).
It is used to hold data about the problem being solved.
For a new problem, the user must allocate all the array components,
and set values for {\tt nlp\%n}
and the required integer components of {\tt nlp\%H} if second derivatives
will be used.
Users are free to choose whichever
of the matrix formats described in Section~\ref{galmatrix}
is appropriate for $\bmH$ for their application.

\noindent
The component {\tt nlp\%X} must be set to an initial estimate, $\bmx^{0}$,
of the minimization variables. A good choice will increase the speed
of the package, but the underlying method is designed to converge (at least
to a local solution) from an arbitrary initial guess.

\noindent
On exit, the component {\tt nlp\%X} will contain the best estimates of the
minimization variables $\bmx$, while {\tt nlp\%G} will contain the best 
estimates of the dual variables $\bmz$.

\noindent
\restrictions {\tt nlp\%n} $> 0$ and
{\tt nlp\%H\%type} $\in \{
  \mbox{\tt 'DENSE'}, \mbox{\tt 'COORDINATE'}, \mbox{\tt 'SPARSE\_BY\_ROWS'},
  \mbox{\tt 'DIAGONAL'} \}$.

\itt{control} is a scalar \intentin\ argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}). Default values may be assigned by calling
{\tt \packagename\_initialize} prior to the first call to
{\tt \packagename\_solve}. 

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see Section~\ref{typeinform}).
On initial entry, the  component {\tt status} must be set to the value 1.
Other entries need note be set.
A successful call to
{\tt \packagename\_solve}
is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see Sections~\ref{reverse} and
\ref{galerrors}.

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see Section~\ref{typedata}). It is used to hold data about the problem being
solved. With the possible exceptions of the components
{\tt eval\_status} and {\tt U} (see Section~\ref{reverse}),
it must not have been altered {\bf by the user} since the last call to
{\tt \packagename\_initialize}.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the
\optional\ subroutines
{\tt eval\_F}, {\tt eval\_G},
{\tt eval\_H} and {\tt eval\_HPROD}
(see Section~\ref{typeuserdata}).

\itt{eval\_F} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of the
objective function $f(\bmx)$ at a given vector $\bmx$.
See Section~\ref{ffv} for details.
If {\tt eval\_F} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_F} is absent, \solver\ will use reverse communication to
obtain objective function values (see Section~\ref{reverse}).

\itt{eval\_G} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of the
gradient of the objective function $\nabla_x f(\bmx)$ at a given vector $\bmx$.
See Section~\ref{gfv} for details.
If {\tt eval\_G} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_G} is absent, \solver\ will use reverse communication to
obtain gradient values (see Section~\ref{reverse}).

\itt{eval\_H} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of the
Hessian of the objective function $\nabla_{xx} f(\bmx)$ at a given vector $\bmx$.
See Section~\ref{hfv} for details.
If {\tt eval\_H} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_H} is absent, \solver\ will use reverse communication to
obtain Hessian function values (see Section~\ref{reverse}).

\itt{eval\_HPROD} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of the
product $\nabla_{xx} f(\bmx)\bmv$ of the Hessian of the objective function
$\nabla_{xx} f(\bmx)$  with a given vector $\bmv$.
See Section~\ref{hvfv} for details.
If {\tt eval\_HPROD} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_HPROD} is absent, \solver\ will use reverse communication to
obtain Hessian-vector products (see Section~\ref{reverse}).

\itt{eval\_SHPROD} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of the
product $\nabla_{xx} f(\bmx)\bmv$ of the Hessian of the objective function
$\bmu = \nabla_{xx} f(\bmx)$  with a given {\em sparse} vector $\bmv$,
and to return the nonzero components of the resulting $\bmu$.
See Section~\ref{hvsv} for details.
If {\tt eval\_SHPROD} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_SHPROD} is absent, \solver\ will use reverse communication to
obtain Hessian-sparse-vector products (see Section~\ref{reverse}).

\itt{eval\_PREC} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of the
product $\bmP(\bmx)\bmv$ of the user's preconditioner with a given vector
$\bmv$. See Section~\ref{pv} for details.
If {\tt eval\_PREC} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_PREC} is absent, \solver\ will use reverse communication to
obtain products with the preconditioner (see Section~\ref{reverse}).

\end{description}

%%%%%%% termination subroutine %%%%%%

\subsubsection{The  termination subroutine}
All previously allocated arrays are deallocated as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_terminate( data, control, inform )}

\vspace*{-1mm}
\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
exactly as for
{\tt \packagename\_solve},
which must not have been altered {\bf by the user} since the last call to
{\tt \packagename\_initialize}.
On exit, array components will have been deallocated.

\itt{control} is a scalar \intentin\ argument of type
{\tt \packagename\_control\_type}
exactly as for
{\tt \packagename\_solve}.

\itt{inform} is a scalar \intentout\ argument of type
{\tt \packagename\_inform\_type}
exactly as for
{\tt \packagename\_solve}.
Only the component {\tt status} will be set on exit, and a
successful call to
{\tt \packagename\_terminate}
is indicated when this  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\end{description}

%%%%%%%%%%%%%%%%%%%% Function and derivative values %%%%%%%%%%%%%%%%%%%%%

\subsection{Function and derivative values\label{fdv}}

%%%%%%%%%%%%%%%%%%%%%% Objective function value %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The objective function value via internal evaluation\label{ffv}}

If the argument {\tt eval\_F} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
value of the objective function $f(\bmx)$.
The routine must be specified as

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
      SUBROUTINE eval_F( status, X, userdata, f )
\end{verbatim}
}
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type \integer,
that should be set to 0 if the routine has been able to evaluate
the objective function
and to a non-zero value if the evaluation has not been possible.

\ittf{X} is a rank-one \intentin\ array argument of type \realdp\
whose components contain the vector $\bmx$.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the
subroutines {\tt eval\_F}, {\tt eval\_G},
{\tt eval\_H}, {\tt eval\_HPROD} and {\tt eval\_PREC}
(see Section~\ref{typeuserdata}).

\ittf{f} is a scalar \intentout\ argument of type \realdp,
that should be set to the value of the objective function $f(\bmx)$
evaluated at the vector $\bmx$ input in {\tt X}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Gradient values %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Gradient values via internal evaluation\label{gfv}}

If the argument {\tt eval\_G} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
value of the gradient the objective function $\nabla_x f(\bmx)$.
The routine must be specified as

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
       SUBROUTINE eval_G( status, X, userdata, G )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type \integer,
that should be set to 0 if the routine has been able to evaluate
the gradient of the objective function
and to a non-zero value if the evaluation has not been possible.

\ittf{X} is a rank-one \intentin\ array argument of type \realdp\
whose components contain the vector $\bmx$.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the
subroutines {\tt eval\_F}, {\tt eval\_G},
{\tt eval\_H}, {\tt eval\_HPROD} and {\tt eval\_PREC}
(see Section~\ref{typeuserdata}).

\itt{G} is a rank-one \intentout\ argument of type \realdp,
whose components should be set to the values of the gradient
of the objective function $\nabla_x f(\bmx)$
evaluated at the vector $\bmx$ input in {\tt X}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Hessian values %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Hessian values via internal evaluation\label{hfv}}

If the argument {\tt eval\_H} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
values of the Hessian of the objective function $\nabla_{xx} f(\bmx)$.
The routine must be specified as

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
       SUBROUTINE eval_H( status, X, userdata, Hval )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type \integer,
that should be set to 0 if the routine has been able to evaluate
the Hessian of the objective function
and to a non-zero value if the evaluation has not been possible.

\ittf{X} is a rank-one \intentin\ array argument of type \realdp\
whose components contain the vector $\bmx$.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the
subroutines {\tt eval\_F}, {\tt eval\_G},
{\tt eval\_H}, {\tt eval\_HPROD} and {\tt eval\_PREC}
(see Section~\ref{typeuserdata}).

\itt{Hval} is a scalar \intentout\ argument of type \realdp,
whose components should be set to the values of the Hessian
of the objective function $\nabla_{xx} f(\bmx)$
evaluated at the vector $\bmx$ input in {\tt X}. The values should
be input in the same order as that in which the array indices were
given in {\tt nlp\%H}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Hessian-vector products %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Hessian-vector products via internal evaluation\label{hvfv}}

If the argument {\tt eval\_HPROD} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
sum $\bmu + \nabla_{xx} f(\bmx) \bmv$ involving the
product of the Hessian of the objective function $\nabla_{xx} f(\bmx)$
with a given vector $\bmv$.
The routine must be specified as

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
       SUBROUTINE eval_HPROD( status, X, userdata, U, V, got_h )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type \integer,
that should be set to 0 if the routine has been able to evaluate the
sum $\bmu + \nabla_{xx} f(\bmx) \bmv$
and to a non-zero value if the evaluation has not been possible.

\ittf{X} is a \ rank-one \intentin\ array argument of type
\realdp\ whose components contain the vector $\bmx$.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the
subroutines {\tt eval\_F}, {\tt eval\_G},
{\tt eval\_H}, {\tt eval\_HPROD} and {\tt eval\_PREC}
(see Section~\ref{typeuserdata}).

\ittf{U} is a rank-one \intentinout\ array argument of type \realdp\
whose components on input contain the vector $\bmu$ and on output the
sum $\bmu + \nabla_{xx} f(\bmx) \bmv$.

\ittf{V} is a rank-one \intentin\ array argument of type \realdp\
whose components contain the vector $\bmv$.

\ittf{got\_h} is an \optional\ scalar \intentin\ argument of type default
\logical. If the Hessian has already been evaluated at the current $\bmx$
{\tt got\_h} will be \present\ and set \true; if this is the first time
the Hessian is to be accessed at $\bmx$, either {\tt got\_h} will be absent
or \present\ and set \false. This gives the user the opportunity
to reuse ``start-up'' computations required for the first instance of
$\bmx$ to speed up subsequent products.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Hessian-vector products %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Hessian-sparse-vector products via internal evaluation\label{hvsv}}

If the argument {\tt eval\_SHPROD} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
product $\bmu = \nabla_{xx} f(\bmx) \bmv$ involving 
the Hessian of the objective function $\nabla_{xx} f(\bmx)$
and a given sparse vector $\bmv$, and to return the nonzero components 
of the result $\bmu$. 
This routine is {\bf not required} if the user has set 
{\tt control\%hessian\_available} to \true\, and has made 
the values of $\nabla_{xx} f(\bmx)$ available either by calls to 
{\tt eval\_H} (see \S\ref{hfv})
or by reverse communication (see \S\ref{reverse}).
If needed, the routine must be specified as

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
       SUBROUTINE eval_SHPROD( status, X, userdata, nnz_v, INDEX_nz_v, V,      &
                               nnz_u, INDEX_nz_u, U, got_h )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type \integer,
that should be set to 0 if the routine has been able to evaluate the
sum $\bmu + \nabla_{xx} f(\bmx) \bmv$
and to a non-zero value if the evaluation has not been possible.

\ittf{X} is a \ rank-one \intentin\ array argument of type
\realdp\ whose components contain the vector $\bmx$.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the
subroutines {\tt eval\_F}, {\tt eval\_G},
{\tt eval\_H}, {\tt eval\_HPROD} and {\tt eval\_PREC}
(see Section~\ref{typeuserdata}).

\itt{nnz\_v} is a scalar \intentin\ argument of type \integer,
that specifies the number of nonzeros in the input sparse vector
$\bmv$.

\itt{INDEX\_nz\_v} is a rank-one \intentin\ array argument of length 
at least {\tt nnz\_v} and type \integer\ 
whose first {\tt nnz\_v} components 
give the indices of the nonzero components of $\bmv$.

\ittf{V} is a rank-one \intentin\ array argument of type \realdp\
whose components {\tt INDEX\_nz\_v(i)}, {\tt i} $= 1, \ldots,$ {\tt nnz\_v},
hold the nonzero values of $\bmv$. Any other components should be ignored.

\itt{nnz\_u} is a scalar \intentout\ argument of type \integer,
that gives the number of nonzeros in the output vector $\bmu$.

\itt{INDEX\_nz\_u} is a rank-one \intentout\ array argument of length 
at least {\tt nnz\_u} and type \integer\ 
whose first {\tt nnz\_u} components give the indices of the 
nonzero components of the computed product $\bmu$.

\ittf{U} is a rank-one \intentout\ array argument of type \realdp\
whose components {\tt INDEX\_nz\_u(i)}, {\tt i} $= 1, \ldots,$ {\tt nnz\_u},
hold the nonzero values of $\bmu$. The remaining components should be ignored.

\ittf{got\_h} is an \optional\ scalar \intentin\ argument of type default
\logical. If the Hessian has already been evaluated at the current $\bmx$
{\tt got\_h} will be \present\ and set \true; if this is the first time
the Hessian is to be accessed at $\bmx$, either {\tt got\_h} will be absent
or \present\ and set \false. This gives the user the opportunity
to reuse ``start-up'' computations required for the first instance of
$\bmx$ to speed up subsequent products.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% preconditioner-vector products %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Preconditioner-vector products via internal evaluation\label{pv}}

If the argument {\tt eval\_PREC} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
product $\bmu = \bmP(\bmx) \bmv$ involving the user's preconditioner
$\bmP(\bmx)$ with a given vector $\bmv$. The symmetric matrix $\bmP(\bmx)$
should ideally be chosen so that the eigenvalues of
$\bmP(\bmx) (\nabla_{xx} f(\bmx))^{-1}$ are clustered. This subroutine
will {\bf only be required} if {\tt control\%norm = -3}, and the user prefers
a subroutine call to that provided by reverse communication 
with {\tt inform\%status = 6} (see \S\ref{reverse}).
The routine must be specified as

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
       SUBROUTINE eval_PREC( status, X, userdata, U, V )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type \integer,
that should be set to 0 if the routine has been able to evaluate the
product $\bmP(\bmx) \bmv$
and to a non-zero value if the evaluation has not been possible.

\ittf{X} is a rank-one \intentin\ array argument of type \realdp\
whose components contain the vector $\bmx$.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the
subroutines {\tt eval\_F}, {\tt eval\_G},
{\tt eval\_H} and {\tt eval\_PREC}
(see Section~\ref{typeuserdata}).

\ittf{U} is a rank-one \intentout\ array argument of type \realdp\
whose components on output should contain the product
sum $\bmu = \bmP(\bmx) \bmv$.

\ittf{V} is a rank-one \intentin\ array argument of type \realdp\
whose components contain the vector $\bmv$.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Reverse communication %%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\label{reverse}Reverse Communication Information}

A positive value of {\tt inform\%status} on exit from
{\tt \packagename\_solve}
indicates that
\solver\ is seeking further information---this will happen
if the user has chosen not to evaluate function or
derivative values internally (see Section~\ref{fdv}).
The user should compute the required information and re-enter \solver\
with {\tt inform\%status} and all other arguments (except those specifically
mentioned below) unchanged.

Possible values of {\tt inform\%status} and the information required are
\begin{description}
\ittf{2.} The user should compute the objective function
     value $f(\bmx)$ at the point $\bmx$ indicated in {\tt nlp\%X}.
     The required value should be set in {\tt nlp\%f}, and
     {\tt data\%eval\_status} should be set to 0. If the user is
     unable to evaluate $f(\bmx)$---for instance, if the function is
     undefined at $\bmx$---the user need not set {\tt nlp\%f}, but
     should then set {\tt data\%eval\_status} to a non-zero value.

\ittf{3.} The user should compute the gradient
     of the objective function $\nabla_x f(\bmx)$ at the point $\bmx$
     indicated in {\tt nlp\%X}.
     The value of the $i$-th component of the gradient should be set
     in {\tt nlp\%G(i)},      for $i = 1, \ldots, n$ and
     {\tt data\%eval\_status} should be set to 0. If the user is
     unable to evaluate a component of $\nabla_x f(\bmx)$---for instance,
     if a component of the gradient is
     undefined at $\bmx$---the user need not set {\tt nlp\%G}, but
     should then set {\tt data\%eval\_status} to a non-zero value.

\ittf{4.} The user should compute the Hessian
     of the objective function $\nabla_{xx} f(\bmx)$ at the point $\bmx$
     indicated in {\tt nlp\%X}.
     The value $l$-th component of the Hessian stored according to the
     scheme input in the remainder of {\tt nlp\%H} (see Section~\ref{typeprob})
     should be set in {\tt nlp\%H\%val(l)},
     for $l = 1, \ldots,$ {\tt  nlp\%H\%ne} and
     {\tt data\%eval\_status} should be set to 0. If the user is
     unable to evaluate a component of $\nabla_{xx} f(\bmx)$---for instance,
     if a component of the Hessian is
     undefined at $\bmx$---the user need not set {\tt nlp\%H\%val}, but
     should then set {\tt data\%eval\_status} to a non-zero value.

\ittf{5.} The user should compute the product
     $\nabla_{xx} f(\bmx)\bmv$ of the Hessian
     of the objective function $\nabla_{xx} f(\bmx)$ at the point $\bmx$
     indicated in {\tt nlp\%X} with the vector $\bmv$ and add the result to
     the vector $\bmu$. The vectors $\bmu$ and $\bmv$ are given in
     {\tt data\%U} and {\tt data\%V} respectively, the resulting
     vector $\bmu + \nabla_{xx} f(\bmx)\bmv$ should be set in {\tt data\%U}
     and  {\tt data\%eval\_status} should be set to 0. If the user is
     unable to evaluate the product---for instance,
     if a component of the Hessian is
     undefined at $\bmx$---the user need not set {\tt nlp\%H\%val}, but
     should then set {\tt data\%eval\_status} to a non-zero value.

\ittf{6.} The user should compute the product $\bmu = \bmP(\bmx)\bmv$
     of their preconditioner $\bmP(\bmx)$ at the point $\bmx$
     indicated in {\tt nlp\%X} with the vector $\bmv$.
     The vectors $\bmv$ is given in {\tt data\%V}, the
     resulting vector $\bmu = \bmP(\bmx)\bmv$ should be set in {\tt data\%U}
     and {\tt data\%eval\_status}
     should be set to 0. If the user is unable to evaluate the product---for
     instance, if a component of the preconditioner is undefined at
     $\bmx$---the user need not set {\tt data\%U}, but should then set
     {\tt data\%eval\_status} to a non-zero value.

     \noindent
     This value {\bf can only occur} if the user has set 
     {\tt control\%norm = -3}, and has not provided an optional
     subroutine {\tt eval\_PREC} (see \S\ref{pv}) to compute the required
     product with the preconditioner.

\ittf{7.} The user should compute the product
     $\bmh = \nabla_{xx} f(\bmx)\bmp$ of the Hessian
     of the objective function $\nabla_{xx} f(\bmx)$ at the point $\bmx$
     indicated in {\tt nlp\%X} with the sparse vector $\bmp$.
     The nonzeros of $\bmp$ are stored in
     {\tt data\%P(data\%INDEX\_nz\_p(data}
     {\tt \%nnz\_p\_l:data\%nnz\_p\_u))}
     while the nonzeros of $\bmh$ should be returned in
     {\tt data\%HP(data\%INDEX\_nz\_hp(1}
     {\tt :data\%nnz\_hp))}; the user must set 
     {\tt data\%nnz\_hp} and {\tt data\%INDEX\_nz\_hp} accordingly,
     and  {\tt data\%eval\_status} should be set to 0. If the user is
     unable to evaluate the product---for instance, if a component of 
     the Hessian is undefined at $\bmx$---the user need not set 
     {\tt data\%HP}, {\tt data\%INDEX\_nz\_hp} and {\tt data\%nnz\_hp}
     but should then set {\tt data\%eval\_status} to a non-zero value.

     \noindent
     This value {\bf will not occur} if the user has set 
     {\tt control\%hessian\_available} to \true\, and can provide
     values of $\nabla_{xx} f(\bmx)$  either by calls to {\tt eval\_H} 
     (see \S\ref{hfv}) or by reverse communication (see 
     {\tt inform\%status = 4}, above).

\ittf{23.} The user should follow the instructions for 2 {\bf and} 3 
     above before returning.

\ittf{25.} The user should follow the instructions for 2 {\bf and} 5
     above before returning.

\ittf{35.} The user should follow the instructions for 3 {\bf and} 5
     above before returning.

\ittf{235.} The user should follow the instructions for 2, 3 {\bf and} 5 
     above before returning.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\galerrors
A negative value of {\tt inform\%status} on exit from
{\tt \packagename\_solve}
or
{\tt \packagename\_terminate}
indicates that an error has occurred (but note that the
value {\tt \galbudgetexhausted} that indicates the evaluation 
budget has been achieved is highly likely to occur).
No further calls should be made
until the error has been corrected. Possible values are:

\begin{description}

\itt{\galerrallocate.} An allocation error occurred.
A message indicating the offending
array is written on unit {\tt control\%error}, and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc}, respectively.

\itt{\galerrdeallocate.} A deallocation error occurred.
A message indicating the offending
array is written on unit {\tt control\%error} and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc}, respectively.

\itt{\galerrrestrictions.}
  The restriction {\tt nlp\%n} $> 0$
  or requirement that {\tt nlp\%H\_type} contains its relevant string
  {\tt 'DENSE'}, {\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_ROWS'}
  or {\tt 'DIAGONAL'}
  has been violated.

%\itt{-3.} At least one of the arrays
% {\tt p\%A\_val}, {\tt p\%A\_row}, {\tt p\%A\_col},
% {\tt p\%H\_val}, {\tt p\%H\_row} or {\tt p\%H\_col},
% is not large enough to hold the original, or reordered, matrices $\bmA$
% or $\bmH$.

\itt{\galerrbadbounds.} The bound constraints are inconsistent or infinite.

\itt{\galerrunbounded.}  The objective function appears to be unbounded
 from below on the feasible set.

\itt{\galerranalysis.} The analysis phase of the factorization failed;
 the return status from the factorization
    package is given in the component {\tt inform\%fac\-t\-or\_status}.

\itt{\galerrfactorization.} The factorization failed;
 the return status from the factorization
    package is given in the component {\tt inform\%fac\-t\-or\_status}.

\itt{\galerrsolve.} The solution of a set of linear equations
 using factors from the factorization package failed;
 the return status from the factorization
    package is given in the component {\tt inform\%fac\-t\-or\_status}.

\itt{\galerrillconditioned.} The problem is so ill-conditioned that
  further progress is impossible.

\itt{\galerrtinystep.} The step is too small to make further impact.

\itt{\galerrcpulimit.} The elapsed CPU or system clock time limit has been
    reached. This may happen if either {\tt control\%cpu\_time\_limit} or
    {\tt control\%clock\_time\_limit} is too small, but may also be symptomatic
    of a badly scaled problem.

\itt{\galerralive.} The user has forced termination of \solver\
     by removing the file named {\tt control\%a\-live\_file} from
     unit {\tt control\%alive\_unit}.

\itt{\galerrunknownstorage.} The Hessian storage type in
    {\tt nlp\%H\_type} is not one of 
    {\tt 'DENSE'}, {\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_ROWS'}
    or {\tt 'DIAGONAL'}.

\itt{\galerrmaxstorage.} The hash table used to store the dictionary
     of vertices of the sub-boxes is full, and there is no room to increase
     it further.

\itt{\galbudgetexhausted.} The budget limit on function evaluations has
    been reached.  This will happen if the limit {\tt max\_evals} is
    exceeded, and is quite normal for stochastic global-optimization methods.
    The user may explore increasing {\tt max\_evals} to see if that 
    produces a lower value of the objective function, but there are 
    unfortunately no guarantees.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Further features %%%%%%%%%%%%%%%%%%%%%%%%

\galfeatures
\noindent In this section, we describe an alternative means of setting
control parameters, that is components of the variable {\tt control} of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}),
by reading an appropriate data specification file using the
subroutine {\tt \packagename\_read\_specfile}. This facility
is useful as it allows a user to change  {\tt \packagename} control parameters
without editing and recompiling programs that call {\tt \packagename}.

A specification file, or specfile, is a data file containing a number of
"specification commands". Each command occurs on a separate line,
and comprises a "keyword",
which is a string (in a close-to-natural language) used to identify a
control parameter, and
an (optional) "value", which defines the value to be assigned to the given
control parameter. All keywords and values are case insensitive,
keywords may be preceded by one or more blanks but
values must not contain blanks, and
each value must be separated from its keyword by at least one blank.
Values must not contain more than 30 characters, and
each line of the specfile is limited to 80 characters,
including the blanks separating keyword and value.

The portion of the specification file used by
{\tt \packagename\_read\_specfile}
must start
with a "{\tt BEGIN \packagename}" command and end with an
"{\tt END}" command.  The syntax of the specfile is thus defined as follows:
\begin{verbatim}
  ( .. lines ignored by DGO_read_specfile .. )
    BEGIN DGO
       keyword    value
       .......    .....
       keyword    value
    END
  ( .. lines ignored by DGO_read_specfile .. )
\end{verbatim}
where keyword and value are two strings separated by (at least) one blank.
The ``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiter command lines
may contain additional (trailing) strings so long as such strings are
separated by one or more blanks, so that lines such as
\begin{verbatim}
    BEGIN DGO SPECIFICATION
\end{verbatim}
and
\begin{verbatim}
    END DGO SPECIFICATION
\end{verbatim}
are acceptable. Furthermore,
between the
``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiters,
specification commands may occur in any order.  Blank lines and
lines whose first non-blank character is {\tt !} or {\tt *} are ignored.
The content
of a line after a {\tt !} or {\tt *} character is also
ignored (as is the {\tt !} or {\tt *}
character itself). This provides an easy manner to "comment out" some
specification commands, or to comment specific values
of certain control parameters.

The value of a control parameters may be of three different types, namely
integer, logical or real.
Integer and real values may be expressed in any relevant Fortran integer and
floating-point formats (respectively). Permitted values for logical
parameters are "{\tt ON}", "{\tt TRUE}", "{\tt .TRUE.}", "{\tt T}",
"{\tt YES}", "{\tt Y}", or "{\tt OFF}", "{\tt NO}",
"{\tt N}", "{\tt FALSE}", "{\tt .FALSE.}" and "{\tt F}".
Empty values are also allowed for
logical control parameters, and are interpreted as "{\tt TRUE}".

The specification file must be open for
input when {\tt \packagename\_read\_specfile}
is called, and the associated device number
passed to the routine in device (see below).
Note that the corresponding
file is {\tt REWIND}ed, which makes it possible to combine the specifications
for more than one program/routine.  For the same reason, the file is not
closed by {\tt \packagename\_read\_specfile}.

\subsubsection{To read control parameters from a specification file}
\label{readspec}

Control parameters may be read from a file as follows:
\hskip0.5in
\def\baselinestretch{0.8} {\tt
\begin{verbatim}
     CALL DGO_read_specfile( control, device )
\end{verbatim}
}
\def\baselinestretch{1.0}

\begin{description}
\itt{control} is a scalar \intentinout argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}).
Default values should have already been set, perhaps by calling
{\tt \packagename\_initialize}.
On exit, individual components of {\tt control} may have been changed
according to the commands found in the specfile. Specfile commands and
the component (see Section~\ref{typecontrol}) of {\tt control}
that each affects are given in Table~\vref{specfile}.

\bctable{|l|l|l|}
\hline
  command & component of {\tt control} & value type \\
\hline
  {\tt error-printout-device} & {\tt \%error} & integer \\
  {\tt printout-device} & {\tt \%out} & integer \\
  {\tt print-level} & {\tt \%print\_level} & integer \\
  {\tt start-print} & {\tt \%start\_print} & integer \\
  {\tt stop-print} & {\tt \%stop\_print} & integer \\
  {\tt iterations-between-printing} & {\tt \%print\_gap} & integer \\
  {\tt maximum-number-of-iterations} & {\tt \%maxit} & integer \\
  {\tt maximum-number-of-evaluations} & {tt \%max\_evals} & integer \\
  {\tt initial-dictionary-size} & {tt \%dictionary\_size} & integer \\
  {\tt alive-device} & {\tt \%alive\_unit} & integer \\
  {\tt infinity-value} & {\tt \%infinity} & real \\
  {\tt lipschitz-lower-bound} & {\tt \%lipschitz\_lower\_bound} & real \\
  {\tt lipschitz-reliability-parameter} & {\tt \%lipschitz\_reliability} & real \\
  {\tt lipschitz-control-parameter} & {\tt \%lipschitz\_control} & real \\
  {\tt maximum-box-length-required} & {\tt \%stop\_length} & real \\
  {\tt maximum-objective-gap-required} & {\tt \%stop\_f} & real \\
  {\tt minimum-objective-before-unbounded} & {\tt \%obj\_unbounded} & real \\
  {\tt maximum-cpu-time-limit} & {\tt \%cpu\_time\_limit} & real \\
  {\tt maximum-clock-time-limit} & {\tt \%clock\_time\_limit} & real \\
  {\tt hessian-available}  & {\tt \%hessian\_available} & logical \\
  {\tt prune-boxes}  & {\tt \%prune} & logical \\
  {\tt perform-local-optimization}  & {\tt \%perform\_local\_optimization} & logical \\
  {\tt space-critical}   & {\tt \%space\_critical} & logical \\
  {\tt deallocate-error-fatal}   & {\tt \%deallocate\_error\_fatal} & logical \\
  {\tt alive-filename} & {\tt \%alive\_file} & character \\
\hline

\ectable{\label{specfile}Specfile commands and associated
components of {\tt control}.}

\itt{device} is a scalar \intentin argument of type \integer,
that must be set to the unit number on which the specfile
has been opened. If {\tt device} is not open, {\tt control} will
not be altered and execution will continue, but an error message
will be printed on unit {\tt control\%error}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Information printed %%%%%%%%%%%%%%%%%%%%%%%%

\galinfo
If {\tt control\%print\_level} is positive, information about the progress
of the algorithm will be printed on unit {\tt control\-\%out}.
If {\tt control\%print\_level} $= 1$, a single line of output will be produced
every time the objective function improves. 
This will include the number of attempts to improve the objective so far, 
the values of the objective function and the norm of its
gradient, and the number of function and gradient evaluations.

If {\tt control\%print\_level} $\geq 2$ this
output will be increased to provide significant detail of each iteration.
Further details concerning the attempted solution of the models
may be obtained by increasing
{\tt control\%TRB\_control\%print\_level},
and
{\tt control\%UGO\_control\%print\-\_level}.

%%%%%%%%%%%%%%%%%%%%%% GENERAL INFORMATION %%%%%%%%%%%%%%%%%%%%%%%%

\galgeneral

\galcommon None.
\galworkspace Provided automatically by the module.
\galroutines None.
\galmodules {\tt \packagename\_solve} calls the \galahad\ packages
{\tt GALAHAD\_CLOCK},
{\tt GALAHAD\_SY\-M\-BOLS}, \sloppy
{\tt GALAHAD\_HASH},
{\tt GALAHAD\_NLPT},
{\tt GALAHAD\_USERDATA},
{\tt GALAHAD\_SPECFILE},
{\tt GALAHAD\_SPACE},
{\tt GALAHAD\_\-NORMS},
{\tt GALAHAD\_UGO}
and 
{\tt GALAHAD\_TRB}.
\galio Output is under control of the arguments
 {\tt control\%error}, {\tt control\%out} and {\tt control\%print\_level}.
\galrestrictions {\tt nlp\%n} $> 0$ and
{\tt nlp\%H\_type} $\in \{${\tt 'DENSE'},
 {\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_ROWS'}, {\tt 'DIAGONAL'} $\}$.
\galportability ISO Fortran~95 + TR 15581 or Fortran~2003.
The package is thread-safe.

%%%%%%%%%%%%%%%%%%%%%% METHOD %%%%%%%%%%%%%%%%%%%%%%%%

\galmethod

Starting with the initial box $\bmx^l \leq \bmx \leq \bmx^u$, a sequence of 
boxes is generated by considering the current set, and partitioning
a promising candidate into three equally-sized sub-boxes by splitting 
along one of the box dimensions. Each partition requires only a pair of 
new function and derivative evaluations, and these values, together with 
estimates of Lipschitz constants, makes it possible to remove other boxes 
from further consideration as soon as they cannot contain a global minimizer. 
Efficient control of the dictionary of vertices of the sub-boxes
is handled using a suitable hashing procedure provided by 
{\tt \libraryname\_HASH}; each sub-box is indexed by the concatenated 
coordinates of a pair of opposite vertices. At various
stages, local minimization in a promising sub-box, using 
{\tt \libraryname\_TRB}, may be used to improve the best-known upper bound 
on the global minimizer.
If $n=1$, the specialised univariate global minimization package 
{\tt \libraryname\_UGO} is called directly.

We reiterate that although there are theoretical guarantees, 
these may require a large number of evaluations as the dimension 
and nonconvexity increase.
Thus the method should best be viewed as a heuristic to try to find
a reasonable approximation of the global minimum.

\galreferences
\vspace*{1mm}

\noindent
The global minimization method employed is an extension of that due to
\vspace*{1mm}

\noindent
Ya. D. Sergeyev and D. E. Kasov (2015),
``A deterministic global optimization using smooth diagonal 
auxiliary functions'',
Communications in Nonlinear Science and Numerical Simulation,
Vol 21, Nos 1-3, pp. 99-111.
\vspace*{1mm}

\noindent
but adapted to use 2nd derivatives, while in the special case when $n=1$,
a simplification based on the ideas in
\vspace*{1mm}

\noindent
D. Lera and Ya. D. Sergeyev (2013),
``Acceleration of univariate global optimization algorithms working with
Lipschitz functions and Lipschitz first derivatives''
SIAM J. Optimization Vol. 23, No. 1, pp. 508–529
\vspace*{1mm}

\noindent
is used instead. The generic bound-constrained trust-region method used 
for local minimization is described in detail in
\vspace*{1mm}

\noindent
A. R. Conn, N. I. M. Gould and Ph. L. Toint (2000),
Trust-region methods.
SIAM/MPS Series on Optimization.

\noindent


%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\galexamples
Suppose we wish to minimize the parametric objective function
$f(\bmx) = ( 4 + p * x_1^2 + \frac{1}{3} x_1^4 ) x1^2
                 + x_1 x_2 + ( 4 x_2^2 - 4 ) * x_2^2$
when the parameter $p$ takes the values -2.1,
and the components of $\bmx$ are required to satisfy the
bounds $-3 \leq x_1 \leq 3$ and $-2 \leq x_2 \leq 2$.
We may use the following code:

{\tt \small
\VerbatimInput{\packageexample}
}
\noindent
Notice how the parameter $p$ is passed to the function 
evaluation routines via the {\tt real} component of the derived type 
{\tt userdata}.
The code produces the following output:
{\tt \small
\VerbatimInput{\packageresults}
}
\noindent
If the user prefers to provide function, gradient and Hessian information
without calls to specified routines, the following code is appropriate.
{\tt \small
\VerbatimInput{\packageexampleb}
}
\noindent
This produces the same output.
%following output:
%{\tt \small
%\VerbatimInput{\packageresultsb}
%}
%\noindent

\end{document}

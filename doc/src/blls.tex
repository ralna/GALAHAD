\documentclass{galahad}

% set the package name

\newcommand{\package}{blls}
\newcommand{\packagename}{BLLS}
\newcommand{\fullpackagename}{\libraryname\_\packagename}
\newcommand{\solver}{{\tt \fullpackagename\_solve}}

\begin{document}

\galheader

%%%%%%%%%%%%%%%%%%%%%% SUMMARY %%%%%%%%%%%%%%%%%%%%%%%%

\galsummary
This package uses a preconditioned, projected-gradient method
to solve the {\bf bound-constrained regularized linear least-squares problem}
\disp{\mbox{minimize}\;\; r(\bmx) = q(\bmx) + \half \sigma \|\bmx\|_2^2,
\;\;\mbox{where}\;\; q(\bmx) = \half \| \bmA \bmx - \bmb\|_W^2}
subject to the simple bound constraints
\disp{x_{j}^{l}  \leq  x_{j}^{ } \leq  x_{j}^{u} , \;\;\; j = 1, \ldots , n,}
where the $m$ by $n$ real matrix $\bmA$, the vectors 
$\bmb$, $\bmx^{l}$, $\bmx^{u}$ and the non-negative weights $\bmw$ and 
$\sigma$ are given, and where the Euclidean and weighted-Euclidean norms
are given by $\|\bmv\|_2^2 = \bmv^T \bmv$ and $\|\bmv\|_W^2 = \bmv^T \bmW \bmv$,
respectively, with $\bmW = \mbox{diag}(\bmw)$.
Any of the constraint bounds $x_{j}^{l}$ and $x_{j}^{u}$ may be infinite.
Full advantage is taken of any zero coefficients of the Jacobian matrix $\bmA$
of the {\bf residuals} $\bmc(\bmx) = \bmA \bmx - \bmb$;
the matrix need not be provided as there are options to obtain matrix-vector
products involving $\bmA$ and its transpose either by reverse communication
or from a user-provided subroutine.

%%%%%%%%%%%%%%%%%%%%%% attributes %%%%%%%%%%%%%%%%%%%%%%%%

\galattributes
\galversions{\tt  \fullpackagename\_single, \fullpackagename\_double}.
\galuses {\tt GALAHAD\_CPU\_time},
{\tt GALAHAD\-\_SY\-M\-BOLS},
{\tt GALAHAD\-\_\-SPACE},
{\tt GALAHAD\_STRING},
{\tt GALAHAD\_SORT},
{\tt GALAHAD\_NORMS},
{\tt GALAHAD\_CONVERT},
{\tt GALAHAD\_SBLS},
{\tt GALAHAD\_QPT},
{\tt GALAHAD\_QPD},
{\tt GALAHAD\_USERDATA}.
{\tt GALAHAD\_SPECFILE}.
\galdate December 2020.
\galorigin N. I. M. Gould, STFC-Rutherford Appleton Laboratory.
\gallanguage Fortran~95 + TR 15581 or Fortran~2003.

%%%%%%%%%%%%%%%%%%%%%% HOW TO USE %%%%%%%%%%%%%%%%%%%%%%%%

\galhowto

%\subsection{Calling sequences}

Access to the package requires a {\tt USE} statement such as

\medskip\noindent{\em Single precision version}

\hspace{8mm} {\tt USE \fullpackagename\_single}

\medskip\noindent{\em Double precision version}

\hspace{8mm} {\tt USE  \fullpackagename\_double}

\medskip

\noindent
If it is required to use both modules at the same time, the derived types
{\tt SMT\_type},
{\tt QPT\_problem\_type},
{\tt NLPT\_userdata\-\_type},
{\tt \packagename\_time\_type},
{\tt \packagename\_control\_type},
{\tt \packagename\_inform\_type}
and
{\tt \packagename\_data\_type}
(Section~\ref{galtypes})
and the subroutines
{\tt \packagename\_initialize},
{\tt \packagename\_\-solve},
{\tt \packagename\_terminate},
(Section~\ref{galarguments})
and
{\tt \packagename\_read\_specfile}
(Section~\ref{galfeatures})
must be renamed on one of the {\tt USE} statements.

%%%%%%%%%%%%%%%%%%%%%% matrix formats %%%%%%%%%%%%%%%%%%%%%%%%

\galmatrix
When it is explicitly available,
the coefficient matrix $\bmA$ may be stored in a variety of input formats.

\subsubsection{Dense row-wise storage format}\label{dense-row}
The matrix $\bmA$ is stored as a compact dense matrix by rows,
that is, the values of the entries of each row in turn are
stored in order within an appropriate real one-dimensional array.
Component $n \ast (i-1) + j$ of the storage array {\tt
  A\%val} will hold the value $\bmA_{i,j}$ for $i = 1, \ldots , m$, $j =
1, \ldots , n$.

\subsubsection{Dense column-wise storage format}\label{dense-column}
The matrix $\bmA$ is stored as a compact
dense matrix by columns, that is, the values of the entries of each column
in turn are stored in order within an appropriate real one-dimensional array.
Component $m \ast (j-1) + i$ of the storage array {\tt
  A\%val} will hold the value $\bmA_{i,j}$ for $i = 1, \ldots , m$, $j =
1, \ldots , n$.

\subsubsection{Sparse coordinate storage format}\label{coordinate}
Only the nonzero entries of the matrices are stored. For the $l$-th
entry of $\bmA$, its row index $i$, column index $j$ and value
$\bmA_{ij}$ are stored in the $l$-th components of the integer arrays
{\tt A\%row}, {\tt A\%col} and real array {\tt A\%val}.
The order is unimportant, but the total number of entries {\tt A\%ne} is
required.

\subsubsection{Sparse row-wise storage format}\label{rowwise}
Again only the nonzero entries are stored, but this time they are
ordered so that those in row $i$ appear directly before those in row
$i+1$. For the $i$-th row of $\bmA$, the $i$-th component of the integer
array {\tt A\%ptr} holds the position of the first entry in this row,
while {\tt A\%ptr} $(m+1)$ holds the total number of entries plus one.
The column indices $j$ and values $\bmA_{ij}$ of the entries in the
$i$-th row are stored in components $l =$ {\tt A\%ptr}$(i)$, \ldots
,{\tt A\%ptr} $(i+1)-1$ of the integer array {\tt A\%col}, and real
array {\tt A\%val}, respectively.

\subsubsection{Sparse column-wise storage format}\label{columnwise}
Yet again only the nonzero entries are stored, but this time they are
ordered so that those in column $j$ appear directly before those in column
$j+1$. For the $j$-th column of $\bmA$, the $j$-th component of the integer
array {\tt A\%ptr} holds the position of the first entry in this column,
while {\tt A\%ptr} $(n+1)$ holds the total number of entries plus one.
The row indices $i$ and values $\bmA_{ij}$ of the entries in the
$j$-th column are stored in components $l =$ {\tt A\%ptr}$(j)$, \ldots
,{\tt A\%ptr} $(j+1)-1$ of the integer array {\tt A\%row}, and real
array {\tt A\%val}, respectively.

For sparse matrices, the row- and column-wise storage schemes almost always
requires less storage than their predecessor.

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\galtypes
Ten derived data types are accessible from the package.

%%%%%%%%%%% matrix data type %%%%%%%%%%%

\subsubsection{The derived data type for holding matrices}\label{typesmt}
The derived data type {\tt SMT\_TYPE} is used to hold the matrix $\bmA$.
The components of {\tt SMT\_TYPE} used here are:

\begin{description}

\ittf{m} is a scalar component of type default \integer,
that holds the number of rows in the matrix.

\ittf{n} is a scalar component of type default \integer,
that holds the number of columns in the matrix.

\ittf{ne} is a scalar variable of type default \integer, that
holds the number of matrix entries.

\ittf{type} is a rank-one allocatable array of type default \character, that
is used to indicate the matrix storage scheme used. Its precise length and
content depends on the type of matrix to be stored (see \S\ref{typeprob}).

\ittf{val} is a rank-one allocatable array of type default \realdp\,
and dimension at least {\tt ne}, that holds the values of the entries.
Any duplicated entries that appear in the sparse
coordinate or row-wise schemes will be summed.

\ittf{row} is a rank-one allocatable array of type default \integer,
and dimension at least {\tt ne}, that may hold the row indices of the entries.
(see \S\ref{coordinate} and \S\ref{columnwise}).

\ittf{col} is a rank-one allocatable array of type default \integer,
and dimension at least {\tt ne}, that may the column indices of the entries
(see \S\ref{coordinate}--\ref{rowwise}).

\ittf{ptr} is a rank-one allocatable array of type default \integer,
and dimension at least {\tt m + 1}, that may hold the pointers to
the first entry in each row (see \S\ref{rowwise}).
or dimension at least {\tt n + 1}, that may hold the pointers to
the first entry in each column (see \S\ref{columnwise}).

\end{description}

%%%%%%%%%%% problem type %%%%%%%%%%%

\subsubsection{The derived data type for holding the problem}\label{typeprob}
The derived data type {\tt QPT\_problem\_type} is used to hold
the problem. The components of
{\tt QPT\_problem\_type}
are:

\begin{description}

\ittf{n} is a scalar variable of type default \integer,
 that holds the number of optimization variables, $n$.

\ittf{m} is a scalar variable of type default \integer,
 that holds the number of residuals, $m$.

\ittf{A} is scalar variable of type {\tt SMT\_TYPE}
that holds the Jacobian matrix $\bmA$ of the residuals (if it is available).
The following components are used here:

\begin{description}

\itt{A\%type} is an allocatable array of rank one and type default
\character, that
is used to indicate the storage scheme used. If the dense row-wise
storage scheme (see Section~\ref{dense-row}) is used,
the first twelve components of {\tt A\%type} must contain the
string {\tt DENSE\_BY\_ROWS}, while if the column-wise scheme
(see Section~\ref{dense-column}) is used,
the fifteen components of {\tt A\%type} must contain the
string {\tt DENSE\_BY\_COLUMNS}.
For the sparse coordinate scheme (see Section~\ref{coordinate}),
the first ten components of {\tt A\%type} must contain the
string {\tt COORDINATE},
for the sparse row-wise storage scheme (see Section~\ref{rowwise}),
the first fourteen components of {\tt A\%type} must contain the
string {\tt SPARSE\_BY\_ROWS}.
and for the sparse column-wise storage scheme (see Section~\ref{columnwise}),
the first seventeen components of {\tt A\%type} must contain the
string {\tt SPARSE\_BY\_COLUMNS}.

For convenience, the procedure {\tt SMT\_put}
may be used to allocate sufficient space and insert the required keyword
into {\tt A\%type}.
For example, if {\tt nlp} is of derived type {\tt \packagename\_problem\_type}
and involves a Jacobian we wish to store using the coordinate scheme,
we may simply
%\vspace*{-2mm}
{\tt
\begin{verbatim}
        CALL SMT_put( nlp%A%type, 'COORDINATE' )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent
See the documentation for the \galahad\ package {\tt SMT}
for further details on the use of {\tt SMT\_put}.

\noindent
{\tt A\%type} should {\bf not} be allocated if $\bmA$ is unavailable
(and access provided to  $\bmA$ provided by other means, see later sections), 
and in this case the remaining components of {\tt A} need not be set.

\itt{A\%ne} is a scalar variable of type default \integer, that
holds the number of entries in $\bmA$
in the sparse coordinate storage scheme (see Section~\ref{coordinate}).
It need not be set for any of the other three schemes.

\itt{A\%val} is a rank-one allocatable array of type default \realdp, that holds
the values of the entries of the Jacobian matrix $\bmA$ in any of the
storage schemes discussed in Section~\ref{galmatrix}.

\itt{A\%row} is a rank-one allocatable array of type default \integer,
that holds the row indices of $\bmA$ in the sparse coordinate storage
scheme (see Section~\ref{coordinate}).
It need not be allocated for any of the other three schemes.

\itt{A\%col} is a rank-one allocatable array variable of type default \integer,
that holds the column indices of $\bmA$ in either the sparse coordinate
(see Section~\ref{coordinate}), or the sparse row-wise
(see Section~\ref{rowwise}) storage scheme.
It need not be allocated when the dense or column-wise storage schemes are used.

\itt{A\%row} is a rank-one allocatable array variable of type default \integer,
that holds the row indices of $\bmA$ in either the sparse coordinate
(see Section~\ref{coordinate}), or the sparse column-wise
(see Section~\ref{columnwise}) storage scheme.
It need not be allocated when the dense or row-wise storage schemes are used.

\itt{A\%ptr} is a rank-one allocatable array and type default \integer,
that must be of dimension {\tt m+1}
and hold the starting position of each row of $\bmA$, as well
as the total number of entries plus one, in the sparse row-wise storage
scheme (see Section~\ref{rowwise}).
If the sparse column-wise storage scheme (see Section~\ref{columnwise})
is used, it must instead be of dimension {\tt n+1}
and hold the starting position of each column of $\bmA$, as well
as the total number of entries plus one.
It need not be allocated when the
other schemes are used.

\end{description}

\ittf{B} is a rank-one allocatable array of dimension {\tt m} and type
default \realdp, that holds the constant term $\bmb$ in the residuals.
The $i$-th component of {\tt B}, $i = 1, \ldots, m$, contains $\bmb_{i}$.

\ittf{C} is a rank-one allocatable array of dimension {\tt m} and type
default \realdp, that holds the residuals, $\bmc(\bmx) = \bmA \bmx - \bmb$,
at the point $\bmx$. The $i$-th component of
{\tt C}, $i = 1, \ldots, m$, contains $\bmc_{i}(\bmx)$.

\ittf{G} is a rank-one allocatable array of dimension {\tt n} and type
default \realdp, that holds the gradient of the objective
 $\bmg(\bmx) = \bmA^T \bmc(\bmx)$, at the point $\bmx$. The $j$-th component of
{\tt G}, $j = 1, \ldots, n$, contains $\bmg_{j}(\bmx)$.

\ittf{X\_l} is a rank-one allocatable array of dimension {\tt n} and type
default \realdp, that holds
the vector of lower bounds $\bmx^{l}$ on the the variables.
The $j$-th component of {\tt X\_l}, $j = 1, \ldots , n$,
contains $\bmx_{j}^{l}$.
Infinite bounds are allowed by setting the corresponding
components of {\tt X\_l} to any value smaller than {\tt -infinity},
where {\tt infinity} is a component of the control array {\tt control}
(see Section~\ref{typecontrol}).

\ittf{X\_u} is a rank-one allocatable array of dimension {\tt n} and type
default \realdp, that holds
the vector of upper bounds $\bmx^{u}$ on the variables.
The $j$-th component of {\tt X\_u}, $j = 1, \ldots , n$,
contains $\bmx_{j}^{u}$.
Infinite bounds are allowed by setting the corresponding
components of {\tt X\_u} to any value larger than that {\tt infinity},
where {\tt infinity} is a component of the control array {\tt control}
(see Section~\ref{typecontrol}).

\ittf{X} is a rank-one allocatable array of dimension {\tt n} and type
default \realdp,
that holds the values $\bmx$ of the optimization variables.
The $j$-th component of {\tt X}, $j = 1,  \ldots , n$, contains $x_{j}$.

\ittf{Z} is a rank-one allocatable array of dimension {\tt n} and type default
\realdp, that holds
the values $\bmz$ of estimates  of the dual variables
corresponding to the simple bound constraints (see Section~\ref{galmethod}).
The $j$-th component of {\tt Z}, $j = 1,  \ldots ,  n$, contains $z_{j}$.

\end{description}

%%%%%%%%%%% control type %%%%%%%%%%%

\subsubsection{The derived data type for holding control
 parameters}\label{typecontrol}
The derived data type
{\tt \packagename\_control\_type}
is used to hold controlling data. Default values may be obtained by calling
{\tt \packagename\_initialize}
(see Section~\ref{subinit}),
while components may also be changed by calling
{\tt \packagename\_read\-\_specfile}
(see Section~\ref{readspec}).
The components of
{\tt \packagename\_control\_type}
are:

\begin{description}

\itt{error} is a scalar variable of type default \integer, that holds the
stream number for error messages. Printing of error messages in
{\tt \packagename\_solve} and {\tt \packagename\_terminate}
is suppressed if {\tt error} $\leq 0$.
The default is {\tt error = 6}.

\ittf{out} is a scalar variable of type default \integer, that holds the
stream number for informational messages. Printing of informational messages in
{\tt \packagename\_solve} is suppressed if {\tt out} $< 0$.
The default is {\tt out = 6}.

\itt{print\_level} is a scalar variable of type default \integer, that is used
to control the amount of informational output which is required. No
informational output will occur if {\tt print\_level} $\leq 0$. If
{\tt print\_level} $= 1$, a single line of output will be produced for each
iteration of the process. If {\tt print\_level} $\geq 2$, this output will be
increased to provide significant detail of each iteration.
The default is {\tt print\_level = 0}.

\itt{start\_print} is a scalar variable of type default \integer, that specifies
the first iteration for which printing will be permitted in \solver.
If {\tt start\_print} is negative, printing will be permitted from the outset.
The default is {\tt start\_print = -1}.

\itt{stop\_print} is a scalar variable of type default \integer, that specifies
the last iteration for which printing will be permitted in  \solver.
If {\tt stop\_print} is negative, printing will be permitted once it has been
started by {\tt start\_print}.
The default is {\tt stop\_print = -1}.

\itt{print\_gap} is a scalar variable of type default \integer.
Once printing has been started, output will occur once every
{\tt print\_gap} iterations. If {\tt print\_gap} is no larger than 1,
printing will be permitted on every iteration.
The default is {\tt print\_gap = 1}.

\itt{maxit} is a scalar variable of type default \integer, that holds the
maximum number of iterations which will be allowed in \solver.
The default is {\tt maxit = 1000}.

\itt{cold\_start} is a scalar variable of type default \integer, that
should be set to 0 if a warm start is required (with variables
assigned according to {\tt X\_stat}, see below), and to any other value if the
values given in {\tt prob\%X} suffice.
The default is {\tt cold\_start = 1}.

\itt{preconditioner} is a scalar variable of type default \integer, that
specifies the type of preconditioner (scaling) used when computing the
search direction. Currently this can be 
{\tt 0} (no preconditioner), 
{\tt 1} (a diagonal preconditioner that normalises the rows of $\bmA$) or
{\tt 2} (a preconditioner supplied by the user either via a subroutine
call of {\tt eval\_PREC}, see \S\ref{prec}, or via reverse communication, 
see \S\ref{reverse}),
although other values may be introduced
in future. The default is {\tt preconditioner = 1}.

\itt{change\_max} is a scalar variable of type default \integer, that
specifies the maximum number of per-iteration changes in the working set
permitted when allowing subspace solution rather than steepest descent
(see \S\ref{galmethod}).
The default is {\tt change\_max = 2}.

\itt{cg\_maxit} is a scalar variable of type default \integer, that holds the
maximum number of conjugate-gradient iterations which will be allowed
per main iteration in \solver.
The default is {\tt cg\_maxit = 1000}, and any negative value will
be interpreted as $n$ + 1.

\itt{arcsearch\_max\_steps} is a scalar variable of type default \integer,
that specifies the maximum number of steps allowed in an individual
piecewise arc search.
The default is {\tt arcsearch\_max\_steps = 1000}, and a negative value
removes the limit.

\itt{weight} is a scalar variable of type default \realdp, that is used to
specify the non-negative regularization weight $\sigma$ that controls 
regularization of the objective function. Any value smaller than $0$ will
be regarded as zero.
The default is {\tt weight =} $0.0$.

\itt{infinity} is a scalar variable of type default \realdp, that is used to
specify which constraint bounds are infinite.
Any bound larger than {\tt infinity} in modulus will be regarded as infinite.
The default is {\tt infinity =} $10^{19}$.

\itt{stop\_d} is a scalar variable of type default
\realdp, that holds the
required accuracy for the dual infeasibility (see Section~\ref{galmethod}).
The default is {\tt stop\_d =} $u^{1/3}$,
where $u$ is {\tt EPSILON(1.0)} ({\tt EPSILON(1.0D0)} in
{\tt \fullpackagename\_double}).

\itt{identical\_bounds\_tol}
is a scalar variable of type default \realdp.
Each pair of variable bounds $(x_{j}^{l}, x_{j}^{u})$
that is closer than {\tt identical\_bounds\_tol}
will be reset to the average of their values,
$\half (x_{j}^{l} + x_{j}^{u})$.
The default is {\tt identical\_bounds\_tol =} $u$,
where $u$ is {\tt EPSILON(1.0)} ({\tt EPSILON(1.0D0)} in
{\tt \fullpackagename\_double}).

\itt{stop\_cg\_relative} and {\tt stop\_cg\_absolute}
are scalar variables of type default \realdp,
that hold the relative and absolute convergence tolerances for the
conjugate-gradient iteration that occurs in the face of currently-active
constraints when constructing the search direction.
{\tt \_stop\_cg\_relative = 0.01}
and \sloppy {\tt stop\_cg\_absolute =} $\sqrt{u}$,
where $u$ is {\tt EPSILON(1.0)} ({\tt EPSILON(1.0D0)} in
{\tt \fullpackagename\_double}).

\itt{alpha\_max} is a scalar variable of type default \realdp, that specifies
the largest arc length allowed.
The default is {\tt alpha\_max =} $10^{20}$.

\itt{alpha\_initial} is a scalar variable of type default \realdp, that
specifies the initial arc length during the inexact piecewise arc search.
The default is {\tt alpha\_initial = 1.0}.

\itt{alpha\_reduction} is a scalar variable of type default \realdp, that
specifies the arc length reduction factor for the inexact piecewise arc search.
The default is {\tt alpha\_reduction = 0.5}.

\itt{arcsearch\_acceptance\_tol} is a scalar variable of type default \realdp,
that specifies the required relative reduction during the inexact arc search
The default is {\tt arcsearch\_acceptance\_tol = 0.01}.

\itt{stabilisation\_weight} is a scalar variable of type default \realdp,
that specifies the weight added to the search-direction subproblem to 
stabilise the computation.
The default is {\tt stabilisation\_weight =} $10^{-12}$.

\itt{cpu\_time\_limit} is a scalar variable of type default \realdp,
that is used to specify the maximum permitted CPU time. Any negative
value indicates no limit will be imposed. The default is
{\tt cpu\_time\_limit = - 1.0}.

\itt{direct\_subproblem\_solve} is a scalar variable of type default \logical,
that should be set \true\ if the search over a promising subspace is
carried out using matrix factorization, and \false\ if the conjugate-gradient
least-squares (CGLS) method is to be preferred. The former is generally
more effective so long as the cost of factorization isn't exorbitant.
The default is {\tt direct\_subproblem\_solve = \true}, but the
package will override this if the Jacobian is not explicitly available.

\itt{exact\_arc\_search} is a scalar variable of type default \logical,
that should be set \true\ if the exact minimizer along the search arc is
required, and \false\ if an approximation found by backtracking or
advancing suffices.
The default is {\tt exact\_arc\_search = \true}.

\itt{advance} is a scalar variable of type default \logical, that should
be set \true\ if the approximate arch search is allowed to advance as
well as backtrack.and \false\ if only backtracking is permitted.
The default is {\tt advance = \true}.

\itt{space\_critical} is a scalar variable of type default \logical,
that must be set \true\ if space is critical when allocating arrays
and  \false\ otherwise. The package may run faster if
{\tt space\_critical} is \false\ but at the possible expense of a larger
storage requirement. The default is {\tt space\_critical = .FALSE.}.

\itt{deallocate\_error\_fatal} is a scalar variable of type default \logical,
that must be set \true\ if the user wishes to terminate execution if
a deallocation  fails, and \false\ if an attempt to continue
will be made. The default is {\tt deallocate\_error\_fatal = .FALSE.}.

\itt{prefix} is a scalar variable of type default \character\
and length 30, that may be used to provide a user-selected
character string to preface every line of printed output.
Specifically, each line of output will be prefaced by the string
{\tt prefix(2:LEN(TRIM(prefix))-1)},
thus ignoring the first and last non-null components of the
supplied string. If the user does not want to preface lines by such
a string, they may use the default {\tt prefix = ""}.

\itt{SBLS\_control} is a scalar variable of type
{\tt SBLS\_control\_type} %(see Section~\ref{typeebllsontrol}
whose components are used to control the factorization and/or
preconditioner used,
performed by the package
{\tt \libraryname\_SBLS}.
See the documentation for {\tt \libraryname\_SBLS} for further details.

\end{description}

%%%%%%%%%%% time type %%%%%%%%%%%

\subsubsection{The derived data type for holding timing
 information}\label{typetime}
The derived data type
{\tt \packagename\_time\_type}
is used to hold elapsed CPU times for the various parts of the calculation.
The components of
{\tt \packagename\_time\_type}
are:
\begin{description}
\itt{total} is a scalar variable of type default \real, that gives
 the total time spent in the package.

\itt{analyse} is a scalar variable of type default \real, that gives
 the time spent analysing the required matrices prior to factorization.

\itt{factorize} is a scalar variable of type default \real, that gives
 the time spent factorizing the required matrices.

\itt{solve} is a scalar variable of type default \real, that gives
 the time spent computing the search direction.

\end{description}

%%%%%%%%%%% inform type %%%%%%%%%%%

\subsubsection{The derived data type for holding informational
 parameters}\label{typeinform}
The derived data type
{\tt \packagename\_inform\_type}
is used to hold parameters that give information about the progress and needs
of the algorithm. The components of
{\tt \packagename\_inform\_type}
are:

\begin{description}

\itt{status} is a scalar variable of type default \integer, that gives the
exit status of the algorithm.
%See Sections~\ref{galerrors} and \ref{galinfo}
See Section~\ref{galerrors}
for details.

\itt{alloc\_status} is a scalar variable of type default \integer, that gives
the status of the last attempted array allocation or deallocation.
This will be 0 if {\tt status = 0}.

\itt{bad\_alloc} is a scalar variable of type default \character\
and length 80, that  gives the name of the last internal array
for which there were allocation or deallocation errors.
This will be the null string if {\tt status = 0}.

\itt{factorization\_status} is a scalar variable of type default \integer, that
gives the return status from the matrix factorization.

\itt{iter} is a scalar variable of type default \integer, that
gives the number of iterations performed.

\ittf{obj} is a scalar variable of type default \realdp, that holds the
value of the objective function $r(\bmx)$ at the best estimate of the 
solution found.

\itt{norm_pg} is a scalar variable of type default \realdp, that holds the
Euclidean norm of the projected gradient of $r(\bmx)$ at the best 
estimate of the solution found.

\ittf{time} is a scalar variable of type {\tt \packagename\_time\_type}
whose components are used to hold elapsed CPU times for the various parts
of the calculation (see Section~\ref{typetime}).

\itt{SBLS\_inform} is a scalar variable of type
{\tt SBLS\_inform\_type} % (see Section~\ref{typesblsinform}
whose components provide information about the progress and needs
of the factorization/preconditioner
performed by the package
{\tt \libraryname\_SBLS}.
See the documentation for {\tt \libraryname\_SBLS} for further details.

\end{description}

%%%%%%%%%%% data type %%%%%%%%%%%

\subsubsection{The derived data type for holding problem data}\label{typedata}
The derived data type
{\tt \packagename\_data\_type}
is used to hold all the data for a particular problem,
or sequences of problems with the same structure, between calls of
{\tt \packagename} procedures.
This data should be preserved, untouched, from the initial call to
{\tt \packagename\_initialize}
to the final call to
{\tt \packagename\_terminate}.

%%%%%%%%%%% userdata type %%%%%%%%%%%

\subsubsection{The derived data type for holding user data}\label{typeuserdata}
The derived data type
{\tt NLPT\_userdata\_type}
is available to allow the user to pass data to and from user-supplied
matrix-vector product and preconditioning
subroutines (see Section~\ref{fdv}).
Components of variables of type {\tt NLPT\_userdata\-\_type} may be allocated as
necessary. The following components are available:

\begin{description}
\itt{integer} is a rank-one allocatable array of type default \integer.
\ittf{real} is a rank-one allocatable array of type default  \realdp
\itt{complex} is a rank-one allocatable array of type default \complexdp.
\itt{character} is a rank-one allocatable array of type default \character.
\itt{logical} is a rank-one allocatable array of type default \logical.
\itt{integer\_pointer} is a rank-one pointer array of type default \integer.
\itt{real\_pointer} is a rank-one pointer array of type default  \realdp
\itt{complex\_pointer} is a rank-one pointer array of type default \complexdp.
\itt{character\_pointer} is a rank-one pointer array of type default \character.
\itt{logical\_pointer} is a rank-one pointer array of type default \logical.
\end{description}

%%%%%%%%%%% reverse type %%%%%%%%%%%

\subsubsection{The derived data type for holding reverse-communication data}\label{typereverse}
The derived data type
{\tt \packagename\_reverse\_type}
is used to hold data needed for reverse communication when this is
required.
The components of
{\tt \packagename\_reverse\_type}
are:

\begin{description}

\itt{nz\_v\_start} is a scalar variable of type default \integer, that
may be used to hold the starting position in {\tt NZ\_v} (see below)
of the list of indices of nonzero components of $\bmv$.

\itt{nz\_v\_end} is a scalar variable of type default \integer, that
may be used to hold the finishing position in {\tt NZ\_v} (see below)
of the list of indices of nonzero components of $\bmv$.

\itt{NZ\_v} is a rank-one allocatable array of dimension $n$
and type default \integer, that may be used to hold the indices of the
nonzero components of $\bmv$. If used, components
{\tt NZ\_v(nz\_v\_start:nz\_v\_end)} of {\tt V} (see below) will be nonzero.

\itt{V} is a rank-one allocatable array of dimension $n$
and type default \realdp, that is used to hold the components of the
output vector $\bmv$.

\itt{P} is a rank-one allocatable array of dimension $m$
and type default \realdp, that is used to record the components of the
resulting vector $\bmA \bmv$.

\itt{nz\_p\_end} is a scalar variable of type default \integer, that
is used to record the finishing position in {\tt NZ\_p} (see below)
of the list of indices of nonzero components of $\bmA \bmv$ if required.

\itt{NZ\_p} is a rank-one allocatable array of dimension $n$
and type default \integer, that is used to record the list of
indices of nonzero components of $\bmA \bmv$ if required. Components
{\tt NZ\_p(1:nz\_prod\_end)} of {\tt P} should then be nonzero.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\galarguments
There are three procedures for user calls
(see Section~\ref{galfeatures} for further features):

\begin{enumerate}
\item The subroutine
      {\tt \packagename\_initialize}
      is used to set default values, and initialize private data,
      before solving one or more problems with the
      same sparsity and bound structure.
\item The subroutine
      {\tt \packagename\_solve}
      is called to solve the problem.
\item The subroutine
      {\tt \packagename\_terminate}
      is provided to allow the user to automatically deallocate array
       components of the private data, allocated by
       {\tt \packagename\_solve},
       at the end of the solution process.
\end{enumerate}
We use square brackets {\tt [ ]} to indicate \optional\ arguments.

%%%%%% initialization subroutine %%%%%%

\subsubsection{The initialization subroutine}\label{subinit}
 Default values are provided as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_initialize( data, control )}

\vspace*{-3mm}
\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see Section~\ref{typedata}). It is used to hold data about the problem being
solved.

\itt{control} is a scalar \intentout\ argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}).
On exit, {\tt control} contains default values for the components as
described in Section~\ref{typecontrol}.
These values should only be changed after calling
{\tt \packagename\_initialize}.

\end{description}

%%%%%%%%% main solution subroutine %%%%%%

\subsubsection{The bound-constrained linear least-squares subroutine}\label{qps}
The bound-constrained linear least-squares solution algorithm is called
as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_solve( prob, X\_stat, data, control, inform, userdata[,
W, reverse, %eval\_APROD, eval\_ASPROD] )}
\&}
\vspace*{-1mm}

\hspace{37mm}
{\tt
eval\_APROD, eval\_ASPROD, eval\_AFPROD, eval\_PREC] )}

\vspace*{-3mm}
\begin{description}
\ittf{prob} is a scalar \intentinout\ argument of type
{\tt QPT\_problem\_type}
(see Section~\ref{typeprob}).
It is used to hold data about the problem being solved.
The user must allocate and set values for the array components,
and set values for the components
{\tt prob\%B}, {\tt prob\%X\_l}, {\tt prob\%X\_u} and {\tt prob\%X}.
Additionally, the user can provide $\bmA$ by allocating the
relevant array components and setting values for {\tt prob\%A}
using whichever
of the matrix formats described in Section~\ref{galmatrix}
is appropriate for the user's application;
if the effect of $\bmA$ and its transpose are only available to form products
via reverse communication (see {\tt reverse} below)
or with a set of user-supplied subroutines (see {\tt eval\_APROD}
{\tt eval\_ASPROD} and {\tt eval\_AFPROD} below), {\tt prob\%A} is not needed.

The components {\tt prob\%X}
must be set to initial estimates of the primal variables, $\bmx$.
Inappropriate initial values will be altered, so the user should
not be overly concerned if suitable values are not apparent, and may be
content with merely setting {\tt prob\%X=0.0}.
The components {\tt prob\%C}, {\tt prob\%G} and {\tt prob\%Z}
need not be set or allocated on entry.

On exit, the components {\tt prob\%X} and {\tt prob\%Z}
will contain the best estimates of the primal variables $\bmx$,
and dual variables for the bound constraints $\bmz$, respectively.
The components {\tt prob\%C} and {\tt prob\%G}
will contain the residuals $\bmc(\bmx)$
and gradients $\bmg(\bmx)$ at $\bmx$, respectively.
\restrictions {\tt prob\%n} $> 0$, {\tt prob\%m} $> 0$
              and (if $\bmA$ is provided) {\tt prob\%A\%ne} $\geq 0$.
{\tt prob\%A\_type} $\in \{${\tt 'DENSE\_BY\_ROWS'}, {\tt 'DENSE\_BY\_COLUMNS'},
 {\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_\-ROWS'}, {\tt SPARSE\_BY\_COLUMNS}
$\}$.

\itt{X\_stat} is a rank-one \intentinout\ array argument of dimension {\tt prob\%n}
and type default \integer, that indicates which of the simple bound
constraints are in the current working set. Possible values for
{\tt X\_stat(j)}, {\tt j}$=1, \ldots ,$ {\tt prob\%n}, and their meanings are
\begin{description}
\itt{<0} the $j$-th simple bound constraint
is in the working set, on its lower bound,
\itt{>0} the $j$-th simple bound constraint
is in the working set, on its upper bound, and
\itt{0}  the $j$-th simple bound constraint is not in the working set.
\end{description}
Suitable values must be supplied if
{\tt control\%blls\_control\%cold\_start = 0} on entry,
but need not be provided for other input values of {\tt control\%cold\_start}.
Inappropriate values will be ignored.
On exit, {\tt X\_stat} will contain values appropriate for the ultimate
working set.

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see Section~\ref{typedata}). It is used to hold data about the problem being
solved. It must not have been altered {\bf by the user} since the last call to
{\tt \packagename\_initialize}.

\itt{control} is a scalar \intentin\ argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}). Default values may be assigned by calling
{\tt \packagename\_initialize} prior to the first call to
{\tt \packagename\_solve}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see Section~\ref{typeinform}). On initial entry, the component {\tt status}
must be set to {\tt 1}, while other components need not be set.
A successful call to
{\tt \packagename\_solve}
is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see Sections~\ref{reverse} and
\ref{galerrors}.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt NLPT\_userdata\_type} whose components may be used
to communicate user-supplied data
(see Section~\ref{typeuserdata})
to and from the \optional\ subroutines
 {\tt eval\_APROD} and {\tt eval\_ASPROD} (see below).

\ittf{W} is an \optional\ rank-one \intentinout\ array argument of dimension 
{\tt prob\%n} and type default \realdp\ that if present contains the weights
$\bmw$. If {\tt W} is absent, weights of one will be used instead.

\itt{reverse} is an \optional\ scalar \intentinout\ argument of type
{\tt \packagename\_reverse\_type}
(see Section~\ref{typereverse}).
It is used to communicate reverse-communication data between the
subroutine and calling program.
If {\tt reverse} is \present\ and {\tt eval\%APROD} or {\tt eval\%ASPROD}
(see below) are absent, the user should monitor {\tt inform\%status} on exit
(see Section~\ref{reverse}).

\itt{eval\_APROD} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of the
product $\bmp + \bmA \bmv$ or $\bmp + \bmA^T \bmv$
involving the Jacobian (and its transpose) and given vectors $\bmv$ and $\bmp$.
See Section~\ref{jvp} for details.
If {\tt eval\_APROD} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_APROD} is absent, \solver\ will use reverse communication
(see Section~\ref{reverse})
to obtain Jacobian-vector products if {\tt reverse} is \present\ or
otherwise require that the user has provided all relevant
components of {\tt prob\%A}.

\itt{eval\_ASPROD} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of the
product $\bmA \bmv$  involving the Jacobian and a given {\em sparse}
vector $\bmv$.
See Section~\ref{jvps} for details.
If {\tt eval\_ASPROD} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_ASPROD} is absent, \solver\ will use reverse communication
(see Section~\ref{reverse})
to obtain Jacobian-sparse-vector products if {\tt reverse} is \present\ or
otherwise require that the user has provided all relevant
components of {\tt prob\%A}.

\itt{eval\_AFPROD} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of the
product $\bmA \bmv$ or $\bmA^T v$ involving the Jacobian (and its transpose)
and a given vector $\bmv$ in which either only some components of $\bmv$ or
the resulting product are set/required.
See Section~\ref{jvsp} for details.
If {\tt eval\_AFPROD} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_AFPROD} is absent, \solver\ will use reverse communication
(see Section~\ref{reverse})
to obtain Jacobian-sparse-vector products if {\tt reverse} is \present\ or
otherwise require that the user has provided all relevant
components of {\tt prob\%A}.

\itt{eval\_PREC} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of the
product $\bmP^{-1} \bmv$ involving a symmetric, positive definite 
preconditioner $\bmP$ and a given vector $\bmv$.
See Section~\ref{prec} for details.
If {\tt eval\_PREC} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_PREC} is absent, \solver\ will use reverse communication
(see Section~\ref{reverse})
to obtain preconditioning products so long as {\tt reverse} is \present;
if {\tt reverse} is not \present, no preconditioning will be performed.

\end{description}

%%%%%%% termination subroutine %%%%%%

\subsubsection{The  termination subroutine}
All previously allocated arrays are deallocated as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_terminate( data, control, inform )}

\vspace*{-3mm}
\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
exactly as for
{\tt \packagename\_solve},
which must not have been altered {\bf by the user} since the last call to
{\tt \packagename\_initialize}.
On exit, array components will have been deallocated.

\itt{control} is a scalar \intentin\ argument of type
{\tt \packagename\_control\_type}
exactly as for
{\tt \packagename\_solve}.

\itt{inform} is a scalar \intentout\ argument of type
{\tt \packagename\_inform\_type}
exactly as for
{\tt \packagename\_solve}.
Only the component {\tt status} will be set on exit, and a
successful call to
{\tt \packagename\_terminate}
is indicated when this  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\end{description}


%%%%%%%%%%%%%%%%%%%% Function and derivative values %%%%%%%%%%%%%%%%%%%%%

\subsection{Matrix-vector operations\label{fdv}}

%%%%%%%%%%%%%%%%%%%%%% Jacobian-vector products %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Jacobian-vector products via internal evaluation\label{jvp}}

If the argument {\tt eval\_APROD} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
sum $\bmp + \bmA \bmv$ or $\bmp + \bmA^T\bmv$ involving the
product of the residual Jacobian $\bmA$ or its transpose $\bmA^T$
and a given vector $\bmv$.
The routine must be specified as

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
       SUBROUTINE eval_APROD( status, userdata, transpose, V, P )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type default \integer,
that should be set to 0 if the routine has been able to evaluate the
sum $\bmp + \bmA \bmv$ or $\bmp + \bmA^T\bmv$
and to a non-zero value if the evaluation has not been possible.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt NLPT\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the subroutines
{\tt eval\_APROD}
(see Section~\ref{typeuserdata}).

\itt{transpose} is a scalar \intentin\ array argument of type
default that will be set \true\ if the product involves the transpose
of the Jacobian $\bmA^T$ and \false\ if the product involves
the Jacobian $\bmA$ itself.

\ittf{V} is a rank-one \intentin\ array argument of type default \realdp\
whose components contain the vector $\bmv$.

\ittf{P} is a rank-one \intentinout\ array argument of type default \realdp\
whose components on input contain the vector $\bmp$ and on output the
sum $\bmp + \bmA \bmv$ when {\tt \%transpose} is \false\ or
$\bmp + \bmA^T \bmv$ when {\tt \%transpose} is \true.

\end{description}


%%%%%%%%%%%%%%%%%%%%%% Jacobian-vector products %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Jacobian-sparse-vector products via internal evaluation\label{jvps}}

If the argument {\tt eval\_ASPROD} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
product of the Jacobian $\bmA$ with a given vector $\bmv$.
The routine must be specified as

\def\baselinestretch{0.8}
{\tt \begin{verbatim}
       SUBROUTINE eval_ASPROD( status, userdata, V, P[, NZ_in, nz_in_start, nz_in_end,     &
                               NZ_out, nz_out_end] )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type default \integer,
that should be set to 0 if the routine has been able to evaluate the
product $\bmA \bmv$
and to a non-zero value if the evaluation has not been possible.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt NLPT\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the
subroutine (see Section~\ref{typeuserdata}).

\ittf{V} is a rank-one \intentin\ array argument of type default \realdp\
whose components contain the vector $\bmv$.
If components
{\tt nz\_in\_start},
{\tt nz\_in\_end}
and
{\tt NZ\_in}
(see below) are \present,
only components {\tt NZ\_in(nz\_in\_start:nz\_in\_end)} of {\tt V}
will be nonzero and the remaining components of {\tt V} should be
ignored. Otherwise, all components of {\tt V} should be presumed to be nonzero.

\ittf{P} is a rank-one \intentout\ array argument of type default \realdp\
whose components on output contain the required components of $\bmA \bmv$.
If components
{\tt nz\_out\_end}
and
{\tt NZ\_out}
(see below) are \present,
only the nonzero components {\tt NZ\_out(1:nz\_out\_end)} of {\tt P}
need be assigned.
Otherwise, all components of {\tt P} must be set.

\itt{nz\_in\_start} is an \optional\ scalar variable of type default \integer,
that, if \present, holds the starting position in {\tt NZ\_in}
of the list of indices of nonzero components of $\bmv$.

\itt{nz\_in\_end} is an \optional\ scalar variable of type default \integer,
that, if \present, holds the finishing position in {\tt NZ\_in}
of the list of indices of nonzero components of $\bmv$.

\itt{NZ\_in} is an \optional\  rank-one array of dimension $n$
and type default \integer, that, if \present, holds the indices of the
nonzero components of $\bmv$. If any of
{\tt nz\_in\_start},
{\tt nz\_in\_end}
and
{\tt NZ\_in}
are absent, all components of {\tt V} are assumed to be nonzero.

\itt{nz\_out\_end} is an \optional\ scalar variable of type default \integer,
that, if \present, must be set to record the number of non-zeros in
$\bmA \bmv$.

\itt{NZ\_out} is an \optional\ rank-one array of dimension $m$
and type default \integer, that, if \present, must be set to record the list
of indices of nonzero components of $\bmA \bmv$.
If either of
{\tt nz\_out\_end}
and
{\tt NZ\_out}
are absent, all components of {\tt P} should be set even if they are zero.


\end{description}

%%%%%%%%%%%%%%%%%%%%%% Jacobian-vector products %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Jacobian-vector sub-products via internal evaluation\label{jvsp}}

If the argument {\tt eval\_AFPROD} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
product of the Jacobian $\bmA$, or its transpose, with a given vector $\bmv$.
Here, either only a subset of the components of the vector $\bmv$ are nonzero,
or only a subset of the components product $\bmA^T \bmv$ are to required.
The routine must be specified as

\def\baselinestretch{0.8}
{\tt \begin{verbatim}
       SUBROUTINE eval_AFPROD( status, userdata, transpose, V, P, FREE, n_free )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type default \integer,
that should be set to 0 if the routine has been able to evaluate the
sum $\bmA \bmv$ or $\bmA^T\bmv$
and to a non-zero value if the evaluation has not been possible.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt NLPT\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the subroutines
{\tt eval\_APROD}
(see Section~\ref{typeuserdata}).

\itt{transpose} is a scalar \intentin\ array argument of type
default that will be set \true\ if the product involves the transpose
of the Jacobian $\bmA^T$ and \false\ if the product involves
the Jacobian $\bmA$ itself.

\ittf{V} is a rank-one \intentin\ array argument of type default \realdp\
whose components contain the vector $\bmv$. If {\tt transpose} is \false\
only those components whose indices {\tt FREE(:n\_free)} (see below)
will by set, and the remainder will be presumed to be zero.

\ittf{P} is a rank-one \intentout\ array argument of type default \realdp\
whose components on output must be set to the
product $\bmA \bmv$ when {\tt \%transpose} is \false. If
{\tt \%transpose} is \true, components with indices {\tt FREE(:n\_free)}
(see below) should be set to the corresponding components of the
product $\bmA^T \bmv$, and the remaining components ignored.

\itt{FREE} is a rank-one \intentin\ array argument of
type default \integer\ that flags the input components of $\bmv$ that are set
(when {\tt transpose} is \false) or output components of $\bmA^T \bmv$ that
are required (when {\tt transpose} is \true). Specifically, only indices
{\tt FREE(:n\_free)} of the relevant vector is set or required, and the
remainder should be treated as zero (if {\tt transpose} is \false)
or ignored  (if {\tt transpose} is \true).

\itt{n\_free} is a scalar \intentin\ argument of type default \integer,
that specifies the number of components of {\tt FREE} that need be considered.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Preconditioning products %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Application of a preconditioner via internal evaluation
\label{prec}}

If the argument {\tt eval\_PREC} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
product $\bmP^{-1} \bmv$ involving a symmetric, positive definite 
preconditioner $\bmP$ and a given $n$-vector $\bmv$.
Ideally the $n$ by $n$ matrix $\bmP$ should be chosen so that the
of the product is inexpensive to compute, but also so that $\bmP$ is
a good approximation of $\bmA^T \bmA$ in the sense that the eigenvalues
of $\bmP^{-1} \bmA^T \bmA$ are clustered around a small number of values
(preferably all around 1.0). The routine must be specified as

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
       SUBROUTINE eval_PREC( status, userdata, V, P )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type default \integer,
that should be set to 0 if the routine has been able to evaluate the
product $\bmP^{-1} \bmv$, 
and to a non-zero value if the evaluation has not been possible.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt NLPT\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the subroutines
{\tt eval\_APROD}
(see Section~\ref{typeuserdata}).

\ittf{V} is a rank-one \intentin\ array argument of type default \realdp\
whose components contain the vector $\bmv$.

\ittf{P} is a rank-one \intentinout\ array argument of type default \realdp\
whose components on output contain the vector $\bmp = \bmP^{-1} \bmv$.

\end{description}


%%%%%%%%%%%%%%%%%%%%%% Reverse communication %%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\label{reverse}Reverse Communication Information}

A positive value of {\tt inform\%status} on exit from
{\tt \packagename\_solve}
indicates that
\solver\ is seeking further information---this will happen
if the user has chosen to evaluate matrix-vector products by
reverse communication.
The user should compute the required information and re-enter \solver\
with {\tt inform\%status} and all other arguments (except those specifically
mentioned below) unchanged.

Possible values of {\tt inform\%status} and the information required are
\begin{description}

\ittf{2.} The user should compute the product $\bmA \bmv$
     involving the product of the residual Jacobian, $\bmA$,
     with a given vector $\bmv$.
     The vector $\bmv$ is given in {\tt reverse\%V}, and the
     product $\bmA \bmv$ should be written to {\tt reverse\%P},
     and  {\tt reverse\%eval\_status} should be set to 0.
     If the user is unable to evaluate the product,
     the user need not set {\tt reverse\%P}, but
     should then set {\tt reverse\%eval\_status} to a non-zero value.

\ittf{3.} The user should compute the product $\bmA^T \bmv$
     involving the product of the transpose of the residual
     Jacobian, $\bmA$,  with a given vector $\bmv$.
     The vector $\bmv$ is given in {\tt reverse\%V}, and the
     product $\bmA^T \bmv$ should be written to {\tt reverse\%P},
     and  {\tt reverse\%eval\_status} should be set to 0.
     If the user is unable to evaluate the product,
     the user need not set {\tt reverse\%P}, but
     should then set {\tt reverse\%eval\_status} to a non-zero value.

\ittf{4.} The user should compute the matrix-vector product $\bmA \bmv$
     using the vector $\bmv$ whose nonzero components are stored in positions
     {\tt reverse\%NZ\_in(reverse\%nz\_in\_start:reverse\%nz\_in\_end)}
     of {\tt reverse\%V}. The remaining components of
     {\tt reverse\%V} should be ignored.
     The component {\tt reverse\%eval\_status} should set to 0 unless the
     user is unable to evaluate the product, in which case
     {\tt reverse\%eval\_status} should be set to a non-zero value, and the
     remaining components left unaltered.

\ittf{5.} The user should compute the nonzero components of the
     matrix-vector product $\bmA \bmv$ using the vector $\bmv$ whose
     nonzero components are stored in positions
     {\tt reverse\%NZ\_in(reverse\%nz\_in\_start:reverse\%nz\_in\_end)}
     of \linebreak {\tt reverse\%V}. The remaining components of
     {\tt reverse\%V} should be ignored. The nonzero components must
     occupy positions
     {\tt reverse\%NZ\_out(1:reverse\%nz\_out\_end)} of {\tt reverse\%P},
     and the components
     {\tt reverse\%NZ\_out} and {\tt reverse\%nz\_out\_end} must be set.
     The component {\tt reverse\%eval\_status} should set to 0 unless the
     user is unable to evaluate the product, in which case
     {\tt reverse\%eval\_status} should be set to a non-zero value, and the
      remaining components left unaltered.

\ittf{6.} The user should compute the matrix-vector product $\bmA^T \bmv$
     using the vector $\bmv$ given in {\tt reverse\%V}. The components
     $(\bmA^T \bmv)_j$ of the product $\bmA^T \bmv$, for
     {\tt j = reverse\%NZ\_in(reverse\%nz\_in\_start:reverse\%nz\_in\_end)},
     should be written to {\tt reverse\%P(j)}.
     The component {\tt reverse\%eval\_status} should set to 0 unless the
     user is unable to evaluate the product, in which case
     {\tt reverse\%eval\_status} should be set to a non-zero value, and the
      remaining components left unaltered.

\ittf{7.} The user should compute the product $\bmP^{-1} \bmv$
     involving a symmetric, positive definite preconditioner $\bmP$ 
     and a given vector $\bmv$
     The vector $\bmv$ is given in {\tt reverse\%V}, and the
     product $\bmP^{-1} \bmv$ should be written to {\tt reverse\%P},
     and  {\tt reverse\%eval\_status} should be set to 0.
     If the user is unable to evaluate the product,
     the user need not set {\tt reverse\%P}, but
     should then set {\tt reverse\%eval\_status} to a non-zero value.
     This value of {\tt inform\%status} can only occur if the user 
     has set {\tt control\%preconditioner = 2}.

\end{description}



%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\galerrors
A negative value of {\tt inform\%status} on exit from
{\tt \packagename\_solve}
or
{\tt \packagename\_terminate}
indicates that an error has occurred. No further calls should be made
until the error has been corrected. Possible values are:

\begin{description}

\itt{\galerrallocate.} An allocation error occurred. A message indicating
the offending
array is written on unit {\tt control\%error}, and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc} respectively.

\itt{\galerrdeallocate.} A deallocation error occurred.
A message indicating the offending
array is written on unit {\tt control\%error} and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc} respectively.

\itt{\galerrrestrictions.} One of the restrictions
 {\tt prob\%n} $> 0$,
 {\tt prob\%m} $> 0$
    or the requirement that
    {\tt prob\%A\_type} contain its relevant string
    {\tt 'DENSE\_BY\_ROWS'}, 
    {\tt 'DENSE\_BY\_COLUMNS'}, {\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_ROWS'}
    or {\tt SPARSE\_BY\_COLUMNS},
    when $\bmA$ is available,  has been violated.

%\itt{-3.} At least one of the arrays
% {\tt prob\%A\_val}, {\tt prob\%A\_row}, {\tt prob\%A\_col},
% {\tt prob\%H\_val}, {\tt prob\%H\_row} or {\tt prob\%H\_col},
% is not large enough to hold the original, or reordered, matrix $\bmH$.

\itt{\galerrbadbounds.} The bound constraints are inconsistent.

%\itt{\galerrunbounded.} The objective function appears to be unbounded
%  from below on the feasible set.

\itt{\galerranalysis.} The analysis phase of the factorization failed;
  the return status from the factorization
    package is given in the component {\tt inform\%fac\-t\-or\_status}.

\itt{\galerrfactorization.} The factorization failed; the return status
  from the factorization
    package is given in the component {\tt inform\%fac\-t\-or\_status}.

%\itt{\galerrillconditioned.} The problem is so ill-conditioned that
% further progress is impossible.

%\itt{\galerrtinystep.} The step is too small to make further impact.

\itt{\galerrmaxiterations.} Too many iterations have been performed.
   This may happen if
    {\tt control\%maxit} is too small, but may also be symptomatic of
    a badly scaled problem.

\itt{\galerrcpulimit.} The CPU time limit has been reached. This may happen if
    {\tt control\%cpu\_time\_limit} is too small, but may also be symptomatic
    of a badly scaled problem.

%\itt{\galerrupperentry.} An entry from the strict upper triangle of $\bmH$
% has been specified.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Further features %%%%%%%%%%%%%%%%%%%%%%%%

\galfeatures
\noindent In this section, we describe an alternative means of setting
control parameters, that is components of the variable {\tt control} of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}),
by reading an appropriate data specification file using the
subroutine {\tt \packagename\_read\_specfile}. This facility
is useful as it allows a user to change  {\tt \packagename} control parameters
without editing and recompiling programs that call {\tt \packagename}.

A specification file, or specfile, is a data file containing a number of
"specification commands". Each command occurs on a separate line,
and comprises a "keyword",
which is a string (in a close-to-natural language) used to identify a
control parameter, and
an (optional) "value", which defines the value to be assigned to the given
control parameter. All keywords and values are case insensitive,
keywords may be preceded by one or more blanks but
values must not contain blanks, and
each value must be separated from its keyword by at least one blank.
Values must not contain more than 30 characters, and
each line of the specfile is limited to 80 characters,
including the blanks separating keyword and value.



The portion of the specification file used by
{\tt \packagename\_read\_specfile}
must start
with a "{\tt BEGIN \packagename}" command and end with an
"{\tt END}" command.  The syntax of the specfile is thus defined as follows:
\begin{verbatim}
  ( .. lines ignored by BLLS_read_specfile .. )
    BEGIN BLLS
       keyword    value
       .......    .....
       keyword    value
    END
  ( .. lines ignored by BLLS_read_specfile .. )
\end{verbatim}
where keyword and value are two strings separated by (at least) one blank.
The ``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiter command lines
may contain additional (trailing) strings so long as such strings are
separated by one or more blanks, so that lines such as
\begin{verbatim}
    BEGIN BLLS SPECIFICATION
\end{verbatim}
and
\begin{verbatim}
    END BLLS SPECIFICATION
\end{verbatim}
are acceptable. Furthermore,
between the
``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiters,
specification commands may occur in any order.  Blank lines and
lines whose first non-blank character is {\tt !} or {\tt *} are ignored.
The content
of a line after a {\tt !} or {\tt *} character is also
ignored (as is the {\tt !} or {\tt *}
character itself). This provides an easy manner to "comment out" some
specification commands, or to comment specific values
of certain control parameters.

The value of a control parameters may be of three different types, namely
integer, logical or real.
Integer and real values may be expressed in any relevant Fortran integer and
floating-point formats (respectively). Permitted values for logical
parameters are "{\tt ON}", "{\tt TRUE}", "{\tt .TRUE.}", "{\tt T}",
"{\tt YES}", "{\tt Y}", or "{\tt OFF}", "{\tt NO}",
"{\tt N}", "{\tt FALSE}", "{\tt .FALSE.}" and "{\tt F}".
Empty values are also allowed for
logical control parameters, and are interpreted as "{\tt TRUE}".

The specification file must be open for
input when {\tt \packagename\_read\_specfile}
is called, and the associated device number
passed to the routine in device (see below).
Note that the corresponding
file is {\tt REWIND}ed, which makes it possible to combine the specifications
for more than one program/routine.  For the same reason, the file is not
closed by {\tt \packagename\_read\_specfile}.

\subsubsection{To read control parameters from a specification file}
\label{readspec}

Control parameters may be read from a file as follows:
\hskip0.5in

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
     CALL BLLS_read_specfile( control, device )
\end{verbatim}
}
\def\baselinestretch{1.0}

\begin{description}
\itt{control} is a scalar \intentinout argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}).
Default values should have already been set, perhaps by calling
{\tt \packagename\_initialize}.
On exit, individual components of {\tt control} may have been changed
according to the commands found in the specfile. Specfile commands and
the component (see Section~\ref{typecontrol}) of {\tt control}
that each affects are given in Table~\ref{specfile}.

\bctable{|l|l|l|}
\hline
  command & component of {\tt control} & value type \\
\hline
  {\tt error-printout-device} & {\tt \%error} & integer \\
  {\tt printout-device} & {\tt \%out} & integer \\
  {\tt print-level} & {\tt \%print\_level} & integer \\
  {\tt start-print} & {\tt \%start\_print} & integer \\
  {\tt stop-print} & {\tt \%stop\_print} & integer \\
  {\tt iterations-between-printing} & {\tt \%print\_gap} & integer \\
  {\tt maximum-number-of-iterations} & {\tt \%maxit} & integer \\
  {\tt cold-start} & {\tt \%cold\_start} & integer \\
  {\tt preconditioner} & {\tt \%preconditioner } & integer \\
  {\tt max-change-to-working-set-for-subspace-solution} & {\tt \%change\_max }
                                                        & integer \\
  {\tt maximum-number-of-cg-iterations-per-iteration} & {\tt \%cg\_maxit}
                                                      & integer \\
  {\tt maximum-number-of-arcsearch-steps} & {\tt \%arcsearch\_max\_steps}
                                          & integer \\
  {\tt infinity-value} & {\tt \%infinity} & real \\
  {\tt primal-accuracy-required} & {\tt \%stop\_p} & real \\
  {\tt dual-accuracy-required} & {\tt \%stop\_d} & real \\
  {\tt complementary-slackness-accuracy-required} & {\tt \%stop\_c} & real \\
  {\tt identical-bounds-tolerance} & {\tt \%identical\_bounds\_tol} & real \\
  {\tt cg-relative-accuracy-required} & {\tt \%stop\_cg\_relative} & real \\
  {\tt cg-absolute-accuracy-required} & {\tt \%stop\_cg\_absolute} & real \\

  {\tt maximum-arcsearch-stepsize} & {\tt \%alpha\_max} & real \\
  {\tt initial-arcsearch-stepsize} & {\tt \%alpha\_initial} & real \\
  {\tt arcsearch-reduction-factor} & {\tt \%alpha\_reduction} & real \\
  {\tt arcsearch-acceptance-tolerance} & {\tt \%arcsearch\_acceptance\_tol}
                                       & real \\
  {\tt regularization-weight} & {\tt \%regularization\_weight} & real \\
  {\tt maximum-cpu-time-limit} & {\tt \%cpu\_time\_limit} & real \\
  {\tt direct-subproblem-solve} & {\tt \%direct\_subproblem\_solve} & logical \\
  {\tt exact-arc-search-used} & {\tt \%exact\_arc\_search } & logical \\
  {\tt inexact-arc-search-can-advance} & {\tt \%advance} & logical \\
  {\tt space-critical}   & {\tt \%space\_critical} & logical \\
  {\tt deallocate-error-fatal}   & {\tt \%deallocate\_error\_fatal} & logical \\
  {\tt output-line-prefix} & {\tt \%prefix} & {\tt character} \\
\hline

\ectable{\label{specfile}Specfile commands and associated
components of {\tt control}.}

\itt{device} is a scalar \intentin argument of type default \integer,
that must be set to the unit number on which the specfile
has been opened. If {\tt device} is not open, {\tt control} will
not be altered and execution will continue, but an error message
will be printed on unit {\tt control\%error}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Information printed %%%%%%%%%%%%%%%%%%%%%%%%

\galinfo
If {\tt control\%print\_level} is positive, information about the progress
of the algorithm will be printed on unit {\tt control\-\%out}.
If {\tt control\%print\_level} $= 1$, a single line of output will be produced
for each iteration of the process.
This will give the total number of CG iterations performed (if any), the value
of the objective function and the norm of the projected gradient, the stepsize
taken, the number of free variables (i.e., those that have a positive value),
the change in the number of free variables since the last iteration, and the
elapsed CPU time in seconds.
If {\tt control\%print\_level} $\geq 2$ this
output will be increased to provide significant detail of each iteration.
This extra output includes residuals of the linear systems solved, and,
for larger values of {\tt control\%print\_level}, and the values of the 
primal and dual variables.

%%%%%%%%%%%%%%%%%%%%%% GENERAL INFORMATION %%%%%%%%%%%%%%%%%%%%%%%%

\galgeneral

\galcommon None.
\galworkspace Provided automatically by the module.
\galroutines None.
\galmodules {\tt \packagename\_solve} calls the \galahad\ packages
{\tt GALAHAD\_CPU\_time},
{\tt GALAHAD\_SY\-M\-BOLS}, \newline
{\tt GALAHAD\_SPACE},
{\tt GALAHAD\_STRING},
{\tt GALAHAD\_SORT},
{\tt GALAHAD\_NORMS},
{\tt GALAHAD\_CONVERT},
{\tt GALAHAD\_SBLS}, \newline
{\tt GALAHAD\_QPT},
{\tt GALAHAD\_QPD},
{\tt GALAHAD\_USERDATA} and
{\tt GALAHAD\_SPECFILE}.
\galio Output is under control of the arguments
 {\tt control\%error}, {\tt control\%out} and {\tt control\%print\_level}.
\galrestrictions {\tt prob\%n} $> 0$, {\tt prob\%m} $> 0$,
{\tt prob\%A\_type} $\in \{${\tt 'DENSE\_BY\_ROWS'}, {\tt 'DENSE\_BY\_COLUMNS'},
 {\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_\-ROWS'},
 {\tt SPARSE\_BY\_COLUMNS} $\}$
(if $\bmA$ is explicit).
\galportability ISO Fortran~95 + TR 15581 or Fortran~2003.
The package is thread-safe.

%%%%%%%%%%%%%%%%%%%%%% METHOD %%%%%%%%%%%%%%%%%%%%%%%%

\galmethod
The required solution $\bmx$ necessarily satisfies
the primal optimality conditions
\eqn{4.1}{
\bmx^{l} \leq\bmx \leq\bmx^{u},}
the dual optimality conditions
\eqn{4.2a}{
 \bmA^T \bmW (\bmA \bmx - \bmb ) + \sigma \bmx = \bmz
 \tim{and}
 \bmz = \bmz^{l} + \bmz^{u} ,}
and
\eqn{4.2b}{
 \bmz^{l} \geq 0 \;\; \mbox{and} \;\;
 \bmz^{u} \leq 0 ,}
and the complementary slackness conditions
\eqn{4.3}{
(\bmx -\bmx^{l} )^{T} \bmz^{l} = 0   \tim{and}
(\bmx -\bmx^{u} )^{T} \bmz^{u} = 0 ,}
where the components of the vector $\bmz$ are known as
the dual variables for the bounds,
and where the vector inequalities hold componentwise.
Projected-gradient methods iterate towards a point
that satisfies these conditions by ultimately aiming to satisfy
\req{4.2a}, while ensuring that
\req{4.1}, and \req{4.2b} and \req{4.3} are satisfied at each stage.
Appropriate norms of the amounts by
which \req{4.1}, \req{4.2a} and \req{4.3} fail to be satisfied are known as the
primal and dual infeasibility, and the violation of complementary slackness,
respectively.

The method is iterative. Each iteration proceeds in two stages.
Firstly, a search direction $\bms$ from the current estimate of the solution
$\bmx$ is computed. This may be in a scaled steepest-descent direction, or,
if the working set of variables on bounds has not changed dramatically,
in a direction that provides an approximate minimizer of the objective
over a subspace comprising the currently free-variables. The latter is
computed either using an appropriate sparse factorization by the
package {\tt GALAHAD\_SBLS}, or by the
conjugate-gradient least-squares (CGLS) method; tt may be necessary to
regularize the subproblem very slightly to avoid a ill-posedness.
Thereafter, a piecewise linesearch (arc search) is carried out along
the arc $\bmx(\alpha) = P( \bmx + \alpha \bms)$ for $\alpha > 0$,
where the projection operator
is defined component-wise at any feasible point $v$ to be
\disp{P_j(\bmv) = \min( \max( \bmx_j, \bmx_j^{l}), \bmx_j^{u});}
thus this arc bends the search direction into the feasible region.
The arc search is performed either exactly, by passing through a set
of increasing breakpoints at which it changes direction, or inexactly,
by evaluating a sequence of different $\alpha$  on the arc.
All computation is designed to exploit sparsity in $\bmA$.

\vspace*{1mm}

\galreferences
\vspace*{1mm}

\noindent
Full details are provided in
\vspace*{1mm}

\noindent
N. I. M. Gould (2022).
Numerical methods for solving bound-constrained
linear least squares problems.
In preparation.

%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\galexample
Suppose we wish to minimize
\disp{
\half \left\| \vect{x_1 \\ x_1 + x_2 - 2 \\ x_3 - 1 \\ x_3 - 2} \right\|_2^2}
subject to the simple bounds
$-1  \leq  x_{1}$,
$x_{2} \leq 1$
and $0 \leq x_{3}  \leq  2$.
Then, on writing the data for this problem as
\disp{\bmA = \mat{ccc}{1 & & \\ 1 & 1 &   \\ &  & 1 \\ &  & 1}, \;\;
 \bmb = \vect{ 0 \\ 2 \\ 1  \\ 2}, \;\;
\bmx^{l} = \vect{ -1 \\ - \infty \\ 0 } \tim{and}
\bmx^{u} = \vect{ \infty \\ 1 \\ 2 }}
in sparse coordinate format, we may use the following code:

{\tt \small
\VerbatimInput{\packageexample}
}
\noindent
This produces the following output: \vspace*{-2mm}
{\tt \small
\VerbatimInput{\packageresults}
}
\noindent
The same problem may be solved holding the data in
a sparse row-wise storage format by replacing the lines
{\tt \small
\begin{verbatim}
!  sparse coordinate storage format
...
! problem data complete
\end{verbatim}
}
\noindent
by
{\tt \small
\begin{verbatim}
! sparse row-wise storage format
   CALL SMT_put( p%A%type, 'SPARSE_BY_ROWS', s )  ! Specify sparse-by-rows
   ALLOCATE( p%A%val( a_ne ), p%A%col( a_ne ), p%A%ptr( m + 1 ) )
   p%A%val = (/ 1.0_wp, 1.0_wp, 1.0_wp, 1.0_wp, 1.0_wp /) ! Jacobian A
   p%A%col = (/ 1, 1, 2, 3, 3 /)                          ! Column indices
   p%A%ptr = (/ 1, 2, 4, 5, 6 /)                          ! Set row pointers
! problem data complete
\end{verbatim}
}
\noindent
a sparse column-wise storage format by replacing the lines
{\tt \small
\begin{verbatim}
! sparse column-wise storage format
   CALL SMT_put( p%A%type, 'SPARSE_BY_COLUMNS', s )  ! Specify sparse-by-columns
   ALLOCATE( p%A%val( a_ne ), p%A%row( a_ne ), p%A%ptr( n + 1 ) )
   p%A%val = (/ 1.0_wp, 1.0_wp, 1.0_wp, 1.0_wp, 1.0_wp /) ! Jacobian A
   p%A%row = (/ 1, 2, 2, 3, 4 /)                          ! Row indices
   p%A%ptr = (/ 1, 3, 4, 6 /)                             ! Set column pointers
! problem data complete
\end{verbatim}
}
\noindent
a dense-by-rows storage format with the replacement lines
{\tt \small
\begin{verbatim}
! dense storage format
   CALL SMT_put( p%A%type, 'DENSE_BY_ROWS', s )  ! Specify dense-by-rows
   ALLOCATE( p%A%val( m * n  )
   p%A%val = (/ 1.0_wp, 0.0_wp, 0.0_wp, 1.0_wp, 1.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, &
                1.0_wp, 0.0_wp, 01.0_wp, 1.0_wp /)
! problem data complete
\end{verbatim}
}
\noindent
or a dense-by-columns storage format using the replacement
{\tt \small
\begin{verbatim}
! dense storage format
   CALL SMT_put( p%A%type, 'DENSE_BY_COLUMS', s )  ! Specify dense-by-columns
   ALLOCATE( p%A%val( m * n  )
   p%A%val = (/ 1.0_wp, 1.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, 1.0_wp, 0.0_wp, 0.0_wp, &
                0.0_wp, 0.0_wp, 1.0_wp, 1.0_wp /)
! problem data complete
\end{verbatim}
}
\noindent
respectively.

The same problem may be solved using reverse communication with the
following code:

{\tt \small
\VerbatimInput{\packageexampleb}
}
\noindent
%Notice that storage for the Hessian is now not needed.
%This produces the same output.
This produces the following output: \vspace*{-2mm}
{\tt \small
\VerbatimInput{\packageresultsb}
}
\noindent

The same problem may also be solved by user-provided matrix-vector
products as follows:

{\tt \small
\VerbatimInput{\packageexamplec}
}
\noindent
This produces the same output.
Now notice how the matrix $\bmA$ is passed to the matrix-vector product
evaluation routines via the {\tt integer} and
{\tt real} components of the derived type {\tt userdata}.

%This produces the following output:
%%{\tt \small
%\VerbatimInput{\packageresultsc}
%}
%\noindent
\end{document}

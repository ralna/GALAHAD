\documentclass{galahad}

% set the package name

\newcommand{\package}{sils}
\newcommand{\packagename}{SILS}
\newcommand{\fullpackagename}{\libraryname\_\-\packagename}

\begin{document}

\galheader

%%%%%%%%%%%%%%%%%%%%%% SUMMARY %%%%%%%%%%%%%%%%%%%%%%%%

\galsummary

This package 
{\bf solves a sparse symmetric system of linear equations.} Given 
a sparse symmetric matrix $\bmA = \{ a_{ij} \}_{n \times n}$, and an 
$n$-vector $\bmb$ or a matrix $\bmB = \{ b_{ij} \}_{n \times r}$, this
subroutine solves the system $\bmA \bmx = \bmb$ or the system $\bmA 
\bmX = \bmB$ . 
The matrix $\bmA$ need not be definite. There is an option for iterative  
refinement. 
 
\noindent The method used is a direct method based on a sparse variant 
of Gaussian elimination and is discussed further by Duff and 
Reid, {\em ACM Trans. Math. Software} {\bf 9} (1983), 302-325. 

%%%%%%%%%%%%%%%%%%%%%% attributes %%%%%%%%%%%%%%%%%%%%%%%%

\galattributes
\galversions{\tt  \fullpackagename\_single, \fullpackagename\_double}.
\galremark {\tt GALAHAD\_\packagename} is a Fortran 90 encapsulation of 
the HSL Fortran 77 package {\tt MA27}, that offers some 
additional facilities.  The user interface is designed to be
equivalent to the more recent HSL package {\tt HSL\_MA57}, so the
two packages may be used interchangeably.
\galuses {\tt \libraryname\_SMT}, {\tt MA27}.
\galdate April 2001.
\galorigin Interface by N. I. M. Gould, Rutherford Appleton Laboratory,
documentation follows that of I.S. Duff and J.K. Reid, ibid.
\gallanguage Fortran~95 + TR 15581 or Fortran~2003. 

%%%%%%%%%%%%%%%%%%%%%% HOW TO USE %%%%%%%%%%%%%%%%%%%%%%%%

\galhowto

\subsection{Calling sequences}

Access to the package requires a {\tt USE} statement such as

\medskip\noindent{\em Single precision version}

\hskip0.5in {\tt USE \fullpackagename\_single}

\medskip\noindent{\em Double precision version}

\hskip0.5in {\tt USE  \fullpackagename\_double}

\medskip

If it is required to use both modules at the same time, the derived types 
{\tt SMT\_TYPE},
{\tt \packagename\_CONTROL},
{\tt \packagename\_AINFO},
{\tt \packagename\_FINFO},
{\tt \packagename\_SINFO}, and
{\tt \packagename\_FACTORS},
(Section~\ref{galtypes})
and the subroutines
{\tt \packagename\_INITIALIZE},
{\tt \packagename\_ANALYSE},
{\tt \packagename\_FACTORIZE},
{\tt \packagename\_SOLVE},
{\tt \packagename\_FINALIZE},
(Section~\ref{galarguments})
{\tt \packagename\_ENQUIRE},
{\tt \packagename\_ALTER D}, and
{\tt \packagename\_PART\_SOLVE}
(Section~\ref{galfeatures})
must be renamed on one of the {\tt USE} statements.

\noindent There are five principal subroutines for user calls (see 
Section~\ref{galfeatures} for further features): 
 
\begin{description} 
 
\item[] The subroutine {\tt \packagename\_INITIALIZE} must be called to 
initialize the 
structure for the factors. It may also be called to set default values 
for the components of the control structure. If non-default values are 
wanted for any of the control components, the corresponding components 
should be altered after the call to {\tt \packagename\_INITIALIZE}. 
  
\item[] {\tt \packagename\_ANALYSE} accepts the pattern of $\bmA$ 
 and chooses  pivots 
 for Gaussian elimination using a selection criterion to preserve 
 sparsity.  It subsequently constructs subsidiary information for 
 actual factorization by {\tt \packagename\_FACTORIZE}. The user may provide
 the pivot sequence, in which case only the necessary information for 
 {\tt \packagename\_FACTORIZE} will be generated. 
 
\item[] {\tt \packagename\_FACTORIZE} factorizes a matrix $\bmA$ using the 
information 
 from a previous call to {\tt \packagename\_ANALYSE}. The actual pivot sequence 
 used may differ from that of {\tt \packagename\_ANALYSE} if $\bmA$ is not 
definite. 
 
\item[] {\tt \packagename\_SOLVE} uses the factors generated by 
  {\tt \packagename\_FACTORIZE} to 
  solve a system of equations with one ($\bmA \bmx = \bmb$) 
  or several ($\bmA \bmX = \bmB$) right-hand sides, 
  or to improve a given solution or set of solutions 
  by iterative refinement. 
 
\item[] {\tt \packagename\_FINALIZE} reallocates the arrays held inside the  
  structure for the factors to have size zero. It should be called 
  when all the systems involving its matrix have been solved unless 
  the structure is about to be used for the factors of another matrix. 
  
\end{description} 


%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\galtypes
Six derived data types are accessible from the package.

%%%%%%%%%%% problem type %%%%%%%%%%%

\subsubsection{The derived data type for holding the matrix}\label{typeprob}
The derived data type {\tt SMT\_TYPE} is used to hold the matrix $\bmA$. 
The components of {\tt SMT\_TYPE} are:

\begin{description}

\ittf{N} is a scalar variable of type default \integer, that holds
the order $n$ of the matrix  $\bmA$. 
\restriction {\tt N} $\geq$ {\tt 1}. 

\ittf{NE} is a scalar variable of type default \integer, that holds the 
number of matrix entries.  
\restriction {\tt NE} $\geq$ {\tt 0}.

\ittf{VAL} is a rank-one allocatable array of type default \realdp, 
and dimension at least {\tt NE}, that holds the values of the entries. 
Each pair of off-diagonal entries $a_{ij} = a_{ji} $ 
is represented as a single entry. Duplicated entries are summed. 

\ittf{ROW} is a rank-one allocatable array of type default \integer, 
and dimension at least {\tt NE}, that holds the row indices of the entries. 

\ittf{COL} is a rank-one allocatable array of type default \integer, 
and dimension at least {\tt NE}, that holds the column indices of the entries. 

\end{description}

%%%%%%%%%%% control type %%%%%%%%%%%

\subsubsection{The derived data type for holding control 
 parameters}\label{typecontrol}
The derived data type 
{\tt \packagename\_CONTROL} 
is used to hold controlling data. Default values may be obtained by calling 
{\tt \packagename\_initialize}
(see Section~\ref{subinit}). The components of 
{\tt \packagename\_CONTROL} 
are:

\begin{description}

\ittf{LP} is an \integer\ scalar used by the subroutines as the output 
 stream for error messages.  If it is negative, these 
 messages will be suppressed.  The default value is {\tt 6}. 
 
\ittf{WP} is an \integer\ scalar used by the subroutines as the output 
 stream for warning messages.  If it is negative, these messages  
 will be suppressed.  The default value is {\tt 6}. 
 
\ittf{MP} is an \integer\ scalar used by the subroutines as the output 
 stream for diagnostic printing.  If it is negative, these messages  
 will be suppressed.  The default value is {\tt 6}. 
 
\ittf{SP} is an \integer\ scalar used by the subroutines as the output 
 stream for statistics. If it is negative, these messages will  
 be suppressed.  The default value is {\tt -1}. 
 
\itt{LDIAG} is an \integer\ scalar used by the subroutines to control 
 diagnostic printing.  If {\tt LDIAG} is less than {\tt 1}, no messages will 
 output. If the value is {\tt 1}, only error messages will 
 be printed.  If the value is {\tt 2}, then error and warning messages will 
 be printed. If the value is {\tt 3}, scalar data and a few 
 entries of array data on entry and exit from each subroutine will be 
 printed.  If the value is greater than {\tt 3}, all data will be printed on  
 entry and 
 exit.  The default value is {\tt 2}. 
 
\ittf{LA} is an \integer\ scalar used by {\tt \packagename\_FACTORIZE}. 
If {\tt LA} $\geq$ 
{\tt NRLNEC} (see Section~\ref{typeinfoa}), the real array that holds data for the 
factors is reallocated to have size {\tt LA}.  Otherwise, the array is not 
reallocated unless its size is less than {\tt NRLNEC}, in which case it is 
reallocated with size {\tt NRLTOT} (see Section~\ref{typeinfoa}). The default value 
is {\tt 0}. 
 
\ittf{LIW} is an \integer\ scalar used by {\tt \packagename\_FACTORIZE}. If 
{\tt LIW} $\geq$ 
{\tt NIRNEC} (see Section~\ref{typeinfoa}), the integer 
array that holds data for the 
factors is reallocated to have size {\tt LIW}.  Otherwise, the array is not 
reallocated unless its size is less than {\tt NIRNEC}, in which case it is 
reallocated with size {\tt NIRTOT} (see Section~\ref{typeinfoa}). 
The default value 
is {\tt 0}. 
 
\itt{MAXLA} is an \integer\ scalar used by {\tt \packagename\_FACTORIZE}. 
An error 
return occurs if the real array that holds data for the factors is too 
small and reallocating it to have size changed by the factor {\tt MULTIPLIER} 
would make its size greater than {\tt MAXLA}. The default value is 
{\tt HUGE(0)}. 
 
\itt{MAXLIW} is an \integer\ scalar used by {\tt \packagename\_FACTORIZE}. 
An error 
return occurs if the integer array that holds data for the factors is too 
small and reallocating it to have size changed by the factor {\tt MULTIPLIER} 
would make its size greater than {\tt MAXLIW}. The default value is 
{\tt HUGE(0)}. 
 
\itt{MULTIPLIER} is a \realdp\ scalar used by {\tt \packagename\_FACTORIZE} 
when a real or integer array that holds data for the factors is too small. The 
array is reallocated with its size changed by the factor {\tt MULTIPLIER}. 
The default value is {\tt 2.0}.
 
\itt{REDUCE} is a \realdp\ scalar that reduces the size of previously 
allocated 
internal workspace arrays if they are larger than currently required 
by a factor of {\tt REDUCE} or more. The default value is {\tt 2.0}.
 
\itt{NEMIN} is an \integer\ scalar used by {\tt \packagename\_ANALYSE} for the 
  minimum number of eliminations in a step that is automatically 
  accepted. If two adjacent steps can be combined and each has fewer 
  eliminations, they are combined.  The default value is {\tt 1}. 
 
\itt{THRESH} is an \integer\ scalar used by {\tt \packagename\_ANALYSE} to 
identify dense 
rows during pivot selection.  It is the percentage density for a row to 
be regarded as dense.  The default value is {\tt 100}. 
 
\itt{ORDERING} is a scalar variable of type default \integer, that 
controls the initial order of the rows when performing the factorization.
Possible values are: 
\begin{description} 
\itt{0} The ordering will be chosen by the Approximate Minimum Degree method
       without provisions for ``dense'' rows/columns.
\itt{1} The ordering specified in the argument {\tt PERM} for 
       {\tt \packagename\_analyse} will be used.
\itt{2} The ordering will be chosen by the Approximate Minimum Degree method
       with provisions for ``dense'' rows/columns.
\itt{3} The ordering will be chosen by the Minimum Degree method.
\itt{4} The ordering will be chosen by the Nested Dissection method; this
 requires the user to have installed the external package {\tt METIS}.
% , which is optionally required by {\tt HSL\_MA57} and {\tt PARDISO}.
\itt{5} Ordering 4 will be used unless it is unavailable in which case 
ordering 2 will be chosen.
\end{description} 
The default value is {\tt 5}, and any inappropriate choice
will be reset to this default.

\itt{PIVOTING} is an \integer\ scalar that is used to control numerical 
pivoting by {\tt \packagename\_FACTORIZE}. It must have one of the 
following values: 

\begin{description} 
\itt{1}  Numerical pivoting will be performed, with relative pivot  
tolerance given by the component {\tt U}.  
 
\itt{2}  No pivoting will be performed and an error exit will occur 
immediately a sign change is detected among the pivots. This is 
suitable for cases when $\bmA$  is thought to be definite and is likely to 
decrease the factorization time while still providing a stable 
decomposition. 
 
\itt{3}  No pivoting will be performed and an error exit will occur if a 
zero pivot is detected. This is likely to decrease the factorization 
time, but may be unstable if there is a sign change among the pivots. 
 
\itt{4}  No pivoting will be performed but the matrix will be altered 
if a non-positive pivot is encountered. 

\end{description} 

\noindent The default value is {\tt 1.} 
 
\ittf{U} is a \realdp\ scalar that is used by {\tt \packagename\_FACTORIZE} 
when the 
component {\tt PIVOTING} has the value {\tt 1} to hold the relative pivot 
tolerance.  The default value is {\tt 0}.{\tt 01}.  For problems requiring 
greater 
than average numerical care a higher value than the default would be 
advisable. Values greater than {\tt 0}.{\tt 5} are treated as {\tt 0}.{\tt 5} 
and less than {\tt 0}.{\tt 0} as {\tt 0}.{\tt 0}. 
 
\itt{TOLERANCE} is a \realdp\ scalar that is used by 
{\tt \packagename\_FACTORIZE}.  
Any entry of modulus less than or equal to {\tt TOLERANCE} is treated as zero. 
The default value is {\tt 0}.{\tt 0}
 
\itt{FACTORBLOCKING} is an \integer\ scalar used by 
{\tt \packagename\_FACTORIZE} 
to determine 
the block size used for the Level {\tt 3} {\tt BLAS}.  The default value 
is {\tt 16}. 
 
\itt{SOLVEBLOCKING} is an \integer\ scalar used by {\tt \packagename\_SOLVE} 
to determine the block size used for the Level {\tt 2} and Level {\tt 3} 
{\tt BLAS}.  The default value is {\tt 16}. 
 
\itt{CONVERGENCE} is a \realdp\ scalar that is used by 
{\tt \packagename\_SOLVE}.  This is used to used to monitor convergence 
iterative refinement. If the norm of
the scaled residuals does not decrease by a factor of at least
{\tt CONVERGENCE}, convergence is deemed to be too slow and the
solution phase is terminated.
The default value is {\tt 0}.{\tt 5}. 


\end{description}

%%%%%%%%%%% info type for analyse %%%%%%%%%%%

\subsubsection{The derived data type for holding informational
 parameters from {\tt \packagename\_ANALYSE}}\label{typeinfoa}
The derived data type 
{\tt \packagename\_AINFO} 
is used to hold parameters that give information about the progress of the
{\tt \packagename\_AN\-ALYSE} subroutine. The components of
{\tt \packagename\_AINFO} 
are:

\begin{description}

\itt{FLAG} is an \integer\ scalar. The value 
 zero indicates that the subroutine has performed 
 successfully.  For nonzero values, see Section~\ref{erroranal}. 
 
\itt{MORE} is an \integer\ scalar that provides further information in the 
case of an error, see Section~\ref{erroranal}. 
 
\ittf{OOR} is an \integer\ scalar that is set to the number of 
entries with one or both indices out of range.  
 
\ittf{DUP} is an \integer\ scalar that is set to the number of 
duplicate off-diagonal entries. 
 
\itt{STAT} is an \integer\ scalar. In the case of the failure of an 
allocate or deallocate statement, it is set to the {\tt STAT} value. 
 
\itt{NSTEPS} is an \integer\ scalar that is set to the number of  
 nodes in the assembly tree (number of major steps in the 
 factorization). 
 
\itt{MAXFRT}  is an \integer\ scalar that holds the largest front size. 
 
\itt{OPSA} is a \realdp\ scalar that is set to the number of 
 floating-point additions required by the assembly of frontal 
 matrices if no pivoting 
 is performed.  Numerical pivoting may increase the number of 
 operations. 
 
\itt{OPSE} is a \realdp\ scalar that is set to the number of 
 floating-point operations required by the factorization if no pivoting 
 is performed.  Numerical pivoting may increase the number of 
 operations. 
 
\itt{NRLTOT} and {\tt NIRTOT} are \integer\ scalars that give the total 
 amount of real and integer words respectively required for a 
 successful factorization without the need for data compression, 
 provided no numerical pivoting is performed.   
 
\itt{NRLNEC} and {\tt NIRNEC} are \integer\ scalars that give the total 
 amount 
 of real and integer words required respectively for successful 
 factorization allowing data compression, provided no numerical pivoting 
 is performed. 
 
\itt{NRLADU} and {\tt NIRADU} are \integer\ scalars that give the number 
 of real and integer words required respectively to hold the matrix 
 factors if no numerical pivoting is performed. 
 
\itt{NCMPA} is an \integer\ scalar that holds the number of compresses 
 of the internal data structure performed by {\tt \packagename\_AN\-ALYSE.} 

\end{description}

%%%%%%%%%%% info type for factorize %%%%%%%%%%%

\subsubsection{The derived data type for holding informational
 parameters from {\tt \packagename\_FACTORIZE}}\label{typeinfof}
The derived data type 
{\tt \packagename\_FINFO} 
is used to hold parameters that give information about the progress of the
{\tt \packagename\_FAC\-TORIZE} subroutine. The components of
{\tt \packagename\_FINFO} 
are:

\begin{description}

\itt{FLAG} is an \integer\ scalar. The value 
 of zero indicates that the subroutine has performed 
 successfully.  For nonzero values, see Section~\ref{errorfact}. 
 
\itt{MORE} is an \integer\ scalar that provides further information in the 
case of an error, see Section~\ref{errorfact}. 
 
\itt{STAT} is an \integer\ scalar. In the case of the failure of an 
allocate or deallocate statement, it is set to the {\tt STAT} value. 
 
\itt{MAXFRT}  is an \integer\ scalar that holds the largest front size. 
 
\itt{OPSA} is a \realdp\ scalar that is set to the number of 
 floating-point additions performed during assembly. 
 
\itt{OPSE} is a \realdp\ scalar that is set to the number of 
 floating-point operations performed during factorization. 
 
\itt{OPSB} is a \realdp\ scalar that is set to the number of 
 additional floating-point operations performed during factorization 
 because of use of the {\tt BLAS}. 
 
\itt{NRLTOT} and {\tt NIRTOT} are \integer\ scalars that give the total 
 amount of \realdp\ and \integer\ words respectively required for a 
 successful factorization without the need for data compression, 
 provided the same pivots are used.  
 
\itt{NRLNEC} and {\tt NIRNEC} are \integer\ scalars that give the amount 
 of  \realdp\ and \integer\ words required respectively for successful 
 factorization allowing data compression, provided 
 the same pivots are used.  
 
\itt{NEBDU} is an \integer\ scalar that gives the total number of  
 entries in the factorization. 
 
\itt{NRLBDU} and {\tt NIRBDU} are \integer\ scalars that give the amount of 
 real and integer words used respectively to hold the factorization. 
 
\itt{NCMPBR} and {\tt NCMPBI} are \integer\ scalars that hold the number of 
 compresses of the real and integer data structure respectively 
 required by the factorization. 
 
\itt{NTWO} is an \integer\ scalar that holds 
 the number of $2$ by $2$ pivots used during the factorization. 
 
\itt{NEIG} is an \integer\ scalar that holds 
 the number of negative eigenvalues of $\bmA$. 
 
\itt{RANK} is an \integer\ scalar that holds 
 the rank of the original factorization. 
 
\itt{DELAY} is an \integer\ scalar that holds the number of pivots passed 
up the tree because of numerical pivoting considerations. 
 
\itt{SIGNC} is an \integer\ scalar that holds the number of sign changes 
of pivot when {\tt \packagename\_CONTROL\%PIVOTING} is set to {\tt 3}. 
 
\itt{MODSTEP} is an \integer\ scalar that holds the pivot step at which  
matrix modification is first performed when 
{\tt \packagename\_CO\-NTROL\%PIVOTING} is set to {\tt 4}. 
 
\itt{MAXCHANGE} is a \realdp\ scalar that is set to the value of the largest 
change made to a pivot when {\tt \packagename\_AINFO\%MODSTEP} is positive. 
 
\end{description}

%%%%%%%%%%% info type for solve %%%%%%%%%%%

\subsubsection{The derived data type for holding informational
 parameters from {\tt \packagename\_SOLVE}}\label{typeinfos}
The derived data type 
{\tt \packagename\_SINFO} 
is used to hold parameters that give information about the progress of the
{\tt \packagename\_FA\-CTORIZE} subroutine. The components of
{\tt \packagename\_SINFO} 
are:

\begin{description}

\itt{FLAG} is an \integer\ scalar. The value 
 of zero indicates that the subroutine has performed 
 successfully.  For nonzero values, see Section~\ref{errorsolve}.
 
%\itt{MORE} is an \integer\ scalar that provides further information in the 
%case of an error, see Section~\ref{errorsolve}.
 
\itt{STAT} is an \integer\ scalar. In the case of the failure of an 
allocate or deallocate statement, it is set to the {\tt STAT} value. 
 
\end{description}

%%%%%%%%%%% factors type %%%%%%%%%%%

\subsubsection{The derived data type for holding factors of a matrix}
\label{typefactors}
The derived data type 
{\tt \packagename\_FACTORS} 
is used to hold the factors and related data for a matrix.
All components are private.

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\galarguments
We use square brackets {\tt [ ]} to indicate \optional\ arguments.

%%%%%% initialization subroutine %%%%%%

\subsubsection{The initialization subroutine}\label{subinit}
The initialization subroutine must be called for each structure used 
to hold the factors. It may also be called for a structure used to 
control the subroutines. Each argument is optional. A call with no 
arguments has no effect. 

\hskip0.5in 
{\tt CALL \packagename\_INITIALIZE( [FACTORS][, CONTROL] )}

\begin{description}

\itt{FACTORS} is optional, scalar, of \intentout\ and of type 
{\tt \packagename\_FACTORS}. On exit, its allocatable array components will have 
targets of length zero.  Without such initialization, these components 
are undefined and other calls are likely to fail. 
 
\itt{CONTROL} is optional, scalar, of \intentout\ and of type 
{\tt \packagename\_CONTROL}. On exit, its components will have been 
given the default values specified in Section~\ref{typecontrol}. 

\end{description}

%%%%%%%%% analysis subroutine %%%%%%

\subsubsection{The sparsity pattern analysis subroutine}
The sparsity pattern of $\bmA$ may be analysed as follows:

\hskip0.5in 
{\tt CALL \packagename\_ANALYSE( MATRIX, FACTORS, CONTROL, AINFO[, PERM] )}

\begin{description}
\itt{MATRIX} is scalar, of \intentin\ and of type 
{\tt SMT\_TYPE.}  
The user must set the components {\tt N}, {\tt NE}, {\tt ROW}, 
and {\tt COL}, and they are not altered by the subroutine. 
 {\bf Restrictions:} 
 {\tt MATRIX\%N} $\geq$ {\tt 1} and {\tt MATRIX\%NE} $\geq$ {\tt 0}. 
  
\itt{FACTORS} is scalar, of \intentinout\ and of type 
{\tt \packagename\_FACTORS}. It must have been initialized by a call to 
{\tt \packagename\_INI\-TIALIZE} or have been used for a previous calculation. 
In the latter case, the previous data will be lost but the allocatable 
arrays will not be reallocated unless they are found to be too small. 
 
\itt{CONTROL} is scalar, of \intentin\ and of type 
{\tt \packagename\_CONTROL}. Its components control the action, as explained in 
Section~\ref{typecontrol}. 
 
\itt{AINFO} is scalar, of \intentout\ and of type {\tt \packagename\_AINFO}. 
Its components provide information about the execution, as explained in 
Section~\ref{typeinfoa}. 
 
\itt{PERM} is an optional rank-one default \integer\ array of \intentin\
and length {\tt N}.
If present, {\tt PERM} ($i$), $i = 1, \ldots, n$, should be set 
to the position of  variable $i$ in the pivotal sequence. 
  
\end{description}

%%%%%%%%% factorization subroutine %%%%%%

\subsubsection{The numerical factorization subroutine}
Once it has been analysed, the matrix $\bmA$ may be factorized as follows:

\hskip0.5in 
{\tt CALL \packagename\_FACTORIZE( MATRIX, FACTORS, CONTROL, FINFO )}

\begin{description}

\itt{MATRIX} is scalar, of \intentin\ and of type {\tt SMT\_TYPE}.  The 
components {\tt N} and {\tt NE} must be unaltered since the call 
to {\tt \packagename\_ANALYSE}. The user must set the component {\tt VAL} 
to hold the real values of the entries. None of the components are altered 
by the subroutine. 
 
\itt{FACTORS} is scalar, of \intentinout\ and of type 
{\tt \packagename\_FACTORS}. It must be unaltered since the call 
to {\tt \packagename\_ANALYSE} or a subsequent call to 
{\tt \packagename\_FACTORIZE}. 
 
\itt{CONTROL} is scalar, of \intentin\ and of type 
{\tt \packagename\_CONTROL}. Its components control the action, as explained in 
Section~\ref{typecontrol}. 
 
\itt{FINFO} is scalar, of \intentout\ and of type {\tt \packagename\_FINFO}. 
Its components provide information about the execution, as explained in 
Section~\ref{typeinfof}. 

\end{description}

%%%%%%%%% solve subroutine %%%%%%

\subsubsection{The solution subroutine}
Given the factorization, a set of equations may be solved as follows:

\hskip0.5in 
{\tt CALL \packagename\_SOLVE( MATRIX, FACTORS, X, CONTROL, SINFO[, RHS] )}

\begin{description}

\itt{MATRIX} is scalar, of \intentin\ and of type {\tt SMT\_TYPE.}  It 
must be unaltered since the call to {\tt \packagename\_FACTORIZE} and is  
not altered by the subroutine. 
 
\itt{FACTORS} is scalar, of \intentin\ and of type {\tt \packagename\_FACTORS}.
It must be unaltered since the call to {\tt \packagename\_FACTORIZE} and is  
not altered by the subroutine. 
 
\itt{X} is an assumed-shape array with 1 or 2 dimensions, of 
\intentinout\, and of type \realdp.  If {\tt RHS} is absent, {\tt X} must 
be set 
by the user to the vector $\bmb$ or the matrix $\bmB$ and on return it holds 
the solution $\bmx$ or $\bmX$. 
If {\tt RHS} is present, {\tt X} must be set by the user 
to an approximate solution and on return it holds an improved solution, 
obtained by one cycle of iterative refinement without any use of 
arithmetic with additional precision. 
 
\itt{CONTROL} is scalar, of \intentin\ and of type {\tt \packagename\_CONTROL}.
Its components control the action, as explained in Section~\ref{typecontrol}. 
 
\itt{SINFO} is scalar, of \intentout\, and of type {\tt \packagename\_SINFO}.  
Its components provide information about the execution, as explained in 
Section~\ref{typeinfos}.
 
\ittf{RHS} is an assumed-shape array of the same shape as {\tt X}, optional, of 
intent(in), and of type \realdp. If present, it must be set by the user 
to the vector $\bmb$ or the matrix $\bmB$. 

\end{description}

%%%%%%% termination subroutine %%%%%%

\subsubsection{The termination subroutine}
All previously allocated arrays are reallocated to have targets of length zero
as follows:

\hskip0.5in 
{\tt CALL \packagename\_FINALIZE( FACTORS, CONTROL, INFO )}

\begin{description}
\itt{FACTORS} is scalar, of \intentinout\ and of type 
{\tt \packagename\_FACTORS}. On exit, its allocatable array components will have 
been reallocated to have targets of length zero.  Without such 
finalization, the storage occupied is unavailable for other purposes. 
In particular, this is very wasteful if the structure goes out of scope 
on return from a procedure. 
 
\itt{CONTROL} is scalar, of \intentin\ and of type {\tt \packagename\_CONTROL}.
Its components control the action, as explained in Section~\ref{typecontrol}. 
 
\itt{INFO} is scalar, of \intentout\, and of type \integer.  On return, 
the value {\tt 0} indicates success. Any other value is the {\tt STAT} value of 
an {\tt ALLOCATE} or {\tt DEALLOCATE} statement that has failed. 

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\galerrors
\subsubsection{When analysing the sparsity pattern}\label{erroranal}
A successful return from {\tt \packagename\_ANALYSE} is indicated by 
 {\tt AINFO\%FLAG} having the value zero.  A negative value is 
 associated with an error message which will  be output on unit 
 {\tt CONTROL\%LP}. Possible negative values are:  
 
\begin{description} 
\itt{-1} Value of {\tt MATRIX\%N} out of range.  {\tt MATRIX\%N} $<$ {\tt 1}. 
{\tt AINFO\%MORE} is set to value of {\tt MATRIX\%N}. 
 
\itt{-2} Value of {\tt MATRIX\%NE} out of range.  {\tt MATRIX\%NE} $<$ {\tt 0}. 
{\tt AINFO\%MORE} is set to value of {\tt MATRIX\%NE}. 
 
\itt{-3} Failure of an allocate or deallocate statement. {\tt AINFO\%STAT} 
 is set to the {\tt STAT} value. 
 
\itt{-9} The array {\tt PERM} does not hold a permutation. 
{\tt AINFO\%MORE} holds first component at which error was detected. 
 
\end{description} 

A positive flag value is associated with a warning message 
 which will  be output on unit {\tt AINFO\%MP}. Possible positive values are: 
 
\begin{description} 
 
\itt{1} Index (in {\tt MATRIX\%ROW} or {\tt MATRIX\%COL)} out of range. 
 Action taken by 
 subroutine is to ignore any such entries and continue. {\tt AINFO\%OOR} 
 is set to the number of such entries. Details of the first ten are 
 printed on unit {\tt CONTROL\%MP}. 
 
\itt{2} Duplicate indices. 
       Action taken by subroutine is to keep the duplicates and then to 
       sum corresponding reals when {\tt \packagename\_FACTORIZE} is called. 
       {\tt AINFO\%DUP} is set to the number of 
       faulty entries. Details of the first ten are printed on unit  
       {\tt CONTROL\%MP}. 
 
\itt{3} Both out-of-range indices and duplicates exist. 
 
\end{description} 
 
\subsubsection{When factorizing the matrix}\label{errorfact}
A successful return from {\tt \packagename\_FACTORIZE} is indicated by 
 {\tt FINFO\%FLAG} having the value zero.  A negative value is 
 associated with an error message which will  be output on unit 
 {\tt CONTROL\%LP}. In this case, no factorization will have been 
 calculated.  Possible negative values are: 
 
 
\begin{description} 
\itt{-1} Value of {\tt MATRIX\%N} differs from the {\tt \packagename\_ANALYSE} 
value. {\tt FINFO\%MORE} holds value of {\tt MATRIX\%N}. 
 
\itt{-2} Value of {\tt MATRIX\%NE} out of range.  {\tt MATRIX\%NE} $<$ {\tt 0}.
  
{\tt FINFO\%MORE} holds value of {\tt MATRIX\%NE}. 
 
\itt{-3} Failure of an allocate or deallocate statement. {\tt FINFO\%STAT} 
 is set to the {\tt STAT} value.  
 
\itt{-5} Zero pivot detected ({\tt CONTROL\%PIVOTING} has the value 
{\tt 2} or {\tt 3}). 
{\tt FINFO\%MORE} is set to the pivot step at which this was detected. 
 
\itt{-6} A change of sign of pivots has been detected  ({\tt CONTROL\%PIVOTING} 
has the value {\tt 2}). {\tt FINFO\%MORE} 
is set to the pivot step at which this was detected. 
 
\itt{-7} The real array that holds data for the factors 
  needs to be bigger than {\tt CONTROL\%MAXLA}.  
 
\itt{-8} The integer array that holds data for the factors 
 needs to be bigger than {\tt CONTROL\%MAXLIW}.  
 
\end{description} 
 

A positive flag value is associated with a warning message 
 which will  be output on unit {\tt CONTROL\%MP}. In this case, a 
 factorization will have been calculated. 
 
\begin{description} 
\itt{4} Matrix is rank deficient.  In this case, {\tt FINFO\%RANK} will be 
set to the rank of the original factorization, but the factorization is 
altered by changing all the zero pivots to one. This will enable the 
subsequent solution of consistent sets of equations. 
 
\itt{5} Pivots have different signs when {\tt CONTROL\%PIVOTING} has the value 
 {\tt 3}. 
 {\tt FINFO\%NEIG} is set to the number of negative eigenvalues. 
 Details of the first ten are printed on unit {\tt CONTROL\%MP}. 
       {\tt FINFO\%MORE} is set to the number of sign changes. 
 
\end{description} 
 

\subsubsection{When solving a linear system}\label{errorsolve}
A successful return from {\tt \packagename\_SOLVE} is indicated by 
 {\tt FINFO\%FLAG} having the value zero.  A negative value is 
 associated with an error message which will  be output on unit 
 {\tt CONTROL\%LP}. In this case, no solution will have been 
 found.  Possible negative values are: 
 
 
\begin{description} 
\itt{-3} Failure of an allocate or deallocate statement. {\tt FINFO\%STAT} 
 is set to the {\tt STAT} value.  
\end{description} 
 
%%%%%%%%%%%%%%%%%%%%%% Further features %%%%%%%%%%%%%%%%%%%%%%%%

\galfeatures
\noindent In this section, we describe features for enquiring about and 
manipulating the parts of the factorization constructed. These features 
will not be needed by a user who wants simply to solve systems of 
equations with matrix $\bmA$. 

The algorithm produces an $\bmL \bmD \bmL^T$ factorization 
of a permutation of $\bmA$, where $\bmL$ is a unit lower triangular 
matrix and $\bmD$ is a block diagonal matrix with blocks of order 
1 and 2. It is convenient to write this factorization in the form 
\disp{\bmA = (\bmP \bmL \bmP^T) (\bmP \bmD \bmP^T) (\bmP \bmL^T \bmP^T ),}
where $\bmP$ is a permutation matrix. The following subroutines 
are provided: 
\begin{description} 
\ittf{} {\tt \packagename\_ENQUIRE} returns $\bmP$ or $\bmD$ or both. 
 
\ittf{} {\tt \packagename\_ALTER\_D} alters $\bmD$. Note that this means that 
we no longer have a factorization of the given matrix $\bmA$. 
 
\ittf{} {\tt \packagename\_PART\_SOLVE} solves one of the systems of equations 
$\bmP \bmL \bmP^T \bmx =  \bmb$,  
$\bmP \bmD \bmP^T \bmx =  \bmb$, or 
$\bmP \bmL^T \bmP^T \bmx =  \bmb$, 
for one or more right-hand sides. 
 
\end{description} 
 
\subsubsection{To return $\bmP$ or $\bmD$ or both}
 
\hskip0.5in 
{\tt CALL \packagename\_ENQUIRE( FACTORS[, PERM][, PIVOTS][, D][, PERTURBATION] )}
 
\begin{description} 
\itt{FACTORS} is scalar, of \intentin\ and of type {\tt \packagename\_FACTORS}.
It must be unaltered since the call to {\tt \packagename\_FACTORIZE} 
or a subsequent call to {\tt \packagename\_ALTER\_D}. 
 
\itt{PERM} is an optional rank-one default \integer\ array of \intentout\
 and length {\tt N}.
If present, {\tt PERM} will be set to the pivot permutation
selected by {\tt \packagename\_ANALYSE}.
  
\itt{PIVOTS} is an optional rank-one default \integer\ array of \intentout\
 and length {\tt N}.
If present, the index of pivot $i$ will be placed in 
{\tt PIVOTS} ($i$), $i = 1, \ldots, n$, with its sign negative if it is 
the index of a 2 x 2 block. 
  
\itt{D} is an optional rank-two default \realdp\ array
of \intentout\, and shape {\tt (2, N)}.
If present, the diagonal entries of $\bmD^{-1} $ will 
be placed in {\tt D( 1, i )}, $i = 1, \ldots n$ and the off-diagonal 
entries of $\bmD^{-1} $ will be placed in {\tt D( 2, i )}, 
$i = 1, \ldots n-1$. 

\itt{PERTURBATION} is an optional rank-one default \realdp\ array of 
\intentout\ and length {\tt N}.
If present, {\tt PERTURBATION} will be set to a vector of diagonal perturbations
chosen by {\tt \packagename\_FACTORIZE}. This array can only be nonzero if
{\tt \packagename\_FACTORIZE} was last called with {\tt CONTROL\%PIVOTING} = 4.

\end{description} 
 
\subsubsection{To alter $\bmD$}
 
\hskip0.5in 
{\tt CALL \packagename\_ALTER D( FACTORS, D, INFO )}
 
\begin{description} 
\itt{FACTORS} is scalar, of \intentinout\ and of type 
{\tt \packagename\_FACTORS}. It 
must be unaltered since the call to {\tt \packagename\_FACTOR\-IZE}  
or a subsequent call to {\tt \packagename\_ALTER\_D}. 
  
\itt{D} is an array of shape ($2$, $n$) of \intentinout\, and of 
type \realdp. The diagonal entries of $\bmD^{-1} $ will 
be altered to {\tt D( 1, i )}, $i = 1, \ldots n$ and the off-diagonal 
entries of $\bmD^{-1} $ will be altered to {\tt D( 2, i )}, 
$i = 1, \ldots n-1$. 
 
\itt{INFO} is scalar, of \intentout\, and of type \integer.  On return, 
the value {\tt 0} indicates success and the value $i > 0$ indicates that  
{\tt D(2, i)} is nonzero, but is not part of a block of order 
{\tt 2} of $\bmD$. 
 
\end{description} 

\subsubsection{To perform a partial solution}
 
\hskip0.5in 
{\tt CALL \packagename\_PART\_SOLVE( FACTORS, CONTROL, PART, X, INFO )}
 
\begin{description} 
\itt{FACTORS} is scalar, of \intentin\ and of type {\tt \packagename\_FACTORS}.
It must be unaltered since the call to {\tt \packagename\_FACTORIZE}  
or a subsequent call to {\tt \packagename\_ALTER\_D}. 
 
\itt{CONTROL} is scalar, of \intentin\ and of type {\tt \packagename\_CONTROL}.
Its components control the action, as explained in Section~\ref{typecontrol}. 
 
\itt{PART} is scalar, of \intentin\, and of type \character. It 
must have one of the values 
\begin{description} 
\itt{L} for solving $\bmP \bmL \bmP^T \bmx =  \bmb$ or 
                     $\bmP \bmL \bmP^T \bmX =  \bmB$,  
\itt{D} for solving $\bmP \bmD \bmP^T \bmx =  \bmb$ or 
                  $\bmP \bmD \bmP^T \bmX =  \bmB$, or  
\itt{U} for solving $\bmP \bmL^T \bmP^T \bmx =  \bmb$ or 
                  $\bmP \bmL^T \bmP^T \bmX = \bmB$.  
\end{description} 
 
\itt{X} is an assumed-shape array with 1 or 2 dimensions, of 
intent(inout), and of type \realdp.  It must be set by the user to the 
vector $\bmb$ or the matrix $\bmB$ and on return it holds the solution 
$\bmx$ or $\bmX$. 
 
\itt{INFO} is scalar, of \intentout\, and of type \integer.  On return, 
the value {\tt 0} indicates success. Any other value is the {\tt STAT} value of 
an  {\tt ALLOCATE} or {\tt DEALLOCATE} statement that has failed. 
 
\end{description} 

%%%%%%%%%%%%%%%%%%%%%% GENERAL INFORMATION %%%%%%%%%%%%%%%%%%%%%%%%

\galgeneral

\galcommon None.
\galworkspace Provided automatically by the module.
\galroutines {\tt MA27A/AD}, {\tt MA27B/BD}, {\tt MA27C/CD}.
\galmodules {\tt GALAHAD\_SMT\_single/double}.
\galio Error, warning and diagnostic messages only.  Error 
 messages on unit {\tt CONTROL\%LP} and warning and diagnostic messages on unit 
 {\tt CONTROL\%WP} and  {\tt CONTROL\%MP}, respectively.  These have default 
 value {\tt 6},  and printing of these messages 
 is suppressed if the relevant unit number is set negative.  These messages are
 also suppressed if {\tt \packagename\_CONTROL\%LDIAG} is less than {\tt 1}. 
\galrestrictions {\tt MATRIX\%N} $\geq$ {\tt 1}, 
                 {\tt MATRIX\%NE} $\geq$ {\tt 0}. 
\galportability ISO Fortran~95 + TR 15581 or Fortran~2003. 
The package is thread-safe.

%%%%%%%%%%%%%%%%%%%%%% METHOD %%%%%%%%%%%%%%%%%%%%%%%%

\galmethod
A version of sparse Gaussian elimination is used. 
 

The {\tt \packagename\_ANALYSE} entry chooses pivots from the 
 diagonal using the minimum degree criterion employing a 
 generalized element model of the elimination thus avoiding the 
 need to store the filled-in pattern explicitly.  The 
 elimination is represented as an assembly tree 
 with the order of elimination determined by a depth-first 
 search of the tree. 
 

The {\tt \packagename\_FACTORIZE} entry factorizes the matrix by using the 
 assembly and elimination ordering generated by {\tt \packagename\_ANALYSE}.  At 
 each stage in the multifrontal approach, pivoting and 
 elimination are performed on full submatrices and, when 
 diagonal $1 \times 1$ pivots would be numerically unstable, $2 \times 2$ 
 diagonal blocks are used.  The operations on the full submatrices 
 are performed using the Level 3 {\tt BLAS}.  {\tt \packagename\_FACTORIZE} 
 can thus be  used to 
 factor indefinite systems and will perform well on machines 
 with caches or levels of memory hierarchy. 
 

The {\tt \packagename\_SOLVE} entry uses the factors from 
{\tt \packagename\_FACTORIZE} to solve 
 systems of equations either by loading the appropriate parts of 
 the vectors into an  array  of the current front-size and 
 using full matrix code employing the Level {\tt 2} and Level {\tt 3} 
{\tt BLAS} 
 or by indirect addressing at each stage, 
 whichever performs better. 
 

\galreference
A fuller account of this method is given by Duff and Reid 
(AERE-R.10533, 1982) and Duff and Reid, ACM Trans. Math. 
Software {\bf 9} (1983), 302-325. 
 

%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\galexample
We illustrate the use of the package on the solution of the 
single set of equations 
\disp{\mat{ccccc}{ 2 & 3 &   &   &   \\ 
                   3 &   & 4 &   & 6 \\
                     & 4 & 1 & 5 &   \\
                     &   & 5 &   &   \\
                     & 6 & &     & 1 } \bmx = 
       \vect{ 8 \\ 45 \\ 31 \\ 15 \\ 17}}
(Note that this example does not illustrate all the facilities). 
Then we may use the following code
{\tt
\begin{verbatim}

   PROGRAM MAIN 
   USE GALAHAD_SILS_DOUBLE 
   IMPLICIT NONE 
   INTEGER, PARAMETER :: wp = KIND( 1.0D+0 )
   TYPE(SMT_TYPE) MATRIX 
   TYPE(SILS_CONTROL) CONTROL 
   TYPE(SILS_AINFO) AINFO 
   TYPE(SILS_FINFO) FINFO 
   TYPE(SILS_SINFO) SINFO 
   TYPE(SILS_FACTORS) FACTORS 
   REAL ( KIND = wp ), ALLOCATABLE, DIMENSION( : ) :: B, X
   INTEGER I,INFO,N,NE 
   READ (5,*) N,NE  ! Read matrix order and number of entries
   MATRIX%N = N 
   MATRIX%NE = NE 
! Allocate arrays of appropriate sizes 
   ALLOCATE(MATRIX%VAL(NE), MATRIX%ROW(NE), MATRIX%COL(NE)) 
   ALLOCATE(B(N), X(N)) 
! Read matrix and right-hand side                                        
   READ (5,*) (MATRIX%ROW(I),MATRIX%COL(I),MATRIX%VAL(I),I=1,NE)  
   READ (5,*) B  
   CALL SILS_INITIALIZE(FACTORS,CONTROL) ! Initialize the structures 
   CALL SILS_ANALYSE(MATRIX,FACTORS,CONTROL,AINFO) ! Analyse 
   IF(AINFO%FLAG<0) THEN 
      WRITE(6,'(A,I2)') & 
         ' Failure of SILS_ANALYSE with AINFO%FLAG=', AINFO%FLAG 
      STOP 
   END IF 
   CALL SILS_FACTORIZE(MATRIX,FACTORS,CONTROL,FINFO) ! Factorize 
   IF(FINFO%FLAG<0) THEN 
      WRITE(6,'(A,I2)') & 
         ' Failure of SILS_FACTORIZE with FINFO%FLAG=', FINFO%FLAG 
      STOP 
   END IF 
   X = B ! Solve without refinement 
   CALL SILS_SOLVE(MATRIX,FACTORS,X,CONTROL,SINFO) 
   IF(SINFO%FLAG==0)WRITE(6,'(A,/,(3F20.16))')  & 
      ' Solution without refinement is',X 
   CALL SILS_SOLVE(MATRIX,FACTORS,X,CONTROL,SINFO,B) ! Perform one refinement 
   IF(SINFO%FLAG==0)WRITE(6,'(A,/,(3F20.16))') & 
       ' Solution after one refinement is',X 
   END PROGRAM MAIN                                           

\end{verbatim}
}
with the following data
{\tt
\begin{verbatim}

 5 7 
 1 1 2.0 
 1 2 3.0 
 2 3 4.0 
 2 5 6.0 
 3 3 1.0 
 3 4 5.0 
 5 5 1.0 
 8. 45. 31. 15. 17. 

\end{verbatim}
}
This produces the following output:
{\tt
\begin{verbatim}

 Solution without refinement is 
  1.0000000000000000  1.9999999999999998  3.0000000000000000 
  4.0000000000000008  5.0000000000000017 
 Solution after one refinement is 
  1.0000000000000000  2.0000000000000000  3.0000000000000000 
  4.0000000000000000  5.0000000000000000 

\end{verbatim}
}

\end{document}


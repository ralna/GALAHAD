\documentclass{galahad}

% set the package name

\newcommand{\package}{trek}
\newcommand{\packagename}{TREK}
\newcommand{\fullpackagename}{\libraryname\_\packagename}

\begin{document}

\galheader

%%%%%%%%%%%%%%%%%%%%%% SUMMARY %%%%%%%%%%%%%%%%%%%%%%%%

\galsummary
Given real $n$ by $n$ symmetric matrices $\bmH$ and $\bmS$
(with $\bmS$ diagonally dominant),
a real $n$ vector $\bmc$ and scalars $f$ and $\Delta>0$, this package 
uses an {\bf extended Krylov-subspace method} to find a
{\bf global minimizer of the quadratic objective function
$\half \bmx^T \bmH \bmx  +  \bmc^T \bmx + f$, where the vector $\bmx$ is
required to satisfy the constraint $\|\bmx\|_{\bmS} \leq  \Delta$}, and
where the $\bmS$-norm of $\bmx$ is $\|\bmx\|_{\bmS} = \sqrt{\bmx^T \bmS \bmx}$.
This problem commonly occurs as a trust-region subproblem in nonlinear
optimization calculations.
The matrix $\bmS$ need not be provided in the commonly-occurring
$\ell_2$-trust-region case for which $\bmS = \bmI$, the $n$ by $n$
identity matrix.

\noindent
A factorization of the matrix $\bmH$ (and $\bmS$, if it is required)
will be used, so this package is most suited
for the case where such a factorization may be found efficiently. If
this is not the case, the package {\tt \libraryname\_GLTR} may be preferred.

%%%%%%%%%%%%%%%%%%%%%% attributes %%%%%%%%%%%%%%%%%%%%%%%%

\galattributes
\galversions{\tt  \fullpackagename\_single, \fullpackagename\_double}.
\galuses
{\tt \libraryname\_CLOCK},
{\tt \libraryname\_SY\-M\-BOLS},
{\tt \libraryname\_SPACE}, {\tt \libraryname\_\-NORMS},
{\tt \libraryname\_ROOTS}, {\tt \libraryname\_SPECFILE},
{\tt \libraryname\_SMT}, {\tt \libraryname\_RAND}, 
{\tt \libraryname\_TRS}, {\tt \libraryname\_SLS}, 
{\tt \libraryname\_MOP}
\galdate November 2025.
\galorigin H.\ Al Daas and N. I. M. Gould, Rutherford Appleton Laboratory.
\gallanguage Fortran~95 + TR 15581 or Fortran~2003.
\galparallelism Some options may use OpenMP and its runtime library.

%%%%%%%%%%%%%%%%%%%%%% HOW TO USE %%%%%%%%%%%%%%%%%%%%%%%%

\galhowto

\input{versions}

\noindent
If it is required to use more than one of the modules at the same time, 
the derived types
{\tt SMT\_TYPE},
{\tt \packagename\_control\_type},
{\tt \packagename\_inform\_type},
{\tt \packagename\_data\_type},
(Section~\ref{galtypes})
and the subroutines
{\tt \packagename\_initialize},
{\tt \packagename\_solve}, {\tt \packagename\_\-terminate}
(Section~\ref{galarguments})
and
{\tt \packagename\_read\_specfile}
(Section~\ref{galfeatures})
must be renamed on one of the {\tt USE} statements.

%%%%%%%%%%%%%%%%%%%%%% matrix formats %%%%%%%%%%%%%%%%%%%%%%%%

\galmatrix
The matrices $\bmH$ and (if required) $\bmS$
may be stored in a variety of input formats.

\subsubsection{Dense storage format}\label{dense}
The matrix $\bmH$ is stored as a compact
dense matrix by rows, that is, the values of the entries of each row in turn are
stored in order within an appropriate real one-dimensional array.
Since $\bmH$ is symmetric, only the lower triangular part (that is the part
$h_{ij}$ for $1 \leq j \leq i \leq n$) need be held. In this case
the lower triangle should be stored by rows, that is
component $i \ast (i-1)/2 + j$ of the storage array {\tt H\%val}
will hold the value $h_{ij}$ (and, by symmetry, $h_{ji}$)
for $1 \leq j \leq i \leq n$. The same is true for $\bmS$ if it is used.

\subsubsection{Sparse co-ordinate storage format}\label{coordinate}
Only the nonzero entries of the matrices are stored.
For the $l$-th entry of $\bmH$, $1 \leq j \leq i \leq n$,
its row index $i$, column index $j$ and value $h_{ij}$
are stored in the $l$-th components of the integer arrays {\tt H\%row},
{\tt H\%col} and real array {\tt H\%val}, respectively.
Note that only the entries in the lower triangle should be stored.
The same scheme may be used for $\bmS$ if it is required.

\subsubsection{Sparse row-wise storage format}\label{rowwise}
Again only the nonzero entries are stored, but this time
they are ordered so that those in row $i$ appear directly before those
in row $i+1$. For the $i$-th row of $\bmH$, the $i$-th component of the
integer array {\tt H\%ptr} holds the position of the first entry in this row,
while {\tt H\%ptr} $(m+1)$ holds the total number of entries plus one.
The column indices $j$, $1 \leq j \leq i$, and values $h_{ij}$ of the
entries in the $i$-th row are stored in components
$l =$ {\tt H\%ptr}$(i)$, \ldots ,{\tt H\%ptr} $(i+1)-1$ of the
integer array {\tt H\%col}, and real array {\tt H\%val}, respectively.
Note that as before only the entries in the lower triangle should be stored.
For sparse matrices, this scheme almost always requires less storage than
its predecessor.
This scheme may also be used for $\bmS$ if it is required.

\subsubsection{Diagonal storage format}\label{diagonal}
If $\bmH$ is diagonal (i.e., $h_{ij} = 0$ for all $1 \leq i \neq j \leq n$)
only the diagonals entries $h_{ii}$, $1 \leq i \leq n$,  need be stored,
and the first $n$ components of the array {\tt H\%val} may be used for
the purpose. The same applies to $\bmS$ if it is required.

\subsubsection{Scaled-identity-matrix storage format}\label{scaled-identity}
If $\bmH$ is a scalar multiple of the identity matrix
(i.e., $h_{ii} = h_{11}$  and $h_{ij} = 0$ for all $1 \leq i \neq j \leq n$)
only the first diagonal entry $h_{11}$ needs be stored,
and the first component of the array {\tt H\%val} may be used for
the purpose. The same applies to $\bmS$ if it is required.

\subsubsection{Identity-matrix storage format}\label{identity}
If $\bmH$ is the identity matrix
(i.e., $h_{ii} = 1$ and $h_{ij} = 0$ for all $1 \leq i \neq j \leq n$),
no explicit entries needs be stored. The same would be true for $\bmS$, but
$\bmS$ need not be provided if $\bmS = \bmI$.

\subsubsection{Zero-matrix storage format}\label{zero}
If $\bmH = \bmzero$ (i.e., $h_{ij} = 0$ for all $1 \leq i, j \leq n$),
no explicit entries needs be stored. This is not relevant for $\bmS$,
as $\bmS$ is required to be non-singular.

%%%%%%%%%%%%%%%%%%%%%%%%%%% kinds %%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{kinds}

%%%%%%%%%%%%%%%%%%%%%% parallel usage %%%%%%%%%%%%%%%%%%%%%%%%

\input{parallel}

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\galtypes
Six derived data types are accessible from the package.

%%%%%%%%%%% matrix data type %%%%%%%%%%%

\subsubsection{The derived data type for holding matrices}\label{typesmt}
The derived data type {\tt SMT\_TYPE} is used to hold the matrices $\bmH$
and perhaps $\bmS$.
The components of {\tt SMT\_TYPE} used here are:

\begin{description}

\ittf{m} is a scalar component of type \integer,
that holds the number of rows in the matrix.

\ittf{n} is a scalar component of type \integer,
that holds the number of columns in the matrix.

\ittf{ne} is a scalar variable of type \integer, that
holds the number of matrix entries.

\ittf{type} is a rank-one allocatable array of type default \character, that
is used to indicate the matrix storage scheme used. Its precise length and
content depends on the type of matrix to be stored.

\ittf{val} is a rank-one allocatable array of type \realdp\,
and dimension at least {\tt ne}, that holds the values of the entries.
Each pair of off-diagonal entries $h_{ij} = h_{ji}$ of the {\em symmetric}
matrix $\bmH$ is represented as a single entry
(see \S\ref{dense}--\ref{rowwise}).
Any duplicated entries that appear in the sparse
co-ordinate or row-wise schemes will be summed.

\ittf{row} is a rank-one allocatable array of type \integer,
and dimension at least {\tt ne}, that may hold the row indices of the entries.
(see \S\ref{coordinate}).

\ittf{col} is a rank-one allocatable array of type \integer,
and dimension at least {\tt ne}, that may hold the column indices of the entries
(see \S\ref{coordinate}--\ref{rowwise}).

\ittf{ptr} is a rank-one allocatable array of type \integer,
and dimension at least {\tt n + 1}, that may holds the pointers to
the first entry in each row (see \S\ref{rowwise}).

\end{description}

%%%%%%%%%%% control type %%%%%%%%%%%

\subsubsection{The derived data type for holding control
 parameters}\label{typecontrol}
The derived data type
{\tt \packagename\_control\_type}
is used to hold controlling data. Default values may be obtained by calling
{\tt \packagename\_initialize}
(see Section~\ref{subinit}). The components of
{\tt \packagename\_control\_type}
are:

\begin{description}
\itt{error} is a scalar variable of type \integer, that holds the
stream number for error messages.
Printing of error messages in
{\tt \packagename\_solve} and {\tt \packagename\_terminate}
is suppressed if ${\tt error} \leq {\tt 0}$.
The default is {\tt error = 6}.

\ittf{out} is a scalar variable of type \integer, that holds the
stream number for informational messages.
Printing of informational messages in
{\tt \packagename\_solve} is suppressed if ${\tt out} < {\tt 0}$.
The default is {\tt out = 6}.

\itt{print\_level} is a scalar variable of type \integer,
that is used
to control the amount of informational output which is required. No
informational output will occur if ${\tt print\_level} \leq {\tt 0}$. If
{\tt print\_level = 1} a single line of output will be produced for each
iteration of the process. If {\tt print\_level} $\geq$ {\tt 2} this output
will be increased to provide significant detail of each iteration.
The default is {\tt print\_level = 0}.

\itt{eks\_max} is a scalar variable of type \integer, that specifies
the maximum dimension of the extended Krylov space employed. 
If a negative value is given, this will be replaced by {\tt 100}.
The default is {\tt eks\_max = - 1}.

\itt{it\_max} is a scalar variable of type \integer, that is used
to specify the maximum number of iterations allowed.
If a negative value is given, this will be replaced by {\tt 100}.
The default is {\tt it\_max = - 1}.

\ittf{f} is a scalar variable of type default
\realdp, that gives the value of the constant term $f$ in the
quadratic objective function. This value has no effect on the
computed minimizer $\bmx$. The default is {\tt f = 0.0}.

\itt{reduction} is a scalar variable of type \realdp, that holds the value
of the reduction factor for a suggested subsequent trust-region radius
(see {\tt control\%next\_radius}).
The suggested radius will be {\tt reduction} times the smaller of
the current radius and $\|\bmx\|_{\bmS}$ at the output $\bmx$.
The default is {\tt reduction = 0.5}.

\itt{stop\_residual} is a scalar variable of type \realdp, that holds
the value of the stopping tolerance used by the algorithm. The
iteration stops as soon as $\bmx$ and $\lambda$ are found to satisfy
$\| ( \bmH + \lambda \bmS ) \bmx + \bmc \| <$ {\tt stop\_residual} 
$\times \max( 1, \|\bmc\| )$.
The default is {\tt stop\_residual =} $10\sqrt{u}$,
where $u$ is {\tt EPSILON(1.0\_rp\_)}

\itt{reorthogonalize} is a scalar variable of type default \logical, that
may be set \true\ if the user wishes the package to reorthogonalise
the generated basis of the extended Krylov space at every iteration.
This can be very expensive, and is generally not warranted.
The default is {\tt reorthogonalize = \false} which is our recommendation.

\itt{s\_version\_52} is a scalar variable of type default \logical, that
may be set \true\ if the user wishes to use Algorithm 5.2 in the
paper to generate the extended Krylov space recurrences when a non-unit $S$
is given, and \false\ if those from Algorithm B.3 should be used instead.
In practice, there is very little difference in performance and accuracy.
The default is {\tt s\_version\_52 = \true}.

\itt{perturb\_c} is a scalar variable of type default \logical, that
may be set \true\ if the user wishes the package make a tiny 
pseudo-random perturbations to the components of the term $\bmc$ 
to try to protect from the so-called (probability zero) ``hard case''.
Perturbations are generally not needed, and should only be used in
very exceptional cases.
The default is {\tt perturb\_c = \false}.

\itt{stop\_check\_all\_orders} is a scalar variable of type default \logical, 
that may be set \true\ if the user wishes the package to check for termination
for each new member of the extended Krylov space. Such checks incur some extra
cost, and experience shows that testing every second member is sufficient, 
using {\tt stop\_check\_all\_orders = \false}.
The default is {\tt stop\_check\_all\_orders = \false}.

\itt{new\_radius} is a scalar variable of type 
default \logical, that if \true\ will resolve the 
problem with the previous $\bmH$, $\bmc$ and (if provided) $\bmS$, but
with the smaller radius, {\tt radius}, 
provided to {\tt \packagename\_solve}.
The default is {\tt new\_radius = \false}.

\itt{new\_values} is a scalar variable of type 
default \logical, that if \present\ and \true\ will resolve the 
problem with the data structures set for the previous 
$\bmH$ and (if provided) $\bmS$, but with new values {\tt H\%val}, {\tt C} 
and/or {\tt S\%val} provided to {\tt \packagename\_solve}.
The default is {\tt new\_values = \false}.

\itt{space\_critical} is a scalar variable of type default \logical, that
may be set \true\ if the user wishes the package to allocate as little
internal storage as possible, and \false\ otherwise. The package may
be more efficient if {\tt space\_critical} is set \false.
The default is {\tt space\_critical = \false}.

\itt{deallocate\_error\_fatal} is a scalar variable of type default \logical,
that may be set \true\ if the user wishes the package to return to the user
in the unlikely event that an internal array deallocation fails,
and \false\ if the package should be allowed to try to continue.
The default is {\tt deallocate\_error\_fatal = \false}.

\itt{linear\_solver} is a scalar variable of type default \character\
and length 30, that specifies the external package to be used to
solve any symmetric positive-definite linear system involving $\bmH$ 
that might arise. Current possible
choices are {\tt 'sils'}, {\tt 'ma27'}, {\tt 'ma57'}, {\tt 'ma77'},
{\tt 'ma86'}, {\tt 'ma87'}, {\tt 'ma97'}, {\tt ssids}, {\tt 'pardiso'},
{\tt 'wsmp'}, {\tt 'sytr'}, {\tt 'potr'} and {\tt 'pbtr'}
although only {\tt 'sytr'}, {\tt 'potr'}, {\tt 'pbtr'} and, for 
OMP 4.0-compliant compilers, {\tt 'ssids'} are installed by default.
See the documentation for the \galahad\ package {\tt SLS} for further details.
The default is {\tt linear\_solver = 'ssids'}, but we recommend
{\tt 'pbtr'} instead if $\bmH$ is banded with a small bandwidth.

\itt{linear\_solver\_for\_S} is a scalar variable of type default \character\
and length 30, that specifies the external package to be used to
solve any symmetric positive-definite linear system involving the optional
$\bmS$ that might arise. Current possible
choices are {\tt 'sils'}, {\tt 'ma27'}, {\tt 'ma57'}, {\tt 'ma77'},
{\tt 'ma86'}, {\tt 'ma87'}, {\tt 'ma97'}, {\tt ssids}, {\tt 'pardiso'},
{\tt 'wsmp'}, {\tt 'sytr'}, {\tt 'potr'} and {\tt 'pbtr'}
although only {\tt 'sytr'}, {\tt 'potr'}, {\tt 'pbtr'} and, for 
OMP 4.0-compliant compilers, {\tt 'ssids'} are installed by default.
See the documentation for the \galahad\ package {\tt SLS} for further details.
The default is {\tt linear\_solver = 'ssids'}, but we recommend
{\tt 'pbtr'} instead if $\bmS$ is banded with a small bandwidth.

\itt{prefix} is a scalar variable of type default \character\
and length 30, that may be used to provide a user-selected
character string to preface every line of printed output.
Specifically, each line of output will be prefaced by the string
{\tt prefix(2:LEN(TRIM(prefix))-1)},
thus ignoring the first and last non-null components of the
supplied string. If the user does not want to preface lines by such
a string, they may use the default {\tt prefix = ""}.

\itt{SLS\_control} is a scalar variable of type
{\tt SLS\_control\_type} that is used to control various aspects of the
factorization package {\tt SLS}. See the documentation for
{\tt \libraryname\_SLS} for more details.

\itt{SLS\_S\_control} is a scalar variable of type
{\tt SLS\_control\_type} that is used to control various aspects of the
factorization package {\tt SLS} when applied to $\bmS$. See the documentation 
for {\tt \libraryname\_SLS} for more details.

\itt{TRS\_control} is a scalar variable of type
{\tt TRS\_control\_type} that is used to control various aspects of the
diagonal trust-region solver from the package {\tt TRS}. See the documentation 
for {\tt \libraryname\_TRS} for more details.

\end{description}

%%%%%%%%%%% time type %%%%%%%%%%%

\subsubsection{The derived data type for holding timing
 information}\label{typetime}
The derived data type
{\tt \packagename\_time\_type}
is used to hold elapsed CPU and system clock times for the various parts of
the calculation. The components of
{\tt \packagename\_time\_type}
are:
\begin{description}
\itt{total} is a scalar variable of type \realdp, that gives
 the total CPU time spent in the package.

\itt{assemble} is a scalar variable of type \realdp, that gives
 the CPU time spent assembling the matrices $\bmH$ and (if provided) $\bmS$
 from their constituent parts.

\itt{analyse} is a scalar variable of type \realdp, that gives
 the CPU time spent analysing the matrices $\bmH$ and (if provided) $\bmS$
 prior to factorization.

\itt{factorize} is a scalar variable of type \realdp, that gives
 the CPU time spent factorizing the matrices $\bmH$ and (if provided) $\bmS$.

\itt{solve} is a scalar variable of type \realdp, that gives
 the CPU time spent using the factors to solve relevant linear equations.

\itt{clock\_total} is a scalar variable of type \realdp, that gives
 the total elapsed system clock time spent in the package.

\itt{clock\_assemble} is a scalar variable of type \realdp, that gives
 the elapsed system clock time spent assembling the 
 matrices $\bmH$ and (if provided) $\bmS$ from their constituent parts.

\itt{clock\_analyse} is a scalar variable of type \realdp, that gives
 the elapsed system clock time spent analysing the matrices $\bmH$ and
  (if provided) $\bmS$ prior to factorization.

\itt{clock\_factorize} is a scalar variable of type \realdp, that gives
 the elapsed system clock time spent factorizing the required matrices.

\itt{clock\_solve} is a scalar variable of type \realdp, that gives
 the elapsed system clock time spent using the factors to solve relevant
linear equations.

\end{description}

%%%%%%%%%%% inform type %%%%%%%%%%%

\subsubsection{The derived data type for holding informational
 parameters}\label{typeinform}
The derived data type
{\tt \packagename\_inform\_type}
is used to hold parameters that give information about the progress and needs
of the algorithm. The components of
{\tt \packagename\_inform\_type}
are:

\begin{description}
\itt{status} is a scalar variable of type \integer, that gives the
current status of the algorithm. See Section~\ref{galerrors} for details.

\itt{alloc\_status} is a scalar variable of type \integer,
that gives the status of the last internal array allocation
or deallocation. This will be {\tt 0} if {\tt status = 0}.

\itt{bad\_alloc} is a scalar variable of type default \character\
and length 80, that  gives the name of the last internal array
for which there were allocation or deallocation errors.
This will be the null string if {\tt status = 0}.

\itt{iter} is a scalar variable of type \integer, that gives the
total number of iterations required.

\itt{n\_vec} is a scalar variable of type \integer, that gives the
number of orthogonal vectors required (the dimension of the extended-Krylov
subspace).

\itt{obj} is a scalar variable of type \realdp, that holds the
value of the objective function $\half \bmx^T \bmH \bmx  +  \bmc^T \bmx$.

\itt{x\_norm} is a scalar variable of type \realdp,
that holds the value of $\|\bmx\|_{\bmS}$.

\itt{multiplier} is a scalar variable of type \realdp, that holds the
value of the Lagrange multiplier $\lambda$ associated with the constraint.

\itt{radius} is a scalar variable of type \realdp, that holds the value of
the current radius.

\itt{next\_radius} is a scalar variable of type \realdp, that holds the value 
of the proposed next radius to be used if the current radius proves to be
too large (see {\tt inform\%reduction}).

\itt{error} is a scalar variable of type \realdp, that holds the value 
of the norm of the maximum relative residual error, 
$\|(\bmH+\lambda\bmS) \bmx + \bmc\|/\max(1,\|\bmc\|)$.

\ittf{time} is a scalar variable of type {\tt \packagename\_time\_type}
whose components are used to hold elapsed CPU  and system clock times for the
various parts of the calculation (see Section~\ref{typetime}).

\itt{SLS\_inform} is a scalar variable of type {\tt SLS\_inform\_type},
that holds informational parameters concerning the analysis, factorization
and solution phases for $\bmH$ performed by
the \galahad\ sparse matrix factorization package {\tt SLS}.
See the documentation for the package {\tt SLS} for details of the
derived type {\tt SLS\_inform\_type}.

\itt{SLS\_S\_inform} is a scalar variable of type {\tt SLS\_inform\_type},
that holds informational parameters concerning the analysis, factorization
and solution phases for $\bmS$, if present, performed by
the \galahad\ sparse matrix factorization package {\tt SLS}.
See the documentation for the package {\tt SLS} for details of the
derived type {\tt SLS\_inform\_type}.

\itt{TRS\_inform} is a scalar variable of type {\tt TRS\_inform\_type},
that holds informational parameters concerning the 
diagonal trust-region subroutine
contained in the \galahad\ refinement package {\tt TRS}.
See the documentation for the package {\tt TRS} for details of the
derived type {\tt TRS\_inform\_type}.


\end{description}

%%%%%%%%%%% data type %%%%%%%%%%%

\subsubsection{The derived data type for holding problem data}\label{typedata}
The derived data type
{\tt \packagename\_data\_type}
is used to hold all the data for a particular problem between calls of
{\tt \packagename} procedures.
This data should be preserved, untouched, from the initial call to
{\tt \packagename\_initialize}
to the final call to
{\tt \packagename\_terminate}.

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\galarguments
There are three procedures for user calls
(see Section~\ref{galfeatures} for further features):

\begin{enumerate}
\item The subroutine
      {\tt \packagename\_initialize}
      is used to set default values and initialize private data.
\item The subroutine
      {\tt \packagename\_solve}
      is called to solve the problem.
\item The subroutine
      {\tt \packagename\_terminate}
      is provided to allow the user to automatically deallocate array
       components of the private data, allocated by
       {\tt \packagename\_solve},
       at the end of the solution process.
\end{enumerate}
We use square brackets {\tt [ ]} to indicate \optional\ arguments.

%%%%%% initialization subroutine %%%%%%

\subsubsection{The initialization subroutine}\label{subinit}
 Default values are provided as follows:

\vspace*{2mm}
\hskip0.5in
{\tt CALL \packagename\_initialize( data, control, inform )}

\begin{description}

\itt{data} is a scalar \intentinout argument of type
{\tt \packagename\_data\_type}
(see Section~\ref{typedata}). It is used to hold data about the problem being
solved.

\itt{control} is a scalar \intentout argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}).
On exit, {\tt control} contains default values for the components as
described in Section~\ref{typecontrol}.
These values should only be changed after calling
{\tt \packagename\_initialize}.

\itt{inform} is a scalar \intentout\ argument of type
{\tt \packagename\_inform\_type}
(see Section~\ref{typeinform}). A successful call to
{\tt \packagename\_initialize}
is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\end{description}

%%%%%%%%% problem solution subroutine %%%%%%

\subsubsection{The optimization problem solution subroutine}
The trust-region solution algorithm is called as follows:

\vspace*{2mm}
\hskip0.5in
{\tt CALL \packagename\_solve( n, H, C, radius, X, data, control, inform[, S])}

\begin{description}

\ittf{n} is a scalar \intentin\ argument of type \integer, that must be
set to the number of unknowns, $n$. {\bf Restriction: } $n  >  0$.

\ittf{H} is scalar \intentin\ argument of type {\tt SMT\_TYPE}
that holds the Hessian matrix $\bmH$. The following components
are used here:

\begin{description}

\itt{H\%type} is an allocatable array of rank one and type default
\character, that
is used to indicate the storage scheme used. If the dense storage scheme
(see Section~\ref{dense}) is used,
the first five components of {\tt H\%type} must contain the
string {\tt DENSE}.
For the sparse co-ordinate scheme (see Section~\ref{coordinate}),
the first ten components of {\tt H\%type} must contain the
string {\tt COORDINATE},
for the sparse row-wise storage scheme (see Section~\ref{rowwise}),
the first fourteen components of {\tt H\%type} must contain the
string {\tt SPARSE\_BY\_ROWS},
and for the diagonal storage scheme (see Section~\ref{diagonal}),
the first eight components of {\tt H\%type} must contain the
string {\tt DIAGONAL},
for the scaled-identity matrix storage scheme
(see Section~\ref{scaled-identity}),
the first fifteen components of {\tt H\%type} must contain the
string {\tt SCALED\_IDENTITY},
for the identity matrix storage scheme
(see Section~\ref{identity}),
the first eight components of {\tt H\%type} must contain the
string {\tt IDENTITY}, and
for the zero matrix storage scheme
(see Section~\ref{zero}),
the first four components of {\tt H\%type} must contain the
string {\tt ZERO}.

For convenience, the procedure {\tt SMT\_put}
may be used to allocate sufficient space and insert the required keyword
into {\tt H\%type}.
For example, if we wish to store $\bmS$ using the co-ordinate scheme,
we may simply
%\vspace*{-2mm}
{\tt
\begin{verbatim}
        CALL SMT_put( H%type, 'COORDINATE' )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent
See the documentation for the \galahad\ package {\tt SMT}
for further details on the use of {\tt SMT\_put}.

\itt{H\%ne} is a scalar variable of type \integer, that
holds the number of entries in the {\bf lower triangular} part of $\bmH$
in the sparse co-ordinate storage scheme (see Section~\ref{coordinate}).
It need not be set for any of the other three schemes.

\itt{H\%val} is a rank-one allocatable array of type \realdp, that holds
the values of the entries of the {\bf lower triangular} part
of the Hessian matrix $\bmH$ in any of the
storage schemes discussed in Section~\ref{galmatrix}.

\itt{H\%row} is a rank-one allocatable array of type \integer,
that holds the row indices of the {\bf lower triangular} part of $\bmH$
in the sparse co-ordinate storage
scheme (see Section~\ref{coordinate}).
It need not be allocated for any of the other three schemes.

\itt{H\%col} is a rank-one allocatable array variable of type \integer,
that holds the column indices of the {\bf lower triangular} part of
$\bmH$ in either the sparse co-ordinate
(see Section~\ref{coordinate}), or the sparse row-wise
(see Section~\ref{rowwise}) storage scheme.
It need not be allocated when the dense or diagonal storage schemes are used.

\itt{H\%ptr} is a rank-one allocatable array of dimension {\tt n+1} and type
\integer, that holds the starting position of
each row of the {\bf lower triangular} part of $\bmH$, as well
as the total number of entries plus one, in the sparse row-wise storage
scheme (see Section~\ref{rowwise}). It need not be allocated when the
other schemes are used.

\end{description}

\ittf{C} is an array \intentin\ argument of dimension {\tt n} and
type \realdp,  whose $i$-th entry holds the component $c_i$ of
the vector $\bmc$ for the objective function.

\itt{radius} is a scalar \intentin\ variable of type default \realdp,
that must be set on initial entry
to the value of the radius of the trust-region constraint, $\Delta$.
{\bf Restriction: } $\Delta > 0$.

\ittf{X} is an array \intentout\ argument of dimension {\tt n} and
type \realdp, that holds an estimate of the solution $\bmx$
of the problem on exit.

\itt{data} is a scalar \intentinout argument of type
{\tt \packagename\_data\_type}
(see Section~\ref{typedata}). It is used to hold data about the problem being
solved. It must not have been altered {\bf by the user} since the last call to
{\tt \packagename\_initialize}.

\itt{control} is a scalar \intentin\ argument of type
{\tt \packagename\_control\_type}.
(see Section~\ref{typecontrol}).
Default values may be assigned by calling {\tt \packagename\_initialize}
prior to the first call to {\tt \packagename\_solve}.

\itt{inform} is a scalar \intentinout argument of type
{\tt \packagename\_inform\_type}
(see Section~\ref{typeinform})
whose components need not be set on entry.
A successful call to
{\tt \packagename\_solve}
is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\ittf{S} is an \optional\ scalar \intentin\ argument of type {\tt SMT\_TYPE}
that holds the diagonally dominant scaling matrix $\bmS$. It need only be set
if $\bmS \neq \bmI$ and in this case the following components are used:

\begin{description}

\itt{S\%type} is an allocatable array of rank one and type default
\character, that
is used to indicate the storage scheme used. If the dense storage scheme
(see Section~\ref{dense}) is used,
the first five components of {\tt S\%type} must contain the
string {\tt DENSE}.
For the sparse co-ordinate scheme (see Section~\ref{coordinate}),
the first ten components of {\tt S\%type} must contain the
string {\tt COORDINATE},
for the sparse row-wise storage scheme (see Section~\ref{rowwise}),
the first fourteen components of {\tt S\%type} must contain the
string {\tt SPARSE\_BY\_ROWS},
and for the diagonal storage scheme (see Section~\ref{diagonal}),
the first eight components of {\tt S\%type} must contain the
string {\tt DIAGONAL},
for the scaled-identity matrix storage scheme
(see Section~\ref{scaled-identity}),
the first fifteen components of {\tt S\%type} must contain the
string {\tt SCALED\_IDENTITY},
for the identity matrix storage scheme
(see Section~\ref{identity}),
the first eight components of {\tt S\%type} must contain the
string {\tt IDENTITY}, and
for the zero matrix storage scheme
(see Section~\ref{zero}),
the first four components of {\tt S\%type} must contain the
string {\tt ZERO}.

For convenience, the procedure {\tt SMT\_put}
may be used to allocate sufficient space and insert the required keyword
into {\tt S\%type}.
For example, if we wish to store $\bmS$ using the co-ordinate scheme,
we may simply
%\vspace*{-2mm}
{\tt
\begin{verbatim}
        CALL SMT_put( M%type, 'COORDINATE' )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent
See the documentation for the \galahad\ package {\tt SMT}
for further details on the use of {\tt SMT\_put}.

\itt{S\%ne} is a scalar variable of type \integer, that
holds the number of entries in the {\bf lower triangular} part of $\bmS$
in the sparse co-ordinate storage scheme (see Section~\ref{coordinate}).
It need not be set for any of the other three schemes.

\itt{S\%val} is a rank-one allocatable array of type \realdp, that holds
the values of the entries of the {\bf lower triangular} part
of the scaling matrix $\bmS$ in any of the
storage schemes discussed in Section~\ref{galmatrix}.

\itt{S\%row} is a rank-one allocatable array of type \integer,
that holds the row indices of the {\bf lower triangular} part of $\bmS$
in the sparse co-ordinate storage
scheme (see Section~\ref{coordinate}).
It need not be allocated for any of the other three schemes.

\itt{S\%col} is a rank-one allocatable array variable of type \integer,
that holds the column indices of the {\bf lower triangular} part of
$\bmS$ in either the sparse co-ordinate
(see Section~\ref{coordinate}), or the sparse row-wise
(see Section~\ref{rowwise}) storage scheme.
It need not be allocated when the dense or diagonal storage schemes are used.

\itt{S\%ptr} is a rank-one allocatable array of dimension {\tt n+1} and type
\integer, that holds the starting position of
each row of the {\bf lower triangular} part of $\bmS$, as well
as the total number of entries plus one, in the sparse row-wise storage
scheme (see Section~\ref{rowwise}). It need not be allocated when the
other schemes are used.

\end{description}
If {\tt S} is absent, the $\ell_2$-norm, $\|\bmx\|_2 = \sqrt{\bmx^T \bmx}$,
will be employed.

\end{description}

%%%%%%% termination subroutine %%%%%%

\subsubsection{The termination subroutine}
All previously allocated arrays are deallocated as follows:

\vspace*{2mm}
\hskip0.5in
{\tt CALL \packagename\_terminate( data, control, inform )}

\begin{description}

\itt{data} is a scalar \intentinout argument of type
{\tt \packagename\_data\_type}
exactly as for
{\tt \packagename\_solve}
that must not have been altered {\bf by the user} since the last call to
{\tt \packagename\_initialize}.
On exit, array components will have been deallocated.

\itt{control} is a scalar \intentin argument of type
{\tt \packagename\_control\_type}
exactly as for
{\tt \packagename\_solve}.

\itt{inform} is a scalar \intentout argument of type
{\tt \packagename\_inform\_type}
exactly as for
{\tt \packagename\_solve}.
Only the component {\tt status} will be set on exit, and a
successful call to
{\tt \packagename\_terminate}
is indicated when this  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\galerrors
A negative value of  {\tt inform\%status} on exit from
{\tt \packagename\_solve}
or
{\tt \packagename\_terminate}
indicates that an error might have occurred. No further calls should be made
until the error has been corrected. Possible values are:

\begin{description}
\itt{\galerrallocate.} An allocation error occurred. A message indicating
the offending
array is written on unit {\tt control\%error}, and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc}, respectively.

\itt{\galerrdeallocate.} A deallocation error occurred.
A message indicating the offending
array is written on unit {\tt control\%error} and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc}, respectively.

\itt{\galerrrestrictions.} ({\tt \packagename\_solve} only)
One of the restrictions
{\tt n > 0}
{\tt radius > 0},
{\tt H\%n} $\neq$ {\tt n},
{\tt S\%n} $\neq$ {\tt n}
or the radius has not decreased when {\tt resolve = /true/}
has been violated.

\itt{\galerranalysis.} ({\tt \packagename\_solve} only)
The analysis phase of the factorization of one of the matrices 
$\bmH$ and (if provided) $\bmS$ failed.

\itt{\galerrfactorization.} ({\tt \packagename\_solve} only)
The factorization of one of the matrices 
$\bmH$ and (if provided) $\bmS$ failed.

\itt{\galerrsolve.} ({\tt \packagename\_solve} only)
The solve phase involving one of the matrices 
$\bmH$ and (if provided) $\bmS$ failed.

\itt{\galerrpreconditioner.} ({\tt \packagename\_solve} only)
The matrix $\bmS$ appears not to be diagonally dominant.

\itt{\galerrillconditioned.} ({\tt \packagename\_solve} only)
The problem is so ill-conditioned that further progress is impossible.

\itt{\galerrmaxiterations.} ({\tt \packagename\_solve} only)
Too many iterations have been required.  This may happen if
{\tt control\%eks\_max} is too small,
but may also be symptomatic of a badly scaled problem.

\itt{\galerrcallorder.} ({\tt \packagename\_solve} only)
A resolve call has been made before an initial call (see 
{\tt control\%new\_radius} and {\tt control\%new\_values}).

\itt{\galerrlapack.} ({\tt \packagename\_solve} only)
An error occurred in a call to an LAPACK subroutine.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Further features %%%%%%%%%%%%%%%%%%%%%%%%

\galfeatures
\noindent In this section, we describe an alternative means of setting
control parameters, that is components of the variable {\tt control} of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}),
by reading an appropriate data specification file using the
subroutine {\tt \packagename\_read\_specfile}. This facility
is useful as it allows a user to change  {\tt \packagename} control parameters
without editing and recompiling programs that call {\tt \packagename}.

A specification file, or specfile, is a data file containing a number of
"specification commands". Each command occurs on a separate line,
and comprises a "keyword",
which is a string (in a close-to-natural language) used to identify a
control parameter, and
an (optional) "value", which defines the value to be assigned to the given
control parameter. All keywords and values are case insensitive,
keywords may be preceded by one or more blanks but
values must not contain blanks, and
each value must be separated from its keyword by at least one blank.
Values must not contain more than 30 characters, and
each line of the specfile is limited to 80 characters,
including the blanks separating keyword and value.

The portion of the specification file used by
{\tt \packagename\_read\_specfile}
must start
with a "{\tt BEGIN \packagename}" command and end with an
"{\tt END}" command.  The syntax of the specfile is thus defined as follows:
\begin{verbatim}
  ( .. lines ignored by TREK_read_specfile .. )
    BEGIN TREK
       keyword    value
       .......    .....
       keyword    value
    END
  ( .. lines ignored by TREK_read_specfile .. )
\end{verbatim}
where keyword and value are two strings separated by (at least) one blank.
The ``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiter command lines
may contain additional (trailing) strings so long as such strings are
separated by one or more blanks, so that lines such as
\begin{verbatim}
    BEGIN TREK SPECIFICATION
\end{verbatim}
and
\begin{verbatim}
    END TREK SPECIFICATION
\end{verbatim}
are acceptable. Furthermore,
between the
``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiters,
specification commands may occur in any order.  Blank lines and
lines whose first non-blank character is {\tt !} or {\tt *} are ignored.
The content
of a line after a {\tt !} or {\tt *} character is also
ignored (as is the {\tt !} or {\tt *}
character itself). This provides an easy manner to "comment out" some
specification commands, or to comment specific values
of certain control parameters.

The value of a control parameters may be of three different types, namely
integer, logical or real.
Integer and real values may be expressed in any relevant Fortran integer and
floating-point formats (respectively). Permitted values for logical
parameters are "{\tt ON}", "{\tt TRUE}", "{\tt .TRUE.}", "{\tt T}",
"{\tt YES}", "{\tt Y}", or "{\tt OFF}", "{\tt NO}",
"{\tt N}", "{\tt FALSE}", "{\tt .FALSE.}" and "{\tt F}".
Empty values are also allowed for
logical control parameters, and are interpreted as "{\tt TRUE}".

The specification file must be open for
input when {\tt \packagename\_read\_specfile}
is called, and the associated device number
passed to the routine in device (see below).
Note that the corresponding
file is {\tt REWIND}ed, which makes it possible to combine the specifications
for more than one program/routine.  For the same reason, the file is not
closed by {\tt \packagename\_read\_specfile}.

Control parameters corresponding to the components
{\tt TRS\_control},
{\tt SLS\_control}
and
{\tt IR\_control} may be changed by including additional sections enclosed by
``{\tt BEGIN TRS}'' and
``{\tt END TRS}'', and
``{\tt BEGIN SLS}'' and
``{\tt END SLS}'', respectively.
See the specification sheets for the packages
{\tt \libraryname\_TRS}
and
{\tt \libraryname\_SLS}

for further details.

\subsubsection{To read control parameters from a specification file}
\label{readspec}

Control parameters may be read from a file as follows:
\hskip0.5in
\def\baselinestretch{0.8} {\tt \begin{verbatim}
     CALL TREK_read_specfile( control, device )
\end{verbatim}}
\def\baselinestretch{1.0}

\begin{description}
\itt{control} is a scalar \intentinout argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}).
Default values should have already been set, perhaps by calling
{\tt \packagename\_initialize}.
On exit, individual components of {\tt control} may have been changed
according to the commands found in the specfile. Specfile commands and
the component (see Section~\ref{typecontrol}) of {\tt control}
that each affects are given in Table~\ref{specfile}.

\bctable{|l|l|l|}
\hline
  command & component of {\tt control} & value type \\
\hline
  {\tt error-printout-device} & {\tt \%error} & integer \\
  {\tt printout-device} & {\tt \%out} & integer \\
  {\tt print-level} & {\tt \%print\_level} & integer \\
  {\tt maximum-subspace-dimension} & {\tt \%eks\_max} & integer \\
  {\tt maximum-number-of-iterations} & {\tt \%it\_max} & integer \\
  {\tt constant-term-in-objective} & {\tt \%f} & real \\
  {\tt radius-reduction-factor} & {\tt \%reduction} & real \\
  {\tt residual-accuracy} & {\tt \%stop\_residual} & real \\
  {\tt reorthogonalize-vectors} & {\tt \%reorthogonalize} & logical \\
  {\tt s-version-52} & {\tt \%s\_version\_52} & logical \\
  {\tt perturb-c} & {\tt \%perturb-c} & logical \\
  {\tt stop-check-all-orders} & {\tt \%stop-check-all-orders} & logical \\
  {\tt space-critical} & {\tt \%space\_critical} & logical \\
  {\tt deallocate-error-fatal} & {\tt \%deallocate\_error\_fatal} & logical \\
  {\tt linear-equation-solver} & {\tt \%linear\_solver} & character \\
  {\tt linear-equation-solver-for-S} & {\tt \%linear\_solver\_for\_S} & character \\
  {\tt output-line-prefix} & {\tt \%prefix} & character \\
\hline

\ectable{\label{specfile}Specfile commands and associated
components of {\tt control}.}

\itt{device} is a scalar \intentin argument of type \integer,
that must be set to the unit number on which the specfile
has been opened. If {\tt device} is not open, {\tt control} will
not be altered and execution will continue, but an error message
will be printed on unit {\tt control\%error}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Information printed %%%%%%%%%%%%%%%%%%%%%%%%

\galinfo
If {\tt control\%print\_level} is positive, information about the progress
of the algorithm will be printed on unit {\tt control\-\%\-out}.
If {\tt control\%print\_level = 1}, a single line of output will be produced
for each iteration of the process. This will include the size of the
subspace, the norm of the current estimate of $\bmx$ and the radius, the
current estimate of the shift $\lambda$, the error
$\|(\bmH+\lambda\bmS) \bmx + \bmc\|/\max(1,\|\bmc\|)$, and
the current value of the objective function.
If {\tt control\%print\_level} $\geq$ {\tt 2}, this
output will be increased to provide significant detail of each iteration.
This extra output includes times for various phases.

%%%%%%%%%%%%%%%%%%%%%% GENERAL INFORMATION %%%%%%%%%%%%%%%%%%%%%%%%

\galgeneral

\galcommon None.
\galworkspace Provided automatically by the module.
\galroutines None.
\galmodules {\tt \packagename\_solve} calls the \galahad\ packages
{\tt \libraryname\_CLOCK},
{\tt \libraryname\_SY\-M\-BOLS},
{\tt \libraryname\_SPACE}, {\tt \libraryname\_\-NORMS},
{\tt \libraryname\_ROOTS}, {\tt \libraryname\_SPECFILE},
{\tt \libraryname\_SMT}, {\tt \libraryname\_RAND}, 
{\tt \libraryname\_TRS}, {\tt \libraryname\_SLS}, 
and
{\tt \libraryname\_MOP}.
\galio Output is under control of the arguments
{\tt control\%error}, {\tt control\%out} and {\tt control\%print\_level}.
\galrestrictions $n  >  0, \;  \Delta  >  0$.
\galportability ISO Fortran~95 + TR 15581 or Fortran~2003.
The package is thread-safe.

%%%%%%%%%%%%%%%%%%%%%% METHOD %%%%%%%%%%%%%%%%%%%%%%%%

\galmethod
The required solution $\bmx_*$ necessarily satisfies the optimality condition
$\bmH \bmx_* + \lambda_* \bmS \bmx_* + \bmc = \bmzero$,
where $\lambda_* \geq 0$ is a Lagrange
multiplier corresponding to the constraint $\|\bmx\|_{\bmS}  \leq  \Delta$.
In addition in all cases, the matrix $\bmH + \lambda_* \bmS$ will be positive
semi-definite; in most instances it will actually be positive definite, 
but in special ``hard'' cases singularity is a possibility.

\noindent
The method is iterative, and is based upon building a solution approximation
from an orthogonal basis of the evolving extended Krylov subspaces
${\cal K}_{2m+1}(\bmH,\bmc) = \mbox{span}\{\bmc,\bmH^{-1}\bmc,\bmH \bmc,
 \bmH^{-2}\bmc, \bmH^2\bmc,\ldots,\bmH^{-m}\bmc,\bmH^{m}\bmc\}$
as $m$ increases. The key observations are (i) the manifold of
solutions to the optimality system
\[ ( \bmH + \lambda \bmI ) \bmx(\lambda) = - \bmc\]
as a function of $\sigma$ is of approximately very low rank, (ii)
the subspace ${\cal K}_{2m+1}(\bmH,\bmc)$ rapidly gives a very good 
approximation to this manifold, (iii) it is straightforward to
build an orthogonal basis of ${\cal K}_{2m+1}(\bmH,\bmc)$
using short-term recurrences and a single factorization of $\bmH$, and
(iv) solutions to the trust-region subproblem restricted to elements
of the orthogonal subspace may be found very efficiently 
using effective high-order root-finding methods. The fact that the
second element in the subspace is $\bmH^{-1} \bmc$ means that it is easy
to check for the interior-solution possibility $\bmx = - \bmH^{-1} c$
that occurs when such a $\bmx$ satisfies $\|\bmx\| \leq \Delta$.
Coping with general scalings $\bmS$ is a straightforward extension so long
as factorization of $\bmS$ is also possible.

\galreference
The method is described in detail in
\vspace*{1mm}

\noindent
H. Al Daas and N. I. M. Gould.
Extended-Krylov-subspace methods for trust-region and norm-regularization 
subproblems. Preprint STFC-P-2025-002, Rutherford Appleton Laboratory,
Oxfordshire, England.

%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\galexample
Suppose we wish to solve a problem in 10,000 unknowns, whose data is
\disp{\bmH  = \mat{ccccc}{ -2 & 1 \\ 1 & -2 & . \\ & . & . & . \\ & & . & -2 & 1
                           \\ & & & 1 & -2 }, \;\;
\bmS  = \mat{ccccc}{ 2 &   \\   & 2  &   \\ & & . \\ & & & 2 & \\ & & & & 2 },
\;\; \bmc  =  \vect{ 1 \\ 1 \\ . \\ 1 \\ 1 } \tim{and} f = 0,}
starting with a radius $\Delta = 10$, but then gradually halving the radius
at every subsequent stage. Then we may use the following code:

%\renewcommand{\packagedir}{\galahaddir/src/forthcoming/\package}
{\tt \small
\VerbatimInput{\packageexample}
}
\noindent
This produces the following output:
{\tt \small
\VerbatimInput{\packageresults}
}

\end{document}

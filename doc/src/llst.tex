\documentclass{galahad}

% set the package name

\newcommand{\package}{llst}
\newcommand{\packagename}{LLST}
\newcommand{\fullpackagename}{\libraryname\_\packagename}

\begin{document}

\galheader

%%%%%%%%%%%%%%%%%%%%%% SUMMARY %%%%%%%%%%%%%%%%%%%%%%%%

\galsummary
Given a real $m$ by $n$ matrix $\bmA$,
a real $n$ by $n$ symmetric diagonally-dominant matrix $\bmS$,
a real $m$ vector $\bmb$ and a scalar $\Delta>0$, this package finds a
{\bf minimizer of the linear least-squares objective function
$\| \bmA \bmx  - \bmb \|_2$, where the vector $\bmx$ is
required to satisfy the constraint $\|\bmx\|_S \leq  \Delta$},
where the $\bmS$-norm of $\bmx$ is $\|\bmx\|_S = \sqrt{\bmx^T \bmS \bmx}$.
This problem commonly occurs as a trust-region subproblem in nonlinear
least-squares calculations.
The package may also be used to solve the related problem in which $\bmx$ is
instead required to satisfy the
{\bf equality constraint $\|\bmx\|_S = \Delta$}.
The matrix $\bmS$ need not be provided in the commonly-occurring
$\ell_2$-trust-region case for which $\bmS = \bmI$, the $n$ by $n$
identity matrix.

\noindent
Factorization of matrices of the form
\eqn{kkt}{\mat{cc}{ \lambda \bmS & \bmA^T \\ \bmA & - \bmI}}
for a succession
of scalars $\lambda$ will be required, so this package is most suited
for the case where such a factorization may be found efficiently. If
this is not the case, the package {\tt \libraryname\_LSTR} may be preferred.


%%%%%%%%%%%%%%%%%%%%%% attributes %%%%%%%%%%%%%%%%%%%%%%%%

\galattributes
\galversions{\tt  \fullpackagename\_single, \fullpackagename\_double}.
\galuses
{\tt \libraryname\_CLOCK},
{\tt \libraryname\_SY\-M\-BOLS},
{\tt \libraryname\_SPACE}, {\tt \libraryname\_\-RAND},
{\tt \libraryname\_\-NORMS},
{\tt \libraryname\_ROOTS}, {\tt \libraryname\_SPECFILE},
{\tt \libraryname\_SBLS},
{\tt \libraryname\_SLS}, {\tt \libraryname\_IR},
{\tt \libraryname\_MOP}
\galdate October 2008.
\galorigin N. I. M. Gould, Rutherford Appleton Laboratory.
\gallanguage Fortran~95 + TR 15581 or Fortran~2003.
\galparallelism Some options may use OpenMP and its runtime library.

%%%%%%%%%%%%%%%%%%%%%% HOW TO USE %%%%%%%%%%%%%%%%%%%%%%%%

\galhowto

Access to the package requires a {\tt USE} statement such as

\medskip\noindent{\em Single precision version}

\hskip0.5in {\tt USE \fullpackagename\_single}

\medskip\noindent{\em Double precision version}

\hskip0.5in {\tt USE  \fullpackagename\_double}

\medskip

\noindent
If it is required to use both modules at the same time, the derived types
{\tt SMT\_TYPE},
{\tt \packagename\_control\_type},
{\tt \packagename\_history\_\-type},
{\tt \packagename\_inform\_type},
{\tt \packagename\_data\_type},
(Section~\ref{galtypes})
and the subroutines
{\tt \packagename\_initialize},
{\tt \packagename\_solve}, {\tt \packagename\_\-terminate}
(Section~\ref{galarguments})
and
{\tt \packagename\_read\_specfile}
(Section~\ref{galfeatures})
must be renamed on one of the {\tt USE} statements.

%%%%%%%%%%%%%%%%%%%%%% matrix formats %%%%%%%%%%%%%%%%%%%%%%%%

\galmatrix
The matrices $\bmA$ and (if required) $\bmS$
may be stored in a variety of input formats.

\subsubsection{Dense storage format}\label{dense}
The matrix $\bmA$ is stored as a compact
dense matrix by rows, that is, the values of the entries of each row in turn are
stored in order within an appropriate real one-dimensional array.
Component $n \ast (i-1) + j$ of the storage array {\tt A\%val} will hold the
value $a_{ij}$ for $i = 1, \ldots , m$, $j = 1, \ldots , n$.
Since $\bmS$ is symmetric, only the lower triangular part (that is the part
$s_{ij}$ for $1 \leq j \leq i \leq n$) need be held. In this case
the lower triangle will be stored by rows, that is
component $i \ast (i-1)/2 + j$ of the storage array {\tt S\%val}
will hold the value $s_{ij}$ (and, by symmetry, $s_{ji}$)
for $1 \leq j \leq i \leq n$.

\subsubsection{Sparse co-ordinate storage format}\label{coordinate}
Only the nonzero entries of the matrices are stored. For the
$l$-th entry of $\bmA$, its row index $i$, column index $j$
and value $a_{ij}$
are stored in the $l$-th components of the integer arrays {\tt A\%row},
{\tt A\%col} and real array {\tt A\%val}, respectively.
The order is unimportant, but the total
number of entries {\tt A\%ne} is also required.
The same scheme is applicable to
$\bmS$ (thus requiring integer arrays {\tt S\%row}, {\tt S\%col}, a real array
{\tt S\%val} and an integer value {\tt S\%ne}),
except that only the entries in the lower triangle need be stored.

\subsubsection{Sparse row-wise storage format}\label{rowwise}
Again only the nonzero entries are stored, but this time
they are ordered so that those in row $i$ appear directly before those
in row $i+1$. For the $i$-th row of $\bmA$, the $i$-th component of a
integer array {\tt A\%ptr} holds the position of the first entry in this row,
while {\tt A\%ptr} $(m+1)$ holds the total number of entries plus one.
The column indices $j$ and values $a_{ij}$ of the entries in the $i$-th row
are stored in components
$l =$ {\tt A\%ptr}$(i)$, \ldots ,{\tt A\%ptr} $(i+1)-1$ of the
integer array {\tt A\%col}, and real array {\tt A\%val}, respectively.
The same scheme is applicable to
$\bmS$ (thus requiring integer arrays {\tt S\%ptr}, {\tt S\%col}, and
a real array {\tt S\%val}),
except that only the entries in the lower triangle need be stored.

For sparse matrices, this scheme almost always requires less storage than
its predecessor.

\subsubsection{Diagonal storage format}\label{diagonal}
If $\bmS$ is diagonal (i.e., $s_{ij} = 0$ for all $1 \leq i \neq j \leq n$)
only the diagonals entries $s_{ii}$, $1 \leq i \leq n$,  need be stored,
and the first $n$ components of the array {\tt S\%val} may be used for
the purpose. This scheme is inappropriate and thus unavailable for $\bmA$.

\subsection{Integer kinds}\label{Integer kinds}
We use the term
long \integer\ to denote {\tt INTEGER\-(kind=long)}, where
{\tt long = selected\_int\_kind(18))}.

%%%%%%%%%%%%%%%%%%%%%% parallel usage %%%%%%%%%%%%%%%%%%%%%%%%

\input{parallel}

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\galtypes
Six derived data types are accessible from the package.

%%%%%%%%%%% matrix data type %%%%%%%%%%%

\subsubsection{The derived data type for holding matrices}\label{typesmt}
The derived data type {\tt SMT\_TYPE} is used to hold the matrices $\bmA$
and perhaps $\bmS$.
The components of {\tt SMT\_TYPE} used here are:

\begin{description}

\ittf{m} is a scalar component of type default \integer,
that holds the number of rows in the matrix.

\ittf{n} is a scalar component of type default \integer,
that holds the number of columns in the matrix.

\ittf{ne} is a scalar variable of type default \integer, that
holds the number of matrix entries.

\ittf{type} is a rank-one allocatable array of type default \character, that
is used to indicate the matrix storage scheme used. Its precise length and
content depends on the type of matrix to be stored.

\ittf{val} is a rank-one allocatable array of type default \realdp\,
and dimension at least {\tt ne}, that holds the values of the entries.
Each pair of off-diagonal entries $s_{ij} = s_{ji}$ of the {\em symmetric}
matrix $\bmS$ is represented as a single entry
(see \S\ref{dense}--\ref{rowwise}).
Any duplicated entries that appear in the sparse
co-ordinate or row-wise schemes will be summed.

\ittf{row} is a rank-one allocatable array of type default \integer,
and dimension at least {\tt ne}, that may hold the row indices of the entries.
(see \S\ref{coordinate}).

\ittf{col} is a rank-one allocatable array of type default \integer,
and dimension at least {\tt ne}, that may hold the column indices of the entries
(see \S\ref{coordinate}--\ref{rowwise}).

\ittf{ptr} is a rank-one allocatable array of type default \integer,
and dimension at least {\tt n + 1}, that may holds the pointers to
the first entry in each row (see \S\ref{rowwise}).

\end{description}

%%%%%%%%%%% control type %%%%%%%%%%%

\subsubsection{The derived data type for holding control
 parameters}\label{typecontrol}
The derived data type
{\tt \packagename\_control\_type}
is used to hold controlling data. Default values may be obtained by calling
{\tt \packagename\_initialize}
(see Section~\ref{subinit}). The components of
{\tt \packagename\_control\_type}
are:

\begin{description}
\itt{error} is a scalar variable of type default \integer, that holds the
stream number for error messages.
Printing of error messages in
{\tt \packagename\_solve} and {\tt \packagename\_terminate}
is suppressed if ${\tt error} \leq {\tt 0}$.
The default is {\tt error = 6}.

\ittf{out} is a scalar variable of type default \integer, that holds the
stream number for informational messages.
Printing of informational messages in
{\tt \packagename\_solve} is suppressed if ${\tt out} < {\tt 0}$.
The default is {\tt out = 6}.

\itt{print\_level} is a scalar variable of type default \integer,
that is used
to control the amount of informational output which is required. No
informational output will occur if ${\tt print\_level} \leq {\tt 0}$. If
{\tt print\_level = 1} a single line of output will be produced for each
iteration of the process. If {\tt print\_level} $\geq$ {\tt 2} this output
will be increased to provide significant detail of each iteration.
The default is {\tt print\_level = 0}.

%\itt{dense\_factorization} is a scalar variable of type default \integer,
%that is used to indicate whether the problem should be treated as dense
%and solved using dense-factorization methods. Possible values are:
%\begin{description}
%\itt{0} the problem should be considered as sparse.
%\itt{1} the problem should be considered as dense.
%\itt{other} the algorithm will decide whether to treat the
%problem as dense or sparse depending on its dimension and the
%sparsity of the matrices involved.
%\end{description}
%The default is {\tt dense\_factorization = 0}.

\itt{new\_a} is a scalar variable of type default \integer, that is used
to indicate how $\bmA$ has changed (if at all) since the previous
call to {\tt \packagename\_solve}. Possible values are:
\begin{description}
\itt{0} $\bmA$ is unchanged.
\itt{1} the values in $\bmA$ have changed, but its nonzero structure
is as before.
\itt{2} both the values and structure of $\bmA$ have changed.
\end{description}
The default is {\tt new\_a = 2}.

\itt{new\_s} is a scalar variable of type default \integer, that is used
to indicate how $\bmS$ (if required) has changed (if at all) since the previous
call to {\tt \packagename\_solve}. Possible values are:
\begin{description}
\itt{0} $\bmS$ is unchanged.
\itt{1} the values in $\bmS$ have changed, but its nonzero structure
is as before.
\itt{2} both the values and structure of $\bmS$ have changed.
\end{description}
The default is {\tt new\_s = 2}.

\itt{max\_factorizations} is a scalar variable of type default \integer,
that holds the maximum number of factorizations which will be permitted.
If {\tt max\_factorizations} is set to a negative number, there will be
no limit on the number of factorizations allowed.
The default is {\tt max\_factorizations = -1}.

\itt{taylor\_max\_degree} is a scalar variable of type default \integer,
that specifies the maximum degree of Taylor approximant that will be used
to approximate the secular function when trying to improve $\lambda$;
a first-degree approximant results in Newton's method.
The higher the degree, the better in general the improvement, but the larger the
cost. Thus there is a balance between many cheap low-degree approximants
and a few more expensive higher-degree ones. Our experience favours
higher-degree approximants.
The default is {\tt taylor\_max\_degree = 3}, which is the highest degree
currently supported.

\itt{initial\_multiplier} is a scalar variables of type \realdp, that should
be set to an initial estimate of the required multiplier $\lambda_*$
(see Section~\ref{galmethod}). The algorithm will only use this value
if {\tt \%use\_initial\_multiplier} is set \true\ (see below), and otherwise
will be reset by {\tt \packagename\_solve}. A good initial estimate
may sometimes dramatically improve the performance of the package.
The default is {\tt initial\_multiplier = 0.0}.

\itt{lower} is a scalar variables of type \realdp, that holds the value
of any known lower bound on the required multiplier $\lambda_*$. A good lower
bound may sometimes dramatically improve the performance of the package, but
an incorrect value might cause the method to fail. Thus resetting
{\tt lower} from its default should be used with caution.
The default is {\tt lower = - HUGE(1.0)}
({\tt -HUGE(1.0D0)} in {\tt \fullpackagename\_double}).

\itt{upper} is a scalar variables of type \realdp, that holds the value
of any known upper bound on the required multiplier $\lambda_*$. A good upper
bound may sometimes dramatically improve the performance of the package, but
an incorrect value might cause the method to fail. Thus resetting
{\tt upper} from its default should be used with caution.
The default is {\tt upper = HUGE(1.0)}
({\tt HUGE(1.0D0)} in {\tt \fullpackagename\_double}).

\itt{stop\_normal} is a scalar variable of type \realdp,
that hold values for the standard convergence tolerances of the method
(see Section~\ref{galmethod}).
In particular, the method is deemed to have converged when the
computed solution $\bmx$ and its multiplier $\lambda$ satisfy either
$\lambda = 0$ and $|\|\bmx\|_S < \Delta$ or
$|\|\bmx\|_S -  \Delta| \leq$ {\tt stop\_normal} $\ast \; \max(1,\Delta)$.
The default is {\tt stop\_normal =} $u^{0.75}$,
where $u$ is {\tt EPSILON(1.0)} ({\tt EPSILON(1.0D0)} in
{\tt \fullpackagename\_double}).

\itt{equality\_problem} is a scalar variable of type default \logical, that
may be set \true\ if the user requires that the solution
occur on the constraint boundary (i.e., that the inequality constraint be
replaced by $\|\bmx\|_S = \Delta$), and \false\ otherwise.
The default is {\tt equality\_problem = \false}.

\itt{use\_initial\_multiplier} is a scalar variable of type default \logical,
that may be set \true\ if the user wishes to use the value of initial
multiplier supplied in {\tt \%initial\_multiplier},
and \false\ if the initial value will be chosen automatically.
The default is {\tt use\_initial\_multiplier = \false}.

\itt{space\_critical} is a scalar variable of type default \logical, that
may be set \true\ if the user wishes the package to allocate as little
internal storage as possible, and \false\ otherwise. The package may
be more efficient if {\tt space\_critical} is set \false.
The default is {\tt space\_critical = \false}.

\itt{deallocate\_error\_fatal} is a scalar variable of type default \logical,
that may be set \true\ if the user wishes the package to return to the user
in the unlikely event that an internal array deallocation fails,
and \false\ if the package should be allowed to try to continue.
The default is {\tt deallocate\_error\_fatal = \false}.

\itt{definite\_linear\_solver} is a scalar variable of type default \character\
and length 30, that specifies the external package to be used to
solve any symmetric positive-definite linear system that might arise.
Current possible
choices are {\tt 'sils'}, {\tt 'ma27'}, {\tt 'ma57'}, {\tt 'ma77'},
{\tt 'ma86'}, {\tt 'ma87'}, {\tt 'ma97'}, {\tt 'ssids'}, {\tt 'pardiso'}
and {\tt 'wsmp'}.
See the documentation for the \galahad\ package {\tt SLS} for further details.
The default is {\tt definite\_linear\_solver = 'sils'}.

\itt{prefix} is a scalar variable of type default \character\
and length 30, that may be used to provide a user-selected
character string to preface every line of printed output.
Specifically, each line of output will be prefaced by the string
{\tt prefix(2:LEN(TRIM(prefix))-1)},
thus ignoring the first and last non-null components of the
supplied string. If the user does not want to preface lines by such
a string, they may use the default {\tt prefix = ""}.

\itt{SBLS\_control} is a scalar variable of type
{\tt SBLS\_control\_type} that is used to control various aspects of the
factorization package {\tt SBLS}. See the documentation for
{\tt \libraryname\_SBLS} for more details.

\itt{SLS\_control} is a scalar variable of type
{\tt SLS\_control\_type} that is used to control various aspects of the
factorization package {\tt SLS}. See the documentation for
{\tt \libraryname\_SLS} for more details.

\itt{IR\_control} is a scalar variable of type
{\tt IR\_control\_type} that is used to control various aspects of the
iterative refinement package {\tt IR}. See the documentation for
{\tt \libraryname\_IR} for more details.

\end{description}

%%%%%%%%%%% history type %%%%%%%%%%%

\subsubsection{The derived data type for holding history
 information}\label{typehist}
The derived data type
{\tt \packagename\_history\_type}
is used to hold the value of $\|\bmx(\lambda)\|_S$, where
$\bmx(\lambda)$ satisfies
$(\bmH + \lambda \bmS)\bmx(\lambda) = - \bmc$ and $\bmA\bmx(\lambda) = \bmzero$
for a specific $\lambda$ arising during the computation.
The components of
{\tt \packagename\_history\_type}
are:
\begin{description}
\itt{lambda} is a scalar variable of type default \realdp, that gives
 the value $\lambda$.

\itt{x\_norm} is a scalar variable of type default \real, that gives
 the corresponding value $\|\bmx(\lambda)\|_S$.

\end{description}

%%%%%%%%%%% time type %%%%%%%%%%%

\subsubsection{The derived data type for holding timing
 information}\label{typetime}
The derived data type
{\tt \packagename\_time\_type}
is used to hold elapsed CPU and system clock times for the various parts of
the calculation. The components of
{\tt \packagename\_time\_type}
are:
\begin{description}
\itt{total} is a scalar variable of type default \realdp, that gives
 the total CPU time spent in the package.

\itt{assemble} is a scalar variable of type default \realdp, that gives
 the CPU time spent assembling the matrix \req{kkt} from its constituent parts.

\itt{analyse} is a scalar variable of type default \realdp, that gives
 the CPU time spent analysing required matrices prior to factorization.

\itt{factorize} is a scalar variable of type default \realdp, that gives
 the CPU time spent factorizing the required matrices.

\itt{solve} is a scalar variable of type default \realdp, that gives
 the CPU time spent using the factors to solve relevant linear equations.

\itt{clock\_total} is a scalar variable of type default \realdp, that gives
 the total elapsed system clock time spent in the package.

\itt{clock\_assemble} is a scalar variable of type default \realdp, that gives
 the elapsed system clock time spent assembling the matrix \req{kkt} from
its constituent parts.

\itt{clock\_analyse} is a scalar variable of type default \realdp, that gives
 the elapsed system clock time spent analysing required matrices prior to
factorization.

\itt{clock\_factorize} is a scalar variable of type default \realdp, that gives
 the elapsed system clock time spent factorizing the required matrices.

\itt{clock\_solve} is a scalar variable of type default \realdp, that gives
 the elapsed system clock time spent using the factors to solve relevant
linear equations.

\end{description}

%%%%%%%%%%% inform type %%%%%%%%%%%

\subsubsection{The derived data type for holding informational
 parameters}\label{typeinform}
The derived data type
{\tt \packagename\_inform\_type}
is used to hold parameters that give information about the progress and needs
of the algorithm. The components of
{\tt \packagename\_inform\_type}
are:

\begin{description}
\itt{status} is a scalar variable of type default \integer, that gives the
current status of the algorithm. See Section~\ref{galerrors} for details.

\itt{alloc\_status} is a scalar variable of type default \integer,
that gives the status of the last internal array allocation
or deallocation. This will be 0 if {\tt status = 0}.

\itt{bad\_alloc} is a scalar variable of type default \character\
and length 80, that  gives the name of the last internal array
for which there were allocation or deallocation errors.
This will be the null string if {\tt status = 0}.

\itt{factorizations} is a scalar variable of type default \integer, that
gives the number of factorizations of the matrix \req{kkt}
for different $\lambda$, performed during the calculation.

\itt{max\_entries\_factors} is a scalar variable of type default \integer, that
gives the maximum number of entries in any of the matrix factorizations
performed during the calculation.

\itt{len\_history} is a scalar variable of type default \integer, that gives
the number of $(\lambda,\|\bmx(\lambda)\|_S)$ pairs encountered during the
calculation.

\itt{r\_normj} is a scalar variable of type default \realdp, that holds the
value of the norm of the residual $\| \bmA \bmx - \bmb\|_2$.

\itt{x\_norm} is a scalar variable of type default \realdp,
that holds the value of $\|\bmx\|_S$.

\itt{multiplier} is a scalar variable of type default \realdp, that holds the
value of the Lagrange multiplier $\lambda$ associated with the constraint.

\ittf{time} is a scalar variable of type {\tt \packagename\_time\_type}
whose components are used to hold elapsed CPU  and system clock times for the
various parts of the calculation (see Section~\ref{typetime}).

\itt{history} is an array argument of dimension {\tt len\_history} and
type {\tt \packagename\_history\_type} that contains a list of pairs
$(\lambda,\|\bmx(\lambda)\|_S)$ encountered during the
calculation (see Section~\ref{typehist}).

\itt{SBLS\_inform} is a scalar variable of type {\tt SBLS\_inform\_type},
that holds informational parameters concerning the analysis, factorization
and solution phases performed by
the \galahad\ sparse matrix factorization package {\tt SBLS}.
See the documentation for the package {\tt SBLS} for details of the
derived type {\tt SBLS\_inform\_type}.

\itt{SLS\_inform} is a scalar variable of type {\tt SLS\_inform\_type},
that holds informational parameters concerning the analysis, factorization
and solution phases performed by
the \galahad\ sparse matrix factorization package {\tt SLS}.
See the documentation for the package {\tt SLS} for details of the
derived type {\tt SLS\_inform\_type}.

\itt{IR\_inform} is a scalar variable of type {\tt IR\_inform\_type},
that holds informational parameters concerning the iterative refinement
subroutine contained in the \galahad\ refinement package {\tt IR}.
See the documentation for the package {\tt IR} for details of the
derived type {\tt IR\_inform\_type}.


\end{description}

%%%%%%%%%%% data type %%%%%%%%%%%

\subsubsection{The derived data type for holding problem data}\label{typedata}
The derived data type
{\tt \packagename\_data\_type}
is used to hold all the data for a particular problem between calls of
{\tt \packagename} procedures.
This data should be preserved, untouched, from the initial call to
{\tt \packagename\_initialize}
to the final call to
{\tt \packagename\_terminate}.

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\galarguments
There are three procedures for user calls
(see Section~\ref{galfeatures} for further features):

\begin{enumerate}
\item The subroutine
      {\tt \packagename\_initialize}
      is used to set default values and initialize private data.
\item The subroutine
      {\tt \packagename\_solve}
      is called to solve the problem.
\item The subroutine
      {\tt \packagename\_terminate}
      is provided to allow the user to automatically deallocate array
       components of the private data, allocated by
       {\tt \packagename\_solve},
       at the end of the solution process.
\end{enumerate}
We use square brackets {\tt [ ]} to indicate \optional\ arguments.

%%%%%% initialization subroutine %%%%%%

\subsubsection{The initialization subroutine}\label{subinit}
 Default values are provided as follows:

\hskip0.5in
{\tt CALL \packagename\_initialize( data, control, inform )}

\begin{description}

\itt{data} is a scalar \intentinout argument of type
{\tt \packagename\_data\_type}
(see Section~\ref{typedata}). It is used to hold data about the problem being
solved.

\itt{control} is a scalar \intentout argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}).
On exit, {\tt control} contains default values for the components as
described in Section~\ref{typecontrol}.
These values should only be changed after calling
{\tt \packagename\_initialize}.

\itt{inform} is a scalar \intentout\ argument of type
{\tt \packagename\_inform\_type}
(see Section~\ref{typeinform}). A successful call to
{\tt \packagename\_initialize}
is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\end{description}

%%%%%%%%% problem solution subroutine %%%%%%

\subsubsection{The optimization problem solution subroutine}
The optimization problem solution algorithm is called as follows:

\hskip0.5in
{\tt CALL \packagename\_solve( m, n, radius, A, B, X, data, control, inform[, S] )}

\begin{description}

\ittf{m} is a scalar \intentin\ argument of type default \integer, that must be
set to the number of residuals, $m$. {\bf Restriction: } $m  >  0$.

\ittf{n} is a scalar \intentin\ argument of type default \integer, that must be
set to the number of unknowns, $n$. {\bf Restriction: } $n  >  0$.

\itt{radius} is a scalar \intentin\ variable of type default \realdp,
that must be set on initial entry
to the value of the radius of the trust-region constraint, $\Delta$.
{\bf Restriction: } $\Delta > 0$.

\ittf{A} is a scalar \intentin\ argument of type {\tt SMT\_TYPE}
that holds the constraint matrix $\bmA$. The following components are used:

\begin{description}

\itt{A\%type} is an allocatable array of rank one and type default
\character, that
is used to indicate the storage scheme used. If the dense storage scheme
(see Section~\ref{dense}) is used,
the first five components of {\tt A\%type} must contain the
string {\tt DENSE}.
For the sparse co-ordinate scheme (see Section~\ref{coordinate}),
the first ten components of {\tt A\%type} must contain the
string {\tt COORDINATE},
for the sparse row-wise storage scheme (see Section~\ref{rowwise}),
the first fourteen components of {\tt A\%type} must contain the
string {\tt SPARSE\_BY\_ROWS}.

For convenience, the procedure {\tt SMT\_put}
may be used to allocate sufficient space and insert the required keyword
into {\tt A\%type}.
For example, if we wish to store $\bmA$ using the co-ordinate scheme,
we may simply
%\vspace*{-2mm}
{\tt
\begin{verbatim}
        CALL SMT_put( A%type, 'COORDINATE' )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent
See the documentation for the \galahad\ package {\tt SMT}
for further details on the use of {\tt SMT\_put}.

\itt{A\%m} is a scalar variable of type default \integer, that
holds the number of rows of $\bmA$.

\itt{A\%ne} is a scalar variable of type default \integer, that
holds the number of entries in $\bmA$
in the sparse co-ordinate storage scheme (see Section~\ref{coordinate}).
It need not be set for either of the other schemes.

\itt{A\%val} is a rank-one allocatable array of type default \realdp, that holds
the values of the entries of the constraint matrix $\bmA$ in any of the
storage schemes discussed in Section~\ref{galmatrix}.

\itt{A\%row} is a rank-one allocatable array of type default \integer,
that holds the row indices of $\bmA$ in the sparse co-ordinate storage
scheme (see Section~\ref{coordinate}).
It need not be allocated for either of the other schemes.

\itt{A\%col} is a rank-one allocatable array variable of type default \integer,
that holds the column indices of $\bmA$ in either the sparse co-ordinate
(see Section~\ref{coordinate}), or the sparse row-wise
(see Section~\ref{rowwise}) storage scheme.
It need not be allocated when the dense storage scheme is used.

\itt{A\%ptr} is a rank-one allocatable array of dimension {\tt A\%m+1} and type
default \integer, that holds the starting position of
each row of $\bmA$, as well
as the total number of entries plus one, in the sparse row-wise storage
scheme (see Section~\ref{rowwise}). It need not be allocated when the
other schemes are used.
\end{description}

\ittf{B} is an array \intentin\ argument of dimension {\tt m} and
type default \realdp,  whose $i$-th entry holds the component $b_i$ of
the vector $\bmb$ in the residual.

\ittf{X} is an array \intentout\ argument of dimension {\tt n} and
type default \realdp, that holds an estimate of the solution $\bmx$
of the problem on exit.

\itt{data} is a scalar \intentinout argument of type
{\tt \packagename\_data\_type}
(see Section~\ref{typedata}). It is used to hold data about the problem being
solved. It must not have been altered {\bf by the user} since the last call to
{\tt \packagename\_initialize}.

\itt{control} is a scalar \intentin\ argument of type
{\tt \packagename\_control\_type}.
(see Section~\ref{typecontrol}).
Default values may be assigned by calling {\tt \packagename\_initialize}
prior to the first call to {\tt \packagename\_solve}.

\itt{inform} is a scalar \intentinout argument of type
{\tt \packagename\_inform\_type}
(see Section~\ref{typeinform}).
On initial entry, the component {\tt status} must be set to {\tt 1.}
The remaining components need not be set.
A successful call to
{\tt \packagename\_solve}
is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\ittf{S} is an \optional\ scalar \intentin\ argument of type {\tt SMT\_TYPE}
that holds the diagonally dominant scaling matrix $\bmS$. It need only be set
if $\bmS \neq \bmI$ and in this case the following components are used:

\begin{description}

\itt{S\%type} is an allocatable array of rank one and type default
\character, that
is used to indicate the storage scheme used. If the dense storage scheme
(see Section~\ref{dense}) is used,
the first five components of {\tt S\%type} must contain the
string {\tt DENSE}.
For the sparse co-ordinate scheme (see Section~\ref{coordinate}),
the first ten components of {\tt S\%type} must contain the
string {\tt COORDINATE},
for the sparse row-wise storage scheme (see Section~\ref{rowwise}),
the first fourteen components of {\tt S\%type} must contain the
string {\tt SPARSE\_BY\_ROWS},
and for the diagonal storage scheme (see Section~\ref{diagonal}),
the first eight components of {\tt S\%type} must contain the
string {\tt DIAGONAL}.

For convenience, the procedure {\tt SMT\_put}
may be used to allocate sufficient space and insert the required keyword
into {\tt S\%type}.
For example, if we wish to store $\bmS$ using the co-ordinate scheme,
we may simply
%\vspace*{-2mm}
{\tt
\begin{verbatim}
        CALL SMT_put( M%type, 'COORDINATE' )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent
See the documentation for the \galahad\ package {\tt SMT}
for further details on the use of {\tt SMT\_put}.

\itt{S\%ne} is a scalar variable of type default \integer, that
holds the number of entries in the {\bf lower triangular} part of $\bmS$
in the sparse co-ordinate storage scheme (see Section~\ref{coordinate}).
It need not be set for any of the other three schemes.

\itt{S\%val} is a rank-one allocatable array of type default \realdp, that holds
the values of the entries of the {\bf lower triangular} part
of the scaling matrix $\bmS$ in any of the
storage schemes discussed in Section~\ref{galmatrix}.

\itt{S\%row} is a rank-one allocatable array of type default \integer,
that holds the row indices of the {\bf lower triangular} part of $\bmS$
in the sparse co-ordinate storage
scheme (see Section~\ref{coordinate}).
It need not be allocated for any of the other three schemes.

\itt{S\%col} is a rank-one allocatable array variable of type default \integer,
that holds the column indices of the {\bf lower triangular} part of
$\bmS$ in either the sparse co-ordinate
(see Section~\ref{coordinate}), or the sparse row-wise
(see Section~\ref{rowwise}) storage scheme.
It need not be allocated when the dense or diagonal storage schemes are used.

\itt{S\%ptr} is a rank-one allocatable array of dimension {\tt n+1} and type
default \integer, that holds the starting position of
each row of the {\bf lower triangular} part of $\bmS$, as well
as the total number of entries plus one, in the sparse row-wise storage
scheme (see Section~\ref{rowwise}). It need not be allocated when the
other schemes are used.

\end{description}
If {\tt S} is absent, the $\ell_2$-norm, $\|\bmx\|_2 = \sqrt{\bmx^T \bmx}$,
will be employed.


\end{description}

%%%%%%% termination subroutine %%%%%%

\subsubsection{The  termination subroutine}
All previously allocated arrays are deallocated as follows:

\hskip0.5in
{\tt CALL \packagename\_terminate( data, control, inform )}

\begin{description}

\itt{data} is a scalar \intentinout argument of type
{\tt \packagename\_data\_type}
exactly as for
{\tt \packagename\_solve}
that must not have been altered {\bf by the user} since the last call to
{\tt \packagename\_initialize}.
On exit, array components will have been deallocated.

\itt{control} is a scalar \intentin argument of type
{\tt \packagename\_control\_type}
exactly as for
{\tt \packagename\_solve}.

\itt{inform} is a scalar \intentout argument of type
{\tt \packagename\_inform\_type}
exactly as for
{\tt \packagename\_solve}.
Only the component {\tt status} will be set on exit, and a
successful call to
{\tt \packagename\_terminate}
is indicated when this  component {\tt status} has the value 0.
For other return values of {\tt status}, see Section~\ref{galerrors}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\galerrors
A negative value of  {\tt inform\%status} on exit from
{\tt \packagename\_solve}
or
{\tt \packagename\_terminate}
indicates that an error might have occurred. No further calls should be made
until the error has been corrected. Possible values are:

\begin{description}
\itt{\galerrallocate.} An allocation error occurred. A message indicating
the offending
array is written on unit {\tt control\%error}, and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc}, respectively.

\itt{\galerrdeallocate.} A deallocation error occurred.
A message indicating the offending
array is written on unit {\tt control\%error} and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc}, respectively.

\itt{\galerrrestrictions.} ({\tt \packagename\_solve} only)
One of the restrictions
{\tt n > 0},
{\tt m > 0}
or
{\tt radius > 0}
has been violated.

\itt{\galerranalysis.} ({\tt \packagename\_solve} only)
The analysis phase of the factorization of the matrix \req{kkt} failed.

\itt{\galerrfactorization.} ({\tt \packagename\_solve} only)
The factorization of the matrix \req{kkt} failed.

\itt{\galerrpreconditioner.} ({\tt \packagename\_solve} only)
The matrix $\bmS$ appears not to be diagonally dominant.

\itt{\galerrillconditioned.} ({\tt \packagename\_solve} only)
The problem is so ill-conditioned that further progress is impossible.

\itt{\galerrmaxiterations.} ({\tt \packagename\_solve} only)
 Too many factorizations have been required.  This may happen if
    {\tt control\%max\_factorizations} is too small,
    but may also be symptomatic of a badly scaled problem.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Further features %%%%%%%%%%%%%%%%%%%%%%%%

\galfeatures
\noindent In this section, we describe an alternative means of setting
control parameters, that is components of the variable {\tt control} of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}),
by reading an appropriate data specification file using the
subroutine {\tt \packagename\_read\_specfile}. This facility
is useful as it allows a user to change  {\tt \packagename} control parameters
without editing and recompiling programs that call {\tt \packagename}.

A specification file, or specfile, is a data file containing a number of
"specification commands". Each command occurs on a separate line,
and comprises a "keyword",
which is a string (in a close-to-natural language) used to identify a
control parameter, and
an (optional) "value", which defines the value to be assigned to the given
control parameter. All keywords and values are case insensitive,
keywords may be preceded by one or more blanks but
values must not contain blanks, and
each value must be separated from its keyword by at least one blank.
Values must not contain more than 30 characters, and
each line of the specfile is limited to 80 characters,
including the blanks separating keyword and value.

The portion of the specification file used by
{\tt \packagename\_read\_specfile}
must start
with a "{\tt BEGIN \packagename}" command and end with an
"{\tt END}" command.  The syntax of the specfile is thus defined as follows:
\begin{verbatim}
  ( .. lines ignored by LLST_read_specfile .. )
    BEGIN LLST
       keyword    value
       .......    .....
       keyword    value
    END
  ( .. lines ignored by LLST_read_specfile .. )
\end{verbatim}
where keyword and value are two strings separated by (at least) one blank.
The ``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiter command lines
may contain additional (trailing) strings so long as such strings are
separated by one or more blanks, so that lines such as
\begin{verbatim}
    BEGIN LLST SPECIFICATION
\end{verbatim}
and
\begin{verbatim}
    END LLST SPECIFICATION
\end{verbatim}
are acceptable. Furthermore,
between the
``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiters,
specification commands may occur in any order.  Blank lines and
lines whose first non-blank character is {\tt !} or {\tt *} are ignored.
The content
of a line after a {\tt !} or {\tt *} character is also
ignored (as is the {\tt !} or {\tt *}
character itself). This provides an easy manner to "comment out" some
specification commands, or to comment specific values
of certain control parameters.

The value of a control parameters may be of three different types, namely
integer, logical or real.
Integer and real values may be expressed in any relevant Fortran integer and
floating-point formats (respectively). Permitted values for logical
parameters are "{\tt ON}", "{\tt TRUE}", "{\tt .TRUE.}", "{\tt T}",
"{\tt YES}", "{\tt Y}", or "{\tt OFF}", "{\tt NO}",
"{\tt N}", "{\tt FALSE}", "{\tt .FALSE.}" and "{\tt F}".
Empty values are also allowed for
logical control parameters, and are interpreted as "{\tt TRUE}".

The specification file must be open for
input when {\tt \packagename\_read\_specfile}
is called, and the associated device number
passed to the routine in device (see below).
Note that the corresponding
file is {\tt REWIND}ed, which makes it possible to combine the specifications
for more than one program/routine.  For the same reason, the file is not
closed by {\tt \packagename\_read\_specfile}.

Control parameters corresponding to the components
{\tt SLS\_control}
and
{\tt IR\_control} may be changed by including additional sections enclosed by
``{\tt BEGIN SLS}'' and
``{\tt END SLS}'', and
``{\tt BEGIN IR}'' and
``{\tt END IR}'', respectively.
See the specification sheets for the packages
{\tt \libraryname\_SLS}
and
{\tt \libraryname\_IR}
for further details.

\subsubsection{To read control parameters from a specification file}
\label{readspec}

Control parameters may be read from a file as follows:
\hskip0.5in
\def\baselinestretch{0.8} {\tt \begin{verbatim}
     CALL LLST_read_specfile( control, device )
\end{verbatim}}
\def\baselinestretch{1.0}

\begin{description}
\itt{control} is a scalar \intentinout argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}).
Default values should have already been set, perhaps by calling
{\tt \packagename\_initialize}.
On exit, individual components of {\tt control} may have been changed
according to the commands found in the specfile. Specfile commands and
the component (see Section~\ref{typecontrol}) of {\tt control}
that each affects are given in Table~\ref{specfile}.

\bctable{|l|l|l|}
\hline
  command & component of {\tt control} & value type \\
\hline
  {\tt error-printout-device} & {\tt \%error} & integer \\
  {\tt printout-device} & {\tt \%out} & integer \\
  {\tt print-level} & {\tt \%print\_level} & integer \\
  {\tt use-dense-factorization} & {\tt \%dense\_factorization} & integer \\
  {\tt has-a-changed}  & {\tt \%new\_a} & integer \\
  {\tt has-s-changed}  & {\tt \%new\_s} & integer \\
  {\tt factorization-limit} & {\tt \%max\_factorizations} & integer \\
  {\tt max-degree-taylor-approximant} & {\tt \%taylor\_max\_degree} & integer \\
  {\tt initial-multiplier} & {\tt \%initial\_multiplier} & real \\
  {\tt lower-bound-on-multiplier} & {\tt \%lower} & real \\
  {\tt upper-bound-on-multiplier} & {\tt \%upper} & real \\
  {\tt stop-normal-case} & {\tt \%stop\_normal} & real \\
  {\tt use-initial-multiplier} & {\tt \%use\_initial\_multiplier} & logical \\
  {\tt initialize-approximate-eigenvector} &
        {\tt \%initialize\_approx\_eigenvector} & real \\
  {\tt equality-problem} & {\tt \%equality\_problem} & logical \\
  {\tt space-critical} & {\tt \%space\_critical} & logical \\
  {\tt deallocate-error-fatal} & {\tt \%deallocate\_error\_fatal} & logical \\
  {\tt definite-linear-equation-solver} & {\tt \%definite\_linear\_solver} & character \\
  {\tt output-line-prefix} & {\tt \%prefix} & character \\
\hline

\ectable{\label{specfile}Specfile commands and associated
components of {\tt control}.}

\itt{device} is a scalar \intentin argument of type default \integer,
that must be set to the unit number on which the specfile
has been opened. If {\tt device} is not open, {\tt control} will
not be altered and execution will continue, but an error message
will be printed on unit {\tt control\%error}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Information printed %%%%%%%%%%%%%%%%%%%%%%%%

\galinfo
If {\tt control\%print\_level} is positive, information about the progress
of the algorithm will be printed on unit {\tt control\-\%\-out}.
If {\tt control\%print\_level = 1}, a single line of output will be produced
for each iteration of the process. In the first phase of the algorithm,
this will include the current estimate of the multiplier and known
brackets on its optimal value. In the second phase, the residual
$\|\bmx\|_S - \Delta$, the current estimate of the multiplier and
the size of the correction will be printed.
If {\tt control\%print\_level} $\geq$ {\tt 2}, this
output will be increased to provide significant detail of each iteration.
This extra output includes times for various phases.

%%%%%%%%%%%%%%%%%%%%%% GENERAL INFORMATION %%%%%%%%%%%%%%%%%%%%%%%%

\galgeneral

\galcommon None.
\galworkspace Provided automatically by the module.
\galroutines None.
\galmodules {\tt \packagename\_solve} calls the \galahad\ packages
{\tt \libraryname\_CLOCK},
{\tt \libraryname\_SY\-M\-BOLS},
{\tt \libraryname\_\-SPACE},
{\tt \libraryname\-\_\-RAND},
{\tt \libraryname\_\-NORMS},
{\tt \libraryname\_\-ROOTS},
{\tt \libraryname\_SPECFILE},
{\tt \libraryname\_SBLS},
{\tt \libraryname\_SLS},
{\tt \libraryname\_IR}
and
{\tt \libraryname\_MOP}.
\galio Output is under control of the arguments
{\tt control\%error}, {\tt control\%out} and {\tt control\%print\_level}.
\galrestrictions $n  >  0, \;  \Delta  >  0$.
\galportability ISO Fortran~95 + TR 15581 or Fortran~2003.
The package is thread-safe.

%%%%%%%%%%%%%%%%%%%%%% METHOD %%%%%%%%%%%%%%%%%%%%%%%%

\galmethod
The required solution $\bmx_*$ necessarily satisfies the optimality condition
$\bmA^T \bmA \bmx_* + \lambda_* \bmS \bmx_* = A^T \bmb$,
where $\lambda_* \geq 0$ is a Lagrange
multiplier corresponding to the constraint $\|\bmx\|_S  \leq  \Delta$;
for the equality-constrained problem $\|\bmx\|_S = \Delta$ and
the multiplier is unconstrained.

\noindent
The method is iterative, and proceeds in two phases.
Firstly, lower and upper bounds, $\lambda_{\mbox{\protect\tiny L}}$ and
$\lambda_{\mbox{\protect\tiny U}}$, on $\lambda_*$ are computed
using Gershgorin's theorems and other eigenvalue bounds,
including those that may involve the Cholesky factorization of $\bmS$  The
first phase of the computation proceeds by progressively shrinking  the bound
interval $[\lambda_{\mbox{\protect\tiny L}},\lambda_{\mbox{\protect\tiny U}}]$
until a value $\lambda$ for which
$\|\bmx(\lambda)\|_S  \geq  \Delta$ is found.
Here $\bmx(\lambda)$ and its companion $\bmy(\lambda)$
are defined to be a solution of
\eqn{ls}{(\bmA^T \bmA  + \lambda \bmS)\bmx(\lambda) = \bmA^T \bmb;}
along the way the possibility that
$\|\bmx(0)\|_S  \leq  \Delta$ is examined, and if this transpires
the process is terminated with $\bmx_* = \bmx(0)$.
Once the terminating $\lambda$ from the first phase has been discovered,
the second phase
consists of applying Newton or higher-order iterations to the nonlinear
``secular'' equation $\|\bmx(\lambda)\|_S  =  \Delta$ with
the knowledge that such iterations are both globally and ultimately
rapidly convergent.

The dominant cost is the requirement that we solve a sequence of linear systems
\req{ls}. This may be rewritten as
\eqn{kktb}{\mat{cc}{ \lambda \bmS & \bmA^T \\ \bmA & - \bmI} 
\vect{ \bmx(\lambda) \\ \bmy(\lambda)} =
\vect{ \bmA^T \bmb \\ \bmzero},}
for some auxiliary vector $\bmy(\lambda)$.
In general a sparse symmetric, indefinite factorization of the
coefficient matrix of \req{kktb} is
often preferred to a Cholesky factorization of that of \req{ls}.

\galreference
The method is the obvious adaptation to the linear least-squares
problem of that described in detail in
\vspace*{1mm}

\noindent
H. S. Dollar, N. I. M. Gould and D. P. Robinson.
On solving trust-region and other regularised subproblems in optimization.
\em Mathematical Programming Computation \bf 2(1) \rm (2010) 21--57.

%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\galexample
Suppose we wish to solve a problem with $m = 5,000$ residuals
and $n = 10,001$ unknowns, whose data is
\disp{\bmA  = \mat{ccccccccccc}{
1 &   &   &   &   & 1 &   &   &     &   & 1 \\
  & 1 & . &   &   &   & 2 & . &     &   & 1 \\
  & . & . & . &   &   & . & . & .   &   & 1 \\
  &   & . & 1 &   &   &   & . & m-1 &   & 1 \\
  &   &   &   & 1 &   &   &   &     & m & 1 }, \;\;
\bmS  = \mat{ccccc}{ 1 & \\   & 4  &   \\ & & . \\
 & & & (n-1)^2 & \\ & & & & n^2 },
\tim{and}
\bmb  =  \vect{ 1 \\ 1 \\ . \\ 1 \\ 1 },}
with a radius $\Delta = 10$.
Then we may use the following code:

{\tt \small
\VerbatimInput{\packageexample}
}
\noindent
This produces the following output:
{\tt \small
\VerbatimInput{\packageresults}
}

\end{document}

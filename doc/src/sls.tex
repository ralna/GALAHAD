\documentclass{galahad}

% set the package name

\newcommand{\package}{sls}
\newcommand{\packagename}{SLS}
\newcommand{\fullpackagename}{\libraryname\_\-\packagename}

\begin{document}

\galheader

%%%%%%%%%%%%%%%%%%%%%% SUMMARY %%%%%%%%%%%%%%%%%%%%%%%%

\galsummary

This package
{\bf solves dense or sparse symmetric systems of linear equations}
using variants of Gaussian elimination.
Given a sparse symmetric matrix $\bmA = \{ a_{ij} \}_{n \times n}$, and an
$n$-vector $\bmb$ or a matrix $\bmB = \{ b_{ij} \}_{n \times r}$, this
subroutine solves the system $\bmA \bmx = \bmb$ or the system $\bmA
\bmX = \bmB$ . The matrix $\bmA$ need not be definite.

\noindent The method provides a common interface to a variety of well-known
solvers from HSL and elsewhere. Currently supported solvers include
{\tt MA27/SILS}, {\tt HSL\_MA57}, {\tt HSL\_MA77} , {\tt HSL\_MA86},
{\tt HSL\_MA87} and {\tt HSL\_MA97} from {HSL},
{\tt SSIDS} from {SPRAL},
{\tt PARDISO} both from the Pardiso Project and Intel's MKL
and {\tt WSMP} from the IBM alpha Works, as
well as {\tt POTR}, {\tt SYTR} and {\tt SBTR} from LAPACK.
Note that
{\bf the solvers themselves do not form part of this package and
must be obtained separately.}
Dummy instances are provided for solvers that are unavailable.
Also note that additional flexibility may be obtained by calling the
solvers directly rather that via this package.

%%%%%%%%%%%%%%%%%%%%%% attributes %%%%%%%%%%%%%%%%%%%%%%%%

\galattributes
\galversions{\tt  \fullpackagename\_single, \fullpackagename\_double}.
\galcalls
{\tt GALAHAD\_CLOCK},
{\tt GALAHAD\-\_SYMBOLS},
{\tt GALAHAD\_\-SORT},
{\tt GALAHAD\_SPACE},
{\tt GALAHAD\_SPECFILE},
{\tt GALAHAD\_STRING},
{\tt GALAHAD\_SMT},
{\tt GALAHAD\_SILS}
%{\tt HSL\_ZD11}
and optionally
{\tt HSL\_\-MA57},
{\tt HSL\_MA77},
{\tt HSL\_MA86},
{\tt HSL\_MA87},
{\tt HSL\_MA97},
{\tt HSL\_MC64},
{\tt HSL\_MC68},
{\tt MC61},
{\tt MC77},
and {\tt METIS}.
\galdate August 2009.
\galorigin N. I. M. Gould, Rutherford Appleton Laboratory.
\gallanguage Fortran~95 + TR 15581 or Fortran~2003.
\galparallelism Some solvers may use OpenMP and its runtime library.

%%%%%%%%%%%%%%%%%%%%%% HOW TO USE %%%%%%%%%%%%%%%%%%%%%%%%

\galhowto

\subsection{Calling sequences}

Access to the package requires a {\tt USE} statement such as

\medskip\noindent{\em Single precision version}

\hskip0.5in {\tt USE \fullpackagename\_single}

\medskip\noindent{\em Double precision version}

\hskip0.5in {\tt USE  \fullpackagename\_double}

\medskip

If it is required to use both modules at the same time, the derived types
{\tt SMT\_type},
{\tt \packagename\_control\_type},
{\tt \packagename\_time\-\_type},
{\tt \packagename\_data\-\_type}, and
{\tt \packagename\_inform\_type}
(\S\ref{galtypes}),
and the subroutines
{\tt \packagename\_initialize},
{\tt \packagename\_analyse},
{\tt \packagename\-\_factorize},
{\tt \packagename\_solve},
{\tt \packagename\_terminate}
(\S\ref{galarguments}),
{\tt \packagename\_enquire},
{\tt \packagename\_alter\_d}, and
{\tt \packagename\_part\_solve}
(\S\ref{galfeatures})
must be renamed on one of the {\tt USE} statements.

\noindent There are five principal subroutines for user calls (see
\S\ref{galfeatures} for further features):

\begin{description}

\item[] The subroutine {\tt \packagename\_initialize} must be called to
specify the external solver to be used.
It may also be called to set default values
for solver-specific components of the control structure.
If non-default values are
wanted for any of the control components, the corresponding components
should be altered after the call to {\tt \packagename\_initialize}.

\item[] {\tt \packagename\_analyse} accepts the pattern of $\bmA$
 and optionally chooses pivots
 for Gaussian elimination using a selection criterion to preserve
 sparsity.  It subsequently constructs subsidiary information for
 actual factorization by {\tt \packagename\_factorize}. If the user provides
 the pivot sequence, only the necessary information for
 {\tt \packagename\_factorize} will be generated.

\item[] {\tt \packagename\_factorize} factorizes the matrix $\bmA$ using the
 information
 from a previous call to {\tt \packagename\_analyse}. The actual pivot sequence
 used may differ from that of {\tt \packagename\_analyse} if $\bmA$ is not
definite.

\item[] {\tt \packagename\_solve} uses the factors generated by
  {\tt \packagename\_factorize} to
  solve a system of equations with one ($\bmA \bmx = \bmb$)
  or several ($\bmA \bmX = \bmB$) right-hand sides.
  Iterative refinement may be used to improve a given solution
  or set of solutions.

\item[] {\tt \packagename\_terminate} deallocates the arrays held inside the
  structure for the factors. It should be called
  when all the systems involving its matrix have been solved
  or before another external solver is to be used.
\end{description}

\subsection{Supported external solvers}

In Table~\ref{solvers} we summarize key features of
the external solvers supported by \packagename. Further details
are provided in the references cited in \S\ref{galmethod}.

\bctable{|l|l|l|l|l|}
\hline
 solver & factorization & indefinite $\bmA$ & out-of-core & parallelised \\
\hline
{\tt SILS/MA27} & multifrontal & yes & no & no \\
{\tt HSL\_MA57} & multifrontal & yes & no & no \\
{\tt HSL\_MA77} & multifrontal & yes & yes & OpenMP core \\
{\tt HSL\_MA86} & left-looking & yes & no & OpenMP fully \\
{\tt HSL\_MA87} & left-looking & no & no & OpenMP fully \\
{\tt HSL\_MA97} & multifrontal & yes & no & OpenMP core \\
{\tt SSIDS} & multifrontal & yes & no & CUDA core \\
{\tt PARDISO} & left-right-looking & yes & no & OpenMP fully \\
{\tt MKL\_PARDISO} & left-right-looking & yes & optionally & OpenMP fully \\
{\tt WSMP} & left-right-looking & yes & no & OpenMP fully \\
{\tt POTR} & dense & no & no & with parallel LAPACK \\
{\tt SYTR} & dense & yes & no & with parallel LAPACK \\
{\tt PBTR} & dense band & no & no & with parallel LAPACK \\
\hline

\ectable{\label{solvers}External solver characteristics.}
\vspace*{-8mm}
%%%%%%%%%%%%%%%%%%%%%% matrix formats %%%%%%%%%%%%%%%%%%%%%%%%

\galmatrix
The matrix $\bmA$ may be stored in a variety of input formats.

\subsubsection{Sparse co-ordinate storage format}\label{coordinate}
Only the nonzero entries of the lower-triangular part of $\bmA$ are stored.
For the $l$-th entry of the lower-triangular portion of $\bmA$,
its row index $i$, column index $j$ and value $a_{ij}$
are stored in the $l$-th components of the integer arrays {\tt row},
{\tt col} and real array {\tt val}, respectively.
The order is unimportant, but the total number of entries
{\tt ne} is also required.

\subsubsection{Sparse row-wise storage format}\label{rowwise}
Again only the nonzero entries of the lower-triangular part are stored,
but this time they are ordered so that those in row $i$ appear directly
before those in row $i+1$. For the $i$-th row of $\bmA$, the $i$-th component
of an integer array {\tt ptr} holds the position of the first entry in this row,
while {\tt ptr} $(m+1)$ holds the total number of entries plus one.
The column indices $j$ and values $a_{ij}$ of the entries in the $i$-th row
are stored in components
$l =$ {\tt ptr}$(i)$, \ldots ,{\tt ptr} $(i+1)-1$ of the
integer array {\tt col}, and real array {\tt val}, respectively.

For sparse matrices, this scheme almost always requires less storage than
its predecessor.

\subsubsection{Dense storage format}\label{dense}
The matrix $\bmA$ is stored as a compact
dense matrix by rows, that is, the values of the entries of each row in turn are
stored in order within an appropriate real one-dimensional array.
Since $\bmA$ is symmetric, only the lower triangular part (that is the part
$a_{ij}$ for $1 \leq j \leq i \leq n$) need be held, and this part will be
stored by rows, that is component
$i \ast (i-1)/2 + j$ of the storage array {\tt val}
will hold the value $a_{ij}$ (and, by symmetry, $a_{ji}$)
for $1 \leq j \leq i \leq n$.

%\subsubsection{Diagonal storage format}\label{diagonal}
%If $\bmA$ is diagonal (i.e., $a_{ij} = 0$ for all $1 \leq i \neq j \leq n$)
%only the diagonals entries $a_{ii}$, $1 \leq i \leq n$,  need be stored,
%and the first $n$ components of the array {\tt A\%val} may be used for
%the purpose.

%%%%%%%%%%%%%%%%%%%%%% long integers %%%%%%%%%%%%%%%%%%%%%%

\subsection{Integer kinds}\label{Integer kinds}
We use the term
long \integer\ to denote {\tt INTEGER\-(kind=long)}, where
{\tt long = selected\_int\_kind(18))}.


%%%%%%%%%%%%%%%%%%%%%% OpenMP usage %%%%%%%%%%%%%%%%%%%%%%%%

\subsection{OpenMP}
OpenMP may be used by the {\tt \fullpackagename} package to provide
parallelism for some solvers in shared memory environments.
To run in parallel, OpenMP
must be enabled at compilation time by using the correct compiler flag
(usually some variant of {\tt -openmp}).
The number of threads may be controlled at runtime
by setting the environment variable {\tt OMP\_NUM\_THREADS}.

\noindent
The code may be compiled and run in serial mode.


%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\galtypes
Five derived data types are used by the package.

%%%%%%%%%%% problem type %%%%%%%%%%%

\subsubsection{The derived data type for holding the matrix}\label{typeprob}
The derived data type {\tt SMT\_type} is used to hold the matrix $\bmA$.
The components of {\tt SMT\_type} used are:

\begin{description}

\ittf{n} is a scalar variable of type default \integer, that holds
the order $n$ of the matrix  $\bmA$.
\restriction {\tt n} $\geq$ {\tt 1}.

\itt{type} is an allocatable array of rank one and type default \character, that
indicates the storage scheme used. If the
sparse co-ordinate scheme (see \S\ref{coordinate}) is used
the first ten components of {\tt type} must contain the
string {\tt COORDINATE}.
For the sparse row-wise storage scheme (see \S\ref{rowwise}),
the first fourteen components of {\tt type} must contain the
string {\tt SPARSE\_BY\_ROWS}, and
for dense storage scheme (see \S\ref{dense})
the first five components of {\tt type} must contain the
string {\tt DENSE}.
%and for the diagonal storage scheme (see \S\ref{diagonal}),
%the first eight components of {\tt type} must contain the
%string {\tt DIAGONAL}.

For convenience, the procedure {\tt SMT\_put}
may be used to allocate sufficient space and insert the required keyword
into {\tt type}.
For example, if $\bmA$ is to be stored in the structure {\tt A}
of derived type {\tt SMT\_type} and we wish to use
the co-ordinate scheme, we may simply
%\vspace*{-2mm}
{\tt
\begin{verbatim}
        CALL SMT_put( A%type, 'COORDINATE', istat )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent
See the documentation for the \galahad\ package {\tt SMT}
for further details on the use of {\tt SMT\_put}.

\itt{ne} is a scalar variable of type default \integer, that
holds the number of entries in the {\bf lower triangular} part of $\bmA$
in the sparse co-ordinate storage scheme (see \S\ref{coordinate}).
It need not be set for any of the other three schemes.

\itt{val} is a rank-one allocatable array of type default \realdp, that holds
the values of the entries of the {\bf lower triangular} part
of the matrix $\bmA$ for each of the
storage schemes discussed in \S\ref{galmatrix}.
Any duplicated entries that appear in the sparse
co-ordinate or row-wise schemes will be summed.

\itt{row} is a rank-one allocatable array of type default \integer,
that holds the row indices of the {\bf lower triangular} part of $\bmA$
in the sparse co-ordinate storage
scheme (see \S\ref{coordinate}).
It need not be allocated for any of the other schemes.
Any entry whose row index lies out of the range $[$1,n$]$ will be ignored.

\itt{col} is a rank-one allocatable array variable of type default \integer,
that holds the column indices of the {\bf lower triangular} part of
$\bmA$ in either the sparse co-ordinate
(see \S\ref{coordinate}), or the sparse row-wise
(see \S\ref{rowwise}) storage scheme.
It need not be allocated when the dense
%or diagonal storage schemes are used.
storage scheme is used.
Any entry whose column index lies out of the range $[$1,n$]$ will be ignored,
while the row and column indices of any entry from the
{\bf strict upper triangle} will implicitly be swapped.

\itt{ptr} is a rank-one allocatable array of size {\tt n+1} and type
default \integer, that holds the starting position of
each row of the {\bf lower triangular} part of $\bmA$, as well
as the total number of entries plus one, in the sparse row-wise storage
scheme (see \S\ref{rowwise}). It need not be allocated for the
other schemes.

\end{description}
Although any of the above-mentioned matrix storage formats may be used
with each supported solver, {\tt MA27/SILS} and {\tt HSL\_MA57}
from HSL are most efficient if co-ordinate input is provided.

%%%%%%%%%%% control type %%%%%%%%%%%

\subsubsection{The derived data type for holding control
 parameters}\label{typecontrol}
The derived data type
{\tt \packagename\_control\_type}
is used to hold controlling data.
Default values specifically for the desired solver
may be obtained by calling
{\tt \packagename\_initialize}
(see \S\ref{subinit}),
%Default values are assigned,
while components may be changed at run time by calling
{\tt \packagename\_read\-\_specfile}
(see \S\ref{readspec}).
The components of
{\tt \packagename\_control\_type}
are:

\begin{description}

\itt{error} is a scalar variable of type default \integer, that holds the
unit number for error messages.
Printing of error messages is suppressed if ${\tt error} < {\tt 0}$.
The default is {\tt error = 6}.

\itt{warning} is a scalar variable of type default \integer, that holds the
unit number for warning messages.
Printing of warning messages is suppressed if ${\tt warning} < {\tt 0}$.
The default is {\tt warning = 6}.

\ittf{out} is a scalar variable of type default \integer, that holds the
unit number for informational messages.
Printing of informational messages is suppressed if ${\tt out} < {\tt 0}$.
The default is {\tt out = 6}.

\itt{statistics} is a scalar variable of type default \integer, that holds the
unit number for statistical output, if any.
Printing of statistical messages is suppressed if ${\tt statistics} < {\tt 0}$.
The default is {\tt statistics = 0}.

\itt{print\_level} is a scalar variable of type default \integer,
that is used
to control the amount of informational output that is required. No
informational output will occur if ${\tt print\_level} \leq {\tt 0}$. If
{\tt print\_level} $\geq$ {\tt 1} a single line of output will be produced
for each step of iterative refinement performed.
%If {\tt print\_level} $\geq$ {\tt 2} this output
%will be increased to provide significant detail of each iteration.
The default is {\tt print\_level = 0}.

\itt{print\_level\_solver} is a scalar variable of type default \integer,
that is used
to control the amount of informational output that is required by the exteral
solver. No
informational output will occur if ${\tt print\_level} \leq {\tt 0}$. If
{\tt print\_level} $\geq$ {\tt 1} the amount of output produced is solver
dependent.
The default is {\tt print\_level\_solver = 0}.

\itt{bits} is a scalar variable of type default \integer,
that indicates the machine architecture being used.
It should be set to {\tt 32} on a  32-bit architecture and to {\tt 64}
on a 64-bit architecture. The default value is {\tt 32},
and this default is used if {\tt bits} $\neq$ {\tt 64}.

\itt{block\_size\_kernel} is a scalar variable of type default \integer,
that gives the target block size for the kernel factorization, if any.
The default value is {\tt 40},
and this default is used if {\tt block\_size\_kernel < 1}.

\itt{block\_size\_elimination} is a scalar variable of type default \integer,
that gives the target block size for parallel factorization, if any.
The default is {\tt block\_size\_elimination = 32},
and this default is used if {\tt block\_size\_\-elimination < 1}.

\itt{blas\_block\_size\_factorize} is a scalar variable of type default \integer,
that gives the block size for level-three basic linear algebra subprograms
(BLAS) in the factorization phase.
The default is {\tt blas\_block\_size\_factorize = 16},
and this default is used if {\tt blas\_block\_size\_factorize < 1}.

\itt{blas\_block\_size\_solve} is a scalar variable of type default \integer,
that gives the block size for level-two and -three basic linear algebra
subprograms (BLAS) in the solution phase.
The default is {\tt blas\_block\_size\_solve = 16},
and this default is used if {\tt blas\_block\_size\_solve < 1}.

\itt{node\_amalgamation} is a scalar variable of type default \integer,
that controls node amalgamation. Two neighbours in the elimination tree are
merged if they both involve fewer than {\tt node\_amalgamation} eliminations.
The default is {\tt node\_amalgamation$=$32}, and this default is used
if {\tt node\_amalgamation < 1}.

\itt{initial\_pool\_size} is a scalar variable of type default \integer,
that holds the initial size of the arrays that store the task pool for
parallel factorization, if any.
The default is {\tt initial\_pool\_size = 100000},
and this default is used if {\tt initial\_pool\_size < 1}.

\itt{min\_real\_factor\_size} is a scalar variable of type default \integer,
that specifies the amount of real storage that will initially be
allocated for the factors and other data.
The default is {\tt min\_real\_factor\_size = 10000},
and this default is used if {\tt min\_real\_factor\_size < 1}.

\itt{min\_integer\_factor\_size} is a scalar variable of type default \integer,
that specifies the amount of integer storage that will initially be
allocated for the factors and other data.
The default is {\tt min\_integer\_factor\_size = 10000},
and this default is used if {\tt min\_integer\_factor\_size < 1}.

\itt{max\_real\_factor\_size} is a scalar variable of type long \integer,
that specifies the maximum amount of real storage that will be
allocated for the factors and other data.
The default is {\tt max\_real\_factor\_size = HUGE(0)}.

\itt{max\_integer\_factor\_size} is a scalar variable of type long \integer,
that specifies the maximum amount of integer storage that will be
allocated for the factors and other data.
The default is {\tt max\_integer\_factor\_size = HUGE(0)}.

\itt{max\_in\_core\_store} is a scalar variable of type long \integer,
that specifies the maximum amount of storage (measured in Fortran storage units)
to be used if the user wants to use in-core arrays when possible in place of
out-of-core direct-access files for solvers that support out-of-core
factorization. If {\tt max\_in\_core\_store = 0}, factorization will
occur entirely out-of-core.
The default is {\tt max\_in\_core\_store = HUGE(0)/4}
({\tt HUGE(0)/8} in {\tt \fullpackagename\-\_\-double})
for 32-bit architectures and
{\tt max\_in\_core\_store = HUGE(0\_long)/4}
({\tt HUGE(0\_long)/8}
in {\tt \fullpackagename\-\_\-double})
in the 64-bit case.

\itt{array\_increase\_factor} is a scalar variable of type \realdp, that holds
the factor by which arrays sizes are to be increased if they are too small.
The default is {\tt array\_increase\_factor = 2.0}.

\itt{array\_decrease\_factor} is a scalar variable of type \realdp, that holds
a factor that is used to assess whether previously allocated internal
workspace arrays are excessive. In particular, if current requirements are
less than {\tt array\_decrease\_factor} times the currently allocated space,
the space will be re-allocated to current requirements.
The default is {\tt array\_decrease\_factor = 2.0}.

\itt{pivot\_control} is a scalar variable of type default \integer,
that is used to control numerical pivoting by {\tt \packagename\_\-factorize}.
Possible values are:
\begin{description}
 \itt{1}  Numerical pivoting will be performed, with relative pivot
     tolerance given by the component {\tt relative\_\-pivot\_tolerance}.
 \itt{2}  No pivoting will be performed and an error exit will occur
     immediately a sign change is detected among the pivots. This is
     suitable for cases when $\bmA$  is thought to be definite and is likely to
     decrease the factorization time while still providing a stable
     decomposition.
 \itt{3}  No pivoting will be performed and an error exit will occur if a
     zero pivot is detected. This is likely to decrease the factorization
     time, but may be unstable if there is a sign change among the pivots
     or a tiny pivot is encountered.
 \itt{4}  No pivoting will be performed but the matrix will be altered
     to ensure that the result is ``sufficiently'' positive definite
     if a non-positive pivot is encountered.
\end{description}
The default is {\tt pivot\_control = 1}, and any value outside of
$[${\tt1,4}$]$ will be reset to the default.

\itt{ordering} is a scalar variable of type default \integer, that
controls the initial order of the rows when performing the factorization.
This will be ignored if an explicit permutation is specified (see the
argument {\tt PERM} for {\tt \packagename\_analyse}).
Possible values are:
\begin{description}
\itt{$<$ 0} The ordering will be chosen by the specified solver with its
        own ordering-selection value {\tt - ordering}.
\itt{0} The ordering will be chosen to be the default for the solver used.
        If the specified solver has no default, the rows will be unordered
        which is unlikely to be satisfactory.
\itt{1} The ordering will be chosen by the Approximate Minimum Degree method
       with provisions for ``dense'' rows/columns.
\itt{2} The ordering will be chosen by the Minimum Degree method.
\itt{3} The ordering will be chosen by the Nested Dissection method; this
 requires the user to have installed the external package {\tt METIS}.
\itt{4} An indefinite ordering involving a combination of 1x1 and 2x2 pivots
       will be used.
% , that is optionally required by {\tt HSL\_MA57} and {\tt PARDISO}.
\itt{5} An ordering that aims to provide a small profile or wavefront
       will be used.
\itt{6} An ordering that aims to provide a small bandwidth will be used.
\itt{$>$ 6} The ordering will be chosen automatically depending on matrix
       characteristics (not yet implemented).
\end{description}
Values {\tt 1} to {\tt 4} are only supported if the HSL package {\tt HSL\_MC68}
is available, while {\tt 5} and {\tt 6} are only possible
when the HSL package {\tt MC61} is provided.
The default is {\tt ordering = 0}, and currently any value $>$ {\tt 6} will
be reset to this default.

\itt{full\_row\_threshold} is a scalar variable of type default \integer,
that controls the threshold for detecting rows with a large percentage
(relative to the matrix order) of nonzeros by {\tt \packagename\_analyse}.
Such rows will normally be ordered last when the factorization occurs.
If {\tt full\_row\_threshold = 100}, only fully dense
rows will be detected.
The default is {\tt full\_row\_threshold = 100},
and any value outside of $[${\tt 0,100}$]$ will be reset to the default.

\itt{row\_search\_indefinite} is a scalar variable of type default \integer,
that controls the maximum number of rows searched for a pivot when using the
indefinite ordering (see {\tt ordering = 4} above).
The default is {\tt row\_search\_\-indefinite = 10},
and this default is used if {\tt row\_search\_\-indefinite < 1}.

\itt{scaling} is a scalar variable of type default \integer, that may control
scaling of the matrix.
Possible values are:
\begin{description}
\itt{$<$ 0} The scaling will be chosen by the specified solver with its
        own scaling-selection value {\tt - scaling}.
\itt{0} No scaling is used.
\itt{1} Scale the matrix so that the diagonal and off diagonal
entries of the result are one and smaller than one, respectively,
in absolute value using the package {\tt HSL\_MC64}.
\itt{2} Scale the matrix so that $\ell_1$-norms of each column
of the result are approximately one using the package {\tt MC77}.
\itt{3} Scale the matrix so that $\ell_{\infty}$-norms of each column
of the result are approximately one using the package {\tt MC77}.
\end{description}
This option is not currently available for all solvers; {\tt -1} is
only available for {\tt HSL\_MA57}, {\tt -2} for {\tt HSL\_MA77}
and {\tt -3}--{\tt -1} for {\tt HSL\_MA97}.
The default is {\tt scaling = 0},
and any value outside of $[${\tt -3,3}$]$ will be reset to the default.

\itt{scale\_maxit} is a scalar variable of type default \integer,
that controls the maximum number of iterations performed
by {\tt MC77} when scaling is requested (see {\tt scale} above).
The default is {\tt scale\_maxit = 10},
and this default is used if {\tt scale\_maxit < 1}.

\itt{scale\_thresh} is a scalar variable of type \realdp,
that is used by {\tt MC77} to terminate the scaling iteration.
The iteration stops as soon as the the difference between
every column norm and one is smaller that {\tt scale\_thresh}
in magnitude. The default is {\tt scale\_thresh = 0.1}.

\itt{relative\_pivot\_tolerance} is a scalar variable of type \realdp,
that holds the relative pivot tolerance that is used to control the
stability of the factorization of indefinite $\bmA$.
The default is {\tt relative\_pivot\_tolerance = 0.01}.
For problems requiring greater
than average numerical care a higher value than the default would be
advisable. Values greater than {\tt 0}.{\tt 5} are treated as {\tt 0}.{\tt 5}
for all solvers except {\tt HSL\_MA77} (where an upper bound {\tt 1.0} is
enforced) and less than {\tt 0}.{\tt 0} as {\tt 0}.{\tt 0}.

\itt{minimum\_pivot\_tolerance} is a scalar variable of type \realdp,
that holds the minimum permitted value of the relative pivot tolerance.
If, at any stage of the computation, fewer than the
expected number of stable pivots have been found using
the current tolerance but the largest
candidate pivot would be acceptable with tolerance
{\tt minimum\_pivot\_tolerance}, the pivot is accepted, and all
subsequent pivots will be assessed relative to
{\tt minimum\_pivot\_tolerance} rather than
{\tt relative\_pivot\_tolerance}.
The default is {\tt minimum\_pivot\_tolerance$=$0.01}.
Values of {\tt minimum\_pivot\_tolerance} greater than
{\tt relative\_pivot\_\-tolerance} are treated as
{\tt relative\_pivot\_tolerance}, while  values
less than $0$ are treated as $0$.

\itt{absolute\_pivot\_tolerance} is a scalar variable of type \realdp, that
holds the absolute pivot tolerance that is used to control the
stability of the factorization of indefinite $\bmA$.
No pivot smaller than {\tt absolute\_pivot\_tolerance} in
absolute value will be accepted.
The default is {\tt absolute\_pivot\_\-tolerance = EPSILON(1.0)}
({\tt EPSILON(1.0D0)} in {\tt \fullpackagename\_double}).

\itt{zero\_tolerance} is a scalar variable of type \realdp, that
controls which small entries are to be ignored during the factorization
of $\bmA$. Any entry smaller in absolute value than
{\tt zero\_\-tolerance} will be treated as zero; as a consequence when
{\tt zero\_tolerance > 0}, the factors produced will be of a perturbation
of order {\tt zero\_tolerance} of $\bmA$.
The default is {\tt zero\_tolerance = 0.0}.

\itt{static\_pivot\_tolerance} and {\tt static\_level\_switch} are
scalar variables of type \realdp, that are used to set the static pivot
level when the solvers {\tt HSL\_MA57} or {\tt HSL\_MA77} are used.
If {\tt static\_pivot\_tolerance$>$0.0} and if,
at any stage of the computation, relatively fewer
than {\tt static\_level\_\-switch}
pivots can be found with relative pivot tolerance greater than
{\tt minimum\_pivot\_tolerance},  diagonal entries are accepted as pivots. If
a candidate diagonal entry has absolute value
at least {\tt static\_pivot\_tolerance}, it is
selected as a pivot; otherwise, the pivot is given the value
that has the same sign but absolute value {\tt static\_pivot\_tolerance}.
The defaults are {\tt static\_pivot\_tolerance = 0.0} and
{\tt static\_level\_switch = 0.0}.
If {\tt static\_pivot\_tolerance}
is larger than zero, but smaller than {\tt zero\_tolerance},
the value {\tt zero\_\-tolerance} will be used.

\itt{consistency\_tolerance} is a scalar variable of type \realdp, that holds
the tolerance used to access whether a singular system is consistent or not.
The default is {\tt xonsistency\_\-tolerance = EPSILON(1.0)}
({\tt EPSILON(1.0D0)} in {\tt \fullpackagename\_double}).

\itt{max\_iterative\_refinements} is a scalar variable of type default
\integer, that holds
the maximum number of iterative refinements that may be attempted.
The default is {\tt max\_iterative\_refinements = 0}.

\itt{acceptable\_residual\_relative}  and {\tt acceptable\_residual\_absolute}
are scalar variables of type \realdp, that
specify an acceptable level for the residual $\bmA \bmx - \bmb$ or residuals
$\bmA \bmx_i - \bmb_i$, $i=1,\ldots,r$,  when there are more than one.
In particular, iterative refinement will cease as soon as
$\|\bmA \bmx - \bmb\|_{\infty}$ falls below
$\max (\| \bmb\|_{\infty} \ast$ {\tt acceptable\_residual\_relative},
{\tt acceptable\_residual\_absolute}$)$;
for the multiple residual case, we require that
$\|\bmA \bmx_i - \bmb_i\|_{\infty}$ falls below
$\max (\| \bmb_i\|_{\infty} \ast$ {\tt acceptable\_residual\_relative},
for each $i=1,\ldots,r$.
The defaults are {\tt acceptable\_residual\_relative =
acceptable\_resi\-dual\_absolute = }$10 u$,
where $u$ is {\tt EPSILON(1.0)} ({\tt EPSILON(1.0D0)} in
{\tt \fullpackagename\_double}).

\itt{out\_of\_core\_directory}
is a scalar variable of type default \character\
and length 400, that identifies the full path name of the
directory in which direct-access files will be written if out-of-core
factorization is performed; the full path must end with a {\tt /}.
Exceptionally, the ``empty'' string {\tt ""} refers to the current
directory. The default is {\tt out\_of\_core\_directory = ""}.

\itt{out\_of\_core\_integer\_factor\_file}
is a scalar variable of type default \character\
and length 400, that identifies the base files name for direct-access files that
hold integer components of the matrix factors when an
out-of-core factorization is obtained.
Files with names
{\tt out\_of\_core\_integer\_factor\_file}
appended with {\tt 1, 2, \ldots} will be created as needed.
There should be no other files with this base file name in the directory
specified for the task.
The default is
{\tt out\_of\_core\_integer\_factor\_file = "factor\_integer\_ooc"}.

\itt{out\_of\_core\_real\_factor\_file}
is a scalar variable of type default \character\
and length 400, that identifies the base files name for direct-access files that
hold real components of the matrix factors when an
out-of-core factorization is obtained.
Files with names
{\tt out\_of\_core\_real\_factor\_file}
appended with {\tt 1, 2, \ldots} will be created as needed.
There should be no other files with this base file name in the directory
specified for the task.
The default is
{\tt out\_of\_core\_real\_factor\_file =
"factor\_real\_ooc"}.

\itt{out\_of\_core\_real\_work\_file}
is a scalar variable of type default \character\
and length 400, that identifies the base files name for direct-access files that
hold real workspace components when an
out-of-core factorization is obtained.
Files with names
{\tt out\_of\_core\_real\_work\_file}
appended with {\tt 1, 2, \ldots} will be created as needed.
There should be no other files with this base file name in the directory
specified for the task.
The default is
{\tt out\_of\_core\_real\_work\_file = "work\_real\_ooc"}.

\itt{out\_of\_core\_indefinite\_file}
is a scalar variable of type default \character\
and length 400, that identifies the base files name for direct-access files that
hold additional real workspace components in the indefinite case when an
out-of-core factorization is obtained.
Files with names
{\tt out\_of\_core\_indefinite\_file}
appended with {\tt 1, 2, \ldots} will be created as needed.
There should be no other files with this base file name in the directory
specified for the task.
The default is
{\tt out\_of\_core\_indefinite\_file = "work\_indefinite\_ooc"}.

\itt{prefix} is a scalar variable of type default \character\
and length 30, that may be used to provide a user-selected
character string to preface every line of printed output.
Specifically, each line of output will be prefaced by the string
{\tt prefix(2:LEN(TRIM(prefix))-1)},
thus ignoring the first and last non-null components of the
supplied string. If the user does not want to preface lines by such
a string, the default {\tt prefix = ""} should be used.

\end{description}

%%%%%%%%%%% time type %%%%%%%%%%%

\subsubsection{The derived data type for holding timing
 information}\label{typetime}
The derived data type
{\tt \packagename\_time\_type}
is used to hold elapsed CPU and system clock times for the various parts
of the calculation. The components of
{\tt \packagename\_time\_type}
are:
\begin{description}
\itt{total} is a scalar variable of type default \realdp, that gives
 the total CPU time (in seconds) spent in the package.

\itt{analyse} is a scalar variable of type default \realdp, that gives
 the CPU time spent in the analysis phase.

\itt{factorize} is a scalar variable of type default \realdp, that gives
 the CPU time spent in the factorization phase.

\itt{solve} is a scalar variable of type default \realdp, that gives
 the CPU time spent in the solve phases.

\itt{order\_external} is a scalar variable of type default \realdp, that gives
 the CPU time spent by the external solvers in the ordering phase.

\itt{analyse\_external} is a scalar variable of type default \realdp, that gives
 the CPU time spent by the external solvers in the analysis phase.

\itt{factorize\_external} is a scalar variable of type default \realdp, that gives
 the CPU time spent by the external solvers in the factorization phase.

\itt{solve\_external} is a scalar variable of type default \realdp, that gives
 the CPU time spent by the external solvers in the solve phases.

\itt{clock\_total} is a scalar variable of type default \realdp, that gives
 the total elapsed system clock time (in seconds) spent in the package.

\itt{clock\_analyse} is a scalar variable of type default \realdp, that gives
 the elapsed system clock time spent in the analysis phase.

\itt{clock\_factorize} is a scalar variable of type default \realdp, that gives
 the elapsed system clock time spent in the factorization phase.

\itt{clock\_solve} is a scalar variable of type default \realdp, that gives
 the elapsed system clock time spent in the solve phases.

\itt{clock\_order\_external} is a scalar variable of type default \realdp,
that gives  the elapsed system clock time spent by the external solvers in the
ordering phase.

\itt{clock\_analyse\_external} is a scalar variable of type default \realdp,
that gives the elapsed system clock time spent by the external solvers in the
analysis phase.

\itt{clock\_factorize\_external} is a scalar variable of type default \realdp,
that gives the elapsed system clock time spent by the external solvers in the
factorization phase.

\itt{clock\_solve\_external} is a scalar variable of type default \realdp,
that gives  the elapsed system clock time spent by the external solvers in the
solve phases.

\end{description}

%%%%%%%%%%% inform type %%%%%%%%%%%

\subsubsection{The derived data type for holding informational
 parameters}\label{typeinform}
The derived data type
{\tt \packagename\_inform\_type}
is used to hold parameters that give information about the progress and needs
of the algorithm. The components of
{\tt \packagename\_inform\_type}
are as follows---any component that is not relevant to the solver being used
will have the value {\tt -1} or {\tt -1.0} as appropriate:

\begin{description}

\itt{status} is a scalar variable of type default \integer, that gives the
exit status of the algorithm.
%See Sections~\ref{galerrors} and \ref{galinfo}
See \S\ref{galerrors}
for details.

\itt{alloc\_status} is a scalar variable of type default \integer, that gives
the status of the last attempted array allocation or deallocation.

\itt{bad\_alloc} is a scalar variable of type default \character\
and length 80, that  gives the name of the last internal array
for which there were allocation or deallocation errors.
This will be the null string if there have been no
allocation or deallocation errors.

%\itt{more\_info} is a scalar variable of type default \integer, that gives
%additional information as
%\ldots %  further information on failure

\itt{entries} is a scalar variable of type default \integer,
that is set to the total number of entries of $\bmA$ supplied.

\itt{out\_of\_range} is a scalar variable of type default \integer,
that is set to the number of
entries of $\bmA$ supplied with one or both indices out of range.

\itt{duplicates} is a scalar variable of type default \integer,
that is set to the number of duplicate off-diagonal entries of $\bmA$ supplied.

\itt{upper} is a scalar variable of type default \integer,
that is set to the number of input entries from the strict upper triangle
of $\bmA$.

\itt{missing\_diagonals} is a scalar variable of type default \integer,
that gives the number of diagonal entries entries missing for an
allegedly-definite matrix $\bmA$.

\itt{max\_depth\_assembly\_tree} is a scalar variable of type default \integer,
that gives the maximum depth of the assembly tree.

\itt{nodes\_assembly\_tree} is a scalar variable of type default \integer,
that holds the number of nodes in the assembly tree.

\itt{real\_size\_desirable} is a scalar variable of type long \integer,
that give the total number of real words required for a
successful factorization without the need for data compression,
provided no numerical pivoting is performed.

\itt{integer\_size\_desirable} is a scalar variable of type long \integer,
that give the total number of integer words required for a
successful factorization without the need for data compression,
provided no numerical pivoting is performed.

\itt{real\_size\_necessary} is a scalar variable of type long \integer,
that give the total number of real words required for a
successful factorization allowing for data compression,
provided no numerical pivoting is performed.

\itt{integer\_size\_necessary} is a scalar variable of type long \integer,
that give the total number of real words required for a
successful factorization allowing for data compression,
provided no numerical pivoting is performed.

\itt{real\_size\_factors} is a scalar variable of type long \integer,
that gives the predicted or actual number of real words to hold factors
of $\bmA$.

\itt{integer\_size\_factors} is a scalar variable of type long \integer,
that gives the predicted or actual number of integer words to hold factors
of $\bmA$.

\itt{entries\_in\_factors} is a scalar variable of type long \integer,
that gives the number of entries in the factors of $\bmA$.

\itt{max\_task\_pool\_size} is a scalar variable of type default \integer,
that gives the maximum number of tasks in the parallel factorization task pool.

\itt{max\_front\_size} is a scalar variable of type default \integer,
that gives the forecast or actual size of the largest front encountered
during the factorization.

\itt{compresses\_real} is a scalar variable of type default \integer,
that gives the number of compresses of real data required.

\itt{compresses\_integer} is a scalar variable of type default \integer,
that gives the number of compresses of integer data required.

\itt{two\_by\_two\_pivots} is a scalar variable of type default \integer,
that gives the number of two-by-two pivots used in the factorization.

\itt{semi\_bandwidths} is a scalar variable of type default \integer,
that gives the semi-bandwidth of the input matrix following
profile or bandwidth reduction.

\itt{delayed\_pivots} is a scalar variable of type default \integer,
that gives the total number of delayed pivots in the factorization.

\itt{pivot\_sign\_changes} is a scalar variable of type default \integer,
that gives the number of pivot sign changes encountered if the no pivoting
option ({\tt control\%pivot\_control = 3}) is used successfully.

\itt{static\_pivots} is a scalar variable of type default \integer,
that gives the number of modified pivots during static pivoting are chosen.

\itt{first\_modified\_pivot} is a scalar variable of type default \integer,
that gives the step at which the first pivot is modified when performing
static pivoting (i.e., if {\tt control\%static\_pivot\_tolerance$>$0.0})
or when modifying the matrix to ensure it is sufficiently positive definite
(i.e., if {\tt control\%pivot\_control = 4}).

\itt{rank} is a scalar variable of type default \integer,
that gives an estimate of the rank of $\bmA$.

\itt{negative\_eigenvalues} is a scalar variable of type default \integer,
that gives an estimate of the number of negative eigenvalues of $\bmA$.

\itt{iterative\_refinements} is a scalar variable of type default \integer,
that gives the number of iterative refinements performed.

\itt{alternative} is a scalar variable of type default \logical,
that will be set {\tt .FALSE.} on exit from
{\tt \packagename\_fredholm\_\-alternative} (see \S\ref{fredholm})
if a solution $\bmx$ to $\bmA \bmx = \bmb$ has been found,
and {\tt .TRUE.} if instead the alternative vector $\bmx$ for which
$\bmA \bmx = \bmzero$ and $\bmb^T \bmx > 0$ has been determined.

\itt{flops\_assembly} is a scalar variable of type long \integer,
that gives the anticipated or actual number of floating-point operations
performed when manipulating the matrix prior to factorization.

\itt{flops\_elimination} is a scalar variable of type long \integer,
that gives the anticipated or actual number of floating-point operations
performed during the factorization.

\itt{flops\_blas} is a scalar variable of type long \integer,
that gives the number of additional floating-point operations
that result from using the basic linear algebra subprograms (BLAS)
in the factorization phase.

\itt{largest\_modified\_pivot} is a scalar variable of type \realdp,
that gives the value of the largest pivot modification when performing
static pivoting (i.e., if {\tt control\%static\_pivot\_\-tolerance$>$0.0})
or when modifying the matrix to ensure it is sufficiently positive definite
(i.e., if {\tt control\-\%pivot\_control = 4}).

\itt{minimum\_scaling\_factor} is a scalar variable of type \realdp,
that gives the minimum scaling factor used.

\itt{maximum\_scaling\_factor} is a scalar variable of type \realdp,
that gives the maximum scaling factor used.

\itt{condition\_number\_1} and
{\tt condition\_number\_2} are scalar variables of type \realdp,
that gives estimates of the condition numbers of the matrix
for category-1 and -2 equations, respectively.

\itt{backward\_error\_1} and
{\tt backward\_error\_2} are scalar variables of type \realdp,
that gives estimates of the backward errors
for category-1 and -2 equations, respectively.

\itt{forward\_error} is a scalar variable of type \realdp,
that gives an estimate of the forward error.

\ittf{time} is a scalar variable of type {\tt \packagename\_time\_type}
whose components are used to hold elapsed CPU and system clock times
(in seconds) for the various parts of the calculation
(see Section~\ref{typetime}).

\itt{sils\_ainfo} is a scalar variable of type {\tt sils\_ainfo},
that corresponds to the output value {\tt sils\_ainfo}
from {\tt SILS}. See the documentation for {\tt SILS} for further
details.

\itt{sils\_finfo} is a scalar variable of type {\tt sils\_finfo},
that corresponds to the output value {\tt sils\_finfo}
from {\tt SILS}. See the documentation for {\tt SILS} for further
details.

\itt{sils\_sinfo} is a scalar variable of type {\tt sils\_sinfo},
that corresponds to the output value {\tt sils\_sinfo}
from {\tt SILS}. See the documentation for {\tt SILS} for further
details.

\itt{ma57\_ainfo} is a scalar variable of type {\tt ma57\_ainfo},
that corresponds to the output value {\tt ma57\_ainfo}
from {\tt HSL\_MA57}. See the documentation for {\tt HSL\_MA57} for further
details.

\itt{ma57\_finfo} is a scalar variable of type {\tt ma57\_finfo},
that corresponds to the output value {\tt ma57\_finfo}
from {\tt HSL\_MA57}. See the documentation for {\tt HSL\_MA57} for further
details.

\itt{ma57\_sinfo} is a scalar variable of type {\tt ma57\_sinfo},
that corresponds to the output value {\tt ma57\_sinfo}
from {\tt HSL\_MA57}. See the documentation for {\tt HSL\_MA57} for further
details.

\itt{ma77\_info} is a scalar variable of type {\tt ma77\_info},
that corresponds to the output value {\tt ma77\_info}
from {\tt HSL\_MA77}. See the documentation for {\tt HSL\_MA77} for further
details.

\itt{ma86\_info} is a scalar variable of type {\tt ma86\_info},
that corresponds to the output value {\tt ma86\_info}
from {\tt HSL\_MA86}. See the documentation for {\tt HSL\_MA86} for further
details.

\itt{ma87\_info} is a scalar variable of type {\tt ma87\_info},
that corresponds to the output value {\tt ma87\_info}
from {\tt HSL\_MA87}. See the documentation for {\tt HSL\_MA87} for further
details.

\itt{ma97\_info} is a scalar variable of type {\tt ma97\_info},
that corresponds to the output value {\tt ma97\_info}
from {\tt HSL\_MA97}. See the documentation for {\tt HSL\_MA97} for further
details.

\itt{ssids\_inform} is a scalar variable of type {\tt ssids\_inform},
that corresponds to the output value {\tt ssids\_inform}
from {\tt SSIDS}. See the documentation for {\tt SSIDS} for further
details.

\itt{mc64\_info} is a scalar variable of type {\tt mc64\_info},
that corresponds to the output value {\tt mc64\_info}
from {\tt HSL\_MC64}. See the documentation for {\tt HSL\_MC64} for further
details.

\itt{mc61\_info} is an array of size 10 and type \integer,
that corresponds to the output array {\tt INFO}
from {\tt MC61}. See the HSL documentation for {\tt MC61} for further
details.

\itt{mc61\_rinfo} is an array of size 15 and type \realdp,
that corresponds to the output array {\tt RINFO}
from {\tt MC61}. See the HSL documentation for {\tt MC61} for further
details.

\itt{mc68\_info} is a scalar variable of type {\tt mc68\_info},
that corresponds to the output value {\tt mc68\_info}
from {\tt HSL\_MC68}. See the documentation for {\tt HSL\_MC68} for further
details.

\itt{mc77\_info} is an array of rank one, of dimension 10 and of
type default \integer, that corresponds to the output array {\tt INFO}
from the primary subroutine in {\tt MC77}. See the documentation for
{\tt MC77} for further details.

\itt{mc77\_rinfo} is an array of rank one, of dimension 10 and of
type default \realdp, that corresponds to the output array {\tt RINFO}
from the primary subroutine in {\tt MC77}. See the documentation for
{\tt MC77} for further details.

\itt{PARDISO\_error} is a scalar variable of type \integer,
that corresponds to the output value {\tt error}
from {\tt PARDISO}. See the documentation for {\tt PARDISO} for further
details.

\itt{PARDISO\_iparm} is an array of size 64 and type \integer,
whose components correspond to those in the output array {\tt IPARM}
from {\tt PARDISO}. See the documentation for {\tt PARDISO} for further
details.

\itt{PARDISO\_dparm} is an array of size 64 and type \realdp,
whose components correspond to those in the output array {\tt DPARM}
from {\tt PARDISO}. See the documentation for {\tt PARDISO} for further
details. This is only available for the Pardiso Project version of the package.

\itt{WSMP\_error} is a scalar variable of type \integer,
that corresponds to the output value {\tt error}
from {\tt WSMP}. See the documentation for {\tt WSMP} for further
details.

\itt{WSMP\_iparm} is an array of size 64 and type \integer,
whose components correspond to those in the output array {\tt IPARM}
from {\tt WSMP}. See the documentation for {\tt WSMP} for further
details.

\itt{WSMP\_dparm} is an array of size 64 and type \realdp,
whose components correspond to those in the output array {\tt DPARM}
from {\tt WSMP}. See the documentation for {\tt WSMP} for further
details.

\itt{lapack\_error} is a scalar variable of type \integer,
that corresponds to the output value {\tt info} returned from
the LAPACK routines {\tt S/DPOTRF/S},
{\tt S/DSYTRF/S} and {\tt S/DPBTRF/S}
See the documentation for LAPACK for further
details.

\end{description}


%%%%%%%%%%% data type %%%%%%%%%%%

\subsubsection{The derived data type for holding problem data}\label{typedata}
The derived data type
{\tt \packagename\_data\_type}
is used to hold all the data for a particular problem,
or sequences of problems with the same structure, between calls to
{\tt \packagename} procedures.
%This data should be preserved, untouched, from the initial call to
%{\tt \packagename\_initialize}
%to the final call to
%{\tt \packagename\_terminate}.
All components are private.

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\galarguments
We use square brackets {\tt [ ]} to indicate \optional\ arguments.

%%%%%% initialization subroutine %%%%%%

\subsubsection{The initialization subroutine}\label{subinit}
The initialization subroutine must be called for each solver used
to initialize data and solver-specific control parameters.

\hskip0.5in
{\tt CALL \packagename\_initialize( solver, data, control, inform )}
\begin{description}

\itt{solver} is scalar, of \intentin, of type \character, and of variable
length that specifies which solver to use. Possible values are
\begin{description}
\itt{sils} if the \galahad\ solver {\tt SILS} is desired.

\itt{ma27} is an alias for {\tt sils} that reflects the fact that the \galahad\
 solver {\tt SILS} is a Fortran-90 encapsulation of the Fortran-77
 package {\tt MA27} from HSL.

\itt{ma57} if the HSL solver {\tt HSL\_MA57} is desired. This is a more
advanced version of {\tt SILS/MA27}.

\itt{ma77} if the HSL solver {\tt HSL\_MA77} is desired. This is particularly
appropriate when the matrix factors are too large to fit in main memory,
and offers the option of parallel execution of core computations.

\itt{ma86} if the HSL solver {\tt HSL\_MA86} is desired. This option
offers the opportunity for general parallel solution, but may be
less efficient than {\tt ma87} below when $\bmA$ is positive definite.

\itt{ma87} if the HSL solver {\tt HSL\_MA87} is desired. This option should
only be selected when $\bmA$ is positive definite, but
offers the opportunity for general parallel solution.

\itt{ma97} if the HSL solver {\tt HSL\_MA97} is desired. This option offers
the functionality of {\tt HSL\_MA57} but offers the option of parallel
execution of core computations.

\itt{ssids} if the HSL solver {\tt HSL\_SSIDS} is desired. This option offers
the functionality of {\tt HSL\_MA97} but additionally performs
core computations on a GPU if available. N.B., {\tt SSIDS} is only
supported for compilers that are OMP 4.0 compliant, and only available
in double precision.

\itt{pardiso} if the Pardiso Project solver {\tt PARDISO} (version 4.0.0
or above) is desired. Again parallel solution is offered with this choice.

\itt{mkl\_pardiso} if the Intel MKL solver {\tt PARDISO} that forked from the
Pardiso Project version in 2006, and supports parallel solution.

\itt{wsmp} if the IBM alpha Works solver {\tt WSMP} (version 10.9
or above) is desired. Parallel solution is also offered with this choice.

\itt{potr} if the LAPACK dense Cholesky factorization package
{\tt (S/D)POTR(F/S)} is desired.

\itt{sytr} if the LAPACK dense symmetric indefinite factorization package
{\tt S/DSYTRF/S} is desired.

\itt{pbtr} if the LAPACK banded Cholesky factorization package
{\tt S/DPBTRF/S} is desired.

\end{description}
Other solvers may be added in the future.
% HSL_MA64, HSL_MA54, HSL_MP54, MUMPS

\itt{data} is a scalar \intentout argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold data about the problem being
solved.

\itt{control} is a scalar \intentout argument of type
{\tt \packagename\_control\_type}
(see \S\ref{typecontrol}).
On exit, {\tt control} contains solver-specific default values for the
components as described in \S\ref{typecontrol}.
These values should only be changed after calling
{\tt \packagename\_initialize}.

\itt{inform} is a scalar \intentout argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\end{description}

%%%%%%%%% analysis subroutine %%%%%%

\subsubsection{The sparsity pattern analysis subroutine}
The sparsity pattern of $\bmA$ may be analysed as follows:

\hskip0.5in
{\tt CALL \packagename\_analyse( matrix, data, control, inform[, PERM] )}

\begin{description}
\itt{matrix} is scalar \intentin\ argument of type {\tt SMT\_type}
that is used to specify $\bmA$.
The user must set all of the relevant components of {\tt matrix} according
to the storage scheme desired (see \S\ref{typeprob}) except
{\tt matrix\%val}. Incorrectly-set components will result in errors
flagged in {\tt inform\%status}, see \S\ref{galerrors}.

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors and other
data about the problem being solved.
It must have been initialized by a call to
{\tt \packagename\_ini\-tialize}.

\itt{control} is scalar \intentin\ argument of type
{\tt \packagename\_control\_type}. Its components control the action
of the analysis phase, as explained in
\S\ref{typecontrol}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\itt{PERM} is an \optional\ \intentin\ rank-one default \integer\ argument of
length {\tt matrix\%n} that may be used to provide a permutation/pivot
order.
If present, {\tt PERM(i)}, {\tt i} $= 1, \ldots,$ {\tt matrix\%n}, should be set
to the desired position of the input row $i$ in the permuted matrix.

\end{description}

%%%%%%%%% factorization subroutine %%%%%%

\subsubsection{The numerical factorization subroutine}
Once it has been analysed, the matrix $\bmA$ may be factorized as follows:

\hskip0.5in
{\tt CALL \packagename\_factorize(matrix, data, control, inform )}

\begin{description}

\itt{matrix} is scalar \intentin\ argument of type {\tt SMT\_type}
that is used to specify $\bmA$.
The user must set all of the relevant components of {\tt matrix} according
to the storage scheme desired (see \S\ref{typeprob}). Those components
set for {\tt \packagename\_analyse} must not have been altered in the interim.

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors and other
data about the problem being solved.
It must have been initialized by a call to
{\tt \packagename\_ini\-tialize} and not altered by the user in the interim.

\itt{control} is scalar \intentin\ argument of type
{\tt \packagename\_control\_type}. Its components control the action
of the factorization phase, as explained in
\S\ref{typecontrol}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\end{description}

%%%%%%%%% solve subroutine %%%%%%

\subsubsection{The solution subroutine}
\label{solve}
Given the factorization, a set of equations may be solved as follows:

\hskip0.5in
{\tt CALL \packagename\_solve( matrix, X, data, control, inform )}

\begin{description}

\itt{matrix} is scalar \intentin\ argument of type {\tt SMT\_type}
that is used to specify $\bmA$.
The user must set all of the relevant components of {\tt matrix} according
to the storage scheme desired (see \S\ref{typeprob}). Those components
set for {\tt \packagename\_factorize} must not have been altered in the interim.

\ittf{X} is an \intentinout\ assumed-shape array argument of rank 1 or 2
and of type \realdp.  On entry, {\tt X} must be set
to the vector $\bmb$ or the matrix $\bmB$ and on successful return it holds
the solution $\bmx$ or $\bmX$. For the single right-hand side case, the
{\tt i}-th component of $\bmb$ and the resulting
{\tt i}-th component of the solution $\bmx$
occupy the {\tt i}-th component of {\tt X}. When there are multiple
right-hand sides, the
{\tt i}-th component of the $j$-th right-hand side $\bmb_j$
and the resulting solution $\bmx_j$ occupy the
{\tt i,j}-th component of {\tt X}.

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors and other
data about the problem being solved.
It must have been initialized by a call to
{\tt \packagename\_ini\-tialize} and not altered by the user in the interim.

\itt{control} is scalar \intentin\ argument of type
{\tt \packagename\_control\_type}. Its components control the action
of the solve phase, as explained in
\S\ref{typecontrol}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\end{description}

%%%%%%% termination subroutine %%%%%%

\subsubsection{The termination subroutine}
All previously allocated internal arrays are deallocated and OpenMP locks
destroyed as follows:

\hskip0.5in
{\tt CALL \packagename\_terminate( data, control, inform )}

\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors and other
data about the problem being solved.
It must have been initialized by a call to
{\tt \packagename\_ini\-tialize} and not altered by the user in the interim.
On exit, its allocatable array components will have been deallocated.

\itt{control} is scalar \intentin\ argument of type
{\tt \packagename\_control\_type}. Its components control the action
of the termination phase, as explained in
\S\ref{typecontrol}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\galerrors
A negative value of {\tt inform\%status} on exit from the subroutines
indicates that an error has occurred. No further calls should be made
until the error has been corrected. Possible values are:

\begin{description}

\itt{\galerrallocate} An allocation error occurred. A message indicating
the offending
array is written on unit {\tt control\%error}, and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc} respectively.

\itt{\galerrdeallocate} A deallocation error occurred.
A message indicating the offending
array is written on unit {\tt control\%error} and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc} respectively.

\itt{\galerrrestrictions} One of the restrictions
 {\tt matrix\%n} $> 0$ or
 {\tt matrix\%ne} $< 0$, for co-ordinate entry,
  or requirements that {\tt matrix\%type}
  contain its relevant string
{\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_ROWS'} or   {\tt 'DENSE'}
%  or {\tt 'DIAGONAL'}
  has been violated.

\itt{\galerrinertia} The matrix is not positive definite while the solver
  used expected it to be.

\itt{\galunknownsolver} The requested solver is not available.

\itt{\galerrunavailable} This option is not available with this solver.

\itt{-32} More than {\tt control\%max\_integer\_factor\_size} words of
      internal integer storage are required for in-core factorization.

\itt{-34} The package {\tt PARDISO} failed; check the solver-specific
  information components {\tt inform\%pardiso\_iparm}
  and {\tt inform\%pardiso\_dparm} along with {\tt PARDISO}'s
  documentation for more details.

\itt{-35} The package {\tt WSMP} failed; check the solver-specific
  information components {\tt inform\%wsmp\_iparm}
  and {\tt inform\%\-wsmp\_dparm} along with {\tt WSMP}'s documentation
  for more details.

\itt{-36} The scaling package {\tt HSL\_MC64} failed; check the solver-specific
  information component {\tt inform\%mc64\_info}
  along with {\tt HSL\_MC64}'s documentation for more details.

\itt{-37} The scaling package {\tt MC77} failed; check the solver-specific
  information components {\tt inform\%mc77\_info}
  and {\tt inform\%mc77\_rinfo} along with {\tt MC77}'s documentation
  for more details.

\itt{-39}  The input permutation/pivot order is not a permutation or is
    faulty in some other way.

\itt{-40} It is not possible to alter the block diagonal factors for this
   solver.

\itt{-41} There is no information about the permutation used or the values
   of the pivots used for this solver (see \S\ref{galenquire}).

\itt{-42} There is no information about the values of diagonal
    perturbations made for this solver (see \S\ref{galenquire}).

\itt{-43} A direct-access file error occurred. See the value of
    {\tt inform\%ma77\_info\%flag} for more details.

\itt{-50} A solver-specific error occurred; check the solver-specific
  information component of {\tt inform} along with the solver's documentation
  for more details.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Further control features %%%%%%%%%%%%%%%%%%%%%%%%

\galfeatures
\noindent In this section, we describe features for enquiring about and
manipulating the parts of the factorization constructed. These features
will not be needed by a user who wants simply to solve systems of
equations with matrix $\bmA$.

The solvers used each produce an $\bmL \bmD \bmL^T$ factorization
of $\bmA$ or a perturbation thereof, where $\bmL$ is a permuted lower
triangular matrix and $\bmD$ is a block diagonal matrix with blocks of order
1 and 2. It is convenient to write this factorization in the form
\disp{\bmA + \bmE = \bmP \bmL \bmD \bmL^T \bmP^T,}
where $\bmP$ is a permutation matrix and $\bmE$ is any diagonal perturbation
introduced. The following subroutines
are provided:
\begin{description}
\ittf{} {\tt \packagename\_enquire} returns any of $\bmP$, $\bmD$, $\bmE$,
or the pivot permutations implicit in $\bmD$.

\ittf{} {\tt \packagename\_alter\_d} alters $\bmD$. Note that this means that
we no longer have a factorization of the given matrix $\bmA$.

\ittf{} {\tt \packagename\_part\_solve} solves one of the systems of equations
$\bmP \bmL \bmx =  \bmb$,
$\bmD \bmx =  \bmb$,
$\bmL^T \bmP^T \bmx =  \bmb$, or when $\bmA$ is positive definite,
$\bmP \bmL \sqrt{\bmD}\bmx =  \bmb$,
for one or more right-hand sides.

\ittf{} {\tt \packagename\_sparse\_forward\_solve} solves
$\bmP \bmL \bmx =  \bmb$ when $\bmb$ is sparse and aims to return a
sparse $\bmx$.

\ittf{} {\tt \packagename\_fredholm\_alternative} computes
the Fredholm alternative for the data $(\bmA,\bmb)$, i.e., returns either
$\bmx$ satisfying $\bmA \bmx = \bmb$ or $\bmx$ satisfying
$\bmA \bmx = \bmzero$ and $\bmb^T \bmx > 0$.

\end{description}
Support for these features from the solvers available with \packagename\
is summarised in Table~\ref{options}.
\bctable{|l|c|c|c|c|c|c|c|c|c|}
\hline
 solver & \multicolumn{4}{c|}{{\tt \packagename\_enquire}} &
{\tt \packagename\_alter\_d} & {\tt \packagename\_part\_solve} &
{\tt \packagename\_sparse-} &
{\tt \packagename\_fredholm-} \\
\cline{2-5}
  & $\bmP$ & pivots & $\bmD$ & $\bmE$ & & &{\tt \_forward\_solve}
 & {\tt \_alterantive} \\
\hline
{\tt SILS/MA27} & $\surd$ & $\surd$  & $\surd$ & $\surd$  & $\surd$  & $\surd$
& $\times^1$ & $\times$ \\
{\tt HSL\_MA57} & $\surd$ & $\surd$  & $\surd$ & $\surd$  & $\surd$  & $\surd$
& $\surd$ & $\surd$ \\
{\tt HSL\_MA77} & $\surd$ & $\times$ & $\surd$ & $\times$ & $\surd$  & $\surd$
& $\times^1$ & $\surd$ \\
{\tt HSL\_MA86} & $\surd$ & $\times$ & $\surd$ & $\surd$  & $\times$ & $\surd$
& $\times^1$ & $\times$ \\
{\tt HSL\_MA87} & $\surd$ & $\times$ & $\surd$ & $\surd$  & $\times$ & $\surd$
& $\surd$ & $\times$ \\
{\tt HSL\_MA97} & $\surd$ & $\surd$  & $\surd$ & $\surd$  & $\surd$  & $\surd$
& $\surd$ & $\surd$ \\
{\tt SSIDS}   & $\surd$ & $\surd$ & $\surd$ & $\surd$ & $\surd$
 & $\surd$ & $\times^1$ & $\times$ \\
{\tt PARDISO}   & $\times$ & $\times$ & $\times$ & $\times$ & $\times$
 & $\surd$ & $\times^1$ & $\times$ \\
{\tt MKL\_PARDISO}   & $\times$ & $\times$ & $\times$ & $\times$ & $\times$
 & $\surd$ & $\times^1$ & $\times$ \\
{\tt WSMP} & $\times$ & $\times$ & $\times$ & $\times$ & $\times$ & $\surd$
& $\times^1$ & $\times$ \\
{\tt POTR} & $\times$ & $\times$ & $\surd$ & $\times$ & $\surd$  & $\surd$
& $\times^1$ & $\times$ \\
{\tt SYTR} & $\times$ & $\surd$ & $\surd$ & $\times$ & $\surd$  & $\surd$
& $\times^1$ & $\times$ \\
{\tt PBTR} & $\times$ & $\times$ & $\surd$ & $\times$ & $\surd$  & $\surd$
& $\times^1$ & $\times$ \\
\hline
\ectable{\label{options}Options supported. $\times^1$ indicates a feature
that is not available directly from the solver, but for which an
(inefficient) simulation is provided.}
%\vspace*{-8mm}
\subsubsection{To return $\bmP$ or $\bmD$ or both}
\label{galenquire}

\hskip0.5in
{\tt CALL \packagename\_enquire( data, inform[, PERM][, PIVOTS][, D][, PERTURBATION] )}

\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors and other
data about the problem being solved.
It must have been initialized by a call to
{\tt \packagename\_ini\-tialize} and not altered by the user in the interim.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\itt{PERM} is an \optional\ rank-one default \integer\ array argument
of \intentout\ and length $n$.
If present, {\tt PERM} will be set to the pivot permutation
selected by {\tt \packagename\_analyse}.

\itt{PIVOTS} is an \optional\ rank-one default \integer\ array argument
of \intentout\  and length $n$.
If present, the index of pivot $i$ will be placed in
{\tt PIVOTS} ($i$), $i = 1, \ldots, n$, with its sign negative if it is
the index of a 2 x 2 block.

\ittf{D} is an \optional\ rank-two default \realdp\ array argument
of \intentout\, and shape {\tt (2, $n$)}.
If present, the diagonal entries of $\bmD^{-1} $ will
be placed in {\tt D( 1, i )}, $i = 1, \ldots n$ and the off-diagonal
entries of $\bmD^{-1} $ will be placed in {\tt D( 2, i )},
$i = 1, \ldots n-1$.

\itt{PERTURBATION} is an \optional\ rank-one default \realdp\ array argument
of \intentout\ and length $n$.
If present, {\tt PERTURBATION} will be set to a vector of diagonal perturbations
chosen by {\tt \packagename\_factorize}. This array can only be nonzero if
{\tt \packagename\_factorize} was last called with {\tt control\%pivoting} = 4
or if the solver chose its own pivot sequence ({\tt control\%pivoting} $\leq 0$).

\end{description}

\subsubsection{To alter $\bmD$}

\hskip0.5in
{\tt CALL \packagename\_alter\_d( data, D, inform )}

\begin{description}

\itt{data} is a scalar \intentinout argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors and other
data about the problem being solved.
It must have been initialized by a call to
{\tt \packagename\_ini\-tialize} and not altered by the user in the interim.

\ittf{D} is an \intentinout\ \realdp\ array argument of shape ($2$, $n$).
The diagonal entries of $\bmD^{-1} $ will
be altered to {\tt D( 1, i )}, $i = 1, \ldots n$ and the off-diagonal
entries of $\bmD^{-1} $ will be altered to {\tt D( 2, i )},
$i = 1, \ldots n-1$.

\itt{inform} is a scalar \intentinout argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\end{description}

\subsubsection{To perform a partial solution}

\hskip0.5in
{\tt CALL \packagename\_part\_solve( part, X, data, control, inform )}

\begin{description}
\itt{part} is scalar, of \intentin\, and of type \character. It
must have one of the values
\begin{description}
\itt{L} for solving $\bmP \bmL \bmx =  \bmb$ or
                     $\bmP \bmL \bmX =  \bmB$,
\itt{D} for solving $\bmD \bmx =  \bmb$ or
                  $\bmD \bmX =  \bmB$, or
\itt{U} for solving $\bmL^T \bmP^T \bmx =  \bmb$ or
                  $\bmL^T \bmP^T \bmX = \bmB$.
\itt{S} for solving $\bmP \bmL \sqrt{\bmD} \bmx =  \bmb$ or
                  $\bmP \bmL \sqrt{\bmD} \bmX =  \bmB$
where $\sqrt{\bmD}$ is the diagonal matrix whose entries are the
square roots \hspace*{-4mm} of those of $\bmD$ when $\bmA$ is positive definite.

\end{description}

\itt{data} is a scalar \intentinout argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors and other
data about the problem being solved.
It must have been initialized by a call to
{\tt \packagename\_ini\-tialize} and not altered by the user in the interim.

\ittf{X} is an \intentinout\ \realdp\ assumed-shape array argument of rank 1 or 2.
On entry, {\tt X} must be set
to the vector $\bmb$ or the matrix $\bmB$ and on successful return it holds
the solution $\bmx$ or $\bmX$. For the single right-hand side case, the
{\tt i}-th component of $\bmb$ and the resulting
{\tt i}-th component of the solution $\bmx$
occupy the {\tt i}-th component of {\tt X}. When there are multiple
right-hand sides, the
{\tt i}-th component of the $j$-th right-hand side $\bmb_j$
and the resulting solution $\bmx_j$ occupy the
{\tt i,j}-th component of {\tt X}.

\itt{control} is scalar \intentin\ argument of type
{\tt \packagename\_control\_type}. Its components control the action
of the solve phase, as explained in
\S\ref{typecontrol}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\end{description}

\subsubsection{To solve $\bmP \bmL \bmx =  \bmb$ for sparse $\bmb$}
\label{sparse_solve}

{\tt
\begin{verbatim}
        CALL SLS_sparse_forward_solve( nnz_b, INDEX_b, B, nnz_x, INDEX_x, X, data,   &
                                       control, inform )
\end{verbatim}
}
\vspace*{-4mm}
\begin{description}
\itt{nnz\_b} is an \intentin\ scalar of type  {\tt INTEGER} that
must hold the number of nonzero entries in the right-hand side.
{\bf Restriction:} {\tt 1$\le$nnz\_b$\le n$}.

\itt{INDEX\_b}  is an  \intentin\ rank-1 array of type {\tt INTEGER}.
The first {\tt nnz\_b} entries must hold the indices of the nonzero entries
in the right-hand side.

\ittf{B} is an  \intentin\ rank-one assumed-shape array argument of
length at least $n$ and of type \realdp.
If {\tt INDEX\_b(i)}$=${\tt k}, {\tt B(k)} must hold the {\tt i-}th
nonzero component of the right-hand side; other entries of {\tt B}
are not accessed.

\itt{nnz\_x}  is an  \intentout\ scalar  of type  {\tt INTEGER}.
On exit, {\tt nnz\_x} holds the number of nonzero entries in the solution.

\itt{INDEX\_x}  is an  \intentout\ rank-1  array of type {\tt INTEGER} and
size {\tt nnz\_x} (that is at most {\tt n}). On exit, the first
{\tt nnz\_x} entries hold the indices of the nonzero entries in the solution.

\ittf{X} is an  \intentinout\ rank-one assumed-shape array argument of
length at least $n$ and of type \realdp.
On entry, its first $n$ entries must be set by the user to zero.
On exit, if {\tt INDEX\_x(i)}$=${\tt k}, {\tt X(k)} holds the {\tt i-}th
nonzero component of the solution; all other entries of {\tt X} are zero.

\itt{data{\rm ,} control {\rm and} inform{\rm :}} see Section~\ref{solve}.

\end{description}

\subsubsection{To find the Fredholm alternative for the data $(\bmA,\bmb)$}
\label{fredholm}

\hskip0.5in
{\tt CALL \packagename\_fredholm\_alternative( matrix, X, data, control,
 inform )}

\begin{description}

\itt{matrix{\rm ,} data{\rm ,} control {\rm and} inform{\rm :}}
see Section~\ref{solve}.

\ittf{X} is an \intentinout\ rank-one assumed-shape array argument of
length at least $n$ and of type \realdp.
On entry, its first $n$ entries must be set by the user to the vector $\bmb$.
On exit, {\tt X} will contain a solution $\bmx$ to $\bmA \bmx = \bmb$ if
{\tt inform\%alternative} is {\tt .FALSE.} or a vector $\bmx$ for which
$\bmA \bmx = \bmzero$ and $\bmb^T \bmx > 0$ if
{\tt inform\%alternative} is {\tt .TRUE.}.
\end{description}

%%%%%%%%%%%%%%%%%%%%%% Further features %%%%%%%%%%%%%%%%%%%%%%%%

\galcontrolfeatures
\noindent In this section, we describe an alternative means of setting
control parameters, that is components of the variable {\tt control} of type
{\tt \packagename\_control\_type}
(see \S\ref{typecontrol}),
by reading an appropriate data specification file using the
subroutine {\tt \packagename\_read\_specfile}. This facility
is useful as it allows a user to change  {\tt \packagename} control parameters
without editing and recompiling programs that call {\tt \packagename}.

A specification file, or specfile, is a data file containing a number of
``specification commands''. Each command occurs on a separate line,
and comprises a ``keyword'',
that is a string (in a close-to-natural language) used to identify a
control parameter, and
an (optional) "value", which defines the value to be assigned to the given
control parameter. All keywords and values are case insensitive,
keywords may be preceded by one or more blanks but
values must not contain blanks, and
each value must be separated from its keyword by at least one blank.
Values must not contain more than 30 characters, and
each line of the specification file is limited to 80 characters,
including the blanks separating keyword and value.

The portion of the specification file used by
{\tt \packagename\_read\_specfile}
must start
with a ``{\tt BEGIN \packagename}'' command and end with an
``{\tt END}'' command.  The syntax of the specfile is thus defined as follows:
\begin{verbatim}
  ( .. lines ignored by SLS_read_specfile .. )
    BEGIN SLS
       keyword    value
       .......    .....
       keyword    value
    END
  ( .. lines ignored by SLS_read_specfile .. )
\end{verbatim}
where keyword and value are two strings separated by (at least) one blank.
The ``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiter command lines
may contain additional (trailing) strings so long as such strings are
separated by one or more blanks, so that lines such as
\begin{verbatim}
    BEGIN SLS SPECIFICATION
\end{verbatim}
and
\begin{verbatim}
    END SLS SPECIFICATION
\end{verbatim}
are acceptable. Furthermore,
between the
``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiters,
specification commands may occur in any order.  Blank lines and
lines whose first non-blank character is {\tt !} or {\tt *} are ignored.
The content
of a line after a {\tt !} or {\tt *} character is also
ignored (as is the {\tt !} or {\tt *}
character itself). This provides an easy way to ``comment out'' some
specification commands, or to comment specific values
of certain control parameters.

The value of a control parameter may be of three different types, namely
integer, character or real.
Integer and real values may be expressed in any relevant Fortran integer and
floating-point formats (respectively).
%Permitted values for logical
%parameters are "{\tt ON}", "{\tt TRUE}", "{\tt .TRUE.}", "{\tt T}",
%"{\tt YES}", "{\tt Y}", or "{\tt OFF}", "{\tt NO}",
%"{\tt N}", "{\tt FALSE}", "{\tt .FALSE.}" and "{\tt F}".
%Empty values are also allowed for
%logical control parameters, and are interpreted as "{\tt TRUE}".

The specification file must be open for
input when {\tt \packagename\_read\_specfile}
is called, and the associated unit number
passed to the routine in {\tt device} (see below).
Note that the corresponding
file is rewound, which makes it possible to combine the specifications
for more than one program/routine.  For the same reason, the file is not
closed by {\tt \packagename\_read\_specfile}.

\subsubsection{To read control parameters from a specification file}
\label{readspec}

Control parameters may be read from a file as follows:
\hskip0.5in

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
     CALL SLS_read_specfile( control, device )
\end{verbatim}
}
\def\baselinestretch{1.0}

\begin{description}
\itt{control} is a scalar \intentinout\ argument of type
{\tt \packagename\_control\_type}
(see \S\ref{typecontrol}).
Default values should have already been set, perhaps by calling
{\tt \packagename\_initialize}.
On exit, individual components of {\tt control} may have been changed
according to the commands found in the specfile. Specfile commands and
the component (see \S\ref{typecontrol}) of {\tt control}
that each affects are given in Table~\ref{specfile}.

\pctable{|l|l|l|}
\hline
  command & component of {\tt control} & value type \\
\hline
{\tt error-printout-device} & {\tt \%error} & {\tt integer} \\
{\tt warning-printout-device} & {\tt \%warning} & {\tt integer} \\
{\tt printout-device} & {\tt \%out} & {\tt integer} \\
{\tt statistics-printout-device} & {\tt \%statistics} & {\tt integer} \\
{\tt print-level} & {\tt \%print\_level} & {\tt integer} \\
{\tt print-level-solver} & {\tt \%print\_level\_solver} & {\tt integer} \\
{\tt architecture-bits} & {\tt \%bits} & {\tt integer} \\
{\tt block-size-for-kernel} & {\tt \%block\_size\_kernel} & {\tt integer} \\
{\tt block-size-for--elimination} & {\tt \%block\_size\_elimination} & {\tt integer} \\
{\tt blas-block-for-size-factorize} & {\tt \%blas\_block\_size\_factorize} & {\tt integer} \\
{\tt blas-block-size-for-solve} & {\tt \%blas\_block\_size\_solve} & {\tt integer} \\
{\tt node-amalgamation-tolerance} & {\tt \%node\_amalgamation} & {\tt integer} \\
{\tt initial-pool-size} & {\tt \%initial\_pool\_size} & {\tt integer} \\
{\tt minimum-real-factor-size} & {\tt \%min\_real\_factor\_size} & {\tt integer} \\
{\tt minimum-integer-factor-size} & {\tt \%min\_integer\_factor\_size} & {\tt integer} \\
{\tt maximum-real-factor-size} & {\tt \%max\_real\_factor\_size} & {\tt integer(long)} \\
{\tt maximum-integer-factor-size} & {\tt \%max\_integer\_factor\_size} & {\tt integer(long)} \\
{\tt maximum-in-core-store} & {\tt \%max\_in\_core\_store} & {\tt integer(long)} \\
{\tt pivot-control} & {\tt \%pivot\_control} & {\tt integer} \\
{\tt ordering} & {\tt \%ordering} & {\tt integer} \\
{\tt full-row-threshold} & {\tt \%full\_row\_threshold} & {\tt integer} \\
{\tt pivot-row-search-when-indefinite} & {\tt \%row\_search\_indefinite} & {\tt integer} \\
{\tt scaling} & {\tt \%scaling} & {\tt integer} \\
{\tt scale-maxit} & {\tt \%scale\_maxit} & {\tt integer} \\
{\tt scale-thresh} & {\tt \%scale\_thresh} & {\tt real} \\
{\tt max-iterative-refinements} & {\tt \%max\_iterative\_refinements} & {\tt integer} \\
{\tt array-increase-factor} & {\tt \%array\_increase\_factor} & {\tt real} \\
{\tt array-decrease-factor} & {\tt \%array\_decrease\_factor} & {\tt real} \\
{\tt relative-pivot-tolerance} & {\tt \%relative\_pivot\_tolerance} & {\tt real} \\
{\tt absolute-pivot-tolerance} & {\tt \%absolute\_pivot\_tolerance} & {\tt real} \\
{\tt zero-tolerance} & {\tt \%zero\_tolerance} & {\tt real} \\
{\tt static-pivot-tolerance} & {\tt \%static\_pivot\_tolerance} & {\tt real} \\
{\tt static-level-switch} & {\tt \%static\_level\_switch} & {\tt real} \\
{\tt consistency-tolerance} & {\tt \%consistency\_tolerance} & {\tt real} \\
{\tt acceptable-residual-relative} & {\tt \%acceptable\_residual\_relative} & {\tt real} \\
{\tt acceptable-residual-absolute} & {\tt \%acceptable\_residual\_absolute} & {\tt real} \\
{\tt out-of-core-directory} & {\tt \%out\_of\_core\_directory} & {\tt character} \\
{\tt out-of-core-integer-factor-file} & {\tt \%out\_of\_core\_integer\_factor\_file} & {\tt character} \\
{\tt out-of-core-real-factor-file} &  {\tt \%out\_of\_core\_real\_factor\_file} & {\tt character} \\
{\tt out-of-core-real-work-file} &  {\tt \%out\_of\_core\_real\_work\_file} & {\tt character} \\
{\tt out-of-core-indefinite-file} &  {\tt \%out\_of\_core\_indefinite\_file} & {\tt character} \\
{\tt output-line-prefix} & {\tt \%prefix} & {\tt character} \\
\hline

\ectable{\label{specfile}Specfile commands and associated
components of {\tt control}.}

\itt{device} is a scalar \intentin\ argument of type default \integer,
that must be set to the unit number on which the specification file
has been opened. If {\tt device} is not open, {\tt control} will
not be altered and execution will continue, but an error message
will be printed on unit {\tt control\%error}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% GENERAL INFORMATION %%%%%%%%%%%%%%%%%%%%%%%%

\galgeneral

%\galcommon None.
\galworkspace Provided automatically by the module.
\galmodules {\tt GALAHAD\_CLOCK},
{\tt GALAHAD\_SYMBOLS},
{\tt GALAHAD\_SORT\_single/double},
{\tt GALAHAD\_SPACE\-\_single/double},
{\tt GALAHAD\_SPECFILE\_single/double},
{\tt GALAHAD\_STRING\_single/double},
{\tt GALAHAD\_SMT\-\_sin\-gle/double},
{\tt GALAHAD\_SILS\_single/double}
and optionally
{\tt HSL\_MA57\_single/double},
{\tt HSL\_MA77\_single/\-double},
{\tt HSL\_MA86\_single/double},
{\tt HSL\_MA87\_single/double},
{\tt HSL\_MA97\_single/double},
{\tt HSL\_MC64\_single\-/double} and
{\tt HSL\_MC68\_single\-/double}.
\galroutines Optionally {\tt MC61}, {\tt MC77} and {\tt METIS}.
\galio Output is under control of the arguments
{\tt control\%error},
{\tt control\%warning},
{\tt control\%out}, \\
{\tt control\-\%statistics}
and {\tt control\%print\_level}.
\galrestrictions {\tt matrix\%n} $\geq$ {\tt 1},
{\tt matrix\%ne} $\geq$ {\tt 0} if
{\tt matrix\%type = 'COORDINATE'},
{\tt matrix\%type}
one of
{\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_ROWS'} or   {\tt 'DENSE'}.
% or {\tt 'DIAGONAL'}.
\galportability ISO Fortran~95 + TR 15581 or Fortran~2003 and optionally OpenNP.
The package is thread-safe.

%%%%%%%%%%%%%%%%%%%%%% METHOD %%%%%%%%%%%%%%%%%%%%%%%%

\galmethod
Variants of sparse Gaussian elimination are used.

\noindent
The solver {\tt SILS} is available as part of \galahad\ and relies on
the HSL Archive package {\tt MA27}. To obtain HSL Archive packages, see

{\tt http://hsl.rl.ac.uk/archive/ }.

\noindent
The solvers
{\tt HSL\_MA57},
{\tt HSL\_MA77},
{\tt HSL\_MA86},
{\tt HSL\_MA87}
and
{\tt HSL\_MA97}, the ordering packages
{\tt MC61} and {\tt HSL\_MC68}, and the scaling packages
{\tt HSL\_MC64} and {\tt MC77}
are all part of HSL 2011.
To obtain HSL 2011 packages, see

{\tt http://hsl.rl.ac.uk/hsl2011/ }.

\noindent
The solver {\tt SSIDS} is from the SPRAL sparse-matrix collection,
and is available as part of \galahad.
%To obtain {\tt SPRAL}, see
%
%{\tt http://ccpforge.cse.rl.ac.uk/gf/project/asearchralna/ }.

\noindent
The solver {\tt PARDISO} is available from the Pardiso Project;
version 4.0.0 or above is required.
To obtain {\tt PARDISO}, see

{\tt http://www.pardiso-project.org/ }.

\noindent
The solver {\tt MKL PARDISO} is available as part of Intel's oneAPI Math Kernel
Library (oneMKL).
To obtain this version of {\tt PARDISO}, see

{\tt https://software.intel.com/content/www/us/en/develop/tools/oneapi.html }.

\noindent
The solver {\tt WSMP} is available from the IBM alpha Works;
version 10.9 or above is required.
To obtain {\tt WSMP}, see

{\tt http://www.alphaworks.ibm.com/tech/wsmp }.

\noindent
The solvers {\tt POTR}, {\tt SYTR} and {\tt PBTR},
are available as
{\tt S/DPOTRF/S},
{\tt S/DSYTRF/S} and {\tt S/DPBTRF/S}
as part of LAPACK. Reference versions
are provided by GALAHAD, but for good performance
machined-tuned versions should be used.

\noindent
Explicit sparsity re-orderings are obtained by calling the HSL package
{\tt HSL\_MC68}.
Both this, {\tt HSL\_MA57} and {\tt PARDISO} rely optionally
on the ordering package {\tt METIS} from the Karypis Lab. To obtain
{\tt METIS}, see

{\tt http://glaros.dtc.umn.edu/gkhome/views/metis/ }.

\noindent
Bandwidth, Profile and wavefront reduction is supported by
calling HSL's {\tt MC61}.

\vspace*{1mm}

\galreferences
\vspace*{1mm}

\noindent
The methods used are described in the user-documentation for
\vspace*{1mm}

\noindent
HSL 2011, A collection of {F}ortran codes for large-scale scientific
 computation (2011). \\
 {\tt http://www.hsl.rl.ac.uk}

\noindent
and papers

\noindent
O. Schenk and K. G\"{a}rtner,
``Solving Unsymmetric Sparse Systems of Linear Equations with PARDISO''.
Journal of Future Generation Computer Systems \bf, 20(3) \rm (2004) 475--487, 

\noindent
O. Schenk and K. G\"{a}rtner,
``On fast factorization pivoting methods for symmetric indefinite systems''.
Electronic Transactions on Numerical Analysis
{\bf 23} (2006) 158--179,
and

\noindent
A. Gupta,
``WSMP: Watson Sparse Matrix Package Part I - direct
solution of symmetric sparse systems''.
IBM Research Report RC 21886, IBM T.\ J.\ Watson Research Center,
NY 10598, USA (2010).


%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\galexample
We illustrate the use of the package on the solution of the
single set of equations
\disp{\mat{ccccc}{ 2 & 3 &   &   &   \\
                   3 &   & 4 &   & 6 \\
                     & 4 & 1 & 5 &   \\
                     &   & 5 &   &   \\
                     & 6 & &     & 1 } \bmx =
       \vect{ 8 \\ 45 \\ 31 \\ 15 \\ 17}}
(Note that this example does not illustrate all the facilities).
Then, choosing the solver {\tt SILS}, we may use the following code:

{\tt \small
\VerbatimInput{\packageexample}
}
\noindent
%with the following data
%{\tt \small
%\VerbatimInput{\packagedata}
%}
%\noindent
This produces the following output:
{\tt \small
\VerbatimInput{\packageresults}
}
\noindent

\end{document}

\documentclass{galahad}

% set the package name

\newcommand{\package}{nls}
\newcommand{\packagename}{NLS}
\newcommand{\fullpackagename}{\libraryname\_\packagename}
\newcommand{\solver}{{\tt \fullpackagename\_solve}}

\begin{document}

\galheader

%%%%%%%%%%%%%%%%%%%%%% SUMMARY %%%%%%%%%%%%%%%%%%%%%%%%

\galsummary
This package uses a {\bf regularization method to find a (local)
unconstrained minimizer of a differentiable weighted sum-of-squares objective
function
\disp{f(\bmx) \eqdef
 \half \sum_{i=1}^m w_i^{} c_i^2(\bmx) \equiv \half \|\bmc(\bmx)\|_W^2}
%or, more generally, a stabilised version
%\disp{f_{\rho,r}(\bmx) \eqdef f(\bmx) +  \sfrac{\rho}{r} \sum_{1=1}^n x_i^r
%\equiv f(\bmx) + \sfrac{\rho}{r} \|\bmx\|_r^r,}
of many variables $\bmx$ involving positive weights $w_i$, $i=1,\ldots,m$.}
%for given stabilisation weight $\rho\geq 0$ and order $r\geq 2$};
%here and elsewhere we define the $q$-norm of a
%vector $\bmv$, whose $i$-th component is $v_i$, $i=1,\ldots,n$,
%to be $\|\bmv\|_q \eqdef \sqrt[q]{\sum_{i=1}^n v_i^q}$.
The method offers the choice of direct and iterative solution of the key
regularization subproblems, and is most suitable for large problems.
First derivatives of the {\bf residual function}
$\bmc(\bmx)$ are required, and if second derivatives of the
$c_i(\bmx)$ can be calculated, they may be exploited---if suitable products
of the first or second derivatives with a vector may be found but not the
derivatives themselves, that can also be used to advantage.

%%%%%%%%%%%%%%%%%%%%%% attributes %%%%%%%%%%%%%%%%%%%%%%%%

\galattributes
\galversions{\tt  \fullpackagename\_single, \fullpackagename\_double}.
\galuses
{\tt GALAHAD\_CLOCK},
{\tt GALAHAD\_SY\-M\-BOLS},
{\tt GALAHAD\_NLPT},
{\tt GALAHAD\_SPECFILE},
{\tt GALAHAD\_PSLS},
{\tt GALAHAD\_GLRT},
{\tt GALAHAD\_RQS},
{\tt GALAHAD\_BSC},
{\tt GALAHAD\_\-SPACE},
{\tt GALAHAD\_ROOTS},
{\tt GALAHAD\_MOP},
{\tt GALAHAD\_NORMS},
{\tt GALAHAD\_STRING}
and
{\tt GALAHAD\_BLAS\_interface}.
\galdate October 2016.
\galorigin N. I. M. Gould, Rutherford Appleton Laboratory.
\gallanguage Fortran~95 + TR 15581 or Fortran~2003.

%%%%%%%%%%%%%%%%%%%%%% HOW TO USE %%%%%%%%%%%%%%%%%%%%%%%%

\galhowto

%\subsection{Calling sequences}

Access to the package requires a {\tt USE} statement such as

\medskip\noindent{\em Single precision version}

\hspace{8mm} {\tt USE \fullpackagename\_single}

\medskip\noindent{\em Double precision version}

\hspace{8mm} {\tt USE  \fullpackagename\_double}

\medskip

\noindent
If it is required to use both modules at the same time, the derived types
{\tt SMT\_type},
{\tt GALAHAD\_userdata\_type},
{\tt \packagename\_time\_\-type},
{\tt \packagename\_control\_type},
{\tt \packagename\_inform\_type},
{\tt \packagename\_data\_type}
and
{\tt NLPT\_problem\_type},
(Section~\ref{galtypes})
and the subroutines
{\tt \packagename\_initialize},
{\tt \packagename\_\-solve},
{\tt \packagename\_terminate},
(Section~\ref{galarguments})
and
{\tt \packagename\_read\_specfile}
(Section~\ref{galfeatures})
must be renamed on one of the {\tt USE} statements.

%%%%%%%%%%%%%%%%%%%%%% terminology %%%%%%%%%%%%%%%%%%%%%%%%

\galterminology
The algorithm used is iterative. From the current best estimate
of the minimizer $\bmx_k$, a trial improved point $\bmx_k + \bms_k$ is sought.
The correction $\bms_k$ is chosen to improve a model $m_k(\bms)$ of
%the stabilised objective function $f_{\rho,p}(\bmx_k+\bms)$ built around
the objective function $f(\bmx_k+\bms)$ built around
$\bmx_k$. The model is the sum of two basic components,
a suitable approximation $t_k(\bms)$ of $f(\bmx_k+\bms)$,
%another approximation of $\sfrac{\rho}{r} \|\bmx_k+\bms\|_r^r$ (if $\rho > 0$),
and a regularization term $\sfrac{\sigma_k}{p} \|\bms\|_{\bmS_k}^p$
involving a weight $\sigma_k$, power $p$ and
a norm $\|\bms\|_{\bmS_k} \eqdef \sqrt{\bms^T \bmS_k \bms}$ for a given positive
definite scaling matrix $\bmS_k$ that is included to prevent large corrections.
The weight  $\sigma_k$ is adjusted as the algorithm progresses to
ensure convergence.

The model $t_k(\bms)$ is a truncated Taylor-series approximation, and this
relies on being able to compute or estimate derivatives of $\bmc(\bmx)$.
Various models are provided, and each has different derivative requirements.
We denote the $m$ by $n$ {\bf residual Jacobian} $\bmJ(\bmx)$ as the matrix
whose $i,j$-th component
\disp{\bmJ(\bmx)_{i,j} \eqdef \partial c_i(\bmx) / \partial x_j \;\;
\mbox{for $i=1,\ldots,m$ and $j=1,\ldots,n$.}}
For a given $m$-vector $\bmy$, the
{\bf weighted residual Hessian} is the sum
\disp{\bmH(\bmx,\bmy) \eqdef \sum_{\ell=1}^m y_\ell \bmH_\ell(\bmx),
\;\; \mbox{where}\;\;
\bmH_\ell(\bmx)_{i,j} \eqdef \partial^2 c_\ell(\bmx) / \partial x_i \partial x_j
\;\; \mbox{for $i,j=1,\ldots,n$}}
is the Hessian of $c_\ell(\bmx)$.
Finally, for a given vector $\bmv$, we define
the {\bf residual-Hessians-vector product matrix}
\disp{\bmP(\bmx,\bmv) \eqdef (\bmH_1(\bmx) \bmv, \ldots, \bmH_m(\bmx) \bmv).}
The models $t_k(\bms)$ provided are,
\begin{enumerate}
\item the first-order Taylor approximation $f(\bmx_k) + \bmg(\bmx_k)^T \bms$,
where
$\bmg(\bmx) = \bmJ^T(\bmx) \bmW \bmc(\bmx)$,
\item a barely second-order approximation
$f(\bmx_k) + \bmg(\bmx_k)^T \bms + \half \bms^T \bmW \bms$,
\item the Gauss-Newton approximation
$\half \| \bmc(\bmx_k) + \bmJ(\bmx_k) \bms\|_{\bmW}^2$,
\item the Newton (second-order Taylor) approximation
  $f(\bmx_k) + \bmg(\bmx_k)^T s + \half \bms^T
  [ \bmJ^T(\bmx_k) \bmW \bmJ(\bmx_k) +
\bmH(\bmx_k,\bmW \bmc(\bmx_k))] \bms$, and
\item the tensor Gauss-Newton approximation
$\half \| \bmc(\bmx_k) + \bmJ(\bmx_k) \bms +
 \half \bms^T \cdot \bmP(\bmx_k,\bms) \|_{\bmW}^2$,
where the $i$-th component of $\bms^T \cdot \bmP(\bmx_k,\bms)$ is
shorthand for the scalar $\bms^T \bmH_i(\bmx_k) \bms$,
\end{enumerate}
where $\bmW$ is the diagonal matrix of weights $w_i$, $i = 1, \ldots m$.

\noindent
Access to a particular model requires that the user is either able to
provide the derivatives needed ({\bf ``matrix available''}) or that the products
of these derivatives (and their transposes) with specified vectors are possible
({\bf ``matrix free''}).

%%%%%%%%%%%%%%%%%%%%%% matrix storage formats %%%%%%%%%%%%%%%%%%%%%%%%

\galmatrix The matrices $\bmJ(\bmx)$, $\bmH(\bmx,\bmy)$ and $\bmP(\bmx,\bmv)$
(as required and when available) may be stored in a variety of input formats.

\subsubsection{Dense storage format}\label{dense}
The matrix $\bmJ$ is stored as a compact
dense matrix by rows, that is, the values of the entries of each row in turn are
stored in order within an appropriate real one-dimensional array.
Component $n \ast (i-1) + j$ of the storage array {\tt
  J\%val} will hold the value $\bmJ_{i,j}$ for $i = 1, \ldots , m$, $j =
1, \ldots , n$.  Since $\bmH$ is symmetric, only the lower triangular
part (that is the part $\bmH_{ij}$ for $1 \leq j \leq i \leq n$)
should be stored. In this case the lower triangle will be stored by rows,
that is component $i \ast (i-1)/2 + j$ of the storage array {\tt H\%val} will
hold the value $\bmH_{ij}$ (and, by symmetry, $\bmH_{ji}$) for $1 \leq j
\leq i \leq n$. If tensor-Newton models are used, the required matrix $\bmP$
may be stored as a compact dense matrix by columns, that is, the values of
the entries of each column in turn are stored in order within an appropriate
real one-dimensional array.

\subsubsection{Sparse co-ordinate storage format}\label{coordinate}
Only the nonzero entries of the matrices are stored. For the $l$-th
entry of $\bmJ$, its row index $i$, column index $j$ and value
$\bmJ_{ij}$ are stored in the $l$-th components of the integer arrays
{\tt J\%row}, {\tt J\%col} and real array {\tt J\%val}.
The order is unimportant, but the total number of entries {\tt J\%ne} is
required.  The same scheme is applicable to $\bmH$
(thus requiring integer arrays {\tt H\%row}, {\tt H\%col}, a real
array {\tt H\%val}, and an integer value {\tt H\%ne}), except that only
the entries in the lower triangle should be stored.

%We recommend this storage format since it is the most efficient
%storage scheme for the underlying linear system solvers.  Any other
%storage formats are converted internally to sparse co-ordinate
%storage and then handled accordingly.

\subsubsection{Sparse row-wise storage format}\label{rowwise}
Again only the nonzero entries are stored, but this time they are
ordered so that those in row $i$ appear directly before those in row
$i+1$. For the $i$-th row of $\bmJ$, the $i$-th component of the integer
array {\tt J\%ptr} holds the position of the first entry in this row,
while {\tt J\%ptr} $(m+1)$ holds the total number of entries plus one.
The column indices $j$ and values $\bmJ_{ij}$ of the entries in the
$i$-th row are stored in components $l =$ {\tt J\%ptr}$(i)$, \ldots
,{\tt J\%ptr} $(i+1)-1$ of the integer array {\tt J\%col}, and real
array {\tt J\%val}, respectively.
The same scheme is applicable to
$\bmH$ (thus requiring integer arrays {\tt H\%ptr}, {\tt H\%col}, and
a real array {\tt H\%val}),
except that only the entries in the lower triangle should be stored.

For sparse matrices, this scheme almost always requires less storage than
its predecessor.

\subsubsection{Sparse column-wise storage format}\label{columnwise}
For the matrix $\bmP$, once again only the nonzero entries are
stored, but this time they are ordered so that those in column $j$ appear
directly before those in column $j+1$. For the $j$-th column of $\bmP$, the
$j$-th component of the integer array {\tt P\%ptr} holds the position of the
first entry in this column, while {\tt P\%ptr} $(n+1)$ holds the total number
of entries plus one.  The row indices $i$ and values $\bmP_{ij}$ of the
entries in the $j$-th column are stored in components $l =$ {\tt
  P\%ptr}$(j)$, \ldots ,{\tt P\%ptr} $(j+1)-1$ of the integer array
{\tt P\%row}, and real array {\tt P\%val}, respectively.

\subsubsection{Diagonal storage format}\label{diagonal}
If $\bmH$ is diagonal (i.e., $\bmH_{ij} = 0$ for all $1 \leq i \neq j \leq n$)
only the diagonal entries $\bmH_{ii}$ for $1 \leq i \leq n$ need be stored,
and the first $n$ components of the array {\tt H\%val} may be used for
the purpose. There is no sensible equivalent for the non-square
matrices $\bmJ$ and $\bmP$.

%%%%%%%%%%%%%%%%%%%%%% long integers %%%%%%%%%%%%%%%%%%%%%%

\subsection{Integer kinds}\label{Integer kinds}
We use the term
long \integer\ to denote {\tt INTEGER\-(kind=long)}, where
{\tt long = selected\_int\_kind(18))}.

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\galtypes
Seven derived data types are accessible from the package.

%%%%%%%%%%% matrix data type %%%%%%%%%%%

\subsubsection{The derived data type for holding matrices}\label{typesmt}
The derived data type {\tt SMT\_TYPE} is used to hold the Hessian matrix $\bmH$
if this is available. The components of {\tt SMT\_TYPE} used here are:

\begin{description}

\ittf{m} is a scalar component of type default \integer,
that holds the row dimension of the matrix.

\ittf{n} is a scalar component of type default \integer,
that holds the column dimension of the matrix.

\ittf{ne} is a scalar variable of type default \integer, that
holds the number of matrix entries.

\ittf{type} is a rank-one allocatable array of type default \character, that
is used to indicate the matrix storage scheme used. Its precise length and
content depends on the type of matrix to be stored (see \S\ref{typeprob}).

\ittf{val} is a rank-one allocatable array of type default \realdp\,
and dimension at least {\tt ne}, that holds the values of the entries.
Each pair of off-diagonal entries $h_{ij} = h_{ji}$ of the {\em symmetric}
matrix $\bmH$ is represented as a single entry
(see \S\ref{dense}--\ref{diagonal}).
Any duplicated entries that appear in the sparse
co-ordinate or row-wise schemes will be summed.

\ittf{row} is a rank-one allocatable array of type default \integer,
and dimension at least {\tt ne}, that may hold the row indices of the entries.
(see \S\ref{coordinate} and \S\ref{columnwise}).

\ittf{col} is a rank-one allocatable array of type default \integer,
and dimension at least {\tt ne}, that may hold the column indices of the entries
(see \S\ref{coordinate}--\ref{rowwise}).

\ittf{ptr} is a rank-one allocatable array of type default \integer,
and dimension at least {\tt n + 1}, that may hold the pointers to
the first entry in each row (see \S\ref{rowwise}--\ref{columnwise}).

\end{description}

%%%%%%%%%%% problem type %%%%%%%%%%%

\subsubsection{The derived data type for holding the problem}\label{typeprob}
The derived data type {\tt NLPT\_problem\_type} is used to hold
the problem. The relevant components of
{\tt NLPT\_problem\_type}
are:

\begin{description}

\ittf{n} is a scalar variable of type default \integer,
 that holds the number of optimization variables, $n$.

\ittf{m} is a scalar variable of type default \integer,
 that holds the number of residual functions, $m$.

%\itt{stabilisation\_weight}  is a scalar variable of type default \realdp,
%that holds the value of the stabilisation weight, $\rho \geq 0$.

%\itt{stabilisation\_power}  is a scalar variable of type default \realdp,
%that holds the value of the stabilisation power, $r \geq 2$.

\ittf{X} is a rank-one allocatable array of dimension {\tt n} and type
default \realdp, that holds the values $\bmx$ of the optimization variables.
The $j$-th component of {\tt X}, $j = 1,  \ldots , n$, contains $x_{j}$.

\ittf{C} is a rank-one allocatable array of dimension {\tt m} and type
default \realdp, that holds the residual values $\bmc(\bmx)$
at the point $\bmx$. The $i$-th component of
{\tt C}, $i = 1, \ldots, m$, contains $\bmc_{i}(\bmx)$.

\ittf{G} is a rank-one allocatable array of dimension {\tt m} and type
default \realdp, that holds the gradient $g(\bmx) = \nabla_x f(\bmx)$ of the
objective function at the point $\bmx$. The $j$-th component of
{\tt G}, $i = 1, \ldots, m$, contains $\partial f(\bmx)/\partial x_j$.

\ittf{J} is scalar variable of type {\tt SMT\_TYPE}
that holds the Jacobian matrix $\bmJ(\bmx)$ (if it is available).
The following components are used here:

\begin{description}

\itt{J\%type} is an allocatable array of rank one and type default
\character, that
is used to indicate the storage scheme used. If the dense storage scheme
(see Section~\ref{dense}) is used,
the first five components of {\tt J\%type} must contain the
string {\tt DENSE}.
For the sparse co-ordinate scheme (see Section~\ref{coordinate}),
the first ten components of {\tt J\%type} must contain the
string {\tt COORDINATE},
and for the sparse row-wise storage scheme (see Section~\ref{rowwise}),
the first fourteen components of {\tt J\%type} must contain the
string {\tt SPARSE\_BY\_ROWS}.

For convenience, the procedure {\tt SMT\_put}
may be used to allocate sufficient space and insert the required keyword
into {\tt J\%type}.
For example, if {\tt nlp} is of derived type {\tt \packagename\_problem\_type}
and involves a Jacobian we wish to store using the co-ordinate scheme,
we may simply
%\vspace*{-2mm}
{\tt
\begin{verbatim}
        CALL SMT_put( nlp%J%type, 'COORDINATE' )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent
See the documentation for the \galahad\ package {\tt SMT}
for further details on the use of {\tt SMT\_put}.

\itt{J\%ne} is a scalar variable of type default \integer, that
holds the number of entries in $\bmJ$
in the sparse co-ordinate storage scheme (see Section~\ref{coordinate}).
It need not be set for any of the other three schemes.

\itt{J\%val} is a rank-one allocatable array of type default \realdp, that holds
the values of the entries of the Jacobian matrix $\bmJ$ in any of the
storage schemes discussed in Section~\ref{galmatrix}.

\itt{J\%row} is a rank-one allocatable array of type default \integer,
that holds the row indices of $\bmJ$ in the sparse co-ordinate storage
scheme (see Section~\ref{coordinate}).
It need not be allocated for any of the other three schemes.

\itt{J\%col} is a rank-one allocatable array variable of type default \integer,
that holds the column indices of $\bmJ$ in either the sparse co-ordinate
(see Section~\ref{coordinate}), or the sparse row-wise
(see Section~\ref{rowwise}) storage scheme.
It need not be allocated when the dense or diagonal storage schemes are used.

\itt{J\%ptr} is a rank-one allocatable array of dimension {\tt n+1} and type
default \integer, that holds the starting position of
each row of $\bmJ$, as well
as the total number of entries plus one, in the sparse row-wise storage
scheme (see Section~\ref{rowwise}). It need not be allocated when the
other schemes are used.

\end{description}

\ittf{H} is scalar variable of type {\tt SMT\_TYPE} that may hold the
weighted Hessian matrix $\bmH(\bmx,\bmy)$ (if it is available).
The following components are used here:

\begin{description}

\itt{H\%type} is an allocatable array of rank one and type default
\character, that
is used to indicate the storage scheme used. If the dense storage scheme
(see Section~\ref{dense}) is used,
the first five components of {\tt H\%type} must contain the
string {\tt DENSE}.
For the sparse co-ordinate scheme (see Section~\ref{coordinate}),
the first ten components of {\tt H\%type} must contain the
string {\tt COORDINATE},
for the sparse row-wise storage scheme (see Section~\ref{rowwise}),
the first fourteen components of {\tt H\%type} must contain the
string {\tt SPARSE\_BY\_ROWS},
and for the diagonal storage scheme (see Section~\ref{diagonal}),
the first eight components of {\tt H\%type} must contain the
string {\tt DIAGONAL}.

For convenience, the procedure {\tt SMT\_put}
may be used to allocate sufficient space and insert the required keyword
into {\tt H\%type}.
For example, if {\tt nlp} is of derived type {\tt \packagename\_problem\_type}
and involves a Hessian we wish to store using the co-ordinate scheme,
we may simply
%\vspace*{-2mm}
{\tt
\begin{verbatim}
        CALL SMT_put( nlp%H%type, 'COORDINATE' )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent
See the documentation for the \galahad\ package {\tt SMT}
for further details on the use of {\tt SMT\_put}.

\itt{H\%ne} is a scalar variable of type default \integer, that
holds the number of entries in the {\bf lower triangular} part of $\bmH$
in the sparse co-ordinate storage scheme (see Section~\ref{coordinate}).
It need not be set for any of the other three schemes.

\itt{H\%val} is a rank-one allocatable array of type default \realdp, that holds
the values of the entries of the {\bf lower triangular} part
of the Hessian matrix $\bmH$ in any of the
storage schemes discussed in Section~\ref{galmatrix}.

\itt{H\%row} is a rank-one allocatable array of type default \integer,
that holds the row indices of the {\bf lower triangular} part of $\bmH$
in the sparse co-ordinate storage
scheme (see Section~\ref{coordinate}).
It need not be allocated for any of the other three schemes.

\itt{H\%col} is a rank-one allocatable array variable of type default \integer,
that holds the column indices of the {\bf lower triangular} part of
$\bmH$ in either the sparse co-ordinate
(see Section~\ref{coordinate}), or the sparse row-wise
(see Section~\ref{rowwise}) storage scheme.
It need not be allocated when the dense or diagonal storage schemes are used.

\itt{H\%ptr} is a rank-one allocatable array of dimension {\tt n+1} and type
default \integer, that holds the starting position of
each row of the {\bf lower triangular} part of $\bmH$, as well
as the total number of entries plus one, in the sparse row-wise storage
scheme (see Section~\ref{rowwise}). It need not be allocated when the
other schemes are used.

\end{description}

\ittf{P} is scalar variable of type {\tt SMT\_TYPE}
that may hold the matrix of residual-Hessians-vector products
$\bmP(\bmx,\bmv) = (\bmH_1(\bmx) \bmv, \ldots, \bmH_m(\bmx) \bmv)$
for a supplied vector $\bmv$ (if it is needed).
The matrix $\bmP$ is held as a
sparse matrix by columns (see Section~\ref{columnwise}) or as a
dense matrix (see Section~\ref{dense}).
The following components are used here:

\begin{description}

\itt{P\%type} is an allocatable array of rank one and type default
\character, that
is used to indicate the storage scheme used. If the dense storage scheme
(see Section~\ref{dense}) is used,
the first sixteen components of {\tt P\%type} must contain the
string {\tt DENSE\_BY\_COLUMNS}, while
and for the sparse column-wise storage scheme (see Section~\ref{columnwise}),
the first seventeen components of {\tt P\%type} must contain the
string {\tt SPARSE\_BY\_COLUMNS}.

For convenience, the procedure {\tt SMT\_put}
may be used to allocate sufficient space and insert the required keyword
into {\tt P\%type}.
For example, if {\tt nlp} is of derived type {\tt \packagename\_problem\_type}
and involves a residual=Hessian-vector product matrix we wish to store
using the dense scheme,
we may simply
%\vspace*{-2mm}
{\tt
\begin{verbatim}
        CALL SMT_put( nlp%P%type, 'DENSE_BY_COLUMNS' )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent
See the documentation for the \galahad\ package {\tt SMT}
for further details on the use of {\tt SMT\_put}.

\itt{P\%val} is a rank-one allocatable array of type default \realdp,
that holds the values of the entries of the product matrix $\bmP$ stored
as consecutive columns.

\itt{P\%row} is a rank-one allocatable array of type default \integer,
that holds the row indices of $\bmP$ in the same order as used for
{\tt P\%val}.

\itt{P\%ptr} is a rank-one allocatable array of dimension {\tt m+1}
and type default \integer, that holds the starting position of
each column of $\bmP$, as well as the total number of entries plus one.

\end{description}

\itt{pname} is a scalar variable of type
default \character\ and length 10, which contains the
``name'' of the problem for printing. The default ``empty'' string is
provided.

\itt{VNAMES} is a rank-one allocatable array of dimension {\tt n} and type
default \character\ and length 10, whose $j$-th entry contains the
``name'' of the $j$-th variable for printing. This is only used
if ``debug''printing {\tt control\%print\_level > 4}) is requested,
and will be ignored if the array is not allocated.

\itt{CNAMES} is a rank-one allocatable array of dimension {\tt m} and type
default \character\ and length 10, whose $i$-th entry contains the
``name'' of the $i$-th residual for printing. This is only used
if ``debug''printing {\tt control\%print\_level > 4}) is requested,
and will be ignored if the array is not allocated.

\end{description}

%%%%%%%%%%% control type %%%%%%%%%%%

\subsubsection{The derived data type for holding control
 parameters}\label{typecontrol}
The derived data type
{\tt \packagename\_control\_type}
is used to hold controlling data. Default values may be obtained by calling
{\tt \packagename\_initialize}
(see Section~\ref{subinit}),
while components may also be changed by calling
{\tt \fullpackagename\_read\-\_spec}
(see Section~\ref{readspec}).
The derived type {\tt \packagename\_subproblem\_control\_type}
comprises all of the components of {\tt \packagename\_control\_type}
except for the last (i.e., {\tt subproblem\_control}).
The components of
{\tt \packagename\_control\_type}
are:

\begin{description}

\itt{error} is a scalar variable of type default \integer, that holds the
stream number for error messages. Printing of error messages in
{\tt \packagename\_solve} and {\tt \packagename\_terminate}
is suppressed if {\tt error} $\leq 0$.
The default is {\tt error = 6}.

\ittf{out} is a scalar variable of type default \integer, that holds the
stream number for informational messages. Printing of informational messages in
{\tt \packagename\_solve} is suppressed if {\tt out} $< 0$.
The default is {\tt out = 6}.

\itt{print\_level} is a scalar variable of type default \integer, that is used
to control the amount of informational output which is required. No
informational output will occur if {\tt print\_level} $\leq 0$. If
{\tt print\_level} $= 1$, a single line of output will be produced for each
iteration of the process. If {\tt print\_level} $\geq 2$, this output will be
increased to provide significant detail of each iteration.
The default is {\tt print\_level = 0}.

\itt{maxit} is a scalar variable of type default \integer, that holds the
maximum number of iterations which will be allowed in {\tt \packagename\_solve}.
The default is {\tt maxit = 1000}.

\itt{start\_print} is a scalar variable of type default \integer, that specifies
the first iteration for which printing will occur in {\tt \packagename\_solve}.
If {\tt start\_print} is negative, printing will occur from the outset.
The default is {\tt start\_print = -1}.

\itt{stop\_print} is a scalar variable of type default \integer, that specifies
the last iteration for which printing will occur in  {\tt \packagename\_solve}.
If {\tt stop\_print} is negative, printing will occur once it has been
started by {\tt start\_print}.
The default is {\tt stop\_print = -1}.

\itt{print\_gap} is a scalar variable of type default \integer.
Once printing has been started, output will occur once every
{\tt print\_gap} iterations. If {\tt print\_gap} is no larger than 1,
printing will be permitted on every iteration.
The default is {\tt print\_gap = 1}.

\itt{alive\_unit} is a scalar variable of type default \integer.
If {\tt alive\_unit} $>$ 0, a temporary file named {\tt alive\_file} (see below)
will be created on stream number {\tt alive\_unit} on initial entry to
\solver, and execution of \solver\ will continue so
long as this file continues to exist. Thus, a user may terminate execution
simply by removing the temporary file from this unit.
If {\tt alive\_unit} $\leq$ 0, no temporary file will be created, and
execution cannot be terminated in this way.
The default is {\tt alive\_unit} $=$ 40.

\itt{jacobian\_available} is a scalar variable of type default \integer,
that specifies the availability of the residual Jacobian.
Possible values are:

\begin{description}
\itt{$\geq$ 2} The Jacobian is available.
\itt{1} The Jacobian is not available explicitly but its effect
may be accessed by matrix-vector products, i.e., it is ``matrix-free''.
\itt{$\leq$ 0} The Jacobian is not available either explicitly or via
matrix-vector products.
\end{description}
The default is {\tt jacobian\_available = 1}.

\itt{hessian\_available} is a scalar variable of type default \integer,
that specifies the availability of the weighted-residual Hessian.
Possible values are:

\begin{description}
\itt{$\geq$ 2} The Hessian is available.
\itt{1} The Hessian is not available explicitly but its effect
may be accessed by matrix-vector products, i.e., it is ``matrix-free''.
\itt{$\leq$ 0} The Hessian is not available either explicitly or via
matrix-vector products.
\end{description}
The default is {\tt hessian\_available = 0}.

\itt{model} is a scalar variable of type default \integer, that specifies
which model to be used to approximate $f(\bmx)$ when computing the step.
Possible values are:

\begin{description}
\itt{$\leq$ 0} the model is chosen automatically on the basis of which option
        looks likely to be the most efficient at any given stage of the
        solution process. Different models may be used at different stages.
        {\bf Not yet implemented.}
\itt{1} a first-order model, not involving the Hessian, will be used.
\itt{2} a barely-second-order model, in which the Hessian is approximated
        by the matrix $\bmW$, will be used.
\itt{3} a Gauss-Newton model, in which the Hessian of $f(\bmx)$
        is approximated by $\bmJ^T(\bmx) \bmW \bmJ(\bmx)$, will be used.
\itt{4} a second-order Newton model, in which the exact Hessian of $f(\bmx)$,
$\bmJ^T(\bmx) \bmW \bmJ(\bmx) + \bmH(\bmx,\bmW \bmc(\bmx))$,
will be used.
\itt{5} an adaptive second-order model, in which there is a transition from
         Gauss-Newton to Newton models, will be used.
\itt{6} a tensor Gauss-Newton model will be used, and an approximate minimizer
of this model will be found by a Gauss-Newton method.
\itt{7} a tensor Gauss-Newton model will be used, and an approximate minimizer
of this model will be found by a Newton method.
\itt{$\geq$ 8} a tensor Gauss-Newton model will be used, and an approximate
 minimizer
of this model will be found by a method that adapts from Gauss-Newton to Newton.
\end{description}
See \S\ref{galterminology} for further details.
The default is {\tt model = 3}.

\itt{norm} is a scalar variable of type default \integer,
that specifies which norm is to be used to define the regularization.
In particular the norm $\|\cdot\|$ will be defined by a symmetric,
positive-definite matrix $\bmS(\bmx)$ that may depend on $\bmx$
so that for every vector $\bmv$, $\|\bmv\|^2 = \bmv^T \bmS(\bmx) \bmv$.
If {\tt \%subproblem\_direct = .FALSE.}, the same $\bmS(\bms)$ also defines the
preconditioner to be used to accelerate the generalized-Lanczos
inner model minimization.  Possible values are:

%{\bf To be updated}.

\begin{description}
\itt{-3} the user's own norm will be used.
\itt{-2} a norm based on a limited-memory BFGS formula will be used.
        {\bf Not yet implemented.}
\itt{-1} the Euclidean ($\ell_2$-) norm is used.
\itt{0} the type is chosen automatically on the basis of which option looks
        likely to be the most efficient at any given stage of the solution
        process. Different norms may be used at different stages.
        {\bf Not yet implemented.}
\itt{1} $\bmS$ is the diagonal of the matrix $\bmJ^T(\bmx_k) \bmW \bmJ(\bmx_k)$,
        or equivalently the squares of the two-norms of the columns of
        $\bmW^{\half} \bmJ(\bmx_k)$.
\itt{2} $\bmS$ is the diagonal of the Hessian matrix,
        $\bmJ^T(\bmx_k) \bmW \bmJ(\bmx_k) + \bmH(\bmx_k,\bmW\bmc(\bmx_k))$,
        suitably modified to ensure that it is significantly positive definite.
\itt{3} $\bmS$ is the Hessian matrix whose entries outside a band of
         given semi-bandwidth are replaced by zeros
        (see {\tt control\%PSLS\_control\%semi\_bandwidth} below).
\itt{4} $\bmS$ is the Hessian matrix whose entries outside a
        bandwidth-reduced reordered band of given semi-bandwidth are
        replaced by zeros
        (see {\tt control\%PSLS\_control\%semi\_bandwidth} below).
\itt{5} $\bmS$ is the (possibly perturbed) Hessian,
         using the Schnabel-Eskow modification
        method to ensure that the resultant matrix is positive definite.
\itt{6} $\bmS$ is the (possibly perturbed) Hessian,
        using the Gill-Murray-Ponc\'{e}leon-Saunders
        modification method to ensure that the resultant matrix is
        positive definite.
%        {\bf Not yet implemented.}
\itt{7} $\bmS$ will be that from the incomplete factorization of the Hessian
        using the Lin-Mor\'{e} method
        (see {\tt control\%PSLS\-\_control\%icfs\_vectors} below).
\itt{8} $\bmS$ will be that from the incomplete factorization of the Hessian
        using the method implemented by HSL\_MI28.
\end{description}
Any value outside this range, and those not yet implemented, will be
treated as the default, {\tt norm = 1}.

\itt{non\_monotone} is a scalar variable of type default \integer, that
specifies the history-length for non-monotone descent strategy.
Any non-positive value results in standard monotone descent, for which
merit function improvement occurs at each iteration. There are often
definite advantages in using a non-monotone strategy with a modest history,
since the occasional local increase in the merit function may
enable the algorithm to move across (gentle) ``ripples'' in
the merit function surface.
However, we do not usually recommend large values of {\tt non\_monotone}.
The default is {\tt non\_monotone = 1}.

\itt{weight\_update\_strategy} is a scalar variable of type default \integer,
that specifies the way in which the regularization weight will be adjusted
at the end of each iteration. Possible values are:
\begin{description}
\itt{1} the traditional acceptance and rejection strategy as described below.
\itt{2} the traditional strategy, except that a zero weight will be tried
first after a very successful step.
\itt{3} a more sophisticated strategy that mimics that proposed
for trust-region methods by Gould, Porcelli and Toint.
\end{description}
Any other value will be considered as if {\tt weight\_update\_strategy = 1},
and this is the default.

\itt{stop\_c\_absolute} is a scalar variable of type default \realdp,
that is used to specify the maximum permitted two-norm of the
residual, $\|\bmc(\bmx)\|_{\bmW}$,
(see Section~\ref{galmethod}) at the estimate of the solution sought.
Any negative value will be recorded as zero.
The default is {\tt stop\_c\_absolute =} $10^{-6}$.

\itt{stop\_c\_relative} is a scalar variable of type default \realdp,
that is used to specify the largest relative reduction in the two-norm of the
residual, $\|\bmc(\bmx)\|_{\bmW}$, that will be permitted
(see Section~\ref{galmethod}) at the estimate of the solution sought
compared to that at the initial point.
Any negative value will be recorded as zero.
The default is {\tt stop\_c\_relative =} $0.0$.

\itt{stop\_g\_absolute} is a scalar variable of type default \realdp,
that is used to specify the maximum permitted two-norm of the gradient,
 $\|\bmJ^T(\bmx) \bmW \bmc(\bmx)\|_2/\|\bmc(\bmx)\|_{\bmW}$,
of the residual  $\|\bmc(\bmx)\|_{\bmW}$,
(see Section~\ref{galmethod}) at the estimate of the solution sought.
Any negative value will be recorded as zero.
The default is {\tt stop\_g\_absolute =} $10^{-6}$.

\itt{stop\_g\_relative} is a scalar variable of type default \realdp,
that is used to specify the largest relative reduction in the norm of the
gradient of the residual that will be permitted
(see Section~\ref{galmethod}) at the estimate of the solution sought
compared to that at the initial point.
Any negative value will be recorded as zero.
The default is {\tt stop\_g\_relative =} $0.0$.
%The default is {\tt stop\_g\_relative =} $10^{-6}$.

\itt{stop\_s} is a scalar variable of type default \realdp,
that is used to specify the minimum acceptable correction step $\bms$
relative to the current estimate of the solution $\bmx$
The algorithm will be deemed to have converged if $|s_i| \leq$
{\tt stop\_s} $\ast \max( 1, |x_i|)$ for all $i = 1, \ldots, n$.
The default is {\tt stop\_s =} $u$,
where $u$ is {\tt EPSILON(1.0)} ({\tt EPSILON(1.0D0)} in
{\tt \fullpackagename\_double}).

\itt{regularization\_power} is a scalar variable of type default \realdp,
that holds the required initial value of the regularization weight. If
{\tt regularization\_power} $\leq 2.0$, the weight will be chosen automatically
by \solver.
The default is {\tt regularization\_power = -1.0}.

\itt{initial\_weight} is a scalar variable of type default \realdp, that holds
the required initial value of the regularization weight. If
{\tt initial\_weight} $\leq 0$, the weight will be chosen automatically
by \solver.
%The default is {\tt initial\_weight = - 1.0}.
The default is {\tt initial\_weight = 100.0}.

\itt{minimum\_weight} is a scalar variable of type default \realdp, that holds
the largest permitted value of the regularization weight as the algorithm
proceeds.
%If  {\tt minimum\_weight} $\leq 0$, the weight will be chosen automatically
%by \solver\
The default is {\tt minimum\_weight =} $10^{-8}$.

\itt{initial\_inner\_weight} is a scalar variable of type default \realdp,
that holds the required initial value of the regularization weight if
the model minimization itself requires an inner iteration
(i.e., if {\tt \%model} $\geq$ {\tt 6}).
If {\tt initial\_inner\_weight} $\leq 0$, the weight will be chosen
automatically by \solver.
The default is {\tt initial\_inner\_weight = 0.0}.

\ittt{eta\_successful}, {\tt eta\_very\_successful}
and {\tt eta\_too\_successful}
are scalar variables of type default
\realdp, that control the acceptance and rejection of the trial step
and the updates to the regularization weight.
At every iteration, the ratio of the actual reduction in the merit function
following the trial step to that predicted by the model is computed.
The step is accepted whenever this ratio exceeds {\tt eta\_successful};
otherwise the regularization weight will be reduced.
If, in addition, the ratio exceeds {\tt eta\_very\_successful} but not
{\tt eta\_too\_successful}, the regularization weight may be increased.
The defaults are
{\tt eta\_successful =} $10^{-8}$,
{\tt eta\_very\_successful = 0.9} and
{\tt eta\_too\_successful = 2.0}.

\ittt{weight\_increase},
{\tt weight\_decrease},
{\tt weight\_increase\_max}
and
{\tt weight\_decrease\_min}
are scalar variables of type default \realdp, that
control the maximum amounts by which the regularization weight can
contract or expand during an iteration. The weight will be decreased by
powers of {\tt weight\_decrease}, but not in total
more than  {\tt weight\_decrease\_min}, until it is smaller than the norm of
the current step.
It can be increased by at most a factor {\tt weight\_increase}, but not
in total less than {\tt weight\_increase\_max}.
The defaults are
{\tt weight\_increase = 10.0},
{\tt weight\_decrease = 0.1},
{\tt weight\_incr\-ease\_max = 100.0} and
{\tt weight\_decrease\_min = 0.1}.

\itt{switch\_to\_newton} is a scalar variable of type default \realdp,
that is used to specify the value of the two-norm of the gradient,
 $\|\bmJ^T(\bmx) \bmW \bmc(\bmx)\|_2/\|\bmc(\bmx)\|_{\bmW}$,
of the residual  $\|\bmc(\bmx)\|_{\bmW}$, required before a switch is made
from the Gauss-Newton model to the Newton one when {\tt \%model = 5}).
The default is
{\tt switch\_to\_newton = 0.1}.

\itt{cpu\_time\_limit} is a scalar variable of type default \realdp,
that is used to specify the maximum permitted CPU time. Any negative
value indicates no limit will be imposed. The default is
{\tt cpu\_time\_limit = - 1.0}.

\itt{clock\_time\_limit} is a scalar variable of type default \realdp,
that is used to specify the maximum permitted elapsed system clock time.
Any negative value indicates no limit will be imposed. The default is
{\tt clock\_time\_limit = - 1.0}.

\itt{subproblem\_direct}
is a scalar variable of type default \logical,
that should be set \true\ if a direct (factorization) method is
desired when solving for the step, and \false\ if an iterative
method suffices.
The default is {\tt subproblem\_direct = .FALSE.}.

\itt{renormalize\_weight}
is a scalar variable of type default \logical,
that should be set \true\ if the regularization weight is to be
re-normaized to account for the shape of the regularization norm
every iteration, and \false\ if no re-normalization is required.
The default is {\tt renormalize\_weight = .FALSE.}.

\itt{magic\_step}
is a scalar variable of type default \logical,
that should be set \true\ if additional ``magic'' steps are to be
used in order to improve the objective as the iteration proceeds,
and \false\ if no ``magic'' steps are used.
The default is {\tt magic\_step = .FALSE.}.

\itt{print\_obj}
is a scalar variable of type default \logical,
that should be set \true\ if output values relate to $f(\bmx)$,
and \false\ if they relate to $\|\bmc(\bmx)\|_{\bmW}$.
The default is {\tt print\_obj = .FALSE.}.

\itt{space\_critical} is a scalar variable of type default \logical,
that must be set \true\ if space is critical when allocating arrays
and  \false\ otherwise. The package may run faster if
{\tt space\_critical} is \false\ but at the possible expense of a larger
storage requirement. The default is {\tt space\_critical = .FALSE.}.

\itt{deallocate\_error\_fatal} is a scalar variable of type default \logical,
that must be set \true\ if the user wishes to terminate execution if
a deallocation  fails, and \false\ if an attempt to continue
will be made. The default is {\tt deallocate\_error\_fatal = .FALSE.}.

\itt{alive\_file} is a scalar variable of type default \character\ and length
30, that gives the name of the temporary file whose removal from stream number
{\tt alive\_unit} terminates execution of \solver.
The default is {\tt alive\_unit} $=$ {\tt ALIVE.d}.

\itt{prefix} is a scalar variable of type default \character\
and length 30, that may be used to provide a user-selected
character string to preface every line of printed output.
Specifically, each line of output will be prefaced by the string
{\tt prefix(2:LEN(TRIM( prefix ))-1)},
thus ignoreing the first and last non-null components of the
supplied string. If the user does not want to preface lines by such
a string, they may use the default {\tt prefix = ""}.

\itt{RQS\_control} is a scalar variable of type
{\tt RQS\_control\_type}
whose components are used to control the
direct regularization step calculation (if any),
performed by the package
{\tt \libraryname\_RQS}.
See the specification sheet for the package
{\tt \libraryname\_RQS}
for details, and appropriate default values
(but note that values of
{\tt RQS\_control\%init\-ial\_multiplier}
and
{\tt RQS\_control\%new\_h}
may be changed by \solver).

\itt{GLRT\_control} is a scalar variable of type
{\tt GLRT\_control\_type}
whose components are used to control the
iterative regularization step calculation (if any),
performed by the package
{\tt \libraryname\_GLRT}.
See the specification sheet for the package
{\tt \libraryname\_GLRT}
for details, and appropriate default values
(but note that value of
{\tt GLRT\_control\%unitm}
may be changed by \solver).

\itt{PSLS\_control} is a scalar variable of type
{\tt PSLS\_control\_type}
whose components are used to control the preconditioning
aspects of the calculation, as performed by the package
{\tt \libraryname\_PSLS}.
See the specification sheet for the package
{\tt \libraryname\_PSLS}
for details, and appropriate default values (but note that values for
{\tt PSLS\_control\%prec\-onditioner},
{\tt PSLS\_control\%semi\_bandwidth} and
{\tt PSLS\_control\%icfs\_vectors}
may be overridden by \solver).

\itt{BSC\_control}  is a scalar variable of type
{\tt BSC\_control\_type}
whose components are used to control the assembly of
the Schur complement, if required, as performed by the package
{\tt \libraryname\_BSC}.
See the specification sheet for the package
{\tt \libraryname\_BSC}
for details, and appropriate default values.

\itt{ROOTS\_control}  is a scalar variable of type
{\tt ROOTS\_control\_type}
whose components are used to control polynomial root-finding methods needed,
as performed by the package {\tt \libraryname\_ROOTS}.
See the specification sheet for the package
{\tt \libraryname\_ROOTS}
for details, and appropriate default values.

\itt{subproblem\_control}  is a scalar variable of type
{\tt \packagename\_subproblem\_control\_type}
whose components are used to control the solution of the
least-squares subproblem that defines the step.
The only differences are that the default values
{\tt subproblem\_control\%maxit = 50} and
{\tt subproblem\_control\%print\_obj = .TRUE.}.
\end{description}

%%%%%%%%%%% time type %%%%%%%%%%%

\subsubsection{The derived data type for holding timing
 information}\label{typetime}
The derived data type
{\tt \packagename\_time\_type}
is used to hold elapsed CPU and system clock times for the various parts
of the calculation. The components of
{\tt \packagename\_time\_type}
are:
\begin{description}
\itt{total} is a scalar variable of type default \real, that gives
 the CPU total time spent in the package.

\itt{preprocess} is a scalar variable of type default \realdp, that gives
 the CPU time spent reordering the problem to standard form prior to solution.

\itt{analyse} is a scalar variable of type default \realdp, that gives
 the CPU time spent analysing required matrices prior to factorization.

\itt{factorize} is a scalar variable of type default \realdp, that gives
 the CPU time spent factorizing the required matrices.

\itt{solve} is a scalar variable of type default \realdp, that gives
 the CPU time spent using the factors to solve relevant linear equations.

\itt{clock\_total} is a scalar variable of type default \real, that gives
 the total elapsed system clock time spent in the package.

\itt{clock\_preprocess} is a scalar variable of type default \realdp, that gives
 the elapsed system clock time spent reordering the problem to standard form
prior to solution.

\itt{clock\_analyse} is a scalar variable of type default \realdp, that gives
 the  elapsed system clock time spent analysing required matrices prior to
factorization.

\itt{clock\_factorize} is a scalar variable of type default \realdp, that gives
 the  elapsed system clock time spent factorizing the required matrices.

\itt{clock\_solve} is a scalar variable of type default \realdp, that gives
 the  elapsed system clock time spent using the factors to solve relevant
linear equations.

\end{description}

%%%%%%%%%%% inform type %%%%%%%%%%%

\subsubsection{The derived data type for holding informational
 parameters}\label{typeinform}
The derived data type
{\tt \packagename\_inform\_type}
is used to hold parameters that give information about the progress and needs
of the algorithm.
The derived type {\tt \packagename\_subproblem\_inform\_type}
comprises all of the components of {\tt \packagename\_inform\_type}
except for the last (i.e., {\tt subproblem\_inform}).
The components of
{\tt \packagename\_inform\_type}
are:

\begin{description}
\itt{status} is a scalar variable of type default \integer, that gives the
exit status of the algorithm.
%See Sections~\ref{galerrors} and \ref{galinfo}
See Sections~\ref{reverse} and \ref{galerrors}
for details.

\itt{alloc\_status} is a scalar variable of type default \integer, that gives
the status of the last attempted array allocation or deallocation.
This will be 0 if {\tt status = 0}.

\itt{bad\_alloc} is a scalar variable of type default \character\
and length 80, that  gives the name of the last internal array
for which there were allocation or deallocation errors.
This will be the null string if {\tt status = 0}.

\ittf{iter} is a scalar variable of type default \integer, that holds the
number of iterations performed.

\itt{cg\_iter} is a scalar variable of type default \integer, that gives the
total number of conjugate-gradient iterations required.

\itt{c\_eval} is a scalar variable of type default \integer, that gives the
total number of residual function evaluations performed.

\itt{j\_eval} is a scalar variable of type default \integer, that gives the
total number of residual Jacobian evaluations performed.

\itt{h\_eval} is a scalar variable of type default \integer, that gives the
total number of weighted Hessian evaluations performed.

\itt{factorization\_max} is a scalar variable of type default \integer, that
gives the largest number of factorizations required during a subproblem
solution.

\itt{factorization\_status} is a scalar variable of type default \integer, that
gives the return status from the matrix factorization.

\itt{max\_entries\_factors} is a scalar variable of type long \integer, that
gives the maximum number of entries in any of the matrix factorizations
performed during the calculation.

\itt{factorization\_integer} is a scalar variable of type default
\integer, that gives the amount of integer storage used for the matrix
factorization.

\itt{factorization\_real} is a scalar variable of type default \integer,
that gives the amount of real storage used for the matrix factorization.

\itt{factorization\_average} is a scalar variable of type default \realdp, that
gives the average number of factorizations per subproblem solved.

\ittf{obj} is a scalar variable of type default \realdp, that holds the
value of the objective function $f(\bmx)$  at the best estimate
of the solution found.

\itt{norm\_c} is a scalar variable of type default \realdp, that holds the
value of the two-norm of the residual function, $\|\bmc(\bmx)\|_{\bmW}$.
at the best estimate of the solution found.

\itt{norm\_g} is a scalar variable of type default \realdp, that holds the
value of the norm of the gradient of the two-norm of the residual function,
$\|\bmJ^T(\bmx) \bmW \bmc(\bmx)\|_2/\|\bmc(\bmx)\|_{\bmW}$, at the best estimate
of the solution found.

\itt{weight} is a scalar variable of type default \realdp, that holds the
final value of the regularization weight used.

\ittf{time} is a scalar variable of type {\tt \packagename\_time\_type}
whose components are used to hold elapsed elapsed CPU and system clock
times for the various parts of the calculation (see Section~\ref{typetime}).

\itt{RQS\_inform} is a scalar variable of type
{\tt RQS\_inform\_type}
whose components give information about the progress and needs
of the direct solution stages of the algorithm performed by the package
{\tt \libraryname\_RQS}.
See the specification sheet for the package
{\tt \libraryname\_RQS}
for details.

\itt{GLRT\_inform} is a scalar variable of type
{\tt GLRT\_inform\_type}
whose components give information about the progress and needs
of the iterative solution stages of the algorithm performed by the package
{\tt \libraryname\_GLRT}.
See the specification sheet for the package
{\tt \libraryname\_GLRT}
for details.

\itt{PSLS\_inform} is a scalar variable of type
{\tt PSLS\_inform\_type}
whose components give information about the progress and needs
of the preconditioning stages of the algorithm performed by the package
{\tt \libraryname\_PSLS}.
See the specification sheet for the package
{\tt \libraryname\_PSLS} for details.

\itt{BSC\_inform} is a scalar variable of type
{\tt BSC\_inform\_type}
whose components give information about the progress and needs
of the construction of required Schur complements
as performed by the package
{\tt \libraryname\_BSC}.
See the specification sheet for the package
{\tt \libraryname\_BSC} for details.

\itt{ROOTS\_inform} is a scalar variable of type
{\tt ROOTS\_inform\_type}
whose components give information about the progress and needs
of the required polynomial root-find calculations
as performed by the package
{\tt \libraryname\_ROOTS}.
See the specification sheet for the package
{\tt \libraryname\_ROOTS} for details.

\itt{subproblem\_inform}  is a scalar variable of type
{\tt \packagename\_subproblem\_inform\_type}
whose components are used to give information about the solution of the
least-squares subproblem that defines the step.
\end{description}

%%%%%%%%%%% data type %%%%%%%%%%%

\subsubsection{The derived data type for holding problem data}\label{typedata}
The derived data type
{\tt \packagename\_data\_type}
is used to hold all the data for a particular problem,
or sequences of problems with the same structure, between calls of
{\tt \packagename} procedures.
This data should be preserved, untouched (except as directed on
return from \solver\ with positive values of {\tt inform\%status}, see
Section~\ref{reverse}),
from the initial call to
{\tt \packagename\_initialize}
to the final call to
{\tt \packagename\_terminate}.

%%%%%%%%%%% userdata type %%%%%%%%%%%

\input{userdata_type}

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\galarguments
There are three procedures for user calls
(see Section~\ref{galfeatures} for further features):

\begin{enumerate}
\item The subroutine
      {\tt \packagename\_initialize}
      is used to set default values, and initialize private data,
      before solving one or more problems with the
      same sparsity and bound structure.
\item The subroutine
      {\tt \packagename\_solve}
      is called to solve the problem.
\item The subroutine
      {\tt \packagename\_terminate}
      is provided to allow the user to automatically deallocate array
       components of the private data, allocated by
       {\tt \packagename\_solve},
       at the end of the solution process.
       It is important to do this if the data object is re-used for another
       problem {\bf with a different structure}
       since {\tt \packagename\_initialize} cannot test for this situation,
       and any existing associated targets will subsequently become unreachable.
\end{enumerate}
We use square brackets {\tt [ ]} to indicate \optional\ arguments.

%%%%%% initialization subroutine %%%%%%

\subsubsection{The initialization subroutine}\label{subinit}
 Default values are provided as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_initialize( data, control, inform )}

\vspace*{-3mm}
\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see Section~\ref{typedata}). It is used to hold data about the problem being
solved.

\itt{control} is a scalar \intentout\ argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}).
On exit, {\tt control} contains default values for the components as
described in Section~\ref{typecontrol}, while
{\tt control\%subproblem\_control} contains default values that are required for the
model minimization if {\tt control\%model} $\geq$ {\tt 6}).
These values should only be changed after calling
{\tt \packagename\_initialize}.

\itt{inform} is a scalar \intentout\ argument of type
{\tt \packagename\_inform\_type}
(see Section~\ref{typeinform}). A successful call to
{\tt \packagename\_initialize}
is indicated when the  component {\tt inform\%status} has the value 0.
For other return values of {\tt inform\%status}, see
Section~\ref{galerrors}.
The components of {\tt inform} correspond to the main algorithm, while
those in {\tt inform\%subproblem\_inform} refer to the model minimization
if {\tt control\%model} $\geq$ {\tt 6}).

\end{description}

%%%%%%%%% main solution subroutine %%%%%%

\subsubsection{The minimization subroutine}
The minimization algorithm is called as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_solve( nlp, control, inform, data, userdata[, W,
   eval\_C, eval\_J, eval\_H, \hspace{3mm}                  \&}
\vspace*{-5mm}

\hspace{37mm}
{\tt eval\_JPROD,  eval\_HPROD, eval\_HPRODS, eval\_SCALE ] )}

\vspace*{-2mm}
\begin{description}
\ittf{nlp} is a scalar \intentinout\ argument of type
{\tt NLPT\_problem\_type}
(see Section~\ref{typeprob}).
It is used to hold data about the problem being solved.
For a new problem, the user must allocate all the array components,
and set values for {\tt nlp\%n}
and the required non-real components of
{\tt nlp\%J}, {\tt nlp\%H} and {\tt nlp\%P} depending on what level
of derivatives are required by the model requested. Specifically,
depending on control parameters in {\tt control} below,
\vspace*{-2mm}
\begin{description}
\item $\mbox{}$ if {\tt control\%jacobian\_available = 2} and
{\tt control\%model $\geq$ 3}, all appropriate components of
 {\tt nlp\%J} should be allocated and, with the exception of {\tt nlp\%J\%val},
filled with data,
\item $\mbox{}$ if {\tt control\%hessian\_available = 2} and
{\tt control\%model $\geq$ 4}, all appropriate components of
 {\tt nlp\%H} should be allocated and, with the exception of {\tt nlp\%H\%val},
filled with data, and
\item $\mbox{}$ if {\tt control\%model $\geq$ 6}, all appropriate
 components of {\tt nlp\%P} should be allocated and, with the exception
 of {\tt nlp\%P\%val}, filled with data.
\end{description}
Users are free to choose whichever
of the matrix formats described in Section~\ref{galmatrix}
is appropriate for $\bmJ$ and $\bmH$ for their application,
but $\bmP$ must be input by columns.

\noindent
The component {\tt nlp\%X} must be set to an initial estimate, $\bmx^{0}$,
of the minimization variables. A good choice will increase the speed
of the package, but the underlying method is designed to converge (at least
to a local solution) from an arbitrary initial guess.

\noindent
On exit, the component {\tt nlp\%X} will contain the best estimates of the
minimization variables $\bmx$.

\noindent
\restrictions {\tt nlp\%n} $> 0$, {\tt nlp\%m} $> 0$,
{\tt nlp\%J\%type} $\in \{
  \mbox{\tt 'DENSE'}, \mbox{\tt 'COORDINATE'}, \mbox{\tt 'SPARSE\_BY\_ROWS'}
 \}$ and
{\tt nlp\%H\%type} $\in \{
  \mbox{\tt 'DENSE'}, \mbox{\tt 'COORDINATE'}, \mbox{\tt 'SPARSE\_BY\_ROWS'},
  \mbox{\tt 'DIAGONAL'} \}$.

\itt{control} is a scalar \intentin\ argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}). Default values may be assigned by calling
{\tt \packagename\_initialize} prior to the first call to
{\tt \packagename\_solve}. The argument
{\tt control\%PSLS\_control\-\%preconditioner}
will be overridden by {\tt control\%norm}.

\noindent
The function and derivative requirements are governed by the value of
{\tt control\%model}. The precise needs are specified in Table~\ref{tab-er}.

\begin{table}[h]
\begin{tabular}{|c||c|c|c|c|c|c||c|c|c|c|c|}
\hline
& & \multicolumn{5}{c||}{matrix available ({\tt eval\_/status})}
& \multicolumn{5}{c|}{matrix free ({\tt eval\_/status})} \\
\hline
{\tt \%model}  & {\tt C/2}
 & {\tt J/3} & {\tt H/4} & {\tt JPROD/5} & {\tt HPROD/6} & {\tt HPRODS/7}
 & {\tt J/3} & {\tt H/4} & {\tt JPROD/5} & {\tt HPROD/6} & {\tt HPRODS/7} \\
\hline
1 \& 2 & $\surd$ & & & $\surd$ & & &  & & $\surd$ & & \\
%\hline
3      & $\surd$ & $\surd$ & & & & &  & & $\surd$ & & \\
\hline
4 \& 5 & $\surd$ & $\surd$ & $\surd$ & & & & & & $\surd$ & $\surd$ & \\
%\hline
6 \& 7 & $\surd$ & $\surd$ & $\surd$ & & & $\surd$ &
                 & & $\surd$ & $\surd$ & $\surd$ \\
\hline
\end{tabular}
\caption{\label{tab-er} Evaluation requirements for models supported. Key:
A $\surd$ in box in column
{\tt A/n} means that the external subroutine {\tt eval\_A} will be used
if provided, but otherwise that reverse communication will be invoked with
{\tt inform\%status = n}. No provision for a derivative need be made
for empty boxes, and thus no {\tt eval\_A} need be present for these cases,
nor will returns with {\tt inform\%status = n} occur.}
\end{table}

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see Section~\ref{typeinform}).
On initial entry, the  component {\tt inform\%status} must be set to the
value 1. Other entries need note be set.
A successful call to
{\tt \packagename\_solve}
is indicated when the  component {\tt inform\%status} has the value 0.
For other return values of {\tt inform\%status}, see
Sections~\ref{reverse} and \ref{galerrors}.

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see Section~\ref{typedata}). It is used to hold data about the problem being
solved. With the possible exceptions of the components
{\tt data\%eval\_status} and {\tt data\%U} (see Section~\ref{reverse}),
it must not have been altered {\bf by the user} since the last call to
{\tt \packagename\_initialize}.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the \optional\ subroutines
{\tt eval\_C}, {\tt eval\_J}, {\tt eval\_H}, {\tt eval\_JPROD},
{\tt eval\_HPROD}, {\tt eval\_HPRODS} and {\tt eval\_SCALE}
(see Section~\ref{typeuserdata}).

\itt{W} is an \optional\ rank-one array of type default \realdp\
whose components specifies the diagonal weighting matrix $\bmW$ that
defines the objective function $f(\bmx)$. If {\tt W} is present, it
must be of length at least $n$, and {\tt W}$(i)$ should contain $w_i > 0$
$i = 1, \ldots, n$. If $\bmW$ is absent, the weights $w_i$ will all be
taken to be $1.0$.

\itt{eval\_C} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of the
residual function $\bmc(\bmx)$ at a given vector $\bmx$.
See Section~\ref{rfv} for details.
%but first check Table~\ref{tab-er} to see if the subroutine is not needed.
If {\tt eval\_C} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_C} is absent, \solver\ will use reverse communication to
obtain objective function values (see Section~\ref{reverse}).

\itt{eval\_J} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of the
Jacobian of the residual function $\bmJ(\bmx)$ at a given vector $\bmx$.
See Section~\ref{jfv} for details,
but first check Table~\ref{tab-er} to see if the subroutine is not needed.
If {\tt eval\_J} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_J} is absent, \solver\ will use reverse communication to
obtain gradient values (see Section~\ref{reverse}).

\itt{eval\_H} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of the
weighted residual Hessian $\bmH(\bmx,\bmy)$ at a given vector pair
$(\bmx,\bmy)$. See Section~\ref{hfv} for details,
but first check Table~\ref{tab-er} to see if the subroutine is not needed.
If {\tt eval\_H} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_H} is absent, \solver\ will use reverse communication to
obtain Hessian function values (see Section~\ref{reverse}).

\itt{eval\_JPROD} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of sum
$\bmu + \bmJ(\bmx)\bmv$ or $\bmu + \bmJ^T(\bmx)\bmv$ involving the
product between the Jacobian of the
residual function $\bmJ(\bmx)$ or its transpose with a given vector $\bmv$.
See Section~\ref{jvfv} for details,
but first check Table~\ref{tab-er} to see if the subroutine is not needed.
If {\tt eval\_JPROD} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_JPROD} is absent, \solver\ will use reverse communication to
obtain Jacobian-vector products (see Section~\ref{reverse}).

\itt{eval\_HPROD} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of sum
$\bmu + \bmH(\bmx,\bmy) \bmv$ involving the product of the weighted residual
Hessian $\bmH(\bmx,\bmy)$ at a given vector pair $(\bmx,\bmy)$
with a given vector $\bmv$. See Section~\ref{hvfv} for details,
but first check Table~\ref{tab-er} to see if the subroutine is not needed.
If {\tt eval\_HPROD} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_HPROD} is absent, \solver\ will use reverse communication to
obtain Hessian-vector products (see Section~\ref{reverse}).

\itt{eval\_HPRODS} is an \optional\
user-supplied subroutine whose purpose is to evaluate the values of the
residual-Hessians-vector product matrix, $\bmP(\bmx,\bmv)$
at a given vector pair $(\bmx,\bmv)$.
See Section~\ref{hpfv} for details,
but first check Table~\ref{tab-er} to see if the subroutine is not needed.
If {\tt eval\_HPRODS} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_HPRODS} is absent, \solver\ will use reverse communication to
obtain Hessian-vector products (see Section~\ref{reverse}).

\itt{eval\_SCALE} is an \optional\
user-supplied subroutine whose purpose is to evaluate the value of the
product $\bmS(\bmx)\bmv$ of the user's preconditioner with a given vector
$\bmv$. See Section~\ref{pv} for details.
If {\tt eval\_SCALE} is present,
it must be declared {\tt EXTERNAL} in the calling program.
If {\tt eval\_SCALE} is absent, \solver\ will use reverse communication to
obtain products with the preconditioner (see Section~\ref{reverse}).

\end{description}

%%%%%%% termination subroutine %%%%%%

\subsubsection{The  termination subroutine}
All previously allocated arrays are deallocated as follows:
\vspace*{1mm}

\hspace{8mm}
{\tt CALL \packagename\_terminate( data, control, inform )}

\vspace*{-1mm}
\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
exactly as for
{\tt \packagename\_solve},
which must not have been altered {\bf by the user} since the last call to
{\tt \packagename\_initialize}.
On exit, array components will have been deallocated.

\itt{control} is a scalar \intentin\ argument of type
{\tt \packagename\_control\_type}
exactly as for
{\tt \packagename\_solve}.

\itt{inform} is a scalar \intentout\ argument of type
{\tt \packagename\_inform\_type}
exactly as for
{\tt \packagename\_solve}.
The component {\tt inform\%status} will be set on exit, and a
successful call to
{\tt \packagename\_terminate}
is indicated when this  component has the value 0.
For other return values of {\tt inform\%status}, see Section~\ref{galerrors}.

\end{description}

%%%%%%%%%%%%%%%%%%%% Function and derivative values %%%%%%%%%%%%%%%%%%%%%

\subsection{Function and derivative values\label{fdv}}

%%%%%%%%%%%%%%%%%%%%%% Residual function value %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{The residual value via internal evaluation\label{rfv}}

If the argument {\tt eval\_C} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
value of the residual functions $\bmc(\bmx)$.
The routine must be specified as

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
      SUBROUTINE eval_C( status, X, userdata, c )
\end{verbatim}
}
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type default \integer,
that should be set to 0 if the routine has been able to evaluate
the residual functions
and to a non-zero value if the evaluation has not been possible.

\ittf{X} is a rank-one \intentin\ array argument of type default \realdp\
whose components contain the vector $\bmx$.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the subroutines
{\tt eval\_C}, {\tt eval\_J}, {\tt eval\_H}, {\tt eval\_JPROD},
{\tt eval\_HPROD}, {\tt eval\_HPRODS} and {\tt eval\_SCALE}
(see Section~\ref{typeuserdata}).

\ittf{C} is a rank-one \intentout\ array argument of type default \realdp\
that should be set to the value of the residuals $\bmc(\bmx)$
evaluated at the vector $\bmx$ input in {\tt X}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Jacobian values %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Jacobian values via internal evaluation\label{jfv}}

If the argument {\tt eval\_J} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
values of the residual Jacobian $\bmJ(\bmx)$.
The routine must be specified as

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
       SUBROUTINE eval_J( status, X, userdata, J_val )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type default \integer,
that should be set to 0 if the routine has been able to evaluate
the residual Jacobian,
and to a non-zero value if the evaluation has not been possible.

\ittf{X} is a rank-one \intentin\ array argument of type default \realdp\
whose components contain the vector $\bmx$.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the subroutines
{\tt eval\_C}, {\tt eval\_J}, {\tt eval\_H}, {\tt eval\_JPROD},
{\tt eval\_HPROD}, {\tt eval\_HPRODS} and {\tt eval\_SCALE}
(see Section~\ref{typeuserdata}).

\itt{J\_val} is a scalar \intentout\ argument of type default \realdp,
whose components should be set to the values
of the Jacobian $\bmJ(\bmx)$
evaluated at the vector $\bmx$ input in {\tt X}.
The values should
be input in the same order as that in which the array indices were
given in {\tt nlp\%J}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Hessian values %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{weighted residual Hessian values via internal evaluation\label{hfv}}

If the argument {\tt eval\_H} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
values of the weighted Hessian $\bmH(\bmx,\bmy)$.
The routine must be specified as

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
       SUBROUTINE eval_H( status, X, Y, userdata, H_val )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type default \integer,
that should be set to 0 if the routine has been able to evaluate
the weighted Hessian
and to a non-zero value if the evaluation has not been possible.

\ittf{X} is a rank-one \intentin\ array argument of type default \realdp\
whose components contain the vector $\bmx$.

\ittf{Y} is a rank-one \intentin\ array argument of type default \realdp\
whose components contain the vector $\bmy$.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the subroutines
{\tt eval\_C}, {\tt eval\_J}, {\tt eval\_H}, {\tt eval\_JPROD},
{\tt eval\_HPROD}, {\tt eval\_HPRODS} and {\tt eval\_SCALE}
(see Section~\ref{typeuserdata}).

\itt{H\_val} is a scalar \intentout\ argument of type default \realdp,
whose components should be set to the values
of the weighted Hessian $\bmH(\bmx,\bmy)$
evaluated at the vector $\bmx$ input in {\tt X}
and $\bmy$ input in {\tt Y} The values should
be input in the same order as that in which the array indices were
given in {\tt nlp\%H}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Jacobian-vector products %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Jacobian-vector products via internal evaluation\label{jvfv}}

If the argument {\tt eval\_JPROD} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
sum $\bmu + \bmJ(\bmx) \bmv$ or $\bmu + \bmJ^T(\bmx)\bmv$ involving the
product of the residual Jacobian $\bmJ(\bmx)$ or its transpose $\bmJ^T(\bmx)$
and a given vector $\bmv$.
The routine must be specified as

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
       SUBROUTINE eval_JPROD( status, X, userdata, transpose, U, V, got_j )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type default \integer,
that should be set to 0 if the routine has been able to evaluate the
sum $\bmu + \bmJ(\bmx) \bmv$ or $\bmu + \bmJ^T(\bmx)\bmv$
and to a non-zero value if the evaluation has not been possible.

\ittf{X} is a \ rank-one \intentin\ array argument of type
default \realdp\ whose components contain the vector $\bmx$.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the subroutines
{\tt eval\_C}, {\tt eval\_J}, {\tt eval\_H}, {\tt eval\_JPROD},
{\tt eval\_HPROD}, {\tt eval\_HPRODS} and {\tt eval\_SCALE}
(see Section~\ref{typeuserdata}).

\itt{transpose} is a scalar \intentin\ array argument of type
default that will be set \true\ if the product involves the transpose
of the Jacobian $\bmJ^T(\bmx)$ and \false\ if the product involves
the Jacobian $\bmJ(\bmx)$ itself.

\ittf{U} is a rank-one \intentinout\ array argument of type default \realdp\
whose components on input contain the vector $\bmu$ and on output the
sum $\bmu + \bmJ(\bmx) \bmv$ when {\tt \%transpose} is \false\ or
$\bmu + \bmJ^T(\bmx) \bmv$ when {\tt \%transpose} is \true.

\ittf{V} is a rank-one \intentin\ array argument of type default \realdp\
whose components contain the vector $\bmv$.

\itt{got\_j} is an \optional\ scalar \intentin\ argument of type default
\logical. If the Jacobian has already been evaluated at the current $\bmx$
{\tt got\_j} will be \present\ and set \true; if this is the first time
the Jacobian is to be accessed at $\bmx$, either {\tt got\_j} will be absent
or \present\ and set \false. This gives the user the opportunity
to reuse ``start-up'' computations required for the first instance of
$\bmx$ to speed up subsequent products.

\end{description}


%%%%%%%%%%%%%%%%%%%%%% Hessian-vector products %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Hessian-vector products via internal evaluation\label{hvfv}}

If the argument {\tt eval\_HPROD} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
sum $\bmu + \bmH(\bmx,\bmy) \bmv$ involving the
product of the weighted residual Hessian $\bmH(\bmx,\bmy)$
with a given vector $\bmv$.
The routine must be specified as

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
       SUBROUTINE eval_HPROD( status, X, Y, userdata, U, V, got_h )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type default \integer,
that should be set to 0 if the routine has been able to evaluate the
sum $\bmu + \bmH(\bmx,\bmy)\bmv$
and to a non-zero value if the evaluation has not been possible.

\ittf{X} is a \ rank-one \intentin\ array argument of type
default \realdp\ whose components contain the vector $\bmx$.

\ittf{Y} is a \ rank-one \intentin\ array argument of type
default \realdp\ whose components contain the vector $\bmy$.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the subroutines
{\tt eval\_C}, {\tt eval\_J}, {\tt eval\_H}, {\tt eval\_JPROD},
{\tt eval\_HPROD}, {\tt eval\_HPRODS} and {\tt eval\_SCALE}
(see Section~\ref{typeuserdata}).

\ittf{U} is a rank-one \intentinout\ array argument of type default \realdp\
whose components on input contain the vector $\bmu$ and on output the
sum $\bmu + \bmH(\bmx,\bmy) \bmv$.

\ittf{V} is a rank-one \intentin\ array argument of type default \realdp\
whose components contain the vector $\bmv$.

\itt{got\_h} is an \optional\ scalar \intentin\ argument of type default
\logical. If the Hessian has already been evaluated at the current pair
$(\bmx,\bmy)$
{\tt got\_h} will be \present\ and set \true; if this is the first time
the Hessian is to be accessed at $(\bmx,\bmy)$, either {\tt got\_h} will
be absent or \present\ and set \false. This gives the user the opportunity
to reuse ``start-up'' computations required for the first instance of
$(\bmx,\bmy)$ to speed up subsequent products.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Hessians-vector product matrix %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Hessians-vector product matrix via internal evaluation\label{hpfv}}

If the argument {\tt eval\_HPRODS} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
values of the residual-Hessians-vector product matrix, $\bmP(\bmx,\bmv)$
at a given vector pair $(\bmx,\bmv)$.
The routine must be specified as
\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
       SUBROUTINE eval_HPRODS( status, X, V, userdata, P_val, got_h )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type default \integer,
that should be set to 0 if the routine has been able to evaluate the
matrix $\bmP(\bmx,\bmv)$,
and to a non-zero value if the evaluation has not been possible.

\ittf{X} is a \ rank-one \intentin\ array argument of type
default \realdp\ whose components contain the vector $\bmx$.

\ittf{V} is a \ rank-one \intentin\ array argument of type
default \realdp\ whose components contain the vector $\bmv$.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the subroutines
{\tt eval\_C}, {\tt eval\_J}, {\tt eval\_H}, {\tt eval\_JPROD},
{\tt eval\_HPROD}, {\tt eval\_HPRODS} and {\tt eval\_SCALE}
(see Section~\ref{typeuserdata}).

\itt{P\%val} is a scalar \intentout\ argument of type default \realdp,
whose components should be set to the values of the Hessian
residual-Hessians-vector product matrix, $\bmP(\bmx,\bmv)$,
stored by columns and evaluated at the vector $\bmx$ input in {\tt X}
and $\bmv$ input in {\tt V}.
The values should be input in the same order as that in which the array
indices were given in {\tt nlp\%P}.

\itt{got\_h} is an \optional\ scalar \intentin\ argument of type default
\logical. If the Hessians have already been evaluated at the current
$\bmx$, {\tt got\_h} will be \present\ and set \true; if this is the first time
the Hessian is to be accessed at $\bmx$, either {\tt got\_h} will
be absent or \present\ and set \false. This gives the user the opportunity
to reuse ``start-up'' computations required for the first instance of
$\bmx$ to speed up subsequent products.

\end{description}


%%%%%%%%%%%%%%%%%%%%%% preconditioner-vector products %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Preconditioner-vector products via internal evaluation\label{pv}}

If the argument {\tt eval\_SCALE} is present when calling \solver, the
user is expected to provide a subroutine of that name to evaluate the
product $\bmu = \bmS(\bmx) \bmv$ involving the user's preconditioner
$\bmS(\bmx)$ with a given vector $\bmv$. The symmetric matrix $\bmS(\bmx)$
should ideally be chosen so that the eigenvalues of
$\bmS(\bmx) (\nabla_{xx} t_k(\bmzero))^{-1}$ are clustered, where $t_k(\bms)$
is the current model of $f(\bmx+\bms)$.
The routine must be specified as

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
       SUBROUTINE eval_SCALE( status, X, userdata, U, V )
\end{verbatim} }
\def\baselinestretch{1.0}
\noindent whose arguments are as follows:

\begin{description}
\itt{status} is a scalar \intentout\ argument of type default \integer,
that should be set to 0 if the routine has been able to evaluate the
product $\bmS(\bmx) \bmv$
and to a non-zero value if the evaluation has not been possible.

\ittf{X} is a rank-one \intentin\ array argument of type default \realdp\
whose components contain the vector $\bmx$.

\itt{userdata} is a scalar \intentinout\ argument of type
{\tt GALAHAD\_userdata\_type} whose components may be used
to communicate user-supplied data to and from the
subroutines {\tt eval\_C}, {\tt eval\_J},
{\tt eval\_H} and {\tt eval\_SCALE}
(see Section~\ref{typeuserdata}).

\ittf{U} is a rank-one \intentout\ array argument of type default \realdp\
whose components on output should contain the product $\bmu = \bmS(\bmx) \bmv$.

\ittf{V} is a rank-one \intentin\ array argument of type default \realdp\
whose components contain the vector $\bmv$.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Reverse communication %%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\label{reverse}Reverse Communication Information}

A positive value of {\tt inform\%status} on exit from
{\tt \packagename\_solve}
indicates that
\solver\ is seeking further information---this will happen
if the user has chosen not to evaluate function or
derivative values internally (see Section~\ref{fdv}).
The user should compute the required information and re-enter \solver\
with {\tt inform\%status} and all other arguments (except those specifically
mentioned below) unchanged.

Possible values of {\tt inform\%status} and the information required are
\begin{description}
\ittf{2.} The user should compute the vector of residual functions
     $\bmc(\bmx)$ at the point $\bmx$ indicated in {\tt nlp\%X}.
     The required value should be set in {\tt nlp\%C}, and
     {\tt data\%eval\_status} should be set to 0. If the user is
     unable to evaluate $\bmc(\bmx)$---for instance, if one or more of the
     residual functions is undefined at $\bmx$---the user need not set
     {\tt nlp\%C}, but should then set {\tt data\%eval\_status}
     to a non-zero value.

\ittf{3.} The user should compute the Jacobian matrix $\bmJ(\bmx)$ of the
     residuals $\bmc(\bmx)$ at the point $\bmx$ indicated in {\tt nlp\%X}.
     The $l$-th component of the Jacobian stored according to the
     scheme input in the remainder of {\tt nlp\%J} (see Section~\ref{typeprob})
     should be set in {\tt nlp\%J\%val(l)}, for $l = 1, \ldots,$
     {\tt  nlp\%J\%ne} and {\tt data\%eval\_status} should be set to 0.
     If the user is unable to  evaluate a component of $\bmJ(\bmx)$---for
     instance, if a component of the Jacobian is
     undefined at $\bmx$---the user need not set {\tt nlp\%J\%val}, but
     should then set {\tt data\%eval\_status} to a non-zero value.

\ittf{4.} The user should compute the weighted Hessian $\bmH(\bmx,\bmy)$
     at the point $\bmx$ given in {\tt nlp\%X} and vector $\bmy$ given in
     {\tt data\%Y}. The $l$-th component of the Hessian stored
     according to the scheme input in the remainder of {\tt nlp\%H}
     (see Section~\ref{typeprob}) should be set in {\tt nlp\%H\%val(l)},
     for $l = 1, \ldots,$ {\tt  nlp\%H\%ne} and
     {\tt data\%eval\_status} should be set to 0. If the user is
     unable to evaluate a component of $\bmH(\bmx,\bmy)$---for instance,
     if a component of the Hessian is
     undefined at $\bmx$---the user need not set {\tt nlp\%H\%val}, but
     should then set {\tt data\%eval\_status} to a non-zero value.

\ittf{5.} The user should compute ones of the sums $\bmu + \bmJ(\bmx) \bmv$
     or $\bmu + \bmJ^T(\bmx) \bmv$ involving the product of the residual
     Jacobian $\bmJ(\bmx)$ or its transpose at the point $\bmx$, given
     in {\tt nlp\%X}, with a given vector $\bmv$.
     The vectors $\bmu$ and $\bmv$ are given in {\tt data\%U}
     and {\tt data\%V} respectively.
     If {\tt data\%transpose} is \false, the resulting
     vector $\bmu + \bmJ(\bmx) \bmv$ should overwrite {\tt data\%U}
     and  {\tt data\%eval\_status} should be set to 0.
     Conversely if {\tt data\%transpose} is \true, the resulting
     vector $\bmu + \bmJ^T(\bmx) \bmv$ should overwrite {\tt data\%U}
     and {\tt data\%eval\_status} set to 0. If the user is
     unable to evaluate the sum---for instance, if a component of the Jacobian
     is undefined at $\bmx$---the user need not set {\tt data\%U}, but
     should then set {\tt data\%eval\_status} to a non-zero value.

\ittf{6.} The user should compute the sum $\bmu + \bmH(\bmx,\bmy) \bmv$,
     involving the product of the weighted residual Hessian $\bmH(\bmx,\bmy)$
     at the point $\bmx$ given in {\tt nlp\%X} and vector $\bmy$ given in
     {\tt data\%Y} with a given vector $\bmv$.
     The vectors $\bmu$ and $\bmv$ are given in {\tt data\%U}
     and {\tt data\%V} respectively, the resulting
     vector $\bmu + \bmH(\bmx,\bmy) \bmv$ should overwrite {\tt data\%U}
     and  {\tt data\%eval\_status} should be set to 0. If the user is
     unable to evaluate the sum---for instance, if a component of the Hessian
     is undefined at $\bmx$---the user need not set {\tt nlp\%H\%val}, but
     should then set {\tt data\%eval\_status} to a non-zero value.

\ittf{7.} The user should compute the residual-Hessians-vector-product
     matrix $\bmP(\bmx,\bmv)$, whose $i$-th column is the product
     $\bmH_i(\bmx)\bmv$ between the Hessian $\bmH_i(\bmx)$ of the $i$-th
     residual function $c_i(\bmx)$ at the point $\bmx$ given in {\tt nlp\%X}
     and a given vector $\bmv$ specified in {\tt data\%V}.
     The nonzeros for column $i$ must be stored in {\tt nlp\%P\%val(l)}, for
     {\tt l = nlp\%P\%ptr(i), ...,  nlp\%P\%ptr(i+1)} for each column
     {\tt i = 1,...,m}, in the same order as the row indices were assigned
     on input to {\tt nlp\%P\%row(l)},
     and  {\tt data\%eval\_status} should be set to 0.
     If the user is unable to evaluate the matrix---for instance
     if a component of one of the Hessians is
     undefined at $\bmx$---the user need not set {\tt nlp\%P\%val}, but
     should then set {\tt data\%eval\_status} to a non-zero value.

\ittf{8.} The user should compute the product $\bmu = \bmS(\bmx)\bmv$
     of their preconditioner $\bmS(\bmx)$ at the point $\bmx$
     indicated in {\tt nlp\%X} with the vector $\bmv$.
     The vectors $\bmv$ is given in {\tt data\%V}, the
     resulting vector $\bmu = \bmS(\bmx)\bmv$ should be set in {\tt data\%U}
     and {\tt data\%eval\_status}
     should be set to 0. If the user is unable to evaluate the product---for
     instance, if a component of the preconditioner is undefined at
     $\bmx$---the user need not set {\tt data\%U}, but should then set
     {\tt data\%eval\_status} to a non-zero value.
\end{description}


%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\galerrors
A negative value of {\tt inform\%status} on exit from
{\tt \packagename\_solve}
or
{\tt \packagename\_terminate}
indicates that an error has occurred. No further calls should be made
until the error has been corrected. Possible values are:

\begin{description}

\itt{\galerrallocate.} An allocation error occurred.
A message indicating the offending
array is written on unit {\tt control\%error}, and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc}, respectively.

\itt{\galerrdeallocate.} A deallocation error occurred.
A message indicating the offending
array is written on unit {\tt control\%error} and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc}, respectively.

\itt{\galerrrestrictions.}
  The restriction {\tt nlp\%n} $> 0$ and {\tt nlp\%m} $> 0$,
  or requirements that
  {\tt nlp\%J\%type}  contains its relevant string
  \mbox{\tt 'DENSE'}, \mbox{\tt 'COORDINATE'} or, \mbox{\tt 'SPARSE\_BY\_ROWS'}
  and that {\tt nlp\%H\_type} contains its
  {\tt 'DENSE'}, {\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_ROWS'}
  has been violated.

%\itt{-3.} At least one of the arrays
% {\tt p\%A\_val}, {\tt p\%A\_row}, {\tt p\%A\_col},
% {\tt p\%H\_val}, {\tt p\%H\_row} or {\tt p\%H\_col},
% is not large enough to hold the original, or reordered, matrices $\bmA$
% or $\bmH$.

%\itt{\galerrunbounded.}  The objective function appears to be unbounded
% from below on the feasible set.

\itt{\galerranalysis.} The analysis phase of the factorization failed;
 the return status from the factorization
    package is given in the component {\tt inform\%fac\-t\-or\_status}.

\itt{\galerrfactorization.} The factorization failed;
 the return status from the factorization
    package is given in the component {\tt inform\%fac\-t\-or\_status}.

\itt{\galerrsolve.} The solution of a set of linear equations
 using factors from the factorization package failed;
 the return status from the factorization
    package is given in the component {\tt inform\%fac\-t\-or\_status}.

\itt{\galerrpreconditioner.} The preconditioner $\bmS(\bmx)$ appears not to
  be positive definite.

\itt{\galerrillconditioned.} The problem is so ill-conditioned that
  further progress is impossible.

\itt{\galerrtinystep.} The step is too small to make further impact.

\itt{\galerrmaxiterations.} Too many iterations have been performed.
  This may happen if
    {\tt control\%maxit} is too small, but may also be symptomatic of
    a badly scaled problem.

\itt{\galerrcpulimit.} The elapsed CPU or system clock time limit has been
    reached. This may happen if either {\tt control\%cpu\_time\_limit} or
    {\tt control\%clock\_time\_limit} is too small, but may also be symptomatic
    of a badly scaled problem.

\itt{\galerralive.} The user has forced termination of \solver\
     by removing the file named {\tt control\%a\-live\_file} from unit
     unit {\tt control\%alive\_unit}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Further features %%%%%%%%%%%%%%%%%%%%%%%%

\galfeatures
\noindent In this section, we describe an alternative means of setting
control parameters, that is components of the variable {\tt control} of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}),
by reading an appropriate data specification file using the
subroutine {\tt \packagename\_read\_specfile}. This facility
is useful as it allows a user to change  {\tt \packagename} control parameters
without editing and recompiling programs that call {\tt \packagename}.

A specification file, or specfile, is a data file containing a number of
"specification commands". Each command occurs on a separate line,
and comprises a "keyword",
which is a string (in a close-to-natural language) used to identify a
control parameter, and
an (optional) "value", which defines the value to be assigned to the given
control parameter. All keywords and values are case insensitive,
keywords may be preceded by one or more blanks but
values must not contain blanks, and
each value must be separated from its keyword by at least one blank.
Values must not contain more than 30 characters, and
each line of the specfile is limited to 80 characters,
including the blanks separating keyword and value.

The portion of the specification file used by
{\tt \packagename\_read\_specfile}
must start
with a "{\tt BEGIN \packagename}" command and end with an
"{\tt END}" command.  The syntax of the specfile is thus defined as follows:
\begin{verbatim}
  ( .. lines ignored by NLS_read_specfile .. )
    BEGIN NLS
       keyword    value
       .......    .....
       keyword    value
    END
  ( .. lines ignored by NLS_read_specfile .. )
\end{verbatim}
where keyword and value are two strings separated by (at least) one blank.
The ``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiter command lines
may contain additional (trailing) strings so long as such strings are
separated by one or more blanks, so that lines such as
\begin{verbatim}
    BEGIN NLS SPECIFICATION
\end{verbatim}
and
\begin{verbatim}
    END NLS SPECIFICATION
\end{verbatim}
are acceptable. Furthermore,
between the
``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiters,
specification commands may occur in any order.  Blank lines and
lines whose first non-blank character is {\tt !} or {\tt *} are ignored.
The content
of a line after a {\tt !} or {\tt *} character is also
ignored (as is the {\tt !} or {\tt *}
character itself). This provides an easy manner to "comment out" some
specification commands, or to comment specific values
of certain control parameters.

The value of a control parameters may be of three different types, namely
integer, logical or real.
Integer and real values may be expressed in any relevant Fortran integer and
floating-point formats (respectively). Permitted values for logical
parameters are "{\tt ON}", "{\tt TRUE}", "{\tt .TRUE.}", "{\tt T}",
"{\tt YES}", "{\tt Y}", or "{\tt OFF}", "{\tt NO}",
"{\tt N}", "{\tt FALSE}", "{\tt .FALSE.}" and "{\tt F}".
Empty values are also allowed for
logical control parameters, and are interpreted as "{\tt TRUE}".

The specification file must be open for
input when {\tt \packagename\_read\_specfile}
is called, and the associated device number
passed to the routine in device (see below).
Note that the corresponding
file is {\tt REWIND}ed, which makes it possible to combine the specifications
for more than one program/routine.  For the same reason, the file is not
closed by {\tt \packagename\_read\_specfile}.

\subsubsection{To read control parameters from a specification file}
\label{readspec}

Control parameters may be read from a file as follows:
\hskip0.5in
\def\baselinestretch{0.8} {\tt
\begin{verbatim}
     CALL NLS_read_specfile( control, device )
\end{verbatim}
}
\def\baselinestretch{1.0}

\begin{description}
\itt{control} is a scalar \intentinout\ argument of type
{\tt \packagename\_control\_type}
(see Section~\ref{typecontrol}).
Default values should have already been set, perhaps by calling
{\tt \packagename\_initialize}.
On exit, individual components of {\tt control} and
{\tt control\%subproblem\_control}
may have been changed
according to the commands found in the specfile. Specfile commands and
the component (see Section~\ref{typecontrol}) of {\tt control}
and {\tt control\%subproblem\_control}
that each affects are given in Table~\ref{specfile}.

\bctable{|l|l|l|}
\hline
  command & component of {\tt control} & value type \\
\hline
  {\tt error-printout-device} & {\tt \%error} & integer \\
  {\tt printout-device} & {\tt \%out} & integer \\
  {\tt print-level} & {\tt \%print\_level} & integer \\
  {\tt start-print} & {\tt \%start\_print} & integer \\
  {\tt stop-print} & {\tt \%stop\_print} & integer \\
  {\tt iterations-between-printing} & {\tt \%print\_gap} & integer \\
  {\tt maximum-number-of-iterations} & {\tt \%maxit} & integer \\
  {\tt alive-device} & {\tt \%alive\_unit} & integer \\
  {\tt jacobian-available} & {\tt \%jacobian\_available} & integer \\
  {\tt hessian-available} & {\tt \%hessian\_available} & integer \\
  {\tt history-length-for-non-monotone-descent} & {\tt \%non\_monotone} & integer \\
  {\tt model-used} & {\tt \%model} & integer \\
  {\tt norm-used} & {\tt \%norm} & integer \\
  {\tt weight-update-strategy} & {\tt weight\_update\_strategy} & integer \\
  {\tt absolute-residual-accuracy-required} & {\tt \%stop\_c\_absolute} & real \\
  {\tt relative-residual-reduction-required} & {\tt \%stop\_c\_relative} & real \\
  {\tt absolute-gradient-accuracy-required} & {\tt \%stop\_g\_absolute} & real \\
  {\tt relative-gradient-reduction-required} & {\tt \%stop\_g\_relative} & real \\
  {\tt minimum-relative-step-allowed} & {\tt \%stop\_s} & real \\
  {\tt initial-regularization-weight} & {\tt \%initial\_weight} & real \\
  {\tt minimum-regularization-weight} & {\tt \%minimum\_weight} & real \\
  {\tt successful-iteration-tolerance} & {\tt \%eta\_successful} & real \\
  {\tt very-successful-iteration-tolerance} & {\tt \%eta\_very\_successful} & real \\
  {\tt too-successful-iteration-tolerance} & {\tt \%eta\_too\_successful} & real \\
  {\tt regularization-weight-minimum-decrease-factor} & {\tt \%weight\_decrease\_min} & real \\
  {\tt regularization-weight-decrease-factor} & {\tt \%weight\_decrease} & real \\
  {\tt regularization-weight-increase-factor} & {\tt \%weight\_increase} & real \\
  {\tt regularization-weight-maximum-increase-factor} & {\tt \%weight\_increase\_max} & real \\
  {\tt minimum-objective-before-unbounded} & {\tt \%obj\_unbounded} & real \\
  {\tt maximum-cpu-time-limit} & {\tt \%cpu\_time\_limit} & real \\
  {\tt maximum-clock-time-limit} & {\tt \%clock\_time\_limit} & real \\
  {\tt hessian-available}  & {\tt \%hessian\_available} & logical \\
  {\tt sub-problem-direct}  & {\tt \%subproblem\_direct} & logical \\
  {\tt retrospective-trust-region}  & {\tt \%retrospective\_trust\_region} & logical \\
  {\tt renormalize-weight}  & {\tt \%renormalize\_weight} & logical \\
  {\tt space-critical}   & {\tt \%space\_critical} & logical \\
  {\tt deallocate-error-fatal}   & {\tt \%deallocate\_error\_fatal} & logical \\
  {\tt alive-filename} & {\tt \%alive\_file} & character \\
\hline

\ectable{\label{specfile}Specfile commands and associated
components of {\tt control}.}

\itt{device} is a scalar \intentin argument of type default \integer,
that must be set to the unit number on which the specfile
has been opened. If {\tt device} is not open, {\tt control} will
not be altered and execution will continue, but an error message
will be printed on unit {\tt control\%error}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Information printed %%%%%%%%%%%%%%%%%%%%%%%%

\galinfo
If {\tt control\%print\_level} is positive, information about the progress
of the algorithm will be printed on unit {\tt control\-\%out}.
If {\tt control\%print\_level} $= 1$, a single line of output will be
produced for each iteration of the process.
This will include the values of the objective function and the norm of its
gradient, the ratio of actual to predicted decrease following the step, the
value of the regularization weight and the time taken so far. In addition, if
a direct solution of the subproblem has been attempted, the Lagrange multiplier
from the secular equation and the number of factorizations
used will be recorded, while if an iterative solution has been used, the
numbers of phase 1 and 2 iterations will be given.

If {\tt control\%print\_level} $\geq 2$ this
output will be increased to provide significant detail of each iteration.
This extra output includes residuals of the linear systems solved, and,
for larger values of {\tt control\%print\_level}, values of the variables
and gradients. Further details concerning the attempted solution of the models
may be obtained by increasing
{\tt control\%RQS\_control\%print\_level}
and
{\tt control\%GLRT\_control\%print\_level},
while details about factorizations are available
by increasing
{\tt control\%PSLS\_control\%print\_level}.
See the specification sheets for the packages
{\tt \libraryname\_GLRT},
{\tt \libraryname\_PSLS} and
{\tt \libraryname\_RQS}
for details.

%%%%%%%%%%%%%%%%%%%%%% GENERAL INFORMATION %%%%%%%%%%%%%%%%%%%%%%%%

\galgeneral

\galcommon None.
\galworkspace Provided automatically by the module.
\galroutines None.
\galmodules {\tt \packagename\_solve} calls the \galahad\ packages
{\tt GALAHAD\_CLOCK},
{\tt GALAHAD\_SY\-M\-BOLS}, \sloppy
{\tt GALAHAD\_NLPT},
{\tt GALAHAD\_SPECFILE},
{\tt GALAHAD\_PSLS},
{\tt GALAHAD\_GLRT},
{\tt GALAHAD\_RQS},
{\tt GALAHAD\_BSC},
{\tt GALAHAD\_SPACE},
{\tt GALAHAD\_ROOTS},
{\tt GALAHAD\_MOP},
{\tt GALAHAD\_NORMS},
{\tt GALAHAD\_STRING}
and
{\tt GALAHAD\_BLAS\_interface}.
\galio Output is under control of the arguments
 {\tt control\%error}, {\tt control\%out} and
{\tt control\%print\_level}.
\galrestrictions {\tt nlp\%n} $> 0$, {\tt nlp\%m} $> 0$,
{\tt nlp\%J\%type} $\in \{
  \mbox{\tt 'DENSE'}, \mbox{\tt 'COORDINATE'}, \mbox{\tt 'SPARSE\_BY\_ROWS'}
 \}$ and
{\tt nlp\%H\%type} $\in \{${\tt 'DENSE'},
 {\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_ROWS'}, {\tt 'DIAGONAL'} $\}$.
\galportability ISO Fortran~95 + TR 15581 or Fortran~2003.
The package is thread-safe.

%%%%%%%%%%%%%%%%%%%%%% METHOD %%%%%%%%%%%%%%%%%%%%%%%%

\galmethod
An adaptive regularization method is used.
In this, an improvement to a current
estimate of the required minimizer, $\bmx_k$ is sought by computing a
step $\bms_k$. The step is chosen to approximately minimize a model $t_k(\bms)$
of $f_{\rho,r}(\bmx_k+\bms)$
that includes a weighted regularization term
$\sfrac{\sigma_k}{p} \|s\|_{\bmS_k}^p$
for some specified positive weight $\sigma_k$. The quality of the
resulting step $\bms_k$ is assessed by computing the "ratio"
%$(f_{\rho,p}(\bmx_k) - f_{\rho,p}(\bmx_k+\bms_k))/(t_k(\bmzero)-t_k(\bms_k))$.
$(f(\bmx_k) - f(\bmx_k + \bms_k))/(t_k(\bmzero) - t_k(\bms_k))$.
The step is deemed to have succeeded if the ratio exceeds a given $\eta_s > 0$,
and in this case $\bmx_{k+1} = \bmx_k + \bms_k$. Otherwise
$\bmx_{k+1} = \bmx_k$, and the weight is increased by powers of a given
increase factor up to a given limit. If the ratio is larger than
$\eta_v \geq \eta_d$, the weight will be decreased by powers of a given
decrease factor again up to a given limit. The method will terminate
as soon as $f(\bmx_k)$ or
$\|\nabla_x f(\bmx_k)\|$ is smaller than a specified value.

A choice of linear, quadratic or quartic models $t_k(\bms)$ is available
(see \S\ref{galterminology}), and normally a two-norm regularization will
be used, but this may change if preconditioning is employed.

If linear or quadratic models are employed, an appropriate,
approximate model minimizer is found using either a direct approach
involving factorization of a shift of the model Hessian $\bmB_k$ or an
iterative (conjugate-gradient/Lanczos) approach based on approximations
to the required solution from a so-called Krlov subspace. The direct
approach is based on the knowledge that the required solution
satisfies the linear system of equations $(\bmB_k + \lambda_k \bmI) \bms_k
= - \nabla_x f(\bmx_k)$ involving a scalar Lagrange multiplier $\lambda_k$.
This multiplier is found by uni-variate root finding, using a safeguarded
Newton-like process, by {\tt \libraryname\_RQS}. The iterative approach
uses {\tt \libraryname\_GLRT}, and is best accelerated by preconditioning
with good approximations to the Hessian of the model using
{\tt \libraryname\_PSLS}. The
iterative approach has the advantage that only Hessian matrix-vector products
are required, and thus the Hessian $\bmB_k$ is not required explicitly.
However when factorizations of the Hessian are possible, the direct approach
is often more efficient.

When a quartic model is used, the model is itself of least-squares form,
and the package calls itself recursively to approximately minimize its
model. The quartic model often gives a better approximation, but at the
cost of more involved derivative requirements.

\vspace*{1mm}

\galreferences
\vspace*{1mm}

\noindent
The generic cubic regularization method is described in detail in
\vspace*{1mm}

\noindent
C. Cartis,  N. I. M. Gould and Ph. L. Toint,
``Adaptive cubic regularisation methods for unconstrained optimization.
Part I: motivation, convergence and numerical results''
{\em Mathematical Programming} {\bf 127(2)} (2011) 245--295,
\vspace*{1mm}

\noindent
and uses ``tricks'' as suggested in
\vspace*{1mm}

\noindent
N. I. M. Gould, M. Porcelli and Ph. L. Toint,
``Updating the regularization parameter in the adaptive cubic regularization
algorithm''.
{\em Computational Optimization and Applications}
{\bf 53(1)} (2012) 1--22.

\noindent
The specific methods employed here are discussed in
\vspace*{1mm}

\noindent
N. I. M. Gould, J. A. Scott and T. Rees,
``Convergence and evaluation-complexity analysis of a regularized
tensor-Newton method for solving nonlinear least-squares problems''.
{\em Computational Optimization and Applications}
{\bf 73(1)} (2019) 1--35.

%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\galexamples
Suppose we wish to minimize the parametric objective function
$\half  ( x_1^2 x_3^{} + p )^2 + \half (x_2^2 + x_3^{} )^2$
when the parameter $p$ takes the value $4$. Starting from the
initial guess $\bmx = (1,1,1)$, and noting that
\disp{\bmc(\bmx) = \vect{ \!\!x_1^2 x_3^{} + p \!\!\\ \!\! x_2^2 + x_3\!\! }, \;
\bmJ(\bmx) = \mat{ccc}{  \!\! 2 x_1 x_3 & 0 & x_1^2  \!\! \\  \!\! 0 & \!\!\!\!\! 2 x_2 \!\!\!\!\! & 1  \!\! }, \;
\bmH(\bmx,\bmy) =
 \mat{ccc}{ 2x_3 y_1 & 0 & 2x_1 y_1 \\ 0 & \!\!\!\!\!\!2 y_2 \!\!\! & 0 \\
 2 x_1 y_1 & 0 & 0 } \& \;
\bmP(\bmx,\bmv) =
 \mat{cc}{ 2x_3 v_1 + 2 x_1 v_3& 0 \\ 0 & \!\!\!\!\!\!\! 2 v_2 \\ 2 x_1 v_1 & 0 },
}
we may use the following code:

{\tt \small
\VerbatimInput{\packageexample}
}
\noindent
Notice how the parameter $p$ is passed to the function evaluation
routines via the {\tt real} component of the derived type {\tt userdata}.
The code produces the following output:
{\tt \small
\VerbatimInput{\packageresults}
}
\noindent
If the Hessian is unavailable, but products of the form
$\bmu + \bmH \bmv$ are, the same problem may be solved as follows:

{\tt \small
\VerbatimInput{\packageexampleb}
}
\noindent
Notice that storage for the Hessian is now not needed.
This produces the %same output.
following output:
{\tt \small
\VerbatimInput{\packageresultsb}
}
\noindent

If the user prefers to provide function and gradient information and
Hessian-vector products
without calls to specified routines, the following code is appropriate:
%Note the product with the user-provided preconditioner
%\disp{
%\bmS(\bmx) = \mat{ccc}{\half & 0 & 0 \\ 0 & \half & 0 \\ 0 & 0 & \quarter }
%}
%which is a suitable approximation to the inverse of the Hessian:

{\tt \small
\VerbatimInput{\packageexamplec}
}
\noindent
This produces the same output as in the previous case.
%This produces the following output:
%{\tt \small
%\VerbatimInput{\packageresultsc}
%}
\noindent


\end{document}

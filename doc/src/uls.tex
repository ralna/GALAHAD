\documentclass{galahad}

% set the package name

\newcommand{\package}{uls}
\newcommand{\packagename}{ULS}
\newcommand{\fullpackagename}{\libraryname\_\-\packagename}

\begin{document}

\galheader

%%%%%%%%%%%%%%%%%%%%%% SUMMARY %%%%%%%%%%%%%%%%%%%%%%%%

\galsummary

This package
{\bf solves dense or sparse unsymmetric systems of linear equations}
using variants of Gaussian elimination.
Given a sparse symmetric matrix $\bmA = \{ a_{ij} \}_{m \times n}$, and an
$m$-vector $\bmb$ or a matrix $\bmB = \{ b_{ij} \}_{m \times r}$, this
subroutine solves the system $\bmA \bmx = \bmb$
or the block system $\bmA \bmX = \bmB$. If
$\bmb$ is an $n$-vector or  $\bmB = \{ b_{ij} \}_{n \times r}$,
the subroutine may solve instead the system $\bmA^T \bmx = \bmb$
or block system  $\bmA^T \bmX = \bmB$ . Both square ($m=n$) and
rectangular ($m\neq n$)  matrices are handled; one of an infinite
class of  solutions for consistent systems will be returned
whenever $\bmA$ is not of full rank.

\noindent The method provides a common interface to a variety of well-known
solvers from HSL.
% and elsewhere.
Currently supported solvers include
{\tt MA28/GLS} and {\tt HSL\_MA48},
%{\tt HSL\_MA77} and {\tt HSL\_MA87}
%from {HSL} and {\tt PARDISO} from the Pardiso Project.
Note that
{\bf the solvers themselves do not form part of this package and must be obtained
separately.} Dummy instances are provided for solvers that are unavailable.
Also note that additional flexibility may be obtained by calling the
solvers directly rather that via this package.

%%%%%%%%%%%%%%%%%%%%%% attributes %%%%%%%%%%%%%%%%%%%%%%%%

\galattributes
\galversions{\tt  \fullpackagename\_single, \fullpackagename\_double}.
\galcalls {\tt GALAHAD\_SYMBOLS},
{\tt GALAHAD\_\-SORT},
{\tt GALAHAD\_SPACE},
{\tt GALAHAD\_SPECFILE},
{\tt GALAHAD\_STRING},
{\tt GALAHAD\_SMT},
{\tt GALAHAD\_GLS}
%{\tt HSL\_ZD11}
and optionally
{\tt HSL\_\-MA48}.
%{\tt HSL\_MA77},
%{\tt HSL\_MA87},
%{\tt HSL\_MC64},
%{\tt HSL\_MC68},
%{\tt MC77},
%and {\tt METIS}.
\galdate August 2009.
\galorigin N. I. M. Gould, Rutherford Appleton Laboratory.
\gallanguage Fortran~95 + TR 15581 or Fortran~2003.
\galparallelism Some solvers may use OpenMP and its runtime library.

%%%%%%%%%%%%%%%%%%%%%% HOW TO USE %%%%%%%%%%%%%%%%%%%%%%%%

\galhowto

\subsection{Calling sequences}

Access to the package requires a {\tt USE} statement such as

\medskip\noindent{\em Single precision version}

\hskip0.5in {\tt USE \fullpackagename\_single}

\medskip\noindent{\em Double precision version}

\hskip0.5in {\tt USE  \fullpackagename\_double}

\medskip

If it is required to use both modules at the same time, the derived types
{\tt SMT\_type},
{\tt \packagename\_control\_type},
{\tt \packagename\_data\-\_type}, and
{\tt \packagename\_inform\_type}
(\S\ref{galtypes}),
and the subroutines
{\tt \packagename\_initialize},
{\tt \packagename\_factorize},
{\tt \packagename\_solve},
{\tt \packagename\_terminate}
(\S\ref{galarguments}),
and
{\tt \packagename\_enquire}
(\S\ref{galfeatures})
must be renamed on one of the {\tt USE} statements.

\noindent There are four principal subroutines for user calls (see
\S\ref{galfeatures} for further features):

\begin{description}

\item[] The subroutine {\tt \packagename\_initialize} must be called to
specify the external solver to be used.
It may also be called to set default values
for solver-specific components of the control structure.
If non-default values are
wanted for any of the control components, the corresponding components
should be altered after the call to {\tt \packagename\_initialize}.

\item[] {\tt \packagename\_factorize} accepts the pattern of $\bmA$
 and chooses pivots for Gaussian elimination using a selection
 criterion to preserve sparsity.  The factors of $\bmA$ are generated
 using the calculated pivot order.

\item[] {\tt \packagename\_solve} uses the factors generated by
  {\tt \packagename\_factorize} to
  solve a system of equations with one ($\bmA \bmx = \bmb$ or $\bmA^T \bmx = \bmb$) )
  or several ($\bmA \bmX = \bmB$ or $\bmA^T \bmX = \bmB$) right-hand sides.
  Iterative refinement may be used to improve a given solution
  or set of solutions.

\item[] {\tt \packagename\_terminate} deallocates the arrays held inside the
  structure for the factors. It should be called
  when all the systems involving its matrix have been solved
  or before another external solver is to be used.
\end{description}

\subsection{Supported external solvers}

In Table~\ref{solvers} we summarize key features of
the external solvers supported by \packagename. Further details
are provided in the references cited in \S\ref{galmethod}.

\bctable{|l|l|l|}
\hline
 solver & out-of-core & parallelised \\
\hline
{\tt GLS/MA28} & no & no \\
{\tt HSL\_MA48} & no & no \\
%{\tt HSL\_MA77} & yes & OpenNP core \\
%{\tt HSL\_MA87} & no & OpenMP fully \\
%{\tt PARDISO} & no & OpenMP fully \\
\hline

\ectable{\label{solvers}External solver characteristics.}
\vspace*{-8mm}
%%%%%%%%%%%%%%%%%%%%%% matrix formats %%%%%%%%%%%%%%%%%%%%%%%%

\galmatrix
The matrix $\bmA$ may be stored in a variety of input formats.

\subsubsection{Sparse co-ordinate storage format}\label{coordinate}
Only the nonzero entries of $\bmA$ are stored.
For the $l$-th entry of $\bmA$,
its row index $i$, column index $j$ and value $a_{ij}$
are stored in the $l$-th components of the integer arrays {\tt row},
{\tt col} and real array {\tt val}, respectively.
The order is unimportant, but the total number of entries
{\tt ne} is also required.

\subsubsection{Sparse row-wise storage format}\label{rowwise}
Again only the nonzero entries are stored,
but this time they are ordered so that those in row $i$ appear directly
before those in row $i+1$. For the $i$-th row of $\bmA$, the $i$-th component
of an integer array {\tt ptr} holds the position of the first entry in this row,
while {\tt ptr} $(m+1)$ holds the total number of entries plus one.
The column indices $j$ and values $a_{ij}$ of the entries in the $i$-th row
are stored in components
$l =$ {\tt ptr}$(i)$, \ldots ,{\tt ptr} $(i+1)-1$ of the
integer array {\tt col}, and real array {\tt val}, respectively.

For sparse matrices, this scheme almost always requires less storage than
its predecessor.

\subsubsection{Dense storage format}\label{dense}
The matrix $\bmA$ is stored as a compact
dense matrix by rows, that is, the values of the entries of each row in turn are
stored in order within an appropriate real one-dimensional array.
In particular,
component $m \ast (i-1) + j$ of the storage array {\tt val}
will hold the value $a_{ij}$
for $1 \leq i \leq m$ and $1 \leq j \leq n$.

\subsection{Integer kinds}\label{Integer kinds}
We use the term
long \integer\ to denote {\tt INTEGER\-(kind=long)}, where
{\tt long = selected\_int\_kind(18))}.

%%%%%%%%%%%%%%%%%%%%%% OpenMP usage %%%%%%%%%%%%%%%%%%%%%%%%

\subsection{OpenMP}
OpenMP may be used by the {\tt \fullpackagename} package to provide
parallelism for some solvers in shared memory environments.
To run in parallel, OpenMP
must be enabled at compilation time by using the correct compiler flag
(usually some variant of {\tt -openmp}).
The number of threads may be controlled at runtime
by setting the environment variable {\tt OMP\_NUM\_THREADS}.

\noindent
The code may be compiled and run in serial mode.


%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\galtypes
Four derived data types are used by the package.

%%%%%%%%%%% problem type %%%%%%%%%%%

\subsubsection{The derived data type for holding the matrix}\label{typeprob}
The derived data type {\tt SMT\_type} is used to hold the matrix $\bmA$.
The components of {\tt SMT\_type} used are:

\begin{description}

\ittf{m} is a scalar variable of type default \integer, that holds
the row dimension $m$ of the matrix  $\bmA$.
\restriction {\tt m} $\geq$ {\tt 1}.

\ittf{n} is a scalar variable of type default \integer, that holds
the column dimension $n$ of the matrix  $\bmA$.
\restriction {\tt n} $\geq$ {\tt 1}.

\itt{type} is an allocatable array of rank one and type default \character, that
indicates the storage scheme used. If the
sparse co-ordinate scheme (see \S\ref{coordinate}) is used
the first ten components of {\tt type} must contain the
string {\tt COORDINATE}.
For the sparse row-wise storage scheme (see \S\ref{rowwise}),
the first fourteen components of {\tt type} must contain the
string {\tt SPARSE\_BY\_ROWS}, and
for dense storage scheme (see \S\ref{dense})
the first five components of {\tt type} must contain the
string {\tt DENSE}.
%and for the diagonal storage scheme (see \S\ref{diagonal}),
%the first eight components of {\tt type} must contain the
%string {\tt DIAGONAL}.

For convenience, the procedure {\tt SMT\_put}
may be used to allocate sufficient space and insert the required keyword
into {\tt type}.
For example, if $\bmA$ is to be stored in the structure {\tt A}
of derived type {\tt SMT\_type} and we wish to use
the co-ordinate scheme, we may simply
%\vspace*{-2mm}
{\tt
\begin{verbatim}
        CALL SMT_put( A%type, 'COORDINATE' )
\end{verbatim}
}
%\vspace*{-4mm}
\noindent
See the documentation for the \galahad\ package {\tt SMT}
for further details on the use of {\tt SMT\_put}.

\itt{ne} is a scalar variable of type default \integer, that
holds the number of entries in $\bmA$
in the sparse co-ordinate storage scheme (see \S\ref{coordinate}).
It need not be set for any of the other three schemes.

\itt{val} is a rank-one allocatable array of type default \realdp, that holds
the values of the entries of the matrix $\bmA$ for each of the
storage schemes discussed in \S\ref{galmatrix}.
Any duplicated entries that appear in the sparse
co-ordinate or row-wise schemes will be summed.

\itt{row} is a rank-one allocatable array of type default \integer,
that holds the row indices of $\bmA$ in the sparse co-ordinate storage
scheme (see \S\ref{coordinate}).
It need not be allocated for any of the other schemes.
Any entry whose row index lies out of the range $[$1,n$]$ will be ignored.

\itt{col} is a rank-one allocatable array variable of type default \integer,
that holds the column indices of $\bmA$ in either the sparse co-ordinate
(see \S\ref{coordinate}), or the sparse row-wise
(see \S\ref{rowwise}) storage scheme.
It need not be allocated when the dense
%or diagonal storage schemes are used.
storage scheme is used.
Any entry whose row index lies out of the range $[$1,m$]$ or
column index lies out of the range $[$1,n$]$ will be ignored.

\itt{ptr} is a rank-one allocatable array of size {\tt m+1} and type
default \integer, that holds the starting position of $\bmA$, as well
as the total number of entries plus one, in the sparse row-wise storage
scheme (see \S\ref{rowwise}). It need not be allocated for the
other schemes.

\end{description}
Although any of the above-mentioned matrix storage formats may be used
with each supported solver, {\tt MA28/GLS} and {\tt HSL\_MA48}
from HSL are most efficient if co-ordinate input is provided.

%%%%%%%%%%% control type %%%%%%%%%%%

\subsubsection{The derived data type for holding control
 parameters}\label{typecontrol}
The derived data type
{\tt \packagename\_control\_type}
is used to hold controlling data.
Default values specifically for the desired solver
may be obtained by calling
{\tt \packagename\_initialize}
(see \S\ref{subinit}),
%Default values are assigned,
while components may be changed at run time by calling
{\tt \packagename\_read\-\_specfile}
(see \S\ref{readspec}).
The components of
{\tt \packagename\_control\_type}
are:

\begin{description}

\itt{error} is a scalar variable of type default \integer, that holds the
unit number for error messages.
Printing of error messages is suppressed if ${\tt error} < {\tt 0}$.
The default is {\tt error = 6}.

\itt{warning} is a scalar variable of type default \integer, that holds the
unit number for warning messages.
Printing of warning messages is suppressed if ${\tt warning} < {\tt 0}$.
The default is {\tt warning = 6}.

\ittf{out} is a scalar variable of type default \integer, that holds the
unit number for informational messages.
Printing of informational messages is suppressed if ${\tt out} < {\tt 0}$.
The default is {\tt out = 6}.

\itt{print\_level} is a scalar variable of type default \integer,
that is used
to control the amount of informational output that is required. No
informational output will occur if ${\tt print\_level} \leq {\tt 0}$. If
{\tt print\_level} $\geq$ {\tt 1} a single line of output will be produced
for each step of iterative refinement performed.
If {\tt print\_level} $\geq$ {\tt 2} this output
may be increased to provide significant detail of the factorization process.
The default is {\tt print\_level = 0}.

\itt{print\_level\_solver} is a scalar variable of type default \integer,
that is used
to control the amount of informational output that is required by the exteral
solver. No
informational output will occur if ${\tt print\_level} \leq {\tt 0}$. If
{\tt print\_level} $\geq$ {\tt 1} the amount of output produced is solver
dependent.
The default is {\tt print\_level\_solver = 0}.

\itt{initial\_fill\_in\_factor} is a scalar variable of type default \integer,
that gives a prediction of the factor by which the fill-in will exceed
the initial number of entries in $\bma$.
The default is {\tt initial\_fill\_in\_factor = 3}.

\itt{min\_real\_factor\_size} is a scalar variable of type default \integer,
that specifies the amount of real storage that will initially be
allocated for the factors and other data.
The default is {\tt min\_real\_factor\_size = 10000},
and this default is used if {\tt min\_real\_factor\_size < 1}.

\itt{min\_integer\_factor\_size} is a scalar variable of type default \integer,
that specifies the amount of integer storage that will initially be
allocated for the factors and other data.
The default is {\tt min\_integer\_factor\_size = 10000},
and this default is used if {\tt min\_integer\_factor\_size < 1}.

\itt{max\_factor\_size} is a scalar variable of type long \integer,
that specifies the maximum amount of real storage that will be
allocated for the factors and other data.
The default is {\tt max\_factor\_size = HUGE(0)}.

\itt{blas\_block\_size\_factorize} is a scalar variable of type default \integer,
that gives the block size for level-three basic linear algebra subprograms
(BLAS) in the factorization phase.
The default is {\tt blas\_block\_size\_factorize = 16},
and this default is used if {\tt blas\_block\_size\_factorize < 1}.

\itt{blas\_block\_size\_solve} is a scalar variable of type default \integer,
that gives the block size for level-two and -three basic linear algebra
subprograms (BLAS) in the solution phase.
The default is {\tt blas\_block\_size\_solve = 16},
and this default is used if {\tt blas\_block\_size\_solve < 1}.

\itt{pivot\_control} is a scalar variable of type default \integer,
that is used to control numerical pivoting by {\tt \packagename\_\-factorize}.
Possible values are:
\begin{description}
 \itt{1}  Threshold partial pivoting will be performed, with relative pivot
     tolerance given by the component {\tt relative\_\-pivot\_tolerance}.
 \itt{2}  Threshold rook pivoting is desired, with relative pivot
     tolerance given by the component {\tt relative\_\-pivot\_\-tolerance}.
 \itt{3}  Threshold complete pivoting is desired, with relative pivot
     tolerance given by the component {\tt relative\_\-pivot\_tolerance}.
 \itt{4}  Threshold symmetric pivoting is desired, with relative pivot
     tolerance given by the component {\tt relative\_\-pivot\_tolerance}.
 \itt{5}  Threshold diagonal pivoting is desired, with relative pivot
     tolerance given by the component {\tt relative\_\-pivot\_tolerance}.
\end{description}
The default is {\tt pivot\_control = 1}, and any value outside of
$[${\tt1,5}$]$ will be reset to the default. If a desired value
is not available, the default will be substituted.

\itt{pivot\_search\_limit} is a scalar variable of type default \integer,
that controls the maximum number of row and columns searched for a pivot.
If {\tt pivot\_search\_\-limit $\leq$ 0}, the search is unlimited.
The default is {\tt pivot\_search\_\-limit = 0}.

\itt{minimum\_size\_for\_btf} is a scalar variable of type default \integer,
that specifies the minimum size of a block within any block-triangular
form found during the factorization.
The default is {\tt minimum\_size\_for\_btf = 1}.

\itt{max\_iterative\_refinements} is a scalar variable of type default
\integer, that holds
the maximum number of iterative refinements that may be attempted.
The default is {\tt max\_iterative\_refinements = 0}.

\itt{stop\_if\_singular} is a scalar variable of type default
\logical, that should be set \true\ if the factorization is
to be terminated if $\bmA$ is found to be singular, and
\false\ if the factorization should continue.
The default is {\tt stop\_if\_singular = \false}.

\itt{array\_increase\_factor} is a scalar variable of type \realdp, that holds
the factor by which arrays sizes are to be increased if they are too small.
The default is {\tt array\_increase\_factor = 2.0}.

\itt{switch\_to\_full\_code\_density} is a scalar variable of type \realdp,
that specifies the density at which a switch to full/dense code
to perform the remaining factorization occurs.
The default is {\tt switch\_to\_full\_code\_density = 0.5}.

\itt{array\_decrease\_factor} is a scalar variable of type \realdp, that holds
a factor which is used to assess whether previously allocated internal
workspace arrays are excessive. In particular, if current requirements are
less than {\tt array\_decrease\_factor} times the currently allocated space,
the space will be re-allocated to current requirements.
The default is {\tt array\_decrease\_factor = 2.0}.

\itt{relative\_pivot\_tolerance} is a scalar variable of type \realdp,
that holds the relative pivot tolerance that is used to control the
stability of the factorization.
The default is {\tt relative\_pivot\-\_tolerance = 0.01}.
For problems requiring greater
than average numerical care a higher value than the default would be
advisable. Values greater than {\tt 0}.{\tt 5} are treated as {\tt 0}.{\tt 5}
and less than {\tt 0}.{\tt 0} as {\tt 0}.{\tt 0}.

\itt{absolute\_pivot\_tolerance} is a scalar variable of type \realdp, that
holds the absolute pivot tolerance which is used to control the
stability of the factorization.
No pivot smaller than {\tt absolute\_pivot\_tolerance} in
absolute value will be accepted.
The default is {\tt absolute\_pivot\_\-tolerance = EPSILON(1.0)}
({\tt EPSILON(1.0D0)} in {\tt \fullpackagename\_double}).

\itt{zero\_tolerance} is a scalar variable of type \realdp, that
controls which small entries are to be ignored during the factorization
of $\bmA$. Any entry smaller in absolute value than
{\tt zero\_\-tolerance} will be treated as zero; as a consequence when
{\tt zero\_tolerance > 0}, the factors produced will be of a perturbation
of order {\tt zero\_tolerance} of $\bmA$.
The default is {\tt zero\_tolerance = 0.0}.

\itt{acceptable\_residual\_relative}  and {\tt acceptable\_residual\_absolute}
are scalar variables of type \realdp, that
specify an acceptable level for the residual $\bmA \bmx - \bmb$ or residuals
$\bmA \bmx_i - \bmb_i$, $i=1,\ldots,r$,  when there are more than one.
In particular, iterative refinement will cease as soon as
$\|\bmA \bmx - \bmb\|_{\infty}$ falls below
$\max (\| \bmb\|_{\infty} \ast$ {\tt acceptable\_residual\_relative},
{\tt acceptable\_residual\_absolute}$)$;
for the multiple residual case, we require that
$\|\bmA \bmx_i - \bmb_i\|_{\infty}$ falls below
$\max (\| \bmb_i\|_{\infty} \ast$ {\tt acceptable\_residual\_relative},
for each $i=1,\ldots,r$.
The defaults are {\tt acceptable\_residual\_relative =
acceptable\_resi\-dual\_absolute = }$10 u$,
where $u$ is {\tt EPSILON(1.0)} ({\tt EPSILON(1.0D0)} in
{\tt \fullpackagename\_double}).

\itt{prefix} is a scalar variable of type default \character\
and length 30, that may be used to provide a user-selected
character string to preface every line of printed output.
Specifically, each line of output will be prefaced by the string
{\tt prefix(2:LEN(TRIM(prefix))-1)},
thus ignoring the first and last non-null components of the
supplied string. If the user does not want to preface lines by such
a string, the default {\tt prefix = ""} should be used.

\end{description}

%%%%%%%%%%% inform type %%%%%%%%%%%

\subsubsection{The derived data type for holding informational
 parameters}\label{typeinform}
The derived data type
{\tt \packagename\_inform\_type}
is used to hold parameters that give information about the progress and needs
of the algorithm. The components of
{\tt \packagename\_inform\_type}
are as follows---any component that is not relevant to the solver being used
will have the value {\tt -1} or {\tt -1.0} as appropriate:

\begin{description}

\itt{status} is a scalar variable of type default \integer, that gives the
exit status of the algorithm.
%See Sections~\ref{galerrors} and \ref{galinfo}
See \S\ref{galerrors}
for details.

\itt{alloc\_status} is a scalar variable of type default \integer, that gives
the status of the last attempted array allocation or deallocation.

\itt{bad\_alloc} is a scalar variable of type default \character\
and length 80, that  gives the name of the last internal array
for which there were allocation or deallocation errors.
This will be the null string if there have been no
allocation or deallocation errors.

%\itt{more\_info} is a scalar variable of type default \integer, that gives
%additional information as
%\ldots %  further information on failure

\itt{out\_of\_range} is a scalar variable of type long \integer,
that is set to the number of
entries of $\bmA$ supplied with one or both indices out of range.

\itt{duplicates} is a scalar variable of type long \integer,
that is set to the number of duplicate off-diagonal entries of $\bmA$ supplied.

\itt{entries\_dropped} is a scalar variable of type long \integer,
that is set to the number of small entries dropped from the factorization.

\itt{workspace\_factors} is a scalar variable of type long \integer,
that gives the total number of reals and integers needed to hold the
factors.

\itt{compresses} is a scalar variable of type default \integer,
that gives the number of compresses of the workspace data required.

\itt{entries\_in\_factors} is a scalar variable of type long \integer,
that gives the number of entries in the factors of $\bmA$.

\itt{rank} is a scalar variable of type default \integer,
that gives an estimate of the rank of $\bmA$.

\itt{structural\_rank} is a scalar variable of type default \integer,
that gives the structural rank of $\bmA$.

\itt{pivot\_control} is a scalar variable of type default \integer,
that specifies what form of numerical pivoting has been used.
Possible values are:
\begin{description}
 \itt{1}  Threshold partial pivoting has been performed.
 \itt{2}  Threshold rook pivoting has been performed.
 \itt{3}  Threshold complete pivoting has been performed.
 \itt{4}  Threshold symmetric pivoting has been performed.
 \itt{5}  Threshold diagonal pivoting has been performed.
\end{description}

\itt{iterative\_refinements} is a scalar variable of type default \integer,
that gives the number of iterative refinements performed.

\itt{gls\_ainfo} is a scalar variable of type {\tt gls\_ainfo},
that corresponds to the output value {\tt gls\_ainfo}
from {\tt GLS}. See the documentation for {\tt GLS} for further
details.

\itt{gls\_finfo} is a scalar variable of type {\tt gls\_finfo},
that corresponds to the output value {\tt gls\_finfo}
from {\tt GLS}. See the documentation for {\tt GLS} for further
details.

\itt{gls\_sinfo} is a scalar variable of type {\tt gls\_sinfo},
that corresponds to the output value {\tt gls\_sinfo}
from {\tt GLS}. See the documentation for {\tt GLS} for further
details.

\itt{ma48\_ainfo} is a scalar variable of type {\tt ma48\_ainfo},
that corresponds to the output value {\tt ma48\_ainfo}
from {\tt HSL\_MA48}. See the documentation for {\tt HSL\_MA48} for further
details.

\itt{ma48\_finfo} is a scalar variable of type {\tt ma48\_finfo},
that corresponds to the output value {\tt ma48\_finfo}
from {\tt HSL\_MA48}. See the documentation for {\tt HSL\_MA48} for further
details.

\itt{ma48\_sinfo} is a scalar variable of type {\tt ma48\_sinfo},
that corresponds to the output value {\tt ma48\_sinfo}
from {\tt HSL\_MA48}. See the documentation for {\tt HSL\_MA48} for further
details.

\itt{PARDISO\_error} is a scalar variable of type \integer,
that corresponds to the output value {\tt error}
from {\tt PARDISO}. See the documentation for {\tt PARDISO} for further
details.

\itt{PARDISO\_iparm} is an array of size 64 and type \integer,
whose components correspond to those in the output array {\tt IPARM}
from {\tt PARDISO}. See the documentation for {\tt PARDISO} for further
details.

\itt{PARDISO\_dparm} is an array of size 64 and type \realdp,
whose components correspond to those in the output array {\tt DPARM}
from {\tt PARDISO}. See the documentation for {\tt PARDISO} for further
details.

\end{description}

%%%%%%%%%%% data type %%%%%%%%%%%

\subsubsection{The derived data type for holding problem data}\label{typedata}
The derived data type
{\tt \packagename\_data\_type}
is used to hold all the data for a particular problem,
or sequences of problems with the same structure, between calls to
{\tt \packagename} procedures.
%This data should be preserved, untouched, from the initial call to
%{\tt \packagename\_initialize}
%to the final call to
%{\tt \packagename\_terminate}.
All components are private.

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\galarguments
%We use square brackets {\tt [ ]} to indicate \optional\ arguments.

%%%%%% initialization subroutine %%%%%%

\subsubsection{The initialization subroutine}\label{subinit}
The initialization subroutine must be called for each solver used
to initialize data and solver-specific control parameters.

\hskip0.5in
{\tt CALL \packagename\_initialize( solver, data, control, inform )}
\begin{description}

\itt{solver} is scalar, of \intentin, of type \character, and of variable
length that specifies which solver to use. Possible values are
\begin{description}
\itt{gls} if the \galahad\ solver {\tt GLS} is desired.

\itt{ma28} is an alias for {\tt gls} that reflects the fact that the \galahad\
 solver {\tt GLS} is a Fortran-90 encapsulation of the Fortran-77
 package {\tt MA28} from HSL.

\itt{ma48} if the HSL solver {\tt HSL\_MA48} is desired. This is a more
advanced version of {\tt GLS/MA28}.

%\itt{ma77} if the HSL solver {\tt HSL\_MA77} is desired. This is particularly
%appropriate when the matrix factors are too large to fit in main memory,
%and offers the option of parallel execution of core computations.

%\itt{ma87} if the HSL solver {\tt HSL\_MA87} is desired. This option should
%currently only be selected when $\bmA$ is positive definite, but
%offers the opportunity for general parallel solution.

%\itt{pardiso} if the Pardiso Project solver {\tt PARDISO} (version 4.0.0
%or above) is desired. Again parallel solution is offered with this choice.

\end{description}
Other solvers may be added in the future.
% LUSOL

\itt{data} is a scalar \intentout argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold data about the problem being
solved.

\itt{control} is a scalar \intentout argument of type
{\tt \packagename\_control\_type}
(see \S\ref{typecontrol}).
On exit, {\tt control} contains solver-specific default values for the
components as described in \S\ref{typecontrol}.
These values should only be changed after calling
{\tt \packagename\_initialize}.

\itt{inform} is a scalar \intentout argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\end{description}

%%%%%%%%% factorization subroutine %%%%%%

\subsubsection{The factorization subroutine}
The matrix $\bmA$ may be factorized as follows:

\hskip0.5in
{\tt CALL \packagename\_factorize( matrix, data, control, inform )}

\begin{description}

\itt{matrix} is scalar \intentin\ argument of type {\tt SMT\_type}
that is used to specify $\bmA$.
The user must set all of the relevant components of {\tt matrix} according
to the storage scheme desired (see \S\ref{typeprob}).
Incorrectly-set components will result in errors
flagged in {\tt inform\%status}, see \S\ref{galerrors}.

%\itt{PERM} is an \optional\ \intentin\ rank-one default \integer\ argument of
%length {\tt matrix\%n} that may be used to provide a permutation/pivot
%order.
%If present, {\tt PERM(i)}, {\tt i} $= 1, \ldots,$ {\tt matrix\%m}, should be set
%to the desired position of the input row $i$ in the permuted matrix.

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors and other
data about the problem being solved.
It must have been initialized by a call to
{\tt \packagename\_ini\-tialize} and not altered by the user in the interim.

\itt{control} is scalar \intentin\ argument of type
{\tt \packagename\_control\_type}. Its components control the action
of the factorization phase, as explained in
\S\ref{typecontrol}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\end{description}

%%%%%%%%% solve subroutine %%%%%%

\subsubsection{The solution subroutine}
Given the factorization, a set of equations may be solved as follows:

\hskip0.5in
{\tt CALL \packagename\_solve( matrix, RHS, X, data, control, inform, trans )}

\begin{description}

\itt{matrix} is scalar \intentin\ argument of type {\tt SMT\_type}
that is used to specify $\bmA$.
The user must set all of the relevant components of {\tt matrix} according
to the storage scheme desired (see \S\ref{typeprob}). Those components
set for {\tt \packagename\_factorize} must not have been altered in the interim.

\itt{RHS} is an \intentin\ assumed-shape array argument of rank 1 or 2
and of type \realdp.  On entry, {\tt RHS} must be set
to the vector $\bmb$ or the matrix $\bmB$ and on successful return it holds
the solution $\bmx$ or $\bmX$. For the single right-hand side case, the
{\tt i}-th component of $\bmb$
occupies the {\tt i}-th component of {\tt RHS}. When there are multiple
right-hand sides, the {\tt i}-th component of the $j$-th right-hand side $B_{i,j}$
occupies the {\tt i,j}-th component of {\tt RHS}.

\itt{X} is an \intentinout\ assumed-shape array argument of rank 1 or 2
and of type \realdp.  On successful return it holds
the solution $\bmx$ or $\bmX$. For the single right-hand side case, the
{\tt i}-th component of the solution $\bmx$
occupies the {\tt i}-th component of {\tt X}. When there are multiple
right-hand sides, the resulting solution $X_{i,j}$ occupies the
{\tt i,j}-th component of {\tt X}.

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors and other
data about the problem being solved.
It must have been initialized by a call to
{\tt \packagename\_ini\-tialize} and not altered by the user in the interim.

\itt{control} is scalar \intentin\ argument of type
{\tt \packagename\_control\_type}. Its components control the action
of the solve phase, as explained in
\S\ref{typecontrol}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\itt{trans} is a scalar \intentin\ argument of type \logical\ that should be
set \true\ if the solution to $\bmA^T \bmx = \bmb$ or $\bmA^T \bmX = \bmB$
is sought, and \false\ if the solution to $\bmA \bmx = \bmb$ or
$\bmA \bmX = \bmB$ is required.

\end{description}

%%%%%%% termination subroutine %%%%%%

\subsubsection{The termination subroutine}
All previously allocated internal arrays are deallocated and OpenMP locks
destroyed as follows:

\hskip0.5in
{\tt CALL \packagename\_terminate( data, control, inform )}

\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors and other
data about the problem being solved.
It must have been initialized by a call to
{\tt \packagename\_ini\-tialize} and not altered by the user in the interim.
On exit, its allocatable array components will have been deallocated.

\itt{control} is scalar \intentin\ argument of type
{\tt \packagename\_control\_type}. Its components control the action
of the termination phase, as explained in
\S\ref{typecontrol}.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\galerrors
A negative value of {\tt inform\%status} on exit from the subroutines
indicates that an error has occurred. No further calls should be made
until the error has been corrected. Possible values are:

\begin{description}

\itt{\galerrallocate} An allocation error occurred. A message indicating
the offending
array is written on unit {\tt control\%error}, and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc} respectively.

\itt{\galerrdeallocate} A deallocation error occurred.
A message indicating the offending
array is written on unit {\tt control\%error} and the returned allocation
status and a string containing the name of the offending array
are held in {\tt inform\%alloc\_\-status}
and {\tt inform\%bad\_alloc} respectively.

\itt{\galerrrestrictions} One of the restrictions
 {\tt matrix\%m} $> 0$ or
 {\tt matrix\%n} $> 0$ or
 {\tt matrix\%ne} $< 0$, for co-ordinate entry,
  or requirements that {\tt matrix\%type}
  contain its relevant string
{\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_ROWS'} or   {\tt 'DENSE'}
%  or {\tt 'DIAGONAL'}
  has been violated.

\itt{\galunknownsolver} The requested solver is not available.

\itt{\galerrunavailable} This option is not available with this solver.

\itt{-32} The integer workspace required is larger than
 {\tt max\_factor\_size}.

\itt{-33} The real workspace  required is larger than
 {\tt max\_factor\_size}.

%\itt{-34} An error occurred in PARDISO.

\itt{-39}  The input permutation/pivot order is not a permutation or is
    faulty in some other way.

\itt{-50} A solver-specific error occurred; check the solver-specific
  information component of {\tt inform} along with the solver's documentation
  for more details.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% Further control features %%%%%%%%%%%%%%%%%%%%%%%%

\galfeatures
\noindent In this section, we describe a feature for enquiring about
the factorization constructed. This feature
will not be needed by a user who wants simply to solve systems of
equations with matrix $\bmA$ or $\bmA^T$.

The solvers used each produce an $\bmP_R \bmL \bmU \bmP_C$ factorization
of $\bmA$, where $\bmL$ and $\bmU$ are lower and upper triangular
matrices, and $\bmP_R$ and $\bmP_C$ are row and column permutation
matrices respectively.
The following subroutine is provided:
\begin{description}
\ittf{} {\tt \packagename\_enquire} returns the row and column permutations
that define $\bmP_R$ and $\bmP_C$.

%\ittf{} {\tt \packagename\_part\_solve} solves one of the systems of equations
%$\bmP \bmL \bmx =  \bmb$,
%$\bmD \bmx =  \bmb$, or
%$\bmL^T \bmP^T \bmx =  \bmb$,
%or one or more right-hand sides.

\end{description}

\newpage
Support for this feature from the solvers available with \packagename\
is summarised in Table~\ref{options}.
\bctable{|l|c|}
\hline
 solver & {\tt \packagename\_enquire} \\
\hline
{\tt GLS/MA28}  & $\surd$  \\
{\tt HSL\_MA48} & $\surd$  \\
%{\tt HSL\_MA77} & $\surd$  \\
%{\tt HSL\_MA87} & $\surd$  \\
%{\tt PARDISO}   & $\times$ \\
\hline
\ectable{\label{options}Options supported.}
\vspace*{-8mm}
\subsubsection{To return $\bmP_R$ and $\bmP_C$}
\label{galenquire}

\hskip0.5in
{\tt CALL \packagename\_enquire( data, inform, ROWS, COLS )}

\begin{description}

\itt{data} is a scalar \intentinout\ argument of type
{\tt \packagename\_data\_type}
(see \S\ref{typedata}). It is used to hold the factors and other
data about the problem being solved.
It must have been initialized by a call to
{\tt \packagename\_ini\-tialize} and not altered by the user in the interim.

\itt{inform} is a scalar \intentinout\ argument of type
{\tt \packagename\_inform\_type}
(see \S\ref{typeinform}).
A successful call is indicated when the  component {\tt status} has the value 0.
For other return values of {\tt status}, see \S\ref{galerrors}.

\itt{ROWS} is a rank-one default \integer\ array argument
of \intentout\  and length $m$. The {\tt ROW($i$)}th row of $\bmA$
is the $i$th row in the factors, $1 \leq i \leq m$.

\itt{COLS} is a rank-one default \integer\ array argument
of \intentout\  and length $n$. The {\tt COL($j$)}th column of $\bmA$
is the $j$th column in the factors, $1 \leq j \leq n$.
\end{description}

%%%%%%%%%%%%%%%%%%%%%% Further features %%%%%%%%%%%%%%%%%%%%%%%%

\galcontrolfeatures
\noindent In this section, we describe an alternative means of setting
control parameters, that is components of the variable {\tt control} of type
{\tt \packagename\_control\_type}
(see \S\ref{typecontrol}),
by reading an appropriate data specification file using the
subroutine {\tt \packagename\_read\_specfile}. This facility
is useful as it allows a user to change  {\tt \packagename} control parameters
without editing and recompiling programs that call {\tt \packagename}.

A specification file, or specfile, is a data file containing a number of
``specification commands''. Each command occurs on a separate line,
and comprises a ``keyword'',
which is a string (in a close-to-natural language) used to identify a
control parameter, and
an (optional) "value", which defines the value to be assigned to the given
control parameter. All keywords and values are case insensitive,
keywords may be preceded by one or more blanks but
values must not contain blanks, and
each value must be separated from its keyword by at least one blank.
Values must not contain more than 30 characters, and
each line of the specification file is limited to 80 characters,
including the blanks separating keyword and value.

The portion of the specification file used by
{\tt \packagename\_read\_specfile}
must start
with a ``{\tt BEGIN \packagename}'' command and end with an
``{\tt END}'' command.  The syntax of the specfile is thus defined as follows:
\begin{verbatim}
  ( .. lines ignored by ULS_read_specfile .. )
    BEGIN ULS
       keyword    value
       .......    .....
       keyword    value
    END
  ( .. lines ignored by ULS_read_specfile .. )
\end{verbatim}
where keyword and value are two strings separated by (at least) one blank.
The ``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiter command lines
may contain additional (trailing) strings so long as such strings are
separated by one or more blanks, so that lines such as
\begin{verbatim}
    BEGIN ULS SPECIFICATION
\end{verbatim}
and
\begin{verbatim}
    END ULS SPECIFICATION
\end{verbatim}
are acceptable. Furthermore,
between the
``{\tt BEGIN \packagename}'' and ``{\tt END}'' delimiters,
specification commands may occur in any order.  Blank lines and
lines whose first non-blank character is {\tt !} or {\tt *} are ignored.
The content
of a line after a {\tt !} or {\tt *} character is also
ignored (as is the {\tt !} or {\tt *}
character itself). This provides an easy way to ``comment out'' some
specification commands, or to comment specific values
of certain control parameters.

The value of a control parameter may be of three different types, namely
integer, character or real.
Integer and real values may be expressed in any relevant Fortran integer and
floating-point formats (respectively).
%Permitted values for logical
%parameters are "{\tt ON}", "{\tt TRUE}", "{\tt .TRUE.}", "{\tt T}",
%"{\tt YES}", "{\tt Y}", or "{\tt OFF}", "{\tt NO}",
%"{\tt N}", "{\tt FALSE}", "{\tt .FALSE.}" and "{\tt F}".
%Empty values are also allowed for
%logical control parameters, and are interpreted as "{\tt TRUE}".

The specification file must be open for
input when {\tt \packagename\_read\_specfile}
is called, and the associated unit number
passed to the routine in {\tt device} (see below).
Note that the corresponding
file is rewound, which makes it possible to combine the specifications
for more than one program/routine.  For the same reason, the file is not
closed by {\tt \packagename\_read\_specfile}.

\subsubsection{To read control parameters from a specification file}
\label{readspec}

Control parameters may be read from a file as follows:
\hskip0.5in

\def\baselinestretch{0.8}
{\tt
\begin{verbatim}
     CALL ULS_read_specfile( control, device )
\end{verbatim}
}
\def\baselinestretch{1.0}

\begin{description}
\itt{control} is a scalar \intentinout\ argument of type
{\tt \packagename\_control\_type}
(see \S\ref{typecontrol}).
Default values should have already been set, perhaps by calling
{\tt \packagename\_initialize}.
On exit, individual components of {\tt control} may have been changed
according to the commands found in the specfile. Specfile commands and
the component (see \S\ref{typecontrol}) of {\tt control}
that each affects are given in Table~\ref{specfile}.

\pctable{|l|l|l|}
\hline
  command & component of {\tt control} & value type \\
\hline
{\tt error-printout-device} & {\tt \%error} & {\tt integer} \\
{\tt warning-printout-device} & {\tt \%warning} & {\tt integer} \\
{\tt printout-device} & {\tt \%out} & {\tt integer} \\
{\tt print-level} & {\tt \%print\_level} & {\tt integer} \\
{\tt print-level-solver} & {\tt \%print\_level\_solver} & {\tt integer} \\
{\tt maximum-block-size-for-btf} & {\tt \%maximum\_block\_size\_for\_btf} & {\tt integer} \\
{\tt blas-block-for-size-factorize} & {\tt \%blas\_block\_size\_factorize} & {\tt integer} \\
{\tt blas-block-size-for-solve} & {\tt \%blas\_block\_size\_solve} & {\tt integer} \\
{\tt initial-fill-in-factor} & {\tt \%initial\_fill\_in\_factor} & {\tt integer} \\
{\tt minimum-real-factor-size} & {\tt \%min\_real\_factor\_size} & {\tt integer} \\
{\tt minimum-integer-factor-size} & {\tt \%min\_integer\_factor\_size} & {\tt integer} \\
{\tt maximum-factor-size} & {\tt \%max\_factor\_size} & {\tt integer(long)} \\
{\tt pivot-control} & {\tt \%pivot\_control} & {\tt integer} \\
{\tt pivot-search-limit} & {\tt \%pivot\_search\_limit} & {\tt integer} \\
{\tt max-iterative-refinements} & {\tt \%max\_iterative\_refinements} & {\tt integer} \\
{\tt stop-if-singular} & {\tt \%stop\_if\_singular} & {\tt logical} \\
{\tt array-increase-factor} & {\tt \%array\_increase\_factor} & {\tt real} \\
{\tt array-decrease-factor} & {\tt \%array\_decrease\_factor} & {\tt real} \\
{\tt relative-pivot-tolerance} & {\tt \%relative\_pivot\_tolerance} & {\tt real} \\
{\tt absolute-pivot-tolerance} & {\tt \%absolute\_pivot\_tolerance} & {\tt real} \\
{\tt zero-tolerance} & {\tt \%zero\_tolerance} & {\tt real} \\
{\tt switch-to-full-code-density} & {\tt \%switch\_to\_full\_code\_density} & {\tt real} \\
{\tt acceptable-residual-relative} & {\tt \%acceptable\_residual\_relative} & {\tt real} \\
{\tt acceptable-residual-absolute} & {\tt \%acceptable\_residual\_absolute} & {\tt real} \\
{\tt output-line-prefix} & {\tt \%prefix} & {\tt character} \\
\hline

\ectable{\label{specfile}Specfile commands and associated
components of {\tt control}.}

\itt{device} is a scalar \intentin\ argument of type default \integer,
that must be set to the unit number on which the specification file
has been opened. If {\tt device} is not open, {\tt control} will
not be altered and execution will continue, but an error message
will be printed on unit {\tt control\%error}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%% GENERAL INFORMATION %%%%%%%%%%%%%%%%%%%%%%%%

\galgeneral

%\galcommon None.
\galworkspace Provided automatically by the module.
\galmodules {\tt GALAHAD\_SYMBOLS},
{\tt GALAHAD\_SORT\_single/double},
{\tt GALAHAD\_SPACE\_single/double},
{\tt GALAHAD\_SPECFILE\_single/double},
{\tt GALAHAD\_STRING\_single/double},
{\tt GALAHAD\_SMT\_single/double}, \\
{\tt GALAHAD\_GLS\_single/double}
and optionally
{\tt HSL\_MA48\_single/double}.
%{\tt HSL\_MA77\_single/double}, \\
%{\tt HSL\_MA87\_single/double},
%{\tt HSL\_MC64\_single\-/double} and
%{\tt HSL\_MC68\_single\-/double}.
\galroutines None.
%Optionally {\tt MC77} and {\tt METIS}.
\galio Output is under control of the arguments
{\tt control\%error},
{\tt control\%warning},
{\tt control\%out}, \\
{\tt control\-\%statistics}
and {\tt control\%print\_level}.
\galrestrictions {\tt matrix\%n} $\geq$ {\tt 1},
{\tt matrix\%ne} $\geq$ {\tt 0} if
{\tt matrix\%type = 'COORDINATE'},
{\tt matrix\%type}
one of
{\tt 'COORDINATE'}, {\tt 'SPARSE\_BY\_ROWS'} or   {\tt 'DENSE'}.
% or {\tt 'DIAGONAL'}.
\galportability ISO Fortran~95 + TR 15581 or Fortran~2003 and optionally OpenNP.
The package is thread-safe.

%%%%%%%%%%%%%%%%%%%%%% METHOD %%%%%%%%%%%%%%%%%%%%%%%%

\galmethod
Variants of sparse Gaussian elimination are used.

\noindent
The solver {\tt GLS} is available as part of \galahad\ and relies on
the HSL Archive packages {\tt MA33}. To obtain HSL Archive packages, see

{\tt http://hsl.rl.ac.uk/archive/ }.

\noindent
The solver {\tt HSL\_MA48}
%{\tt HSL\_MA77} and
%{\tt HSL\_MA87}, the ordering package
%{\tt HSL\_MC68} and the scaling packages
%{\tt HSL\_MC64} and {\tt MC77}
%are all part of HSL 2007.
is part of HSL 2007.
To obtain HSL 2007 packages, see

{\tt http://hsl.rl.ac.uk/hsl2007/ }.

%\noindent
%The solver {\tt PARDISO} is available from the Pardiso Project;
%version 4.0.0 or above is required.
%To obtain {\tt PARDISO}, see

%{\tt http://www.pardiso-project.org/ }.

\vspace*{1mm}

\galreferences
\vspace*{1mm}

\noindent
The methods used are described in the user-documentation for
\vspace*{1mm}

\noindent
HSL 2007, A collection of {F}ortran codes for large-scale scientific
 computation (2007). \\
 {\tt http://www.cse.clrc.ac.uk/nag/hsl}

\noindent
and papers

\noindent
O. Schenk and K. G\"{a}rtner (2004).
``Solving Unsymmetric Sparse Systems of Linear Equations with PARDISO''.
Journal of Future Generation Computer Systems \bf, 20(3) \rm 475--487, 2004,
and

\noindent
O. Schenk and K. G\"{a}rtner (2006).
``On fast factorization pivoting methods for symmetric indefinite systems''.
Electronic. Transactions on Numerical Analysis
{\bf 23} 158--179.

%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\galexample
We illustrate the use of the package on the solution of the
single set of equations
\disp{\mat{ccc}{ 11 & 12 &   \\
                 21 & 22 & 23  \\
                    & 32 & 33 } \bmx =
       \vect{23 \\ 66 \\ 65}}
(Note that this example does not illustrate all the facilities).
Then, choosing the solver {\tt GLS}, we may use the following code:

{\tt \small
\VerbatimInput{\packageexample}
}
%\noindent
%with the following data
%{\tt \small
%\VerbatimInput{\packagedata}
%}
\noindent
This produces the following output:
{\tt \small
\VerbatimInput{\packageresults}
}
\noindent

\end{document}

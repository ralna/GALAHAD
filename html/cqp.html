<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>cqp</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <script src="/usr/share/javascript/mathjax/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<hr />
<p><span><strong>GALAHAD CQP</strong></span></p>
<hr />
<p><span>USER DOCUMENTATION GALAHAD Optimization Library version <span class="math inline">\(3.3\)</span></span></p>
<hr />
<h1 id="galsummary"><a href="#galsummary" data-reference-type="ref" data-reference="galsummary">1</a>. SUMMARY</h1>
<p>This package uses a primal-dual interior-point method to solve the <span><strong>convex quadratic programming problem</strong></span> <span class="math display">\[\label{{qp}} \mbox{minimize}\;\; q({\mathbf{x}}) ={\frac{1}{2}}{\mathbf{x}}^T{\mathbf{H}}{\mathbf{x}}+{\mathbf{g}}^T{\mathbf{x}}+ f \;\;\; (qp)\]</span> or the <span><strong>shifted least-distance problem</strong></span> <span class="math display">\[\label{{lsqp}} \mbox{minimize}\;\;{\frac{1}{2}}\sum_{j=1}^n w_j^2 ( x_j^{ } - x_j^0 )^2 +{\mathbf{g}}^T{\mathbf{x}}+ f \;\;\; (lsqp)\]</span> subject to the general linear constraints <span class="math display">\[{c_{i}^{l}  \leq  {\mathbf{a}}_{i}^{T}{\mathbf{x}}\leq  c_{i}^{u}, \;\;\;
 i = 1, \ldots , m,}\]</span> and the simple bound constraints <span class="math display">\[{x_{j}^{l}  \leq  x_{j}^{ } \leq  x_{j}^{u} , \;\;\; j = 1, \ldots , n,}\]</span> where the <span class="math inline">\(n\)</span> by <span class="math inline">\(n\)</span> symmetric, positive-semi-definite matrix <span class="math inline">\({\mathbf{H}}\)</span>, the vectors <span class="math inline">\({\mathbf{g}}\)</span>, <span class="math inline">\({\mathbf{w}}\)</span>, <span class="math inline">\({\mathbf{x}}^{0}\)</span>, <span class="math inline">\({\mathbf{a}}_{i}\)</span>, <span class="math inline">\({\mathbf{c}}^{l}\)</span>, <span class="math inline">\({\mathbf{c}}^{u}\)</span>, <span class="math inline">\({\mathbf{x}}^{l}\)</span>, <span class="math inline">\({\mathbf{x}}^{u}\)</span> and the scalar <span class="math inline">\(f\)</span> are given. Any of the constraint bounds <span class="math inline">\(c_{i}^{l}\)</span>, <span class="math inline">\(c_{i}^{u}\)</span>, <span class="math inline">\(x_{j}^{l}\)</span> and <span class="math inline">\(x_{j}^{u}\)</span> may be infinite. Full advantage is taken of any zero coefficients in the matrix <span class="math inline">\({\mathbf{H}}\)</span> or the matrix <span class="math inline">\({\mathbf{A}}\)</span> of vectors <span class="math inline">\({\mathbf{a}}_{i}\)</span>.</p>
<p><span><strong>ATTRIBUTES —</strong> </span> <span><strong>Versions:</strong> </span><span>GALAHAD_CQP_single, GALAHAD_CQP_double</span>. <span><strong>Uses:</strong> </span> <span>GALAHAD_CLOCK</span>, <span>GALAHAD_SYMBOLS</span>, <span>GALAHAD_SPACE</span>, <span>GALAHAD_TOOLS</span>, <span>GALAHAD_SPECFILE</span>, <span>GALAHAD_SMT</span>, <span>GALAHAD_QPT</span>, <span>GALAHAD_QPP</span>, <span>GALAHAD_QPD</span>, <span>GALAHAD_FITS</span>, <span>GALAHAD_ROOTS</span>, <span>GALAHAD_NORMS</span>, <span>GALAHAD_SBLS</span>, <span>GALAHAD_CRO</span>, <span>GALAHAD_FDC</span>. <span><strong>Date:</strong> </span>November 2010. <span><strong>Origin:</strong> </span>N. I. M. Gould and D. P. Robinson, Rutherford Appleton Laboratory. <span><strong>Language:</strong> </span>Fortran 95 + TR 15581 or Fortran 2003. <span><strong>Parallelism:</strong> </span>Some options may use OpenMP and its runtime library.</p>
<h1 id="galhowto"><a href="#galhowto" data-reference-type="ref" data-reference="galhowto">2</a>. HOW TO USE THE PACKAGE</h1>
<p>Access to the package requires a <span>USE</span> statement such as</p>
<p><span><em>Single precision version</em></span></p>
<p><span>USE GALAHAD_CQP_single</span></p>
<p><span><em>Double precision version</em></span></p>
<p><span>USE GALAHAD_CQP_double</span></p>
<p>If it is required to use both modules at the same time, the derived types <span>SMT_type</span>, <span>QPT_problem_type</span>, <span>NLPT_userdata_type</span>, <span>CQP_time_type</span>, <span>CQP_control_type</span>, <span>CQP_inform_type</span> and <span>CQP_data_type</span> (Section <a href="#galtypes" data-reference-type="ref" data-reference="galtypes">2.4</a>) and the subroutines <span>CQP_initialize</span>, <span>CQP_solve</span>, <span>CQP_terminate</span>, (Section <a href="#galarguments" data-reference-type="ref" data-reference="galarguments">2.5</a>) and <span>CQP_read_specfile</span> (Section <a href="#galfeatures" data-reference-type="ref" data-reference="galfeatures">2.7</a>) must be renamed on one of the <span>USE</span> statements.</p>
<h2 id="galmatrix"><a href="#galmatrix" data-reference-type="ref" data-reference="galmatrix">2.1</a>. Matrix storage formats</h2>
<p>When they are explicitly available, Both the Hessian matrix <span class="math inline">\({\mathbf{H}}\)</span> and the constraint Jacobian <span class="math inline">\({\mathbf{A}}\)</span>, the matrix whose rows are the vectors <span class="math inline">\({\mathbf{a}}_{i}^{T}\)</span>, <span class="math inline">\(i = 1, \ldots , m\)</span>, may be stored in a variety of input formats.</p>
<h3 id="dense">Dense storage format</h3>
<p>The matrix <span class="math inline">\({\mathbf{A}}\)</span> is stored as a compact dense matrix by rows, that is, the values of the entries of each row in turn are stored in order within an appropriate real one-dimensional array. Component <span class="math inline">\(n \ast (i-1) + j\)</span> of the storage array <span>A%val</span> will hold the value <span class="math inline">\(a_{ij}\)</span> for <span class="math inline">\(i = 1, \ldots , m\)</span>, <span class="math inline">\(j = 1, \ldots , n\)</span>. Since <span class="math inline">\({\mathbf{H}}\)</span> is symmetric, only the lower triangular part (that is the part <span class="math inline">\(h_{ij}\)</span> for <span class="math inline">\(1 \leq j \leq i \leq n\)</span>) need be held. In this case the lower triangle will be stored by rows, that is component <span class="math inline">\(i \ast (i-1)/2 + j\)</span> of the storage array <span>H%val</span> will hold the value <span class="math inline">\(h_{ij}\)</span> (and, by symmetry, <span class="math inline">\(h_{ji}\)</span>) for <span class="math inline">\(1 \leq j \leq i \leq n\)</span>.</p>
<h3 id="coordinate">Sparse co-ordinate storage format</h3>
<p>Only the nonzero entries of the matrices are stored. For the <span class="math inline">\(l\)</span>-th entry of <span class="math inline">\({\mathbf{A}}\)</span>, its row index <span class="math inline">\(i\)</span>, column index <span class="math inline">\(j\)</span> and value <span class="math inline">\(a_{ij}\)</span> are stored in the <span class="math inline">\(l\)</span>-th components of the integer arrays <span>A%row</span>, <span>A%col</span> and real array <span>A%val</span>, respectively. The order is unimportant, but the total number of entries <span>A%ne</span> is also required. The same scheme is applicable to <span class="math inline">\({\mathbf{H}}\)</span> (thus requiring integer arrays <span>H%row</span>, <span>H%col</span>, a real array <span>H%val</span> and an integer value <span>H%ne</span>), except that only the entries in the lower triangle need be stored.</p>
<h3 id="rowwise">Sparse row-wise storage format</h3>
<p>Again only the nonzero entries are stored, but this time they are ordered so that those in row <span class="math inline">\(i\)</span> appear directly before those in row <span class="math inline">\(i+1\)</span>. For the <span class="math inline">\(i\)</span>-th row of <span class="math inline">\({\mathbf{A}}\)</span>, the <span class="math inline">\(i\)</span>-th component of a integer array <span>A%ptr</span> holds the position of the first entry in this row, while <span>A%ptr</span> <span class="math inline">\((m+1)\)</span> holds the total number of entries plus one. The column indices <span class="math inline">\(j\)</span> and values <span class="math inline">\(a_{ij}\)</span> of the entries in the <span class="math inline">\(i\)</span>-th row are stored in components <span class="math inline">\(l =\)</span> <span>A%ptr</span><span class="math inline">\((i)\)</span>, …,<span>A%ptr</span> <span class="math inline">\((i+1)-1\)</span> of the integer array <span>A%col</span>, and real array <span>A%val</span>, respectively. The same scheme is applicable to <span class="math inline">\({\mathbf{H}}\)</span> (thus requiring integer arrays <span>H%ptr</span>, <span>H%col</span>, and a real array <span>H%val</span>), except that only the entries in the lower triangle need be stored.</p>
<p>For sparse matrices, this scheme almost always requires less storage than its predecessor.</p>
<h3 id="diagonal">Diagonal storage format</h3>
<p>If <span class="math inline">\({\mathbf{H}}\)</span> is diagonal (i.e., <span class="math inline">\(h_{ij} = 0\)</span> for all <span class="math inline">\(1 \leq i \neq j \leq n\)</span>) only the diagonals entries <span class="math inline">\(h_{ii}\)</span>, <span class="math inline">\(1 \leq i \leq n\)</span>, need be stored, and the first <span class="math inline">\(n\)</span> components of the array <span>H%val</span> may be used for the purpose. There is no sensible equivalent for the non-square <span class="math inline">\({\mathbf{A}}\)</span>.</p>
<h3 id="scaled-identity">Scaled-identity-matrix storage format</h3>
<p>If <span class="math inline">\({\mathbf{H}}\)</span> is a scalar multiple of the identity matrix (i.e., <span class="math inline">\(h_{ii} = h_{11}\)</span> and <span class="math inline">\(h_{ij} = 0\)</span> for all <span class="math inline">\(1 \leq i \neq j \leq n\)</span>) only the first diagonal entry <span class="math inline">\(h_{11}\)</span> needs be stored, and the first component of the array <span>H%val</span> may be used for the purpose. Again, there is no sensible equivalent for the non-square <span class="math inline">\({\mathbf{A}}\)</span>.</p>
<h3 id="identity">Identity-matrix storage format</h3>
<p>If <span class="math inline">\({\mathbf{H}}\)</span> is the identity matrix (i.e., <span class="math inline">\(h_{ii} = 1\)</span> and <span class="math inline">\(h_{ij} = 0\)</span> for all <span class="math inline">\(1 \leq i \neq j \leq n\)</span>), no explicit entries needs be stored.</p>
<h3 id="zero">Zero-matrix storage format</h3>
<p>If <span class="math inline">\({\mathbf{H}}= {\mathbf{0}}\)</span> (i.e., <span class="math inline">\(h_{ij} = 0\)</span> for all <span class="math inline">\(1 \leq i, j \leq n\)</span>), no explicit entries needs be stored.</p>
<h2 id="galintkinds"><a href="#galintkinds" data-reference-type="ref" data-reference="galintkinds">2.2</a>. Integer kinds</h2>
<p>We use the term long <span>INTEGER</span> to denote <span>INTEGER(kind=long)</span>, where <span>long = selected_int_kind(18))</span>.</p>
<h2 id="galopenmp"><a href="#galopenmp" data-reference-type="ref" data-reference="galopenmp">2.3</a>. OpenMP</h2>
<p>OpenMP may be used by the <span>GALAHAD_CQP</span> package to provide parallelism for some solver options in shared memory environments. See the documentation for the <span class="sans-serif">GALAHAD</span> package <span>SLS</span> for more details. To run in parallel, OpenMP must be enabled at compilation time by using the correct compiler flag (usually some variant of <span>-openmp</span>). The number of threads may be controlled at runtime by setting the environment variable <span>OMP_NUM_THREADS</span>.</p>
<p>The code may be compiled and run in serial mode.</p>
<h2 id="galtypes"><a href="#galtypes" data-reference-type="ref" data-reference="galtypes">2.4</a>. The derived data types</h2>
<p>Ten derived data types are accessible from the package.</p>
<h3 id="typesmt">The derived data type for holding matrices</h3>
<p>The derived data type <span>SMT_TYPE</span> is used to hold the matrices <span class="math inline">\({\mathbf{A}}\)</span> and <span class="math inline">\({\mathbf{H}}\)</span>. The components of <span>SMT_TYPE</span> used here are:</p>
<dl>
<dt>m</dt>
<dd><p>is a scalar component of type default <span>INTEGER</span>, that holds the number of rows in the matrix.</p>
</dd>
<dt>n</dt>
<dd><p>is a scalar component of type default <span>INTEGER</span>, that holds the number of columns in the matrix.</p>
</dd>
<dt>ne</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that holds the number of matrix entries.</p>
</dd>
<dt>type</dt>
<dd><p>is a rank-one allocatable array of type default <span>CHARACTER</span>, that is used to indicate the matrix storage scheme used. Its precise length and content depends on the type of matrix to be stored (see §<a href="#typeprob" data-reference-type="ref" data-reference="typeprob">2.4.2</a>).</p>
</dd>
<dt>val</dt>
<dd><p>is a rank-one allocatable array of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>)  and dimension at least <span>ne</span>, that holds the values of the entries. Each pair of off-diagonal entries <span class="math inline">\(h_{ij} = h_{ji}\)</span> of a <span><em>symmetric</em></span> matrix <span class="math inline">\({\mathbf{H}}\)</span> is represented as a single entry (see §<a href="#dense" data-reference-type="ref" data-reference="dense">2.1.1</a>–<a href="#rowwise" data-reference-type="ref" data-reference="rowwise">2.1.3</a>). Any duplicated entries that appear in the sparse co-ordinate or row-wise schemes will be summed.</p>
</dd>
<dt>row</dt>
<dd><p>is a rank-one allocatable array of type default <span>INTEGER</span>, and dimension at least <span>ne</span>, that may hold the row indices of the entries. (see §<a href="#coordinate" data-reference-type="ref" data-reference="coordinate">2.1.2</a>).</p>
</dd>
<dt>col</dt>
<dd><p>is a rank-one allocatable array of type default <span>INTEGER</span>, and dimension at least <span>ne</span>, that may the column indices of the entries (see §<a href="#coordinate" data-reference-type="ref" data-reference="coordinate">2.1.2</a>–<a href="#rowwise" data-reference-type="ref" data-reference="rowwise">2.1.3</a>).</p>
</dd>
<dt>ptr</dt>
<dd><p>is a rank-one allocatable array of type default <span>INTEGER</span>, and dimension at least <span>m + 1</span>, that may hold the pointers to the first entry in each row (see §<a href="#rowwise" data-reference-type="ref" data-reference="rowwise">2.1.3</a>).</p>
</dd>
</dl>
<h3 id="typeprob">The derived data type for holding the problem</h3>
<p>The derived data type <span>QPT_problem_type</span> is used to hold the problem. The components of <span>QPT_problem_type</span> are:</p>
<dl>
<dt>n</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that holds the number of optimization variables, <span class="math inline">\(n\)</span>.</p>
</dd>
<dt>m</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that holds the number of general linear constraints, <span class="math inline">\(m\)</span>.</p>
</dd>
<dt>Hessian_kind</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that is used to indicate what type of Hessian the problem involves. Possible values for <span>Hessian_kind</span> are:</p>
<dl>
<dt>&lt;0</dt>
<dd><p>In this case, a general quadratic program of the form (<a href="#qp" data-reference-type="ref" data-reference="qp">[qp]</a>) is given. The Hessian matrix <span class="math inline">\({\mathbf{H}}\)</span> will be provided in the component <span>H</span> (see below).</p>
</dd>
<dt>0</dt>
<dd><p>In this case, a linear program, that is a problem of the form (<a href="#lsqp" data-reference-type="ref" data-reference="lsqp">[lsqp]</a>) with weights <span class="math inline">\({\mathbf{w}}= 0\)</span>, is given.</p>
</dd>
<dt>1</dt>
<dd><p>In this case, a least-distance problem of the form (<a href="#lsqp" data-reference-type="ref" data-reference="lsqp">[lsqp]</a>) with weights <span class="math inline">\(w_{j} = 1\)</span> for <span class="math inline">\(j = 1, \ldots , n\)</span> is given.</p>
</dd>
<dt>&gt;1</dt>
<dd><p>In this case, a weighted least-distance problem of the form (<a href="#lsqp" data-reference-type="ref" data-reference="lsqp">[lsqp]</a>) with general weights <span class="math inline">\({\mathbf{w}}\)</span> is given. The weights will be provided in the component <span>WEIGHT</span> (see below).</p>
</dd>
</dl>
</dd>
<dt>H</dt>
<dd><p>is scalar variable of type <span>SMT_TYPE</span> that holds the Hessian matrix <span class="math inline">\({\mathbf{H}}\)</span> whenever <span>Hessian_kind</span> <span class="math inline">\(&lt;0\)</span>. The following components are used:</p>
<dl>
<dt>H%type</dt>
<dd><p>is an allocatable array of rank one and type default <span>CHARACTER</span>, that is used to indicate the storage scheme used. If the dense storage scheme (see Section <a href="#dense" data-reference-type="ref" data-reference="dense">2.1.1</a>) is used, the first five components of <span>H%type</span> must contain the string <span>DENSE</span>. For the sparse co-ordinate scheme (see Section <a href="#coordinate" data-reference-type="ref" data-reference="coordinate">2.1.2</a>), the first ten components of <span>H%type</span> must contain the string <span>COORDINATE</span>, for the sparse row-wise storage scheme (see Section <a href="#rowwise" data-reference-type="ref" data-reference="rowwise">2.1.3</a>), the first fourteen components of <span>H%type</span> must contain the string <span>SPARSE_BY_ROWS</span>, and for the diagonal storage scheme (see Section <a href="#diagonal" data-reference-type="ref" data-reference="diagonal">2.1.4</a>), the first eight components of <span>H%type</span> must contain the string <span>DIAGONAL</span>, for the scaled-identity matrix storage scheme (see Section <a href="#scaled-identity" data-reference-type="ref" data-reference="scaled-identity">2.1.5</a>), the first fifteen components of <span>H%type</span> must contain the string <span>SCALED_IDENTITY</span>, for the identity matrix storage scheme (see Section <a href="#identity" data-reference-type="ref" data-reference="identity">2.1.6</a>), the first eight components of <span>H%type</span> must contain the string <span>IDENTITY</span>, and for the zero matrix storage scheme (see Section <a href="#zero" data-reference-type="ref" data-reference="zero">2.1.7</a>), the first four components of <span>H%type</span> must contain the string <span>ZERO</span>.</p>
<p>For convenience, the procedure <span>SMT_put</span> may be used to allocate sufficient space and insert the required keyword into <span>H%type</span>. For example, if <span>prob</span> is of derived type <span>CQP_problem_type</span> and involves a Hessian we wish to store using the co-ordinate scheme, we may simply</p>
<pre><code>        CALL SMT_put( prob%H%type, &#39;COORDINATE&#39;, istat )</code></pre>
<p>See the documentation for the <span class="sans-serif">GALAHAD</span> package <span>SMT</span> for further details on the use of <span>SMT_put</span>.</p>
</dd>
<dt>H%ne</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that holds the number of entries in the <span><strong>lower triangular</strong></span> part of <span class="math inline">\({\mathbf{H}}\)</span> in the sparse co-ordinate storage scheme (see Section <a href="#coordinate" data-reference-type="ref" data-reference="coordinate">2.1.2</a>). It need not be set for any of the other schemes.</p>
</dd>
<dt>H%val</dt>
<dd><p>is a rank-one allocatable array of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the values of the entries of the <span><strong>lower triangular</strong></span> part of the Hessian matrix <span class="math inline">\({\mathbf{H}}\)</span> in any of non-trivial storage schemes mentioned in Sections <a href="#coordinate" data-reference-type="ref" data-reference="coordinate">2.1.2</a>–<a href="#diagonal" data-reference-type="ref" data-reference="diagonal">2.1.4</a>. For the scaled-identity scheme (see Section <a href="#scaled-identity" data-reference-type="ref" data-reference="scaled-identity">2.1.5</a>), the first component, <span>H%val(1)</span>, holds the scale factor <span class="math inline">\(h_{11}\)</span>. It need not be allocated for any of the remaining schemes.</p>
</dd>
<dt>H%row</dt>
<dd><p>is a rank-one allocatable array of type default <span>INTEGER</span>, that holds the row indices of the <span><strong>lower triangular</strong></span> part of <span class="math inline">\({\mathbf{H}}\)</span> in the sparse co-ordinate storage scheme (see Section <a href="#coordinate" data-reference-type="ref" data-reference="coordinate">2.1.2</a>). It need not be allocated for any of the other schemes.</p>
</dd>
<dt>H%col</dt>
<dd><p>is a rank-one allocatable array variable of type default <span>INTEGER</span>, that holds the column indices of the <span><strong>lower triangular</strong></span> part of <span class="math inline">\({\mathbf{H}}\)</span> in either the sparse co-ordinate (see Section <a href="#coordinate" data-reference-type="ref" data-reference="coordinate">2.1.2</a>), or the sparse row-wise (see Section <a href="#rowwise" data-reference-type="ref" data-reference="rowwise">2.1.3</a>) storage scheme. It need not be allocated when any of the other storage schemes are used.</p>
</dd>
<dt>H%ptr</dt>
<dd><p>is a rank-one allocatable array of dimension <span>n+1</span> and type default <span>INTEGER</span>, that holds the starting position of each row of the <span><strong>lower triangular</strong></span> part of <span class="math inline">\({\mathbf{H}}\)</span>, as well as the total number of entries plus one, in the sparse row-wise storage scheme (see Section <a href="#rowwise" data-reference-type="ref" data-reference="rowwise">2.1.3</a>). It need not be allocated when the other schemes are used.</p>
</dd>
</dl>
<p>If <span>Hessian_kind</span> <span class="math inline">\(\geq 0\)</span>, the components of <span>H</span> need not be set.</p>
</dd>
<dt>WEIGHT</dt>
<dd><p>is a rank-one allocatable array type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that should be allocated to have length <span>n</span>, and its <span class="math inline">\(j\)</span>-th component filled with the value <span class="math inline">\(w_{j}\)</span> for <span class="math inline">\(j = 1, \ldots , n\)</span>, whenever <span>Hessian_kind</span> <span class="math inline">\(&gt;1\)</span>. If <span>Hessian_kind</span> <span class="math inline">\(\leq 1\)</span>, <span>WEIGHT</span> need not be allocated.</p>
</dd>
<dt>target_kind</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that is used to indicate whether the components of the targets <span class="math inline">\({\mathbf{x}}^0\)</span> (if they are used) have special or general values. Possible values for <span>target_kind</span> are:</p>
<dl>
<dt>0</dt>
<dd><p>In this case, <span class="math inline">\({\mathbf{x}}^0 = 0\)</span>.</p>
</dd>
<dt>1</dt>
<dd><p>In this case, <span class="math inline">\(x^0_{j} = 1\)</span> for <span class="math inline">\(j = 1, \ldots , n\)</span>.</p>
</dd>
<dt><span class="math inline">\(\neq\)</span> 0,1</dt>
<dd><p>In this case, general values of <span class="math inline">\({\mathbf{x}}^0\)</span> will be used, and will be provided in the component <span>X0</span> (see below).</p>
</dd>
</dl>
</dd>
<dt>X0</dt>
<dd><p>is a rank-one allocatable array type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that should be allocated to have length <span>n</span>, and its <span class="math inline">\(j\)</span>-th component filled with the value <span class="math inline">\(x_{j}^0\)</span> for <span class="math inline">\(j = 1, \ldots , n\)</span>, whenever <span>Hessian_kind</span> <span class="math inline">\(&gt;0\)</span> and <span>target_kind</span> <span class="math inline">\(\neq 0,1\)</span>. If <span>Hessian_kind</span> <span class="math inline">\(\leq 0\)</span> or <span>target_kind</span> <span class="math inline">\(= 0,1\)</span>, <span>X0</span> need not be allocated.</p>
</dd>
<dt>gradient_kind</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that is used to indicate whether the components of the gradient <span class="math inline">\({\mathbf{g}}\)</span> have special or general values. Possible values for <span>gradient_kind</span> are:</p>
<dl>
<dt>0</dt>
<dd><p>In this case, <span class="math inline">\({\mathbf{g}}= 0\)</span>.</p>
</dd>
<dt>1</dt>
<dd><p>In this case, <span class="math inline">\(g_{j} = 1\)</span> for <span class="math inline">\(j = 1, \ldots , n\)</span>.</p>
</dd>
<dt><span class="math inline">\(\neq\)</span> 0,1</dt>
<dd><p>In this case, general values of <span class="math inline">\({\mathbf{g}}\)</span> will be used, and will be provided in the component <span>G</span> (see below).</p>
</dd>
</dl>
</dd>
<dt>G</dt>
<dd><p>is a rank-one allocatable array type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that should be allocated to have length <span>n</span>, and its <span class="math inline">\(j\)</span>-th component filled with the value <span class="math inline">\(g_{j}\)</span> for <span class="math inline">\(j = 1, \ldots , n\)</span>, whenever <span>gradient_kind</span> <span class="math inline">\(\neq\)</span> 0,1. If <span>gradient_kind</span> <span>= 0, 1</span>, <span>G</span> need not be allocated.</p>
</dd>
<dt>f</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the constant term, <span class="math inline">\(f\)</span>, in the objective function.</p>
</dd>
<dt>A</dt>
<dd><p>is scalar variable of type <span>SMT_TYPE</span> that holds the Jacobian matrix <span class="math inline">\({\mathbf{A}}\)</span> when it is available explicitly. The following components are used:</p>
<dl>
<dt>A%type</dt>
<dd><p>is an allocatable array of rank one and type default <span>CHARACTER</span>, that is used to indicate the storage scheme used. If the dense storage scheme (see Section <a href="#dense" data-reference-type="ref" data-reference="dense">2.1.1</a>) is used, the first five components of <span>A%type</span> must contain the string <span>DENSE</span>. For the sparse co-ordinate scheme (see Section <a href="#coordinate" data-reference-type="ref" data-reference="coordinate">2.1.2</a>), the first ten components of <span>A%type</span> must contain the string <span>COORDINATE</span>, while for the sparse row-wise storage scheme (see Section <a href="#rowwise" data-reference-type="ref" data-reference="rowwise">2.1.3</a>), the first fourteen components of <span>A%type</span> must contain the string <span>SPARSE_BY_ROWS</span>.</p>
<p>Just as for <span>H%type</span> above, the procedure <span>SMT_put</span> may be used to allocate sufficient space and insert the required keyword into <span>A%type</span>. Once again, if <span>prob</span> is of derived type <span>CQP_problem_type</span> and involves a Jacobian we wish to store using the sparse row-wise storage scheme, we may simply</p>
<pre><code>        CALL SMT_put( prob%A%type, &#39;SPARSE_BY_ROWS&#39;, istat )</code></pre>
</dd>
<dt>A%ne</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that holds the number of entries in <span class="math inline">\({\mathbf{A}}\)</span> in the sparse co-ordinate storage scheme (see Section <a href="#coordinate" data-reference-type="ref" data-reference="coordinate">2.1.2</a>). It need not be set for either of the other two appropriate schemes.</p>
</dd>
<dt>A%val</dt>
<dd><p>is a rank-one allocatable array of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the values of the entries of the Jacobian matrix <span class="math inline">\({\mathbf{A}}\)</span> in any of the appropriate storage schemes discussed in Section <a href="#galmatrix" data-reference-type="ref" data-reference="galmatrix">2.1</a>.</p>
</dd>
<dt>A%row</dt>
<dd><p>is a rank-one allocatable array of type default <span>INTEGER</span>, that holds the row indices of <span class="math inline">\({\mathbf{A}}\)</span> in the sparse co-ordinate storage scheme (see Section <a href="#coordinate" data-reference-type="ref" data-reference="coordinate">2.1.2</a>). It need not be allocated for either of the other two appropriate schemes.</p>
</dd>
<dt>A%col</dt>
<dd><p>is a rank-one allocatable array variable of type default <span>INTEGER</span>, that holds the column indices of <span class="math inline">\({\mathbf{A}}\)</span> in either the sparse co-ordinate (see Section <a href="#coordinate" data-reference-type="ref" data-reference="coordinate">2.1.2</a>), or the sparse row-wise (see Section <a href="#rowwise" data-reference-type="ref" data-reference="rowwise">2.1.3</a>) storage scheme. It need not be allocated when the dense storage scheme is used.</p>
</dd>
<dt>A%ptr</dt>
<dd><p>is a rank-one allocatable array of dimension <span>m+1</span> and type default <span>INTEGER</span>, that holds the starting position of each row of <span class="math inline">\({\mathbf{A}}\)</span>, as well as the total number of entries plus one, in the sparse row-wise storage scheme (see Section <a href="#rowwise" data-reference-type="ref" data-reference="rowwise">2.1.3</a>). It need not be allocated when the other appropriate schemes are used.</p>
</dd>
</dl>
</dd>
<dt>C_l</dt>
<dd><p>is a rank-one allocatable array of dimension <span>m</span> and type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the vector of lower bounds <span class="math inline">\({\mathbf{c}}^{l}\)</span> on the general constraints. The <span class="math inline">\(i\)</span>-th component of <span>C_l</span>, <span class="math inline">\(i = 1, \ldots , m\)</span>, contains <span class="math inline">\({\mathbf{c}}_{i}^{l}\)</span>. Infinite bounds are allowed by setting the corresponding components of <span>C_l</span> to any value smaller than <span>-infinity</span>, where <span>infinity</span> is a component of the control array <span>control</span> (see Section <a href="#typecontrol" data-reference-type="ref" data-reference="typecontrol">2.4.3</a>).</p>
</dd>
<dt>C_u</dt>
<dd><p>is a rank-one allocatable array of dimension <span>m</span> and type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the vector of upper bounds <span class="math inline">\({\mathbf{c}}^{u}\)</span> on the general constraints. The <span class="math inline">\(i\)</span>-th component of <span>C_u</span>, <span class="math inline">\(i = 1,  \ldots ,  m\)</span>, contains <span class="math inline">\({\mathbf{c}}_{i}^{u}\)</span>. Infinite bounds are allowed by setting the corresponding components of <span>C_u</span> to any value larger than <span>infinity</span>, where <span>infinity</span> is a component of the control array <span>control</span> (see Section <a href="#typecontrol" data-reference-type="ref" data-reference="typecontrol">2.4.3</a>).</p>
</dd>
<dt>X_l</dt>
<dd><p>is a rank-one allocatable array of dimension <span>n</span> and type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the vector of lower bounds <span class="math inline">\({\mathbf{x}}^{l}\)</span> on the the variables. The <span class="math inline">\(j\)</span>-th component of <span>X_l</span>, <span class="math inline">\(j = 1, \ldots , n\)</span>, contains <span class="math inline">\({\mathbf{x}}_{j}^{l}\)</span>. Infinite bounds are allowed by setting the corresponding components of <span>X_l</span> to any value smaller than <span>-infinity</span>, where <span>infinity</span> is a component of the control array <span>control</span> (see Section <a href="#typecontrol" data-reference-type="ref" data-reference="typecontrol">2.4.3</a>).</p>
</dd>
<dt>X_u</dt>
<dd><p>is a rank-one allocatable array of dimension <span>n</span> and type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the vector of upper bounds <span class="math inline">\({\mathbf{x}}^{u}\)</span> on the variables. The <span class="math inline">\(j\)</span>-th component of <span>X_u</span>, <span class="math inline">\(j = 1, \ldots , n\)</span>, contains <span class="math inline">\({\mathbf{x}}_{j}^{u}\)</span>. Infinite bounds are allowed by setting the corresponding components of <span>X_u</span> to any value larger than that <span>infinity</span>, where <span>infinity</span> is a component of the control array <span>control</span> (see Section <a href="#typecontrol" data-reference-type="ref" data-reference="typecontrol">2.4.3</a>).</p>
</dd>
<dt>X</dt>
<dd><p>is a rank-one allocatable array of dimension <span>n</span> and type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the values <span class="math inline">\({\mathbf{x}}\)</span> of the optimization variables. The <span class="math inline">\(j\)</span>-th component of <span>X</span>, <span class="math inline">\(j = 1,  \ldots , n\)</span>, contains <span class="math inline">\(x_{j}\)</span>.</p>
</dd>
<dt>C</dt>
<dd><p>is a rank-one allocatable array of dimension <span>m</span> and type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the values <span class="math inline">\({\mathbf{A}}{\mathbf{x}}\)</span> of the constraints. The <span class="math inline">\(i\)</span>-th component of <span>C</span>, <span class="math inline">\(i = 1,  \ldots ,  m\)</span>, contains <span class="math inline">\({\mathbf{a}}_{i}^{T}{\mathbf{x}}\equiv ({\mathbf{A}}{\mathbf{x}})_{i}\)</span>.</p>
</dd>
<dt>Y</dt>
<dd><p>is a rank-one allocatable array of dimension <span>m</span> and type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the values <span class="math inline">\({\mathbf{y}}\)</span> of estimates of the Lagrange multipliers corresponding to the general linear constraints (see Section <a href="#galmethod" data-reference-type="ref" data-reference="galmethod">4</a>). The <span class="math inline">\(i\)</span>-th component of <span>Y</span>, <span class="math inline">\(i = 1,  \ldots ,  m\)</span>, contains <span class="math inline">\(y_{i}\)</span>.</p>
</dd>
<dt>Z</dt>
<dd><p>is a rank-one allocatable array of dimension <span>n</span> and type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the values <span class="math inline">\({\mathbf{z}}\)</span> of estimates of the dual variables corresponding to the simple bound constraints (see Section <a href="#galmethod" data-reference-type="ref" data-reference="galmethod">4</a>). The <span class="math inline">\(j\)</span>-th component of <span>Z</span>, <span class="math inline">\(j = 1,  \ldots ,  n\)</span>, contains <span class="math inline">\(z_{j}\)</span>.</p>
</dd>
</dl>
<h3 id="typecontrol">The derived data type for holding control parameters</h3>
<p>The derived data type <span>CQP_control_type</span> is used to hold controlling data. Default values may be obtained by calling <span>CQP_initialize</span> (see Section <a href="#subinit" data-reference-type="ref" data-reference="subinit">2.5.1</a>), while components may also be changed by calling <span>CQP_read_specfile</span> (see Section <a href="#readspec" data-reference-type="ref" data-reference="readspec">2.7.1</a>). The components of <span>CQP_control_type</span> are:</p>
<dl>
<dt>error</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that holds the stream number for error messages. Printing of error messages in <span>CQP_solve</span> and <span>CQP_terminate</span> is suppressed if <span>error</span> <span class="math inline">\(\leq 0\)</span>. The default is <span>error = 6</span>.</p>
</dd>
<dt>out</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that holds the stream number for informational messages. Printing of informational messages in <span>CQP_solve</span> is suppressed if <span>out</span> <span class="math inline">\(&lt; 0\)</span>. The default is <span>out = 6</span>.</p>
</dd>
<dt>print_level</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that is used to control the amount of informational output which is required. No informational output will occur if <span>print_level</span> <span class="math inline">\(\leq 0\)</span>. If <span>print_level</span> <span class="math inline">\(= 1\)</span>, a single line of output will be produced for each iteration of the process. If <span>print_level</span> <span class="math inline">\(\geq 2\)</span>, this output will be increased to provide significant detail of each iteration. The default is <span>print_level = 0</span>.</p>
</dd>
<dt>maxit</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that holds the maximum number of iterations which will be allowed in <span>CQP_solve</span>. The default is <span>maxit = 1000</span>.</p>
</dd>
<dt>start_print</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that specifies the first iteration for which printing will occur in <span>CQP_solve</span>. If <span>start_print</span> is negative, printing will occur from the outset. The default is <span>start_print = -1</span>.</p>
</dd>
<dt>stop_print</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that specifies the last iteration for which printing will occur in <span>CQP_solve</span>. If <span>stop_print</span> is negative, printing will occur once it has been started by <span>start_print</span>. The default is <span>stop_print = -1</span>.</p>
</dd>
<dt>infeas_max</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that specifies the number of iterations for which the overall infeasibility of the problem is not reduced by at least a factor <span>reduce_infeas before</span> the problem is flagged as infeasible (see <span>reduce_infeas</span>). The default is <span>infeas_max = 200</span>.</p>
</dd>
<dt>muzero_fixed</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that specifies the number of iterations before the initial barrier parameter (see <span>muzero</span>) may be altered. The default is <span>muzero_fixed = 1</span>.</p>
</dd>
<dt>indicator_type</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that specifies the type of indicator used to assess when a variable or constraint is active. Possible values are:</p>
<dl>
<dt>1</dt>
<dd><p>a variable/constraint is active if and only if the distance to its neaerest bound is no larger than <span>indicator_tol_p</span> (see below).</p>
</dd>
<dt>2</dt>
<dd><p>a variable/constraint is active if and only if the distance to its neaerest bound is no larger than <span>indicator_tol_pd</span> (see below) times the magnitude of its corresponding dual variable.</p>
</dd>
<dt>3</dt>
<dd><p>a variable/constraint is active if and only if the distance to its neaerest bound is no larger than <span>indicator_tol_tapia</span> (see below) times the distance to the same bound at the previous iteration.</p>
</dd>
</dl>
<p>The default is <span>indicator_type = 3</span>.</p>
</dd>
<dt>arc</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that specifies the type of residual trajectory used to define the path to the solution. Possible values are:</p>
<dl>
<dt>1</dt>
<dd><p>the residual trajectory proposed by Zhang will be used.</p>
</dd>
<dt>2</dt>
<dd><p>the residual trajectory proposed by Zhao and Sun will be used; note this trajectory does not necessarily ensure convergence, so should be used with caution.</p>
</dd>
<dt>3</dt>
<dd><p>a combination in which Zhang’s trajectory is used until the method determines that Zhou and Sun’s will be better.</p>
</dd>
<dt>4</dt>
<dd><p>a mixed linear-quadratic variant of Zhang’s proposal will be used.</p>
</dd>
</dl>
<p>The default is <span>arc = 1</span>.</p>
</dd>
<dt>series_order</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that specifies the order of (Puiseux or Taylor) series to approximate the residual trajectory. The default is <span>series_order = 2</span>.</p>
</dd>
<dt>infinity</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that is used to specify which constraint bounds are infinite. Any bound larger than <span>infinity</span> in modulus will be regarded as infinite. The default is <span>infinity =</span> <span class="math inline">\(10^{19}\)</span>.</p>
</dd>
<dt>stop_abs_p</dt>
<dd><p>and <span>stop_rel_p</span> are scalar variables of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that hold the required absolute and relative accuracy for the primal infeasibility (see Section <a href="#galmethod" data-reference-type="ref" data-reference="galmethod">4</a>). The absolute value of each component of the primal infeasibility on exit is required to be smaller than the larger of <span>stop_abs_p</span> and <span>stop_rel_p</span> times a “typical value” for this component. The defaults are <span>stop_abs_p =</span> <span>stop_rel_p =</span> <span class="math inline">\(u^{1/3}\)</span>, where <span class="math inline">\(u\)</span> is <span>EPSILON(1.0)</span> (<span>EPSILON(1.0D0)</span> in <span>GALAHAD_CQP_double</span>).</p>
</dd>
<dt>stop_abs_d</dt>
<dd><p>and <span>stop_rel_d</span> are scalar variables of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that hold the required absolute and relative accuracy for the dual infeasibility (see Section <a href="#galmethod" data-reference-type="ref" data-reference="galmethod">4</a>). The absolute value of each component of the dual infeasibility on exit is required to be smaller than the larger of <span>stop_abs_p</span> and <span>stop_rel_p</span> times a “typical value” for this component. The defaults are <span>stop_abs_d =</span> <span>stop_rel_d =</span> <span class="math inline">\(u^{1/3}\)</span>, where <span class="math inline">\(u\)</span> is <span>EPSILON(1.0)</span> (<span>EPSILON(1.0D0)</span> in <span>GALAHAD_CQP_double</span>).</p>
</dd>
<dt>stop_abs_c</dt>
<dd><p>and <span>stop_rel_c</span> are scalar variables of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that hold the required absolute and relative accuracy for the violation of complementary slackness (see Section <a href="#galmethod" data-reference-type="ref" data-reference="galmethod">4</a>). The absolute value of each component of the complementary slackness on exit is required to be smaller than the larger of <span>stop_abs_p</span> and <span>stop_rel_p</span> times a “typical value” for this component. The defaults are <span>stop_abs_c =</span> <span>stop_rel_c =</span> <span class="math inline">\(u^{1/3}\)</span>, where <span class="math inline">\(u\)</span> is <span>EPSILON(1.0)</span> (<span>EPSILON(1.0D0)</span> in <span>GALAHAD_CQP_double</span>).</p>
</dd>
<dt>perturb_h</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that specifies any perturbation that is to be added to the diagonal of <span class="math inline">\({\mathbf{H}}\)</span>. The default is <span>perturb_h = 0.0</span>.</p>
</dd>
<dt>prfeas</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that aims to specify the closest that any initial variable may be to infeasibility. Any variable closer to infeasibility than <span>prfeas</span> will be moved to <span>prfeas</span> from the offending bound. However, if a variable is range bounded, and its bounds are closer than <span>prfeas</span> apart, it will be moved to the mid-point of the two bounds. The default is <span>prfeas = <span class="math inline">\(10^4\)</span></span>.</p>
</dd>
<dt>dufeas</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that aims to specify the closest that any initial dual variable or Lagrange multiplier may be to infeasibility. Any variable closer to infeasibility than <span>prfeas</span> will be moved to <span>dufeas</span> from the offending bound. However, if a dual variable is range bounded, and its bounds are closer than <span>dufeas</span> apart, it will be moved to the mid-point of the two bounds. The default is <span>dufeas = <span class="math inline">\(10^4\)</span></span>.</p>
</dd>
<dt>muzero</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the initial value of the barrier parameter. If <span>muzero</span> is not positive, it will be reset automatically to an appropriate value. The default is <span>muzero = -1.0</span>.</p>
</dd>
<dt>tau</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the weight attached to primal-dual infeasibility compared to complementarity when assessing step acceptance. The default is <span>tau = 1.0</span>.</p>
</dd>
<dt>gamma_c</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the smallest value that individual complementarity pairs are allowed to be relative to the average as the iteration proceeds. The default is <span>gamma_c = <span class="math inline">\(10^{-5}\)</span></span>.</p>
</dd>
<dt>gamma_f</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the smallest value the average complementarity is allowed to be relative to the primal-dual infeasibility as the iteration proceeds. The default is <span>gamma_c = <span class="math inline">\(10^{-5}\)</span></span>.</p>
</dd>
<dt>reduce_infeas</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that specifies the least factor by which the overall infeasibility of the problem must be reduced, over <span>infeas_max</span> consecutive iterations, for it not be declared infeasible (see <span>infeas_max)</span>. The default is <span>reduce_infeas = 0.99</span>.</p>
</dd>
<dt>obj_unbounded</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that specifies smallest value of the objective function that will be tolerated before the problem is declared to be unbounded from below. The default is <span>obj_unbounded =</span> <span class="math inline">\(-u^{-2}\)</span>, where <span class="math inline">\(u\)</span> is <span>EPSILON(1.0)</span> (<span>EPSILON(1.0D0)</span> in <span>GALAHAD_CQP_double</span>).</p>
</dd>
<dt>potential_unbounded</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that specifies smallest value of the potential function divided by the number of one-sided variable and constraint bounds that will be tolerated before the analytic center is declared to be unbounded. The default is <span>potential_unbounded = -10.0</span>.</p>
</dd>
<dt>identical_bounds_tol</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>). Every pair of constraint bounds <span class="math inline">\((c_{i}^{l}, c_{i}^{u})\)</span> or <span class="math inline">\((x_{j}^{l}, x_{j}^{u})\)</span> that is closer than <span>identical_bounds_tol</span> will be reset to the average of their values, <span class="math inline">\({\frac{1}{2}}(c_{i}^{l} + c_{i}^{u})\)</span> or <span class="math inline">\({\frac{1}{2}}(x_{j}^{l} + x_{j}^{u})\)</span> respectively. The default is <span>identical_bounds_tol =</span> <span class="math inline">\(u\)</span>, where <span class="math inline">\(u\)</span> is <span>EPSILON(1.0)</span> (<span>EPSILON(1.0D0)</span> in <span>GALAHAD_CQP_double</span>).</p>
</dd>
<dt>indicator_tol_p</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>)that provides the indicator tolerance associated with the test <span>indicator_type = 1</span>. The default is <span>indicator_tol_p =</span> <span class="math inline">\(u^{1/3}\)</span>, where <span class="math inline">\(u\)</span> is <span>EPSILON(1.0)</span> (<span>EPSILON(1.0D0)</span> in <span>GALAHAD_CQP_double</span>).</p>
</dd>
<dt>indicator_tol_pd</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>)that provides the indicator tolerance associated with the test <span>indicator_type = 2</span>. The default is <span>indicator_tol_pd =</span> 1.0.</p>
</dd>
<dt>indicator_tol_tapia</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>)that provides the indicator tolerance associated with the test <span>indicator_type = 3</span>. The default is <span>indicator_tol_tapia =</span> 0.9.</p>
</dd>
<dt>cpu_time_limit</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that is used to specify the maximum permitted CPU time. Any negative value indicates no limit will be imposed. The default is <span>cpu_time_limit = - 1.0</span>.</p>
</dd>
<dt>clock_time_limit</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that is used to specify the maximum permitted elapsed system clock time. Any negative value indicates no limit will be imposed. The default is <span>clock_time_limit = - 1.0</span>.</p>
</dd>
<dt>remove_dependencies</dt>
<dd><p>is a scalar variable of type default <span>LOGICAL</span>, that must be set <span>.TRUE.</span> if the algorithm is to attempt to remove any linearly dependent constraints before solving the problem, and <span>.FALSE.</span> otherwise. We recommend removing linearly dependencies. The default is <span>remove_dependencies = .TRUE.</span>.</p>
</dd>
<dt>treat_zero_bounds_as_general</dt>
<dd><p>is a scalar variable of type default <span>LOGICAL</span>. If it is set to <span>.FALSE.</span>, variables which are only bounded on one side, and whose bound is zero, will be recognised as non-negativities/non-positivities rather than simply as lower- or upper-bounded variables. If it is set to <span>.TRUE.</span>, any variable bound <span class="math inline">\(x_{j}^{l}\)</span> or <span class="math inline">\(x_{j}^{u}\)</span> which has the value 0.0 will be treated as if it had a general value. Setting <span>treat_zero_bounds_as_general</span> to <span>.TRUE.</span> has the advantage that if a sequence of problems are reordered, then bounds which are “accidentally” zero will be considered to have the same structure as those which are nonzero. However, <span>GALAHAD_CQP</span> is able to take special advantage of non-negativities/non-positivities, so if a single problem, or if a sequence of problems whose bound structure is known not to change, is/are to be solved, it will pay to set the variable to <span>.FALSE.</span>. The default is <span>treat_zero_bounds_as_general = .FALSE.</span>.</p>
</dd>
<dt>just_feasible</dt>
<dd><p>is a scalar variable of type default <span>LOGICAL</span>, that must be set <span>.TRUE.</span> if the algorithm should stop as soon as a feasible point of the constraint set is found, and <span>.FALSE.</span> otherwise. The default is <span>just_feasible = .FALSE.</span>.</p>
</dd>
<dt>getdua</dt>
<dd><p>is a scalar variable of type default <span>LOGICAL</span>, that must be set <span>.TRUE.</span> if the user-provided estimates of the dual variables should be replaced by estimates whose aim is to try to balance the requirements of dual feasibility and complementary slackness, and <span>.FALSE.</span> if users estimates are to be used. The default is <span>getdua = .FALSE.</span>.</p>
</dd>
<dt>puiseux</dt>
<dd><p>is a scalar variable of type default <span>LOGICAL</span>, that must be set <span>.TRUE.</span> if a Puiseux series will be used when extrapolating along the central path and <span>.FALSE.</span> if a Taylor series is preferred. We recommend using the Puiseux series unless the solution is known to be non-degenerate. The default is <span>puiseux = .TRUE.</span>.</p>
</dd>
<dt>every_order</dt>
<dd><p>is a scalar variable of type default <span>LOGICAL</span>, that must be set <span>.TRUE.</span> if every order of approximation up to <span>series_order</span> will be tried and the best taken, and <span>.FALSE.</span> if only the exact order specified by <span>series_order</span> will be used. The default is <span>every_order = .TRUE.</span>.</p>
</dd>
<dt>feasol</dt>
<dd><p>is a scalar variable of type default <span>LOGICAL</span>, that should be set <span>.TRUE.</span> if the final solution obtained will be perturbed so that variables close to their bounds are moved onto these bounds, and <span>.FALSE.</span> otherwise. The default is <span>feasol = .FALSE.</span>.</p>
</dd>
<dt>crossover</dt>
<dd><p>is a scalar variable of type default <span>LOGICAL</span>, that must be set <span>.TRUE.</span> if the solution is to be defined in terms of linearly-independent constraints, and <span>.FALSE.</span> otherwise. The default is <span>crossover = .TRUE.</span>.</p>
</dd>
<dt>space_critical</dt>
<dd><p>is a scalar variable of type default <span>LOGICAL</span>, that must be set <span>.TRUE.</span> if space is critical when allocating arrays and <span>.FALSE.</span> otherwise. The package may run faster if <span>space_critical</span> is <span>.FALSE.</span> but at the possible expense of a larger storage requirement. The default is <span>space_critical = .FALSE.</span>.</p>
</dd>
<dt>deallocate_error_fatal</dt>
<dd><p>is a scalar variable of type default <span>LOGICAL</span>, that must be set <span>.TRUE.</span> if the user wishes to terminate execution if a deallocation fails, and <span>.FALSE.</span> if an attempt to continue will be made. The default is <span>deallocate_error_fatal = .FALSE.</span>.</p>
</dd>
<dt>prefix</dt>
<dd><p>is a scalar variable of type default <span>CHARACTER</span> and length 30, that may be used to provide a user-selected character string to preface every line of printed output. Specifically, each line of output will be prefaced by the string <span>prefix(2:LEN(TRIM(prefix))-1)</span>, thus ignoring the first and last non-null components of the supplied string. If the user does not want to preface lines by such a string, they may use the default <span>prefix = ""</span>.</p>
</dd>
<dt>FDC_control</dt>
<dd><p>is a scalar variable of type <span>FDC_control_type</span> whose components are used to control any detection of linear dependencies performed by the package <span>GALAHAD_FDC</span>. See the specification sheet for the package <span>GALAHAD_FDC</span> for details, and appropriate default values.</p>
</dd>
<dt>SBLS_control</dt>
<dd><p>is a scalar variable of type <span>SBLS_control_type</span> whose components are used to control factorizations performed by the package <span>GALAHAD_SBLS</span>. See the specification sheet for the package <span>GALAHAD_SBLS</span> for details, and appropriate default values.</p>
</dd>
<dt>FIT_control</dt>
<dd><p>is a scalar variable of type <span>FIT_control_type</span> whose components are used to control fitting of data to polynomials performed by the package <span>GALAHAD_FIT</span>. See the specification sheet for the package <span>GALAHAD_FIT</span> for details, and appropriate default values.</p>
</dd>
<dt>ROOTS_control</dt>
<dd><p>is a scalar variable of type <span>ROOTS_control_type</span> whose components are used to control the polynomial root finding performed by the package <span>GALAHAD_ROOTS</span>. See the specification sheet for the package <span>GALAHAD_ROOTS</span> for details, and appropriate default values.</p>
</dd>
<dt>CRO_control</dt>
<dd><p>is a scalar variable of type <span>CRO_control_type</span> whose components are used to control crossover performed by the package <span>GALAHAD_CRO</span>. See the specification sheet for the package <span>GALAHAD_CRO</span> for details, and appropriate default values.</p>
</dd>
</dl>
<h3 id="typetime">The derived data type for holding timing information</h3>
<p>The derived data type <span>CQP_time_type</span> is used to hold elapsed CPU and system clock times for the various parts of the calculation. The components of <span>CQP_time_type</span> are:</p>
<dl>
<dt>total</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that gives the total CPU time spent in the package.</p>
</dd>
<dt>preprocess</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that gives the CPU time spent preprocess the problem prior to solution.</p>
</dd>
<dt>find_dependent</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that gives the CPU time spent detecting and removing dependent constraints prior to solution.</p>
</dd>
<dt>analyse</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that gives the CPU time spent analysing the required matrices prior to factorization.</p>
</dd>
<dt>factorize</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that gives the CPU time spent factorizing the required matrices.</p>
</dd>
<dt>solve</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that gives the CPU time spent computing the search direction.</p>
</dd>
<dt>clock_total</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that gives the total elapsed system clock time spent in the package.</p>
</dd>
<dt>clock_preprocess</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that gives the elapsed system clock time spent preprocess the problem prior to solution.</p>
</dd>
<dt>clock_find_dependent</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that gives the elapsed system clock time spent detecting and removing dependent constraints prior to solution.</p>
</dd>
<dt>clock_analyse</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that gives the elapsed system clock time spent analysing the required matrices prior to factorization.</p>
</dd>
<dt>clock_factorize</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that gives the elapsed system clock time spent factorizing the required matrices.</p>
</dd>
<dt>clock_solve</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that gives the elapsed system clock time spent computing the search direction.</p>
</dd>
</dl>
<h3 id="typeinform">The derived data type for holding informational parameters</h3>
<p>The derived data type <span>CQP_inform_type</span> is used to hold parameters that give information about the progress and needs of the algorithm. The components of <span>CQP_inform_type</span> are:</p>
<dl>
<dt>status</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that gives the exit status of the algorithm. See Section <a href="#galerrors" data-reference-type="ref" data-reference="galerrors">2.6</a> for details.</p>
</dd>
<dt>alloc_status</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that gives the status of the last attempted array allocation or deallocation. This will be 0 if <span>status = 0</span>.</p>
</dd>
<dt>bad_alloc</dt>
<dd><p>is a scalar variable of type default <span>CHARACTER</span> and length 80, that gives the name of the last internal array for which there were allocation or deallocation errors. This will be the null string if <span>status = 0</span>.</p>
</dd>
<dt>factorization_status</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that gives the return status from the matrix factorization.</p>
</dd>
<dt>factorization_integer</dt>
<dd><p>is a scalar variable of type long <span>INTEGER</span>, that gives the amount of integer storage used for the matrix factorization.</p>
</dd>
<dt>factorization_real</dt>
<dd><p>is a scalar variable of type long <span>INTEGER</span>, that gives the amount of real storage used for the matrix factorization.</p>
</dd>
<dt>nfacts</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that gives the total number of factorizations performed.</p>
</dd>
<dt>nbacts</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that gives the total number of backtracks performed during the sequence of linesearches.</p>
</dd>
<dt>threads</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that gives the total number of threads used for parallel execution.</p>
</dd>
<dt>iter</dt>
<dd><p>is a scalar variable of type default <span>INTEGER</span>, that gives the number of iterations performed.</p>
</dd>
<dt>obj</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the value of the objective function at the best estimate of the solution found.</p>
</dd>
<dt>primal_infeasibility</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the norm of the violation of primal optimality (see Section <a href="#typetime" data-reference-type="ref" data-reference="typetime">2.4.4</a>) at the best estimate of the solution found.</p>
</dd>
<dt>dual_infeasibility</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the norm of the violation of dual optimality (see Section <a href="#typetime" data-reference-type="ref" data-reference="typetime">2.4.4</a>) at the best estimate of the solution found.</p>
</dd>
<dt>complementary_slackness</dt>
<dd><p>is a scalar variable of type default <span>REAL</span> (double precision in <span class="math inline">\(\)</span><span>GALAHAD_CQP_double</span>), that holds the norm of the violation of complementary slackness (see Section <a href="#typetime" data-reference-type="ref" data-reference="typetime">2.4.4</a>) at the best estimate of the solution found.</p>
</dd>
<dt>feasible</dt>
<dd><p>is a scalar variable of type default <span>LOGICAL</span>, that has the value <span>.TRUE.</span> if the output value of <span class="math inline">\({\mathbf{x}}\)</span> satisfies the constraints, and the value <span>.FALSE.</span> otherwise.</p>
</dd>
<dt>time</dt>
<dd><p>is a scalar variable of type <span>CQP_time_type</span> whose components are used to hold elapsed CPU and system clock times for the various parts of the calculation (see Section <a href="#typetime" data-reference-type="ref" data-reference="typetime">2.4.4</a>).</p>
</dd>
<dt>FDC_inform</dt>
<dd><p>is a scalar variable of type <span>FDC_inform_type</span> whose components are used to provide information about any detection of linear dependencies performed by the package <span>GALAHAD_FDC</span>. See the specification sheet for the package <span>GALAHAD_FDC</span> for details.</p>
</dd>
<dt>SBLS_inform</dt>
<dd><p>is a scalar variable of type <span>SBLS_inform_type</span> whose components are used to provide information about factorizations performed by the package <span>GALAHAD_SBLS</span>. See the specification sheet for the package <span>GALAHAD_SBLS</span> for details.</p>
</dd>
<dt>FIT_inform</dt>
<dd><p>is a scalar variable of type <span>FIT_inform_type</span> whose components are used to provide information about the fitting of data to polynomials performed by the package <span>GALAHAD_FIT</span>. See the specification sheet for the package <span>GALAHAD_FIT</span> for details.</p>
</dd>
<dt>ROOTS_inform</dt>
<dd><p>is a scalar variable of type <span>ROOTS_inform_type</span> whose components are used to provide information about the polynomial root finding performed by the package <span>GALAHAD_ROOTS</span>. See the specification sheet for the package <span>GALAHAD_ROOTS</span> for details.</p>
</dd>
<dt>CRO_inform</dt>
<dd><p>is a scalar variable of type <span>CRO_inform_type</span> whose components are used to provide information about the crossover performed by the package <span>GALAHAD_CRO</span>. See the specification sheet for the package <span>GALAHAD_CRO</span> for details.</p>
</dd>
</dl>
<h3 id="typedata">The derived data type for holding problem data</h3>
<p>The derived data type <span>CQP_data_type</span> is used to hold all the data for a particular problem, or sequences of problems with the same structure, between calls of <span>CQP</span> procedures. This data should be preserved, untouched, from the initial call to <span>CQP_initialize</span> to the final call to <span>CQP_terminate</span>.</p>
<h2 id="galarguments"><a href="#galarguments" data-reference-type="ref" data-reference="galarguments">2.5</a>. Argument lists and calling sequences</h2>
<p>There are three procedures for user calls (see Section <a href="#galfeatures" data-reference-type="ref" data-reference="galfeatures">2.7</a> for further features):</p>
<ol>
<li><p>The subroutine <span>CQP_initialize</span> is used to set default values, and initialize private data, before solving one or more problems with the same sparsity and bound structure.</p></li>
<li><p>The subroutine <span>CQP_solve</span> is called to solve the problem.</p></li>
<li><p>The subroutine <span>CQP_terminate</span> is provided to allow the user to automatically deallocate array components of the private data, allocated by <span>CQP_solve</span>, at the end of the solution process.</p></li>
</ol>
<p>We use square brackets to indicate <span>OPTIONAL</span> arguments.</p>
<h3 id="subinit">The initialization subroutine</h3>
<p>Default values are provided as follows:</p>
<p><span>CALL CQP_initialize( data, control, inform )</span></p>
<dl>
<dt>data</dt>
<dd><p>is a scalar <span>INTENT(INOUT)</span> argument of type <span>CQP_data_type</span> (see Section <a href="#typedata" data-reference-type="ref" data-reference="typedata">2.4.6</a>). It is used to hold data about the problem being solved.</p>
</dd>
<dt>control</dt>
<dd><p>is a scalar <span>INTENT(OUT)</span> argument of type <span>CQP_control_type</span> (see Section <a href="#typecontrol" data-reference-type="ref" data-reference="typecontrol">2.4.3</a>). On exit, <span>control</span> contains default values for the components as described in Section <a href="#typecontrol" data-reference-type="ref" data-reference="typecontrol">2.4.3</a>. These values should only be changed after calling <span>CQP_initialize</span>.</p>
</dd>
<dt>inform</dt>
<dd><p>is a scalar <span>INTENT(OUT)</span> argument of type <span>CQP_inform_type</span> (see Section <a href="#typeinform" data-reference-type="ref" data-reference="typeinform">2.4.5</a>). A successful call to <span>CQP_initialize</span> is indicated when the component <span>status</span> has the value 0. For other return values of <span>status</span>, see Section <a href="#galerrors" data-reference-type="ref" data-reference="galerrors">2.6</a>.</p>
</dd>
</dl>
<h3 id="qps">The quadratic programming subroutine</h3>
<p>The quadratic programming solution algorithm is called as follows:</p>
<p><span>CALL CQP_solve( prob, data, control, inform[, C_stat, B_stat] )</span></p>
<dl>
<dt>prob</dt>
<dd><p>is a scalar <span>INTENT(INOUT)</span> argument of type <span>QPT_problem_type</span> (see Section <a href="#typeprob" data-reference-type="ref" data-reference="typeprob">2.4.2</a>). It is used to hold data about the problem being solved. The user must allocate all the array components, and set values for all components except <span>prob%C</span>.</p>
<p>The components <span>prob%X</span>, <span>prob%Y</span> and <span>prob%Z</span> must be set to initial estimates of the primal variables, <span class="math inline">\({\mathbf{x}}\)</span>, Lagrange multipliers, <span class="math inline">\({\mathbf{y}}\)</span>, for the general constraints and dual variables for the bound constraints, <span class="math inline">\({\mathbf{z}}\)</span>, respectively. Inappropriate initial values will be altered, so the user should not be overly concerned if suitable values are not apparent, and may be content with merely setting <span>prob%X=0.0</span>, <span>prob%Y=0.0</span> and <span>prob%Z=0.0</span>.</p>
<p>On exit, the components <span>prob%X</span> , <span>prob%C</span>, <span>prob%Y</span>, and <span>prob%Z</span> will contain the best estimates of the primal variables <span class="math inline">\({\mathbf{x}}\)</span>, the linear constraints <span class="math inline">\({\mathbf{A}}{\mathbf{x}}\)</span>, Lagrange multipliers, <span class="math inline">\({\mathbf{y}}\)</span>, for the general constraints and dual variables for the bound constraints <span class="math inline">\({\mathbf{z}}\)</span>, respectively. <span><strong>Restrictions:</strong> </span><span>prob%n</span> <span class="math inline">\(&gt; 0\)</span>, <span>prob%m</span> <span class="math inline">\(\geq 0\)</span>, <span>prob%A_type</span> <span class="math inline">\(\in \{\)</span><span>’DENSE’</span>, <span>’COORDINATE’</span>, <span>’SPARSE_BY_ROWS’</span> <span class="math inline">\(\}\)</span>, and (if <span class="math inline">\({\mathbf{H}}\)</span> is provided) <span>prob%H%ne</span> <span class="math inline">\(\geq -2\)</span>. <span>prob%H_type</span> <span class="math inline">\(\in \{\)</span><span>’DENSE’</span>, <span>’COORDINATE’</span>, <span>’SPARSE_BY_ROWS’</span>, <span>’DIAGONAL’</span>, <span>’SCALED_IDENTITY’</span>, <span>’IDENTITY’</span>, <span>’ZERO’</span> <span class="math inline">\(\}\)</span>.</p>
</dd>
<dt>data</dt>
<dd><p>is a scalar <span>INTENT(INOUT)</span> argument of type <span>CQP_data_type</span> (see Section <a href="#typedata" data-reference-type="ref" data-reference="typedata">2.4.6</a>). It is used to hold data about the problem being solved. It must not have been altered <span><strong>by the user</strong></span> since the last call to <span>CQP_initialize</span>.</p>
</dd>
<dt>control</dt>
<dd><p>is a scalar <span>INTENT(IN)</span> argument of type <span>CQP_control_type</span> (see Section <a href="#typecontrol" data-reference-type="ref" data-reference="typecontrol">2.4.3</a>). Default values may be assigned by calling <span>CQP_initialize</span> prior to the first call to <span>CQP_solve</span>.</p>
</dd>
<dt>inform</dt>
<dd><p>is a scalar <span>INTENT(INOUT)</span> argument of type <span>CQP_inform_type</span> (see Section <a href="#typeinform" data-reference-type="ref" data-reference="typeinform">2.4.5</a>). A successful call to <span>CQP_solve</span> is indicated when the component <span>status</span> has the value 0. For other return values of <span>status</span>, see Section <a href="#galerrors" data-reference-type="ref" data-reference="galerrors">2.6</a>.</p>
</dd>
<dt>C_stat</dt>
<dd><p>is an <span>OPTIONAL</span> rank-one <span>INTENT(OUT)</span> array argument of dimension <span>prob%m</span> and type default <span>INTEGER</span>, that indicates which of the general linear constraints are in the optimal active set. Possible values for <span>C_stat(i)</span>, <span>i</span><span class="math inline">\(=1, \ldots ,\)</span> <span>prob%m</span>, and their meanings are</p>
<dl>
<dt>&lt;0</dt>
<dd><p>the <span class="math inline">\(i\)</span>-th general constraint is in the active set, on its lower bound,</p>
</dd>
<dt>&gt;0</dt>
<dd><p>the <span class="math inline">\(i\)</span>-th general constraint is in the active set, on its upper bound, and</p>
</dd>
<dt>0</dt>
<dd><p>the <span class="math inline">\(i\)</span>-th general constraint is not in the active set.</p>
</dd>
</dl>
<p>When <span>control%crossover</span> is <span>.TRUE.</span>, more specific values are</p>
<dl>
<dt>-1</dt>
<dd><p>the <span class="math inline">\(i\)</span>-th general constraint is both independent and active on its lower bound,</p>
</dd>
<dt>-2</dt>
<dd><p>the <span class="math inline">\(i\)</span>-th general constraint is on its lower bound but linearly dependent on others,</p>
</dd>
<dt>1</dt>
<dd><p>the <span class="math inline">\(i\)</span>-th general constraint is both independent and active on its upper bound,</p>
</dd>
<dt>2</dt>
<dd><p>the <span class="math inline">\(i\)</span>-th general constraint is on its upper bound but linearly dependent on others, and</p>
</dd>
<dt>0</dt>
<dd><p>the <span class="math inline">\(i\)</span>-th general constraint is not in the active set.</p>
</dd>
</dl>
</dd>
<dt>B_stat</dt>
<dd><p>is an <span>OPTIONAL</span> rank-one <span>INTENT(OUT)</span> array argument of dimension <span>prob%n</span> and type default <span>INTEGER</span>, that indicates which of the simple bound constraints are in the current active set. Possible values for <span>B_stat(j)</span>, <span>j</span><span class="math inline">\(=1, \ldots ,\)</span> <span>prob%n</span>, and their meanings are</p>
<dl>
<dt>&lt;0</dt>
<dd><p>the <span class="math inline">\(j\)</span>-th simple bound constraint is in the active set, on its lower bound,</p>
</dd>
<dt>&gt;0</dt>
<dd><p>the <span class="math inline">\(j\)</span>-th simple bound constraint is in the active set, on its upper bound, and</p>
</dd>
<dt>0</dt>
<dd><p>the <span class="math inline">\(j\)</span>-th simple bound constraint is not in the active set.</p>
</dd>
</dl>
<p>When <span>control%crossover</span> is <span>.TRUE.</span>, more specific values are</p>
<dl>
<dt>-1</dt>
<dd><p>the <span class="math inline">\(j\)</span>-th simple bound constraint is both independent and active on its lower bound,</p>
</dd>
<dt>-2</dt>
<dd><p>the <span class="math inline">\(j\)</span>-th simple bound constraint is on its lower bound but linearly dependent on others,</p>
</dd>
<dt>1</dt>
<dd><p>the <span class="math inline">\(j\)</span>-th simple bound constraint is both independent and active on its upper bound,</p>
</dd>
<dt>2</dt>
<dd><p>the <span class="math inline">\(j\)</span>-th simple bound constraint is on its upper bound but linearly dependent on others, and</p>
</dd>
<dt>0</dt>
<dd><p>the <span class="math inline">\(j\)</span>-th simple bound constraint is not in the active set.</p>
</dd>
</dl>
</dd>
</dl>
<h3 id="the-termination-subroutine">The termination subroutine</h3>
<p>All previously allocated arrays are deallocated as follows:</p>
<p><span>CALL CQP_terminate( data, control, inform )</span></p>
<dl>
<dt>data</dt>
<dd><p>is a scalar <span>INTENT(INOUT)</span> argument of type <span>CQP_data_type</span> exactly as for <span>CQP_solve</span>, which must not have been altered <span><strong>by the user</strong></span> since the last call to <span>CQP_initialize</span>. On exit, array components will have been deallocated.</p>
</dd>
<dt>control</dt>
<dd><p>is a scalar <span>INTENT(IN)</span> argument of type <span>CQP_control_type</span> exactly as for <span>CQP_solve</span>.</p>
</dd>
<dt>inform</dt>
<dd><p>is a scalar <span>INTENT(OUT)</span> argument of type <span>CQP_inform_type</span> exactly as for <span>CQP_solve</span>. Only the component <span>status</span> will be set on exit, and a successful call to <span>CQP_terminate</span> is indicated when this component <span>status</span> has the value 0. For other return values of <span>status</span>, see Section <a href="#galerrors" data-reference-type="ref" data-reference="galerrors">2.6</a>.</p>
</dd>
</dl>
<h2 id="galerrors">Warning and error messages</h2>
<p>A negative value of <span>inform%status</span> on exit from <span>CQP_solve</span> or <span>CQP_terminate</span> indicates that an error has occurred. No further calls should be made until the error has been corrected. Possible values are:</p>
<dl>
<dt>-1.</dt>
<dd><p>An allocation error occurred. A message indicating the offending array is written on unit <span>control%error</span>, and the returned allocation status and a string containing the name of the offending array are held in <span>inform%alloc_status</span> and <span>inform%bad_alloc</span> respectively.</p>
</dd>
<dt>-2.</dt>
<dd><p>A deallocation error occurred. A message indicating the offending array is written on unit <span>control%error</span> and the returned allocation status and a string containing the name of the offending array are held in <span>inform%alloc_status</span> and <span>inform%bad_alloc</span> respectively.</p>
</dd>
<dt>-3.</dt>
<dd><p>One of the restrictions <span>prob%n</span> <span class="math inline">\(&gt; 0\)</span> , <span>prob%m</span> <span class="math inline">\(\geq 0\)</span> the requirement that <span>prob%A_type</span> contain its relevant string <span>’DENSE’</span>, <span>’COORDINATE’</span> or <span>’SPARSE_BY_ROWS’</span>, or the requirement that <span>prob%H_type</span> contain its relevant string <span>’DENSE’</span>, <span>’COORDINATE’</span>, <span>’SPARSE_BY_ROWS’</span>, <span>’DIAGONAL’</span> <span>SCALED_IDENTITY</span>, <span>IDENTITY</span> or <span>ZERO</span>, when <span class="math inline">\({\mathbf{H}}\)</span> is available, has been violated.</p>
</dd>
<dt>-4.</dt>
<dd><p>The bound constraints are inconsistent.</p>
</dd>
<dt>-5.</dt>
<dd><p>The constraints appear to have no feasible point.</p>
</dd>
<dt>-7.</dt>
<dd><p>The objective function appears to be unbounded from below on the feasible set.</p>
</dd>
<dt>-9.</dt>
<dd><p>The analysis phase of the factorization failed; the return status from the factorization package is given in the component <span>inform%factor_status</span>.</p>
</dd>
<dt>-10.</dt>
<dd><p>The factorization failed; the return status from the factorization package is given in the component <span>inform%factor_status</span>.</p>
</dd>
<dt>-16.</dt>
<dd><p>The problem is so ill-conditioned that further progress is impossible.</p>
</dd>
<dt>-17.</dt>
<dd><p>The step is too small to make further impact.</p>
</dd>
<dt>-18.</dt>
<dd><p>Too many iterations have been performed. This may happen if <span>control%maxit</span> is too small, but may also be symptomatic of a badly scaled problem.</p>
</dd>
<dt>-19.</dt>
<dd><p>The elapsed CPU or system clock time limit has been reached. This may happen if either <span>control%cpu_time_limit</span> or <span>control%clock_time_limit</span> is too small, but may also be symptomatic of a badly scaled problem.</p>
</dd>
<dt>-23.</dt>
<dd><p>An entry from the strict upper triangle of <span class="math inline">\({\mathbf{H}}\)</span> has been specified.</p>
</dd>
</dl>
<h2 id="galfeatures">Further features</h2>
<p>In this section, we describe an alternative means of setting control parameters, that is components of the variable <span>control</span> of type <span>CQP_control_type</span> (see Section <a href="#typecontrol" data-reference-type="ref" data-reference="typecontrol">2.4.3</a>), by reading an appropriate data specification file using the subroutine <span>CQP_read_specfile</span>. This facility is useful as it allows a user to change <span>CQP</span> control parameters without editing and recompiling programs that call <span>CQP</span>.</p>
<p>A specification file, or specfile, is a data file containing a number of "specification commands". Each command occurs on a separate line, and comprises a "keyword", which is a string (in a close-to-natural language) used to identify a control parameter, and an (optional) "value", which defines the value to be assigned to the given control parameter. All keywords and values are case insensitive, keywords may be preceded by one or more blanks but values must not contain blanks, and each value must be separated from its keyword by at least one blank. Values must not contain more than 30 characters, and each line of the specfile is limited to 80 characters, including the blanks separating keyword and value.</p>
<p>The portion of the specification file used by <span>CQP_read_specfile</span> must start with a "<span>BEGIN CQP</span>" command and end with an "<span>END</span>" command. The syntax of the specfile is thus defined as follows:</p>
<pre><code>  ( .. lines ignored by CQP_read_specfile .. )
    BEGIN CQP
       keyword    value
       .......    .....
       keyword    value
    END
  ( .. lines ignored by CQP_read_specfile .. )</code></pre>
<p>where keyword and value are two strings separated by (at least) one blank. The “<span>BEGIN CQP</span>” and “<span>END</span>” delimiter command lines may contain additional (trailing) strings so long as such strings are separated by one or more blanks, so that lines such as</p>
<pre><code>    BEGIN CQP SPECIFICATION</code></pre>
<p>and</p>
<pre><code>    END CQP SPECIFICATION</code></pre>
<p>are acceptable. Furthermore, between the “<span>BEGIN CQP</span>” and “<span>END</span>” delimiters, specification commands may occur in any order. Blank lines and lines whose first non-blank character is <span>!</span> or are ignored. The content of a line after a <span>!</span> or character is also ignored (as is the <span>!</span> or character itself). This provides an easy manner to "comment out" some specification commands, or to comment specific values of certain control parameters.</p>
<p>The value of a control parameters may be of three different types, namely integer, logical or real. Integer and real values may be expressed in any relevant Fortran integer and floating-point formats (respectively). Permitted values for logical parameters are "<span>ON</span>", "<span>TRUE</span>", "<span>.TRUE.</span>", "<span>T</span>", "<span>YES</span>", "<span>Y</span>", or "<span>OFF</span>", "<span>NO</span>", "<span>N</span>", "<span>FALSE</span>", "<span>.FALSE.</span>" and "<span>F</span>". Empty values are also allowed for logical control parameters, and are interpreted as "<span>TRUE</span>".</p>
<p>The specification file must be open for input when <span>CQP_read_specfile</span> is called, and the associated device number passed to the routine in device (see below). Note that the corresponding file is <span>REWIND</span>ed, which makes it possible to combine the specifications for more than one program/routine. For the same reason, the file is not closed by <span>CQP_read_specfile</span>.</p>
<h3 id="readspec">To read control parameters from a specification file</h3>
<p>Control parameters may be read from a file as follows:</p>
<pre><code>     CALL CQP_read_specfile( control, device )</code></pre>
<dl>
<dt>control</dt>
<dd><p>is a scalar <span>INTENT(INOUT)</span>argument of type <span>CQP_control_type</span> (see Section <a href="#typecontrol" data-reference-type="ref" data-reference="typecontrol">2.4.3</a>). Default values should have already been set, perhaps by calling <span>CQP_initialize</span>. On exit, individual components of <span>control</span> may have been changed according to the commands found in the specfile. Specfile commands and the component (see Section <a href="#typecontrol" data-reference-type="ref" data-reference="typecontrol">2.4.3</a>) of <span>control</span> that each affects are given in Table <a href="#specfile" data-reference-type="ref" data-reference="specfile">[specfile]</a>.</p>
<table>
<caption><span id="specfile" label="specfile">[specfile]</span>Specfile commands and associated components of<span>control</span>.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">command</th>
<th style="text-align: left;">component of <span>control</span></th>
<th style="text-align: left;">value type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span>error-printout-device</span></td>
<td style="text-align: left;"><span>%error</span></td>
<td style="text-align: left;">integer</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>printout-device</span></td>
<td style="text-align: left;"><span>%out</span></td>
<td style="text-align: left;">integer</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>print-level</span></td>
<td style="text-align: left;"><span>%print_level</span></td>
<td style="text-align: left;">integer</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>maximum-number-of-iterations</span></td>
<td style="text-align: left;"><span>%maxit</span></td>
<td style="text-align: left;">integer</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>start-print</span></td>
<td style="text-align: left;"><span>%start_print</span></td>
<td style="text-align: left;">integer</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>stop-print</span></td>
<td style="text-align: left;"><span>%stop_print</span></td>
<td style="text-align: left;">integer</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>indicator-type-used</span></td>
<td style="text-align: left;"><span>%indicator_type</span></td>
<td style="text-align: left;">integer</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>arc-used</span></td>
<td style="text-align: left;"><span>%arc</span></td>
<td style="text-align: left;">integer</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>series-order</span></td>
<td style="text-align: left;"><span>%series_order</span></td>
<td style="text-align: left;">integer</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>infinity-value</span></td>
<td style="text-align: left;"><span>%infinity</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>identical-bounds-tolerance</span></td>
<td style="text-align: left;"><span>%identical_bounds_tol</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>absolute-primal-accuracy</span></td>
<td style="text-align: left;"><span>%stop_abs_p</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>relative-primal-accuracy</span></td>
<td style="text-align: left;"><span>%stop_rel_p</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>absolute-dual-accuracy</span></td>
<td style="text-align: left;"><span>%stop_abs_d</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>relative-dual-accuracy</span></td>
<td style="text-align: left;"><span>%stop_rel_d</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>absolute-complementary-slackness-accuracy</span></td>
<td style="text-align: left;"><span>%stop_abs_c</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>relative-complementary-slackness-accuracy</span></td>
<td style="text-align: left;"><span>%stop_rel_c</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>perturb-hessian-by</span></td>
<td style="text-align: left;"><span>%perturb_h</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>initial-barrier-parameter</span></td>
<td style="text-align: left;"><span>%muzero</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>feasibility-vs-complementarity-weight</span></td>
<td style="text-align: left;"><span>%tao</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>balance-complementarity-factor</span></td>
<td style="text-align: left;"><span>%gamma_c</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>balance-feasibility-factor</span></td>
<td style="text-align: left;"><span>%gamma_f</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>poor-iteration-tolerance</span></td>
<td style="text-align: left;"><span>%reduce_infeas</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>minimum-objective-before-unbounded</span></td>
<td style="text-align: left;"><span>%obj_unbounded</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>minimum-potential-before-unbounded</span></td>
<td style="text-align: left;"><span>%potential_unbounded</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>identical-bounds-tolerance</span></td>
<td style="text-align: left;"><span>%identical_bounds_tol</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>primal-indicator-tolerance</span></td>
<td style="text-align: left;"><span>%indicator_tol_p</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>primal-dual-indicator-tolerance</span></td>
<td style="text-align: left;"><span>%indicator_tol_pd</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>tapia-indicator-tolerance</span></td>
<td style="text-align: left;"><span>%indicator_tol_tapia</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>maximum-cpu-time-limit</span></td>
<td style="text-align: left;"><span>%cpu_time_limit</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>maximum-clock-time-limit</span></td>
<td style="text-align: left;"><span>%clock_time_limit</span></td>
<td style="text-align: left;">real</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>remove-linear-dependencies</span></td>
<td style="text-align: left;"><span>%remove_dependencies</span></td>
<td style="text-align: left;">logical</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>treat-zero-bounds-as-general</span></td>
<td style="text-align: left;"><span>%treat_zero_bounds_as_general</span></td>
<td style="text-align: left;">logical</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>just-find-feasible-point</span></td>
<td style="text-align: left;"><span>%just_feasible</span></td>
<td style="text-align: left;">logical</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>puiseux-series</span></td>
<td style="text-align: left;"><span>%puiseux</span></td>
<td style="text-align: left;">logical</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>try-every-order-of-series</span></td>
<td style="text-align: left;"><span>%every_order</span></td>
<td style="text-align: left;">logical</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>cross-over-solution</span></td>
<td style="text-align: left;"><span>%crossover</span></td>
<td style="text-align: left;">logical</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>space-critical</span></td>
<td style="text-align: left;"><span>%space_critical</span></td>
<td style="text-align: left;">logical</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>deallocate-error-fatal</span></td>
<td style="text-align: left;"><span>%deallocate_error_fatal</span></td>
<td style="text-align: left;">logical</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>output-line-prefix</span></td>
<td style="text-align: left;"><span>%prefix</span></td>
<td style="text-align: left;">character</td>
</tr>
</tbody>
</table>
</dd>
<dt>device</dt>
<dd><p>is a scalar <span>INTENT(IN)</span>argument of type default <span>INTEGER</span>, that must be set to the unit number on which the specfile has been opened. If <span>device</span> is not open, <span>control</span> will not be altered and execution will continue, but an error message will be printed on unit <span>control%error</span>.</p>
</dd>
</dl>
<h2 id="galinfo">Information printed</h2>
<p>If <span>control%print_level</span> is positive, information about the progress of the algorithm will be printed on unit <span>control%out</span>. If <span>control%print_level</span> <span class="math inline">\(= 1\)</span>, a single line of output will be produced for each iteration of the process. For the initial-feasible-point phase, this will include values of the current primal and dual infeasibility, and violation of complementary slackness, the feasibility-phase objective value, the current steplength, the value of the barrier parameter, the number of backtracks in the linesearch and the elapsed CPU time in seconds. Once a suitable feasible point has been found, the iteration is divided into major iterations, at which the barrier parameter is reduced, and minor iterations, and which the barrier function is approximately minimized for the current value of the barrier parameter. For the major iterations, the value of the barrier parameter, the required values of dual feasibility and violation of complementary slackness, and the current constraint infeasibility are reported. Each minor iteration of the optimality phase results in a line giving the current dual feasibility and violation of complementary slackness, the objective function value, the ratio of predicted to achieved reduction of the objective function, the trust-region radius, the number of backtracks in the linesearch, the number of conjugate-gradient iterations taken, and the elapsed CPU time in seconds.</p>
<p>If <span>control%print_level</span> <span class="math inline">\(\geq 2\)</span> this output will be increased to provide significant detail of each iteration. This extra output includes residuals of the linear systems solved, and, for larger values of <span>control%print_level</span>, values of the primal and dual variables and Lagrange multipliers.</p>
<h1 id="galgeneral"><a href="#galgeneral" data-reference-type="ref" data-reference="galgeneral">3</a>. GENERAL INFORMATION</h1>
<dl>
<dt>Use of common:</dt>
<dd><p>None.</p>
</dd>
<dt>Workspace:</dt>
<dd><p>Provided automatically by the module.</p>
</dd>
<dt>Other routines called directly:</dt>
<dd><p>None.</p>
</dd>
<dt>Other modules used directly:</dt>
<dd><p><span>CQP_solve</span> calls the <span class="sans-serif">GALAHAD</span> packages <span>GALAHAD_CLOCK</span>, <span>GALAHAD_SYMBOLS</span>, <span>GALAHAD_SPACE</span>, <span>GALAHAD_TOOLS</span>, <span>GALAHAD_SPECFILE</span>, <span>GALAHAD_SMT</span>, <span>GALAHAD_QPT</span>, <span>GALAHAD_QPP</span>, <span>GALAHAD_QPD</span>, <span>GALAHAD_FIT</span>, <span>GALAHAD_ROOTS</span>, <span>GALAHAD_NORMS</span>, <span>GALAHAD_SBLS</span>, <span>GALAHAD_CRO</span> and <span>GALAHAD_FDC</span>.</p>
</dd>
<dt>Input/output:</dt>
<dd><p>Output is under control of the arguments <span>control%error</span>, <span>control%out</span> and <span>control%print_level</span>.</p>
</dd>
<dt>Restrictions:</dt>
<dd><p><span>prob%n</span> <span class="math inline">\(&gt; 0\)</span>, <span>prob%m</span> <span class="math inline">\(\geq  0\)</span>, <span>prob%A_type</span> and <span>prob%H_type</span> <span class="math inline">\(\in \{\)</span><span>’DENSE’</span>, <span>’COORDINATE’</span>, <span>’SPARSE_BY_ROWS’</span>, <span>’DIAGONAL’</span>, <span>’SCALED_IDENTITY’</span>, <span>’IDENTITY’</span>, <span>’ZERO’</span> <span class="math inline">\(\}\)</span>. (if <span class="math inline">\({\mathbf{H}}\)</span> and <span class="math inline">\({\mathbf{A}}\)</span> are explicit).</p>
</dd>
<dt>Portability:</dt>
<dd><p>ISO Fortran 95 + TR 15581 or Fortran 2003. The package is thread-safe.</p>
</dd>
</dl>
<h1 id="galmethod"><a href="#galmethod" data-reference-type="ref" data-reference="galmethod">4</a>. METHOD</h1>
<p>The required solution <span class="math inline">\({\mathbf{x}}\)</span> necessarily satisfies the primal optimality conditions <span class="math display">\[\label{{4.1a}} {\mathbf{A}}{\mathbf{x}}={\mathbf{c}} \;\;\; (4.1a)\]</span> and <span class="math display">\[\label{{4.1b}} {\mathbf{c}}^{l} \leq {\mathbf{c}}\leq {\mathbf{c}}^{u}, \;\;{\mathbf{x}}^{l} \leq{\mathbf{x}}\leq{\mathbf{x}}^{u}, \;\;\; (4.1b)\]</span> the dual optimality conditions <span class="math display">\[\label{{4.2a}} {\mathbf{H}}{\mathbf{x}}+{\mathbf{g}}={\mathbf{A}}^{T}{\mathbf{y}}+{\mathbf{z}}\;\;
 (\mbox{or} \;\;{\mathbf{W}}^{2} ({\mathbf{x}}-{\mathbf{x}}^{0}) +{\mathbf{g}}={\mathbf{A}}^{T}{\mathbf{y}}+{\mathbf{z}}\;\; \mbox{for the least-distance type objective}) \;\;\; (4.2a)\]</span> where <span class="math display">\[\label{{4.2b}} {\mathbf{y}}={\mathbf{y}}^{l} +{\mathbf{y}}^{u}, \;\;{\mathbf{z}}={\mathbf{z}}^{l} +{\mathbf{z}}^{u}, \,\,{\mathbf{y}}^{l} \geq 0 , \;\;{\mathbf{y}}^{u} \leq 0 , \;\;{\mathbf{z}}^{l} \geq 0 \;\; \mbox{and} \;\;{\mathbf{z}}^{u} \leq 0 , \;\;\; (4.2b)\]</span> and the complementary slackness conditions <span class="math display">\[\label{{4.3}}
({\mathbf{A}}{\mathbf{x}}-{\mathbf{c}}^{l} )^{T}{\mathbf{y}}^{l} = 0  ,\;\;
({\mathbf{A}}{\mathbf{x}}-{\mathbf{c}}^{u} )^{T}{\mathbf{y}}^{u} = 0  ,\;\;
({\mathbf{x}}-{\mathbf{x}}^{l} )^{T}{\mathbf{z}}^{l} = 0   \;\; \mbox{and} \;\;
({\mathbf{x}}-{\mathbf{x}}^{u} )^{T}{\mathbf{z}}^{u} = 0 , \;\;\; (4.3)\]</span> where the diagonal matrix <span class="math inline">\({\mathbf{W}}^{2}\)</span> has diagonal entries <span class="math inline">\(w_{j}^{2}\)</span>, <span class="math inline">\(j = 1, \ldots , n\)</span>, where the vectors <span class="math inline">\({\mathbf{y}}\)</span> and <span class="math inline">\({\mathbf{z}}\)</span> are known as the Lagrange multipliers for the general linear constraints, and the dual variables for the bounds, respectively, and where the vector inequalities hold component-wise.</p>
<p>Primal-dual interior point methods iterate towards a point that satisfies these conditions by ultimately aiming to satisfy (<a href="#4.1a" data-reference-type="ref" data-reference="4.1a">[4.1a]</a>), (<a href="#4.2a" data-reference-type="ref" data-reference="4.2a">[4.2a]</a>) and (<a href="#4.3" data-reference-type="ref" data-reference="4.3">[4.3]</a>), while ensuring that (<a href="#4.1b" data-reference-type="ref" data-reference="4.1b">[4.1b]</a>) and (<a href="#4.2b" data-reference-type="ref" data-reference="4.2b">[4.2b]</a>) are satisfied as strict inequalities at each stage. Appropriate norms of the amounts by which (<a href="#4.1a" data-reference-type="ref" data-reference="4.1a">[4.1a]</a>), (<a href="#4.2a" data-reference-type="ref" data-reference="4.2a">[4.2a]</a>) and (<a href="#4.3" data-reference-type="ref" data-reference="4.3">[4.3]</a>) fail to be satisfied are known as the primal and dual infeasibility, and the violation of complementary slackness, respectively. The fact that (<a href="#4.1b" data-reference-type="ref" data-reference="4.1b">[4.1b]</a>) and (<a href="#4.2b" data-reference-type="ref" data-reference="4.2b">[4.2b]</a>) are satisfied as strict inequalities gives such methods their other title, namely interior-point methods.</p>
<p>The method aims at each stage to reduce the overall violation of (<a href="#4.1a" data-reference-type="ref" data-reference="4.1a">[4.1a]</a>), (<a href="#4.2a" data-reference-type="ref" data-reference="4.2a">[4.2a]</a>) and (<a href="#4.3" data-reference-type="ref" data-reference="4.3">[4.3]</a>), rather than reducing each of the terms individually. Given an estimate <span class="math inline">\({\mathbf{v}}= ({\mathbf{x}}, \; {\mathbf{c}}, \; {\mathbf{y}}, \; {\mathbf{y}}^{l}, \;
{\mathbf{y}}^{u}, \; {\mathbf{z}}, \; {\mathbf{z}}^{l}, \; {\mathbf{z}}^{u})\)</span> of the primal-dual variables, a correction <span class="math inline">\(\Delta {\mathbf{v}}= \Delta ({\mathbf{x}}, \; {\mathbf{c}}, \; {\mathbf{y}}, \; {\mathbf{y}}^{l},
 \; {\mathbf{y}}^{u} ,\;{\mathbf{z}},\;{\mathbf{z}}^{l} ,\;{\mathbf{z}}^{u} )\)</span> is obtained by solving a suitable linear system of Newton equations for the nonlinear systems (<a href="#4.1a" data-reference-type="ref" data-reference="4.1a">[4.1a]</a>), (<a href="#4.2a" data-reference-type="ref" data-reference="4.2a">[4.2a]</a>) and a parameterized “residual trajectory” perturbation of (<a href="#4.3" data-reference-type="ref" data-reference="4.3">[4.3]</a>); residual trajectories proposed by Zhang (1994) and Zhao and Sun (1999) are possibilities. An improved estimate <span class="math inline">\({\mathbf{v}}+ \alpha \Delta {\mathbf{v}}\)</span> is then used, where the step-size <span class="math inline">\(\alpha\)</span> is chosen as close to 1.0 as possible while ensuring both that (<a href="#4.1b" data-reference-type="ref" data-reference="4.1b">[4.1b]</a>) and (<a href="#4.2b" data-reference-type="ref" data-reference="4.2b">[4.2b]</a>) continue to hold and that the individual components which make up the complementary slackness (<a href="#4.3" data-reference-type="ref" data-reference="4.3">[4.3]</a>) do not deviate too significantly from their average value. The parameter that controls the perturbation of (<a href="#4.3" data-reference-type="ref" data-reference="4.3">[4.3]</a>) is ultimately driven to zero.</p>
<p>The Newton equations are solved by applying the <span class="sans-serif">GALAHAD</span> matrix factorization package <span>GALAHAD_SBLS</span>, but there are options to factorize the matrix as a whole (the so-called "augmented system" approach), to perform a block elimination first (the "Schur-complement" approach), or to let the method itself decide which of the two previous options is more appropriate. The "Schur-complement" approach is usually to be preferred when all the weights are nonzero or when every variable is bounded (at least one side), but may be inefficient if any of the columns of <span class="math inline">\({\mathbf{A}}\)</span> is too dense.</p>
<p>Optionally, the problem may be pre-processed temporarily to eliminate dependent constraints using the package <span>GALAHAD_FDC</span>. This may improve the performance of the subsequent iteration.</p>
<p>The basic algorithm is a generalisation of those of</p>
<p>Y. Zhang (1994). On the convergence of a class of infeasible interior-point methods for the horizontal linear complementarity problem. SIAM J. Optimization <span><strong>4</strong></span> (1) 208-227,</p>
<p>and</p>
<p>G. Zhao and J. Sun (1999). On the rate of local convergence of high-order infeasible path-following algorithms for <span class="math inline">\(P_*\)</span> linear complementarity problems. Computational Optimization and Applications <span><strong>14</strong></span> (1) 293-307,</p>
<p>with many enhancements described by</p>
<p>N. I. M. Gould, D. Orban and D. P. Robinson (2013). Trajectory-following methods for large-scale degenerate convex quadratic programming, <span><em>Mathematical Programming Computation</em></span> <span><strong>5(2)</strong></span> 113-142.</p>
<h1 id="galexample"><a href="#galexample" data-reference-type="ref" data-reference="galexample">5</a>. EXAMPLE OF USE</h1>
<p>Suppose we wish to minimize <span class="math inline">\({\frac{1}{2}}x_1^2 + x_2^2 + x_2 x_3 + {\frac{3}{2}}x_3^2 + 2 x_2 + 1\)</span> subject to the the general linear constraints <span class="math inline">\(1 \leq  2 x_{1}  +  x_{2}  \leq  2\)</span> and <span class="math inline">\(x_{2}  +  x_{3}  =  2\)</span>, and simple bounds <span class="math inline">\(-1  \leq  x_{1}  \leq  1\)</span> and <span class="math inline">\(x_{3}  \leq  2\)</span>. Then, on writing the data for this problem as <span class="math display">\[{{\mathbf{H}}= \left(\begin{array}{ccc}1 &amp; &amp; \\ &amp; 2 &amp; 1 \\ &amp;  1 &amp; 3\end{array}\right), \;\;{\mathbf{g}}= \left(\begin{array}{c} 0 \\ 2 \\ 0 \end{array}\right), \;\;{\mathbf{x}}^{l} = \left(\begin{array}{c} -1 \\ - \infty \\ - \infty \end{array}\right), \;\;{\mathbf{x}}^{u} = \left(\begin{array}{c} 1 \\ \infty \\ 2 \end{array}\right) }\]</span> and <span class="math display">\[{{\mathbf{A}}= \left(\begin{array}{ccc} 2 &amp; 1 &amp; \\ &amp; 1 &amp; 1\end{array}\right),\;\;{\mathbf{c}}^{l} = \left(\begin{array}{c} 1 \\ 2 \end{array}\right), \;\; \mbox{and} \;\;{\mathbf{c}}^{u} = \left(\begin{array}{c} 2 \\ 2 \end{array}\right)}\]</span> in sparse co-ordinate format, we may use the following code:</p>
<pre><code>! THIS VERSION: GALAHAD 2.4 - 17/11/2010 AT 16:00 GMT.
   PROGRAM GALAHAD_CQP_EXAMPLE
   USE GALAHAD_CQP_double         ! double precision version
   IMPLICIT NONE
   INTEGER, PARAMETER :: wp = KIND( 1.0D+0 ) ! set precision
   REAL ( KIND = wp ), PARAMETER :: infinity = 10.0_wp ** 20
   TYPE ( QPT_problem_type ) :: p
   TYPE ( CQP_data_type ) :: data
   TYPE ( CQP_control_type ) :: control
   TYPE ( CQP_inform_type ) :: inform
   INTEGER :: s
   INTEGER, PARAMETER :: n = 3, m = 2, h_ne = 4, a_ne = 4
   INTEGER, ALLOCATABLE, DIMENSION( : ) :: C_stat, B_stat
! start problem data
   ALLOCATE( p%G( n ), p%X_l( n ), p%X_u( n ) )
   ALLOCATE( p%C( m ), p%C_l( m ), p%C_u( m ) )
   ALLOCATE( p%X( n ), p%Y( m ), p%Z( n ) )
   ALLOCATE( B_stat( n ), C_stat( m ) )
   p%new_problem_structure = .TRUE.           ! new structure
   p%n = n ; p%m = m ; p%f = 1.0_wp           ! dimensions &amp; objective constant
   p%G = (/ 0.0_wp, 2.0_wp, 0.0_wp /)         ! objective gradient
   p%C_l = (/ 1.0_wp, 2.0_wp /)               ! constraint lower bound
   p%C_u = (/ 2.0_wp, 2.0_wp /)               ! constraint upper bound
   p%X_l = (/ - 1.0_wp, - infinity, - infinity /) ! variable lower bound
   p%X_u = (/ 1.0_wp, infinity, 2.0_wp /)     ! variable upper bound
   p%X = 0.0_wp ; p%Y = 0.0_wp ; p%Z = 0.0_wp ! start from zero
!  sparse co-ordinate storage format
   CALL SMT_put( p%H%type, &#39;COORDINATE&#39;, s )     ! Specify co-ordinate
   CALL SMT_put( p%A%type, &#39;COORDINATE&#39;, s )     ! storage for H and A
   ALLOCATE( p%H%val( h_ne ), p%H%row( h_ne ), p%H%col( h_ne ) )
   ALLOCATE( p%A%val( a_ne ), p%A%row( a_ne ), p%A%col( a_ne ) )
   p%H%val = (/ 1.0_wp, 2.0_wp, 1.0_wp, 3.0_wp /) ! Hessian H
   p%H%row = (/ 1, 2, 3, 3 /)                     ! NB lower triangle
   p%H%col = (/ 1, 2, 2, 3 /) ; p%H%ne = h_ne
   p%A%val = (/ 2.0_wp, 1.0_wp, 1.0_wp, 1.0_wp /) ! Jacobian A
   p%A%row = (/ 1, 1, 2, 2 /)
   p%A%col = (/ 1, 2, 2, 3 /) ; p%A%ne = a_ne
! problem data complete
   CALL CQP_initialize( data, control, inform ) ! Initialize control parameters
!  control%print_level = 1
   control%infinity = infinity                  ! Set infinity
   CALL CQP_solve( p, data, control, inform, C_stat, B_stat ) ! Solve
   IF ( inform%status == 0 ) THEN               !  Successful return
     WRITE( 6, &quot;( &#39; CQP: &#39;, I0, &#39; iterations  &#39;, /,                            &amp;
    &amp;     &#39; Optimal objective value =&#39;,                                        &amp;
    &amp;       ES12.4, /, &#39; Optimal solution = &#39;, ( 5ES12.4 ) )&quot; )                &amp;
     inform%iter, inform%obj, p%X
   ELSE                                         !  Error returns
     WRITE( 6, &quot;( &#39; CQP_solve exit status = &#39;, I6 ) &quot; ) inform%status
   END IF
   CALL CQP_terminate( data, control, inform )  !  delete internal workspace
   END PROGRAM GALAHAD_CQP_EXAMPLE</code></pre>
<p>This produces the following output:</p>
<pre><code> CQP: 10 iterations
 Optimal objective value =  6.3462E+00
 Optimal solution =   1.5385E-01  6.9231E-01  1.3077E+00</code></pre>
<p>The same problem may be solved holding the data in a sparse row-wise storage format by replacing the relevant lines in</p>
<pre><code>!  sparse co-ordinate storage format
...
! problem data complete</code></pre>
<p>by</p>
<pre><code>! sparse row-wise storage format
   CALL SMT_put( p%H%type, &#39;SPARSE_BY_ROWS&#39;, s )     ! Specify sparse row
   CALL SMT_put( p%A%type, &#39;SPARSE_BY_ROWS&#39;, s )     ! storage for H and A
   ALLOCATE( p%H%val( h_ne ), p%H%col( h_ne ), p%H%ptr( n + 1 ) )
   ALLOCATE( p%A%val( a_ne ), p%A%col( a_ne ), p%A%ptr( m + 1 ) )
   p%H%val = (/ 1.0_wp, 2.0_wp, 1.0_wp, 3.0_wp /) ! Hessian H
   p%H%col = (/ 1, 2, 2, 3 /)                     ! NB lower triangle
   p%H%ptr = (/ 1, 2, 3, 5 /)
   p%A%val = (/ 2.0_wp, 1.0_wp, 1.0_wp, 1.0_wp /) ! Jacobian A
   p%A%col = (/ 1, 2, 2, 3 /)
   p%A%ptr = (/ 1, 3, 5 /)
! problem data complete</code></pre>
<p>or using a dense storage format with the replacement lines</p>
<pre><code>!  dense storage format
   CALL SMT_put( p%H%type, &#39;DENSE&#39;, s )     ! Specify dense
   CALL SMT_put( p%A%type, &#39;DENSE&#39;, s )     ! storage for H and A
   ALLOCATE( p%H%val( n * ( n + 1 ) / 2 ) )
   ALLOCATE( p%A%val( n * m ) )
   p%H%val = (/ 1.0_wp, 0.0_wp, 2.0_wp, 0.0_wp, 1.0_wp, 3.0_wp /) ! Hessian H
   p%A%val = (/ 2.0_wp, 1.0_wp, 0.0_wp, 0.0_wp, 1.0_wp, 1.0_wp /) ! Jacobian A
! problem data complete</code></pre>
<p>respectively.</p>
<p>If instead <span class="math inline">\({\mathbf{H}}\)</span> had been the diagonal matrix <span class="math display">\[{{\mathbf{H}}= \left(\begin{array}{ccc}1 &amp; &amp;   \\ &amp; 2 &amp; \\  &amp;  &amp; 3\end{array}\right)}\]</span> but the other data is as before, the diagonal storage scheme might be used for <span class="math inline">\({\mathbf{H}}\)</span>, and in this case we would instead</p>
<pre><code>   CALL SMT_put( prob%H%type, &#39;DIAGONAL&#39;, s )  ! Specify dense storage for H
   ALLOCATE( p%H%val( n ) )
   p%H%val = (/ 1.0_wp, 2.0_wp, 3.0_wp /) ! Hessian values</code></pre>
</body>
</html>
